#!/usr/bin/perl

use strict;
use warnings;

my $ME = shift;
my $IN = shift;
my $OUT = shift;

if (!$OUT and $IN) {
    ($OUT = $IN) =~ s/\.t$/.$ME/ or $OUT .= ".$ME";
}
unless ($ME and $IN and -e $IN and $OUT) {

    die <<"USAGE";
Usage: $0 implname testfilename [fudgedtestfilename]

    Verbs:
	#?implname: [num] skip 'reason'
	#?implname: [num] eval 'reason'
	#?implname: [num] try 'reason'
	#?implname: [num] todo 'reason', :by<1.2.3>
	#?implname: emit your_ad_here();
USAGE
}

if (-e $OUT) {
    if (-M $IN >= -M $OUT) {
	print "$OUT\n";		# unchanged, so no need to refudge
	exit(0);
    }
    else {
	unlink $OUT;		# old fudged version, may or may not regenerate...
    }
}

my $REALLY_FUDGED = 0;
my $OUTPUT = "";
my $FUDGE = "";
our $PENDING = 0;
my $ARGS = '';
my $IS = '\\b(?:is|ok|is_deeply|isnt|like|unlike|eval_dies_ok|cmp_ok|isa_ok|use_ok|throws_ok|dies_ok|pass|flunk)(?:\\b|_)';

@ARGV = ($IN);
fudgeblock();

if ($REALLY_FUDGED) {
    open OUT, ">", $OUT or die "Can't create $OUT: $!";
    print OUT $OUTPUT;
    print OUT <<'END';

say "# FUDGED!";
exit(1);	# hopefully reported as "dubious"
END
    close OUT;
    print "$OUT\n";	# pick the output file to run
}
else {
    print "$IN\n";	# pick the input file to run
}

sub fudgeblock {
    while (<>) {
	if (/^\s*\#\? (\w+) \: \s* (.*)/x and $1 eq $ME) {
	    $REALLY_FUDGED = 1;
	    $ARGS = $2;
	    if ($ARGS =~ s/^emit\s*//) {
		$_ = $ARGS;
		next;
	    }
	    if ($ARGS =~ s/^(\d+)\s*//) {
		$PENDING = $1;
	    }
	    else {
		$PENDING = 1;
	    }
	    $ARGS =~ s/^(\w+)\s*//;
	    $FUDGE = $1;
	}

	next unless $PENDING > 0;

	next if /^\s*#/;
	next if /^\s*$/;

	if (/^\{/) {
	    $PENDING--;
	    if ($FUDGE eq 'todo') {
		local $PENDING = 999999;	# do all in block as one action
		$OUTPUT .= $_;
		fudgeblock();
		$_ = '';
	    }
	    else {
		my $more;
		while (defined($more = <>)) {
		    $_ .= $more;
		    last if $more =~ /^\}/;
		}
		my $numtests = () = m/^(\s*$IS)/mgx;
		if ($FUDGE eq 'skip') {
		    s/^/# /mg;
		    $_ = "skip($numtests, $ARGS);" . $_;
		}
		elsif ($FUDGE eq 'try') {
		    chomp;
		    $_ = "try($_) // fail($ARGS);\n";
		}
		elsif ($FUDGE eq 'eval') {
		    chomp;
		    s/(['\\])/\\$1/g;
		    $_ = "eval('$_') // skip($numtests, $ARGS);\n";
		}
		else {
		    warn "Don't know how to mark block for $FUDGE!\n";
		}
	    }
	}
	else {
	    if ($FUDGE eq 'todo') {
		$PENDING -= s/^(\s*)/${1}todo($ARGS); / if /^\s*$IS/;
	    }
	    else {
		while ($_ !~ /;[ \t]*(#.*)?$/) {
		    my $more = <>;
		    last unless $more;
		    $_ .= $more;
		}
		next unless /^\s*$IS/;
		$PENDING--;
		$_ = "{ " . $_ . " }";
		if ($FUDGE eq 'skip') {
		    s/^/# /mg;
		    $_ = "skip(1,$ARGS); $_\n";
		}
		elsif ($FUDGE eq 'try') {
		    $_ = "try($_) // fail($ARGS)\n";
		}
		elsif ($FUDGE eq 'eval') {
		    s/(['\\])/\\$1/g;
		    $_ = "eval('$_') // skip(1,$ARGS);\n";
		}
		else {
		    warn "Don't know how to mark statement for $FUDGE!\n";
		}
	    }
	}
    }
    continue {
	$OUTPUT .= $_;
	return if /^\}/ and $PENDING > 0;
    }
}
