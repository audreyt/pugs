This is VROOM a ViRtual OO Machine. It started as YAP6, a prospective
backend to KP6, but at some point it became non-p6-specific. This
readme is still valid, with some small changes.

Please see the ROADMAP. See also the TODO file for a hacking guide.

What is YAP6?

YAP6 is a prospective runtime for kp6 written in C.

Why in C?

KP6, by its history, aimed to implement a Perl 6 compatible runtime in
many high-level languages. It came from the Pugs project, which is, in
fact, the same effort focused on Haskell. KP6 started using the perl 5
interpreter as the so-called "virtual machine" for it. The problem is
that, implementing a runtime on top of other runtime creates a severe
performance penalty, making KP6 useless in the practical sense, as it
runs severely slow. That is why yap6 is written in C as to avoid
layering different runtimes and get a Perl 6 compatible runtime from
bottom-up.

What about Parrot?

YAP6 is and is not a competitor to Parrot. It is a competitor in the
sense that, for the Perl 6 language, both aim to provide a runtime
environment for it. But they are not competitors in the sense that
YAP6 tries to be the simplest possible implementation of that
runtime. It's based simply on a simplistic refcount garbage collector,
uses directly libc malloc and free for memory management and do not
intend to support other languages natively.

But isn't Perl 6 about language interoperability?

Kind of. This is one of the nice requirements set for the
language. But when you stop and try to figure out how to actually
interoperate in the high-level, you'll see that no matter how the
virtual machine tries to make it easier, you'll end up with some
typemapping which won't be that different from what you can see in
perl 5 XS mechanism. You can argue that it would be doable in a higher
level language, but, actually, I don't think that's much
important. This way, YAP6 would support interoperability with other
languages, but doing it the same way perl 5 does, using a low-level
API that exposes the internals of the interpreter. Actually, the
DISPATCHER mechanism (which could be called prototype in the Perl 6
land) allows as to implement different "responder interfaces" so that
we can expose a perl 5 SV* behind a yap6 value and expose that to the
high-level language without any notice.

Is YAP6 a virtual machine?

It depends on how you define a vm. It's probably more accurate to call
it a runtime library, like Glib or Apache Portable Runtime
Library. But the most precise answer would certainly be: If you call
perl 5 a virtual machine, than yap6 is a vm also. The yap6 structure
is pretty much inspired by P5.

How far is YAP6 going?

As a runtime library, YAP6 will provide the basic runtime interface
based on the DISPATCHER and on the high-level APPLY call. YAP6 aims to
provide an APPLY interface to every native type it implements. On top
of that, it will be possible to implement a "stage 1" Perl 6. The
compiler for this "stage 1" Perl 6 would understand the internals of
YAP6 and would then be able to generate the code for the high-level
Perl 6 language.

What is this "stage 1" Perl 6?

This would be a statically-typed language that would enable the
creation of the Object system in itself, as yap6 only provides basic
types. This language would not be required for yap6 development, but,
it is pretty much sane to avoid working with the low-level C structs
if a higher-level language will be able to produce the exact same
code.

How does the "stage 1" compiled code should look like?

Firstly, it will be C code. It will basically look like a set of
YAP6_* calls, using the native types created by yap6, like:

YAP6__CORE__Value* foo = yap6_list_create();
YAP6__CORE__Value* bar = yap6_int_create(0);
YAP6__CORE__Scalar* place = YAP6_LIST_LOOKP(foo, bar);
YAP6__CORE__Value* baz = yap6_int_create(1);
YAP6__CORE__Value* old = YAP6_SCALAR_STORE(place, baz);
yap6_value_refcnt_dec(old);
yap6_value_refcnt_dec(baz);
yap6_value_refcnt_dec(place);
yap6_value_refcnt_dec(bar);
yap6_value_refcnt_dec(foo);

The above code would be the result for the following stage 1 code.

my @foo;
@foo[0] = 1;

What will be implemented in this "stage 1" language?

Almost everything. The Meta-Object-Protocol, the basic objects
(including the Code object), and finally, the interpreter in itself,
which will implement the stack management, and all the interpreter
operators. This means that the interpreter would work just like p5, as
it would manage all the aspects of the execution, like exception
model, closures, scopes etc. This means that we can't tell right now
if the stage 2 code will be compiled down to C or not. But we do know
that the basis of its working will be very like p5.
