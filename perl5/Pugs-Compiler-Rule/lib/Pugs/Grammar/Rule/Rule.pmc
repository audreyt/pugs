# Generated file - do not edit!
##################((( 32-bit Checksum Validator )))##################
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); unpack('%32N*',<F>)
== 0xF2CEC2BB or die "Checksum failed for outdated .pmc file: ${F}c"}
#####################################################################
package Pugs::Grammar::Rule;
use base 'Pugs::Grammar::LrepBase';
use Pugs::Runtime::LrepRule;
*{'Pugs::Grammar::Rule::ws'} = sub {
    my $grammar = shift;
    #warn "rule argument is undefined" unless defined $_[0];
    $_[0] = "" unless defined $_[0];
    my $bool = $_[0] =~ /^((?:\s|\#(?-s:.)*)+)(.*)$/sx;
    return {
        bool  => $bool,
        match => $1,
        tail  => $2,
        #capture => $1,
    }
};
*{'Pugs::Grammar::Rule::variable'} = sub {
    my $grammar = shift;
    #warn "rule argument is undefined" unless defined $_[0];
    $_[0] = "" unless defined $_[0];
    my $bool = $_[0] =~ /^([\$\%\@](?:(?:\:\:)?[_[:alnum:]]+)+)(.*)$/sx;
    return {
        bool  => $bool,
        match => $1,
        tail  => $2,
        #capture => $1,
    }
};
*{'Pugs::Grammar::Rule::positional_variable'} = sub {
    my $grammar = shift;
    #warn "rule argument is undefined" unless defined $_[0];
    $_[0] = "" unless defined $_[0];
    my $bool = $_[0] =~ /^([\$\%\@]\^(?:[_[:alnum:]]+))(.*)$/sx;
    return {
        bool  => $bool,
        match => $1,
        tail  => $2,
        #capture => $1,
    }
};
*{'Pugs::Grammar::Rule::ident'} = sub {
    my $grammar = shift;
    #warn "rule argument is undefined" unless defined $_[0];
    $_[0] = "" unless defined $_[0];
    my $bool = $_[0] =~ /^((?:(?:\:\:)?[_[:alpha:]][_[:alnum:]]*)+)(.*)$/sx;
    return {
        bool  => $bool,
        match => $1,
        tail  => $2,
        #capture => $1,
    }
};
*{'Pugs::Grammar::Rule::num_variable'} = sub {
    my $grammar = shift;
    #warn "rule argument is undefined" unless defined $_[0];
    $_[0] = "" unless defined $_[0];
    my $bool = $_[0] =~ /^(?:\$[[:digit:]]+)(.*)$/sx;
    return {
        bool  => $bool,
        match => $1,
        tail  => $2,
        #capture => $1,
    }
};
*{'Pugs::Grammar::Rule::dot'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\." )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { 'dot' => 1 ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'dot';
*{'Pugs::Grammar::Rule::plain_text'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          alternation( [
                capture( 'alnum', sub{ $grammar->alnum(@_) } )
              ,
                constant( "\," )
              ,
                constant( "\;" )
              ,
                constant( "_" )
              ,
                constant( "\/" )
              ,
                constant( "\~" )
              ,
                constant( "\"" )
              ,
                constant( "\'" )
              ,
                constant( "\=" )
              ,
          ] )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { 'constant' =>  $_[0]->()  ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'plain_text';
*{'Pugs::Grammar::Rule::special_char'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\\" )
        ,
          sub{ $grammar->any(@_) }
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { special_char =>  $_[0]->() , } } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'special_char';
*{'Pugs::Grammar::Rule::non_capturing_group'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\[" )
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\]" )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return $_[0]{rule}() } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    push @Pugs::Grammar::Rule::rule_terms, 'non_capturing_group';
*{'Pugs::Grammar::Rule::closure_rule'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          capture( 'code', sub{ $grammar->code(@_) } )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { closure => $_[0]{code}() ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'closure_rule';
*{'Pugs::Grammar::Rule::variable_rule'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          alternation( [
                capture( 'variable', sub{ $grammar->variable(@_) } )
              ,
                capture( 'positional_variable', sub{ $grammar->positional_variable(@_) } )
              ,
          ] )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { variable =>  $_[0]->()  ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'variable_rule';
*{'Pugs::Grammar::Rule::match_variable'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          capture( 'num_variable', sub{ $grammar->num_variable(@_) } )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { match_variable => $_[0]{num_variable}() ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'match_variable';
*{'Pugs::Grammar::Rule::named_capture_body'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
          alternation( [
              concat(
                capture( 'capturing_group', sub{ $grammar->capturing_group(@_) } )
              ,
                Pugs::Runtime::LrepRule::abort(
                    sub {
                        return { bool => 1, tail => $_[0], return => sub { return { rule => $_[0]{capturing_group}(), } } };
                    }
                )
              ,
              ),
              concat(
                capture( 'non_capturing_group', sub{ $grammar->non_capturing_group(@_) } )
              ,
                Pugs::Runtime::LrepRule::abort(
                    sub {
                        return { bool => 1, tail => $_[0], return => sub { return { rule => $_[0]{non_capturing_group}(), } } };
                    }
                )
              ,
              ),
              concat(
                capture( 'metasyntax', sub{ $grammar->metasyntax(@_) } )
              ,
                Pugs::Runtime::LrepRule::abort(
                    sub {
                        return { bool => 1, tail => $_[0], return => sub { return { rule => $_[0]{metasyntax}(), } } };
                    }
                )
              ,
              ),
                sub {
                    { die "invalid alias syntax" };
                    return { bool => 1, tail => $_[0] }
                }
              ,
          ] )
        ,
        )->( @_ )
    )
};
*{'Pugs::Grammar::Rule::named_capture'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\$" )
        ,
          constant( "\<" )
        ,
          capture( 'ident', sub{ $grammar->ident(@_) } )
        ,
          constant( "\>" )
        ,
          optional(
              sub{ $grammar->ws(@_) }
            ,
          )
        ,
          constant( "\:" )
        ,
          constant( "\=" )
        ,
          optional(
              sub{ $grammar->ws(@_) }
            ,
          )
        ,
          capture( 'named_capture_body', sub{ $grammar->named_capture_body(@_) } )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { my $body = $_[0]{named_capture_body}();
          $body->{ident} = $_[0]{ident}();
          return { named_capture => $body, } 
        } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'named_capture';
*{'Pugs::Grammar::Rule::before'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\<" )
        ,
          constant( "before" )
        ,
          sub{ $grammar->ws(@_) }
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\>" )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { before => {
                rule  => $_[0]{rule}(),
            }, } 
        } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'before';
*{'Pugs::Grammar::Rule::after'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\<" )
        ,
          constant( "after" )
        ,
          sub{ $grammar->ws(@_) }
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\>" )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { after => {
                rule  => $_[0]{rule}(),
            }, } 
        } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'after';
*{'Pugs::Grammar::Rule::negate'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\<" )
        ,
          constant( "\!" )
        ,
          constant( "before" )
        ,
          sub{ $grammar->ws(@_) }
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\>" )
        ,
          alternation( [
                Pugs::Runtime::LrepRule::abort(
                    sub {
                        return { bool => 1, tail => $_[0], return => sub { return { 
            negate => {
              before => {
                rule  => $_[0]{rule}(),
            }, }, } 
        } };
                    }
                )
              ,
                constant( "after" )
              ,
          ] )
        ,
          sub{ $grammar->ws(@_) }
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\>" )
        ,
          alternation( [
                Pugs::Runtime::LrepRule::abort(
                    sub {
                        return { bool => 1, tail => $_[0], return => sub { return { 
            negate => {
              after => {
                rule  => $_[0]{rule}(),
            }, }, } 
        } };
                    }
                )
              ,
                capture( 'rule', sub{ $grammar->rule(@_) } )
              ,
          ] )
        ,
          constant( "\>" )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { negate => {
                rule  => $_[0]{rule}(),
            }, } 
        } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'negate';
*{'Pugs::Grammar::Rule::capturing_group'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          constant( "\(" )
        ,
          capture( 'rule', sub{ $grammar->rule(@_) } )
        ,
          constant( "\)" )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { capturing_group => $_[0]{rule}() ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    unshift @Pugs::Grammar::Rule::rule_terms, 'capturing_group';
*{'Pugs::Grammar::Rule::colon'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          capture( 'capturing_group',
              alternation( [
                  concat(
                    constant( "\:" )
                  ,
                    constant( "\:" )
                  ,
                    constant( "\:" )
                  ,
                  ),
                  concat(
                    constant( "\:" )
                  ,
                    constant( "\?" )
                  ,
                  ),
                  concat(
                    constant( "\:" )
                  ,
                    constant( "\+" )
                  ,
                  ),
                  concat(
                    constant( "\:" )
                  ,
                    constant( "\:" )
                  ,
                  ),
                    constant( "\:" )
                  ,
                  concat(
                    constant( "\$" )
                  ,
                    constant( "\$" )
                  ,
                  ),
                    constant( "\$" )
                  ,
                  concat(
                    constant( "\^" )
                  ,
                    constant( "\^" )
                  ,
                  ),
                    constant( "\^" )
                  ,
              ] )
            ,
          )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { colon => $_[0]->() ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
    push @Pugs::Grammar::Rule::rule_terms, 'colon';
*{'Pugs::Grammar::Rule::quantifier'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          capture( 'ws1', 
              optional(
                  sub{ $grammar->ws(@_) }
                ,
              )
            ,
          )
        ,
          capture( 'term', 
              alternation( \@Pugs::Grammar::Rule::rule_terms )
            ,
          )
        ,
          capture( 'ws2', 
              optional(
                  sub{ $grammar->ws(@_) }
                ,
              )
            ,
          )
        ,
          capture( 'quant', 
              optional(
                  alternation( [
                      concat(
                        constant( "\?" )
                      ,
                        constant( "\?" )
                      ,
                      ),
                      concat(
                        constant( "\*" )
                      ,
                        constant( "\?" )
                      ,
                      ),
                      concat(
                        constant( "\+" )
                      ,
                        constant( "\?" )
                      ,
                      ),
                        constant( "\?" )
                      ,
                        constant( "\*" )
                      ,
                        constant( "\+" )
                      ,
                  ] )
                ,
              )
            ,
          )
        ,
          capture( 'ws3', 
              optional(
                  sub{ $grammar->ws(@_) }
                ,
              )
            ,
          )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return {  
            term  => $_[0]{term}(),
            quant => $_[0]{quant}(),
            ws1   => $_[0]{ws1}(),
            ws2   => $_[0]{ws2}(),
            ws3   => $_[0]{ws3}(),
        } 
    } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
*{'Pugs::Grammar::Rule::concat'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          capture( 'q1', 
              capture( 'quantifier', sub{ $grammar->quantifier(@_) } )
            ,
          )
        ,
          optional(
            concat(
              capture( 'q2', 
                  capture( 'concat', sub{ $grammar->concat(@_) } )
                ,
              )
            ,
              Pugs::Runtime::LrepRule::abort(
                  sub {
                      return { bool => 1, tail => $_[0], return => sub { 
            my $q2 = $_[0]{q2}();
            return { concat => [ 
                { quant => $_[0]{q1}() ,}, 
                ( exists $q2->{concat} 
                    ? @{$q2->{concat}}
                    : $q2 
                ),
            ] ,} 
        } };
                  }
              )
            ,
            ),
          )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return { quant => $_[0]{q1}() ,} } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
*{'Pugs::Grammar::Rule::rule'} = 
sub {
    my $grammar = shift;
    $_[0] = '' unless defined $_[0];
    package Pugs::Runtime::LrepRule;
    rule_wrapper( $_[0], (
        concat(
          optional(
            concat(
              sub{ $grammar->ws(@_) }
            ,
              constant( "\|" )
            ,
            ),
          )
        ,
          capture( 'q1', 
              capture( 'concat', sub{ $grammar->concat(@_) } )
            ,
          )
        ,
          optional(
            concat(
              constant( "\|" )
            ,
              capture( 'q2', 
                  capture( 'rule', sub{ $grammar->rule(@_) } )
                ,
              )
            ,
              Pugs::Runtime::LrepRule::abort(
                  sub {
                      return { bool => 1, tail => $_[0], return => sub { 
            my $q2 = $_[0]{q2}();
            return { alt => [ 
                $_[0]{q1}(), 
                ( exists $q2->{alt} 
                    ? @{$q2->{alt}}
                    : $q2 
                ),
            ] ,} 
        } };
                  }
              )
            ,
            ),
          )
        ,
          Pugs::Runtime::LrepRule::abort(
              sub {
                  return { bool => 1, tail => $_[0], return => sub { return $_[0]{q1}() } };
              }
          )
        ,
        ),
        )->( @_ )
    )
};
