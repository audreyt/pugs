=pod

=head1 Meta-Meta-Classes

... or How to twist your brain up in knots without even trying.

=head1 Introduction

This document is a working document to clarify (and hopefully
simplify) the all too hairy topic of MetaClasses.  This may not be the
I<correct> or I<one and only way> to view the concept of MetaClasses;
many books have been written on the subject which all use subtly
different concepts and terminology.

This document hopes to provide the working basis for the Perl 6
Meta-Model; in a sense, it builds on the brief notes at the end of
Synopsis 12 (see L<S12>) that describe introspection, and carries it
to its logical conclusion.

=head1 The Object Environment

Let us assume for a moment that all our object's live in an I<object>
environment (B<O>), which is a finite set of objects, each of which is
identified with a unique object reference.

Here is a diagram of the entire object environment:

  +-{Object}--+ +--{Class}--+ +{MetaClass}+ +{MetaMetaClass}+
  |           | |           | |           | |               |
  |  ------   | |   -----   | |  -------  | |  -----------  |
  | ( $foo )------>( Foo )----->( Class )---->( MetaClass ) |
  |  ------   | |   -----   | |  -------  | |  -----------  |
  |           | |           | |           | |               |
  +-----------+ +-----------+ +-----------+ +---------------+

=head2 Rules of the object environment

Our object environment has a set of rules which help to define the
elements that exist within it.

=over 4

=item B<type of XXX, instance of XXX english operators>

(this is a nomenclature point)

When we write "type of XXX", we are moving upwards in the object
environment (to the right on the above diagram); the type of an
instance is a Class, the type of a Class is a MetaClass, and so on.

As a shorthand, the term C<Meta> may be prepended to anything to imply
this I<derivative> function.  This is how we arrive at C<MetaClass>
from C<Class>, for example.  In theory, a C<MetaObject> would be a
C<Class>, but C<MetaObject> sounds silly.

When we write "instance of XXX", we are moving downwards.  An instance
of a MetaMetaClass is a MetaClass, an instance of a MetaClass is a
Class, etc.

To stay on the same level, use the term "XXX object".

=item B<each "level" is independant of the levels above and below it>

Relationships such as "is a", "does a", etc only make sense within a
particular level of the object system.  So, for example, it does not
make sense to describe all of these objects as descending from some
I<Ã¼ber>-Object class.  Rules and principles that apply on one level do
not necessarily transfer to the levels below.

To a type system freak, you could say that each level is seperated by
exactly one lamdba; that is, the distance between a type and a value.
By starting with a solid type definition at some level arbitrarily
designated as the "top", it is possible (in principle, at least) to
induct the lamdba calculus safely down to the lower levels.  This is
important when writing I<type-safe> compilers that are capable of
mutating their object systems at any time.

=item B<each "level" looks like Objects from Perl>

Despite this inherant heterogeneity of each level, they all look like
Objects from Perl.  They are described and accessed in exactly the
same way, and can even share type definitions and refer to each other,
to some extent.

Not that references "between" levels may inhibit the capability of the
code to be compiled so far as to run without an interpreter.

To summarise the above two principles in code;

  MyClass.isa(Object);   # false
  MyClass.isa(Class);    # true
  MyClass.does(Object);  # true

  MyClass.meta.isa(Object);    # false
  MyClass.meta.isa(Class);     # false
  MyClass.meta.isa(MetaClass); # true
  MyClass.meta.does(Object);   # true

  MyClass.meta.meta.isa(Object);        # false
  MyClass.meta.meta.isa(Class);         # false
  MyClass.meta.meta.isa(MetaClass);     # false
  MyClass.meta.meta.isa(MetaMetaClass); # true
  MyClass.meta.meta.does(Object);       # true

Even the above is in an ideal situation; it might be that with some
weird MetaModels, you simply don't get those guarantees.  However,
such situations are probably a bit 'obstruese' so won't be mentioned
further.

=item B<Every C<Object> is an instance of some C<Class>>

These are the occupants of our environment B<O>.  Every noted
O<Object> has a uniquely associated entity called a C<Class>.
Instances are the normalisation of the type system; there is no such
thing (to Perl, anyway) as an instance of an C<Object>.

99% of code will be using C<Objects> for absolutely everything.

=item B<Every C<Class> is an instance of some C<MetaClass>>

These objects are what would normally be described as your program's
I<Model>; ie, objects that are I<Classes> (or I<Roles>, etc) will be
called "Dog", "Tree", etc.

When you write:

  class Dog {
  }

You are actually doing something like this;

  Class.new(name => Dog).apply;   # FIXME perl6ify

This is because the term C<Class> actually refers to a C<MetaClass>,
not a C<Class>.  There is nothing special about the term C<Class> that
makes it so, other than it was defined so.  If we had chosen the term
C<Qualifarniciferate> to refer to instances of C<MetaClasses>, then
the above would simply create an object of class (sorry,
Qualifarniciferate) C<Class>.

C<Class> objects are presented to Perl in much the same manner as
instances of some C<Class> called C<MetaClass> might be.  This might
fool you into thinking that they are also instances of some C<Class>,
however in truth they are only ever instances of C<MetaClass> objects.

=item B<Every C<MetaClass> is an instance of some C<MetaMetaClass>>

These objects are what would normally be described as your B<language>
I<Model>, or program I<Meta-Model>.  These will be called "Class",
"Role", etc.

It is these objects that implement methods like C<.isa>, C<.does>,
etc.  They will almost certainly provide proxy methods in the C<Class>
objects that they produce, that when compiled will produce the desired
behaviour.

=item B<Every I<MetaMetaClass> is an instance of the underlying system>

In theory, we could extend this relationship to any level.  However,
it simply does not make much sense to deal with these objects
directly; they might be Haskell definitions in the case of C<pugs>, or
perhaps in a Pure Perl Interpreter they will actually be real
C<Object>s; but you will not see the definition of C<MetaMetaClass> in
this module; in a sense, Perl 6 classes are being used as an
underlying I<Meta-Meta-Model>.

=back

In Perl, not everything is an object.  But everything can behave as
objects (when asked).

=for EDITOR

(the above probably duplicates much of what is below... )

=head2 Querying the Object environment

Since everything is simply a set or a subset of a set, we can use
simple set difference operations to query the contents of our overall
object environment.

=over 4

=item to get all ordinary object do (C<B<O> - B<C>>)

=item to get all ordinary classes do (C<B<C> - B<M>>)

=item to get all ordinary meta-classes do (C<B<M> - B<MM>>)

=back

=head1 So what is a Meta-Meta-Class anyway?

Lets first define the other objects in our environment.

=head2 So what is an Object?

An C<Object> is a primitve in our model and can be viewed as a simple data dictionary.

Here is an example of how an object describing a book might look like:

  {
      Book => { 
        'title'  => "VALIS",
        'author' => "Phillip K. Dick",
      }
  }

=head2 So what is an Instance?

An I<Instance> is simply an object with a I<class> key in the data dictionary whose 
value is the class reference from which the instance is derived, and a set of instance 
variables (which are defined by the class (and which we will see later)).

So a C<iBook> instance of the class I<Book> would look like this:

    {
        'class' => Book
        Book => { 
            'title'  => "VALIS",
            'author' => "Phillip K. Dick",
        }
    }

=head2 So what is a Class?

A I<Class> is itself just another data dictionary, however its structure is a bit 
more complex. 

First, our class must have a name.

A class also needs to have a set of default instance variables from which new 
instances can be created. 

Next, our class needs to have a method table, which is just another data dictionary 
whose keys are labels and whose values are code references. This table is seperate 
from the instance variables becuase methods remain in the class, and are not 
copied into the instance.

And lastly, we have inheritance. Our class needs to have parents, which we represent
as an ordered list of other I<Class> objects.

So given that, our I<Book> class might be structured something like this:

    {
        'class' => Class,
        Class => {
            'name' => 'Book',
            'parents' => [ ... ],
            'instance_vars' => {
                Book => { title => '', author => '' }
            },
            'method_table' => {
                'get_author' => sub { ... },
                'set_author' => sub { ... },                    
                'get_title'  => sub { ... },
                'set_title'  => sub { ... },                                        
            }
        }
    }

As you can see, our I<Book> class is itself an instance of the meta-class I<Class>. 

A list of supported instance variables and methods can be found by accumulating a properly 
sorted unique list of all a class's instance_vars and method_tables merged with those of 
its ancestors. These lists make it is possible to determine the instance variable and 
method resolution order. 

=head2 So what is a MetaClass?

Once again, we can represent our meta-class as a data dictionary. Here is an example of 
how the meta-class I<Class> would look:

    {
        'class' => MetaClass,
        MetaClass => {
            'name' => 'Class',
            'parents' => [ ... ],
            'instance_vars' => {
                Class => { 
                    'name'          => "",
                    'parents'       => [],
                    'instance_vars' => {},
                    'method_table'  => {}
                }
            },
            'method_table' => {
                'create_instance' => sub { 
                    return { 'class' => Class, Class.<instance_vars> }
                }
            }
        }
    }

The C<instance_vars> for a I<Class> are basically those of an empty parent-less class, 
nothing more, nothing less. The simplicity of this notion can be somewhat difficult to
swallow. The tempation is to make it seem much more complex, but in reality it is not.

We also take this opportunity to define a C<create_instance> method for our I<MetaClass> 
which basically just creates a new data dictionary, adding the required 'class' key and 
value pair, along with a copy of the C<instance_vars>. Again, it need not be any more 
complex than that.

=head2 So what is a MetaMetaClass?

Now we are back to our original question, and hopefully by now the answer is quite obvious.

A MetaMetaClass is simply a concrete implementation of the data structures we have been 
constructing above. Our MetaMetaClass is the root of our object hierarchy, and the object from
which all others can be defined.

"That's all?" you say. "But it can't possibly be all!". 

It is of course important to keep a few things in mind, the first of which is that this 
MetaMetaClass is actually independent of a given programming language. That it is not 
something which the "user" should ever really have access too. It is a part of the compiler 
and/or runtime environment upon which a programming language resides.

The second thing is ... hmmm, what was it??

=head1 Why do we need all this abstraction?

What follows is a (slightly edited) snippet of a converstation which took place on IRC.

    <gaal>	    why do we need one more level after classes?
    <gaal>	    and how come just one more level is enough?
    <gaal>	    what do you do with that? that kind of stuff
    <stevan>	well, there is not a really a quick answer
    <stevan>	but I will try :)
    <stevan>	basically it is this
    <stevan>	a class needs to be something
    <stevan>	an instance of something that is
    <stevan>	because there are more than one class in any system
    <gaal>	    why not an object, like in java?
    <stevan>	well the Object type in Java is sort of like a metaclass
    <gaal>	    okay
    <stevan>	it is the base from which all things are derived
    <stevan>	just automagically
    <gaal>	    yes, i see that.
    <stevan>	the heirarchy must come to a point/root
    <stevan>	in Java it is the Object
    <stevan>	in Smalltalk it is MetaClass (i think)
    <stevan>	take a theoretical object model 
    <gaal>	    uh huh
    <stevan>	where we have basic Classes
    <stevan>	which have methods and properties
    <stevan>	say you want to add Final classes
    <stevan>	like Java
    <stevan>	how would you do that?
    <stevan>	subclass Class of course
    <stevan>	but this means that Class itself must be an instance of something 
    <gaal>	    okay, yes
    <stevan>	remember too that this is not something the "user" of the language ever sees
    <gaal>	    yup
    <gaal>	    that was clear enough from your explanation
    <stevan>	so you can subclass Class and get FinalClass
    <stevan>	so this brings up the question, what is Class an instance of
    <stevan>	MetaClass
    <stevan>	so you can stop your model at MetaClass
    <stevan>	and say that is the root
    <stevan>	OR
    <stevan>	you can go one level higher
    <stevan>	which then makes it easier to have Roles, Classes, Traits, etc.
    <stevan>	the MetaMetaClass is the root now, and each MetaClass is an instance of it
    <stevan>	some of the MetaClasses in Perl6 will be Role, Class
    <stevan>	mugwump also included Module and Package too
    <gaal>	    the perl code in ext/, is it part of the actual implementation of oop in pugs?
    <stevan>	no
    <gaal>	    has autrijus assimilated that into the haskell code?    
    <stevan>	right now it is just a prototype to play around with an object model
    <gaal>	    ah, okay
    <stevan>	he might eventually do that
    <stevan>	if it works out
    <gaal>	    i see. this is cool stuff.    
    <stevan>	but it is easier to prototype in perl (5|6) then it is in Haskell (at least for me)
    <gaal>	    yeah, me too.
    <stevan>	meta-meta-hacking :)
    <stevan>	basically you are modeling the class/object system
    <gaal>	    yes, i get that. i think java is a big help here because it's so consistent
    <stevan>	I will try to update the meta-meta doc later today
    <gaal>	    okay thanks for the brief.
    <stevan>	np

I always find that the best way to explain things is to use examples. So for an 
example of how one might use meta-classes (not meta-meta-classes), please see the 
F<create_your_own_object_model.pod> document in the folder as this document.

Soon (once I get my head around it fully), I will try writing a similar document on 
meta-meta-classes, and hopefully touch on the eventual Perl6 object model itself.

=head1 ACKNOWLEDGEMENTS

Much of what is found in this document is a direct rip-off of the contents of the first
few chapter of this book (defined here as an instance of a Book class):

    {
        'class' => Book,
        Book => {
            'title'     => "Putting Metaclasses to Work",
            'authors'   => [ 'Ira R. Forman', 'Scott H. Danforth' ],
            'publisher' => 'Addison-Wesley'
            'isbn'      => 0-201-43305-2,
        }
    }

However, despite my plagarism/summariazation, I still take responsibility for all errors, 
inconsistencies or outright lies this document might contain.

=head1 AUTHOR

Stevan Little E<lt>stevan@iinteractive.comE<gt>

Sam Vilain E<lt>samv@cpan.orgE<gt>

=cut
