# !!! DO NOT EDIT !!!
# This file was generated by util/patch-rule-pmc.pl at Mon Oct 29 17:27:05 2007

package Pugs::Grammar::Rule;
use utf8;
no strict 'refs';
use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;

our %rule_terms;
our %variables;
*pod_begin = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 760 803
       (
           ( $pad{I1959} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 761 780
           (
  
             ## <group>
             ## pos: 761 767
              (   ( $pad{I1960} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1960} ) && 0 ) )
             ## </group>

           &&

             ## <constant>
             ## pos: 767 768
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 768 769
             ( ( substr( $s, $pos, 1 ) eq 'e' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 769 770
             ( ( substr( $s, $pos, 1 ) eq 'n' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
  
             ## <group>
             ## pos: 770 772
              (   ( $pad{I1961} = $pos or 1 ) &&

               ## <constant>
               ## pos: 770 771
               ( ( substr( $s, $pos, 1 ) eq 'd' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1961} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 772 780
             do { while (
              (   ( $pad{I1962} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1962} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1959} ) or 1 )
           &&            ## <concat>
           ## pos: 781 803
           (
  
             ## <group>
             ## pos: 781 786
              (   ( $pad{I1963} = $pos or 1 ) &&

               ## <dot>
               ## pos: 784 785
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I1963} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 786 790
             do { while (
              (   ( $pad{I1964} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1964} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           &&
  
             ## <group>
             ## pos: 790 803
              (   ( $pad{I1965} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 790 802
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1965} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_begin
 # Data::Bind->sub_signature
#  (\&pod_begin, );
;
*pod_other = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 828 871
       (
           ( $pad{I1966} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 829 848
           (
  
             ## <group>
             ## pos: 829 835
              (   ( $pad{I1967} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1967} ) && 0 ) )
             ## </group>

           &&

             ## <constant>
             ## pos: 835 836
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 836 837
             ( ( substr( $s, $pos, 1 ) eq 'c' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 837 838
             ( ( substr( $s, $pos, 1 ) eq 'u' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
  
             ## <group>
             ## pos: 838 840
              (   ( $pad{I1968} = $pos or 1 ) &&

               ## <constant>
               ## pos: 838 839
               ( ( substr( $s, $pos, 1 ) eq 't' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1968} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 840 848
             do { while (
              (   ( $pad{I1969} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1969} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1966} ) or 1 )
           &&            ## <concat>
           ## pos: 849 871
           (
  
             ## <group>
             ## pos: 849 854
              (   ( $pad{I1970} = $pos or 1 ) &&

               ## <dot>
               ## pos: 852 853
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I1970} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 854 858
             do { while (
              (   ( $pad{I1971} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1971} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           &&
  
             ## <group>
             ## pos: 858 871
              (   ( $pad{I1972} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 858 870
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1972} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_other
 # Data::Bind->sub_signature
#  (\&pod_other, );
;
*ws = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 889 1187
       (
        (   ( $pad{I1973} = $pos or 1 ) &&
           ## <alt>
           ## pos: 890 1184
           (
               ( $pad{I1974} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 896 911
               (
  
                 ## <group>
                 ## pos: 896 903
                  (   ( $pad{I1975} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 900 902
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 903 911
                 do { while (
                  (   ( $pad{I1976} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1976} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1974} ) or 1 )
               &&                ## <concat>
               ## pos: 912 1172
               (
  
                 ## <group>
                 ## pos: 912 919
                  (   ( $pad{I1977} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1977} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 919 1172
                 (
                  (   ( $pad{I1978} = $pos or 1 ) &&
                     ## <concat>
                     ## pos: 920 1165
                     (
  
                       ## <group>
                       ## pos: 920 923
                        (   ( $pad{I1979} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 921 922
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1979} ) && 0 ) )
                       ## </group>

                     &&
                       ## <quant>
                       ## pos: 923 1165
                       (
                        (   ( $pad{I1980} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 924 1150
                           (
                               ( $pad{I1981} = $pos or 1 )
                               && (
                               ## <concat>
                               ## pos: 938 975
                               (
  
                                 ## <group>
                                 ## pos: 938 941
                                  (   ( $pad{I1982} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 940 941
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1982} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 941 942
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 942 943
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 943 944
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 944 946
                                  (   ( $pad{I1983} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 944 945
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1983} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 946 952
                                  (   ( $pad{I1984} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 946 951
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 952 953
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 953 954
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 954 956
                                  (   ( $pad{I1985} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 954 955
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                                 ## </group>

                               &&
                                 ## <quant>
                                 ## pos: 956 960
                                 do { while (
                                  (   ( $pad{I1986} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1986} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               &&
                                 ## <quant>
                                 ## pos: 960 975
                                 do { while (
                                  (   ( $pad{I1987} = $pos or 1 ) &&

                                     ## <dot>
                                     ## pos: 960 961
                                     ( substr( $s, $pos++, 1 ) ne '' )
                                     ## </dot>
 ||    ( ( $pos = $pad{I1987} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 976 1010
                               (
  
                                 ## <group>
                                 ## pos: 976 979
                                  (   ( $pad{I1988} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 978 979
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 979 980
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 980 981
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 981 982
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 982 985
                                  (   ( $pad{I1989} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 982 983
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 985 1010
                                  (   ( $pad{I1990} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 985 997
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1011 1045
                               (
  
                                 ## <group>
                                 ## pos: 1011 1014
                                  (   ( $pad{I1991} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1013 1014
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1014 1015
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1015 1016
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1016 1020
                                  (   ( $pad{I1992} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1016 1017
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1020 1045
                                  (   ( $pad{I1993} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1020 1032
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1046 1080
                               (
  
                                 ## <group>
                                 ## pos: 1046 1049
                                  (   ( $pad{I1994} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1048 1049
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1049 1050
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1050 1055
                                  (   ( $pad{I1995} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1050 1051
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1995} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1055 1080
                                  (   ( $pad{I1996} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1055 1067
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1996} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1081 1115
                               (
  
                                 ## <group>
                                 ## pos: 1081 1084
                                  (   ( $pad{I1997} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1083 1084
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1997} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1084 1085
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1085 1090
                                  (   ( $pad{I1998} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1085 1086
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1998} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1090 1115
                                  (   ( $pad{I1999} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1090 1102
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1999} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1116 1150
                               (
  
                                 ## <group>
                                 ## pos: 1116 1119
                                  (   ( $pad{I2000} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1118 1119
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I2000} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1119 1120
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1120 1121
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1121 1122
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1122 1125
                                  (   ( $pad{I2001} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1122 1123
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I2001} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1125 1150
                                  (   ( $pad{I2002} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1125 1137
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2002} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                       || ( $bool = 1 )
                       )
                       ## </quant>

                     )
                     ## </concat>
 ||    ( ( $pos = $pad{I1978} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1974} ) or 1 )
               &&   
               ## <group>
               ## pos: 1173 1184
                (   ( $pad{I2003} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2003} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1973} ) && 0 ) )
       && do { while (
        (   ( $pad{I1973} = $pos or 1 ) &&
           ## <alt>
           ## pos: 890 1184
           (
               ( $pad{I1974} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 896 911
               (
  
                 ## <group>
                 ## pos: 896 903
                  (   ( $pad{I1975} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 900 902
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1975} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 903 911
                 do { while (
                  (   ( $pad{I1976} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1976} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1974} ) or 1 )
               &&                ## <concat>
               ## pos: 912 1172
               (
  
                 ## <group>
                 ## pos: 912 919
                  (   ( $pad{I1977} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1977} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 919 1172
                 (
                  (   ( $pad{I1978} = $pos or 1 ) &&
                     ## <concat>
                     ## pos: 920 1165
                     (
  
                       ## <group>
                       ## pos: 920 923
                        (   ( $pad{I1979} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 921 922
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1979} ) && 0 ) )
                       ## </group>

                     &&
                       ## <quant>
                       ## pos: 923 1165
                       (
                        (   ( $pad{I1980} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 924 1150
                           (
                               ( $pad{I1981} = $pos or 1 )
                               && (
                               ## <concat>
                               ## pos: 938 975
                               (
  
                                 ## <group>
                                 ## pos: 938 941
                                  (   ( $pad{I1982} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 940 941
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1982} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 941 942
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 942 943
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 943 944
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 944 946
                                  (   ( $pad{I1983} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 944 945
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1983} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 946 952
                                  (   ( $pad{I1984} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 946 951
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 952 953
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 953 954
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 954 956
                                  (   ( $pad{I1985} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 954 955
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                                 ## </group>

                               &&
                                 ## <quant>
                                 ## pos: 956 960
                                 do { while (
                                  (   ( $pad{I1986} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1986} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               &&
                                 ## <quant>
                                 ## pos: 960 975
                                 do { while (
                                  (   ( $pad{I1987} = $pos or 1 ) &&

                                     ## <dot>
                                     ## pos: 960 961
                                     ( substr( $s, $pos++, 1 ) ne '' )
                                     ## </dot>
 ||    ( ( $pos = $pad{I1987} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 976 1010
                               (
  
                                 ## <group>
                                 ## pos: 976 979
                                  (   ( $pad{I1988} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 978 979
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1988} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 979 980
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 980 981
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 981 982
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 982 985
                                  (   ( $pad{I1989} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 982 983
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1989} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 985 1010
                                  (   ( $pad{I1990} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 985 997
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1011 1045
                               (
  
                                 ## <group>
                                 ## pos: 1011 1014
                                  (   ( $pad{I1991} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1013 1014
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1014 1015
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1015 1016
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1016 1020
                                  (   ( $pad{I1992} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1016 1017
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1020 1045
                                  (   ( $pad{I1993} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1020 1032
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1046 1080
                               (
  
                                 ## <group>
                                 ## pos: 1046 1049
                                  (   ( $pad{I1994} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1048 1049
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1994} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1049 1050
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1050 1055
                                  (   ( $pad{I1995} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1050 1051
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1995} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1055 1080
                                  (   ( $pad{I1996} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1055 1067
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1996} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1081 1115
                               (
  
                                 ## <group>
                                 ## pos: 1081 1084
                                  (   ( $pad{I1997} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1083 1084
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1997} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1084 1085
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1085 1090
                                  (   ( $pad{I1998} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1085 1086
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1998} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1090 1115
                                  (   ( $pad{I1999} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1090 1102
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1999} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1981} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 1116 1150
                               (
  
                                 ## <group>
                                 ## pos: 1116 1119
                                  (   ( $pad{I2000} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1118 1119
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I2000} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 1119 1120
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1120 1121
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 1121 1122
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 1122 1125
                                  (   ( $pad{I2001} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 1122 1123
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I2001} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 1125 1150
                                  (   ( $pad{I2002} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 1125 1137
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2002} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1980} ) && 0 ) )
                       || ( $bool = 1 )
                       )
                       ## </quant>

                     )
                     ## </concat>
 ||    ( ( $pos = $pad{I1978} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1974} ) or 1 )
               &&   
               ## <group>
               ## pos: 1173 1184
                (   ( $pad{I2003} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2003} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1973} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ws
 # Data::Bind->sub_signature
#  (\&ws, );
;
*ident = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 1251 1276
       (
        (   ( $pad{I2004} = $pos or 1 ) &&
           ## <alt>
           ## pos: 1252 1273
           (
               ( $pad{I2005} = $pos or 1 )
               && (
  
               ## <group>
               ## pos: 1252 1262
                (   ( $pad{I2006} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 1253 1261
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2006} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2005} ) or 1 )
               &&   
               ## <group>
               ## pos: 1263 1266
                (   ( $pad{I2007} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 1264 1265
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2007} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2005} ) or 1 )
               &&   
               ## <group>
               ## pos: 1267 1273
                (   ( $pad{I2008} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 1268 1272
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2008} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2004} ) && 0 ) )
       && do { while (
        (   ( $pad{I2004} = $pos or 1 ) &&
           ## <alt>
           ## pos: 1252 1273
           (
               ( $pad{I2005} = $pos or 1 )
               && (
  
               ## <group>
               ## pos: 1252 1262
                (   ( $pad{I2006} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 1253 1261
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2006} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2005} ) or 1 )
               &&   
               ## <group>
               ## pos: 1263 1266
                (   ( $pad{I2007} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 1264 1265
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2007} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2005} ) or 1 )
               &&   
               ## <group>
               ## pos: 1267 1273
                (   ( $pad{I2008} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 1268 1272
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2008} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2004} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ident
 # Data::Bind->sub_signature
#  (\&ident, );
;
*alnum = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 1297 1311
        (   ( $pad{I2009} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I2009} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alnum
 # Data::Bind->sub_signature
#  (\&alnum, );
;
*alpha = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 1332 1343
        (   ( $pad{I2010} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I2010} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alpha
 # Data::Bind->sub_signature
#  (\&alpha, );
;
*digit = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 1364 1372
        (   ( $pad{I2011} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I2011} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for digit
 # Data::Bind->sub_signature
#  (\&digit, );
;
*special_char = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 1447 2236
       (
           ( $pad{I2012} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 1448 1616
           (
  
             ## <group>
             ## pos: 1448 1459
              (   ( $pad{I2013} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 1450 1457
                       (
                           ( $pad{I2014} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 1450 1453
                            (   ( $pad{I2015} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 1451 1452
                             ( ( substr( $s, $pos, 1 ) eq 'c' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2015} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2014} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 1454 1457
                            (   ( $pad{I2016} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 1455 1456
                             ( ( substr( $s, $pos, 1 ) eq 'C' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2016} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2013} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1459 1462
              (   ( $pad{I2017} = $pos or 1 ) &&

               ## <constant>
               ## pos: 1459 1461
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2017} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1462 1503
              (   ( $pad{I2018} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 1463 1501
                       (
                        (   ( $pad{I2019} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 1465 1499
                           (
                               ( $pad{I2020} = $pos or 1 )
                               && (
                               ## <named_capture>
                               ## pos: 1465 1472
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               ## </named_capture>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1476 1481
                                (   ( $pad{I2021} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1477 1480
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2021} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1482 1487
                                (   ( $pad{I2022} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1483 1486
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2022} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1488 1493
                                (   ( $pad{I2023} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1489 1492
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2023} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1494 1499
                                (   ( $pad{I2024} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1495 1498
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2024} ) && 0 ) )
                               ## </group>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I2019} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2019} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 1465 1499
                           (
                               ( $pad{I2020} = $pos or 1 )
                               && (
                               ## <named_capture>
                               ## pos: 1465 1472
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               ## </named_capture>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1476 1481
                                (   ( $pad{I2021} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1477 1480
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2021} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1482 1487
                                (   ( $pad{I2022} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1483 1486
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2022} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1488 1493
                                (   ( $pad{I2023} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1489 1492
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2023} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I2020} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1494 1499
                                (   ( $pad{I2024} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 1495 1498
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I2024} ) && 0 ) )
                               ## </group>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I2019} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2018} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1503 1559
              (   ( $pad{I2025} = $pos or 1 ) &&

               ## <constant>
               ## pos: 1503 1505
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2025} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1559 1616
              (   ( $pad{I2026} = $pos or 1 ) &&
               ## <closure>
               ## pos: 1559 1606
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2026} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2012} ) or 1 )
           &&            ## <concat>
           ## pos: 1617 1742
           (
  
             ## <group>
             ## pos: 1617 1628
              (   ( $pad{I2027} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1619 1626
               (
                   ( $pad{I2028} = $pos or 1 )
                   && (
  
                   ## <group>
                   ## pos: 1619 1622
                    (   ( $pad{I2029} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 1620 1621
                     ( ( substr( $s, $pos, 1 ) eq 'x' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2029} ) && 0 ) )
                   ## </group>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2028} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1623 1626
                    (   ( $pad{I2030} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 1624 1625
                     ( ( substr( $s, $pos, 1 ) eq 'X' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2030} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I2027} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 1628 1691
             (
              (   ( $pad{I2031} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 1628 1636
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2031} ) && 0 ) )
             && do { while (
              (   ( $pad{I2031} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 1628 1636
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2031} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 1691 1742
              (   ( $pad{I2032} = $pos or 1 ) &&
               ## <closure>
               ## pos: 1691 1733
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2032} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2012} ) or 1 )
           &&            ## <concat>
           ## pos: 1743 1882
           (
  
             ## <group>
             ## pos: 1743 1754
              (   ( $pad{I2033} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 1745 1752
                       (
                           ( $pad{I2034} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 1745 1748
                            (   ( $pad{I2035} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 1746 1747
                             ( ( substr( $s, $pos, 1 ) eq 'x' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2035} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2034} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 1749 1752
                            (   ( $pad{I2036} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 1750 1751
                             ( ( substr( $s, $pos, 1 ) eq 'X' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2036} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2033} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1754 1757
              (   ( $pad{I2037} = $pos or 1 ) &&

               ## <constant>
               ## pos: 1754 1756
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2037} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1757 1769
              (   ( $pad{I2038} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 1758 1767
                       (
                        (   ( $pad{I2039} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 1758 1766
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I2039} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2039} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 1758 1766
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I2039} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2038} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1769 1825
              (   ( $pad{I2040} = $pos or 1 ) &&

               ## <constant>
               ## pos: 1769 1771
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2040} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 1825 1882
              (   ( $pad{I2041} = $pos or 1 ) &&
               ## <closure>
               ## pos: 1825 1872
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2041} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2012} ) or 1 )
           &&            ## <concat>
           ## pos: 1883 2002
           (
  
             ## <group>
             ## pos: 1883 1894
              (   ( $pad{I2042} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1885 1892
               (
                   ( $pad{I2043} = $pos or 1 )
                   && (
  
                   ## <group>
                   ## pos: 1885 1888
                    (   ( $pad{I2044} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 1886 1887
                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2044} ) && 0 ) )
                   ## </group>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2043} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1889 1892
                    (   ( $pad{I2045} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 1890 1891
                     ( ( substr( $s, $pos, 1 ) eq 'O' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I2045} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I2042} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 1894 1951
             (
              (   ( $pad{I2046} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2046} ) && 0 ) )
             && do { while (
              (   ( $pad{I2046} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2046} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 1951 2002
              (   ( $pad{I2047} = $pos or 1 ) &&
               ## <closure>
               ## pos: 1951 1993
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2047} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2012} ) or 1 )
           &&            ## <concat>
           ## pos: 2003 2136
           (
  
             ## <group>
             ## pos: 2003 2014
              (   ( $pad{I2048} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 2005 2012
                       (
                           ( $pad{I2049} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 2005 2008
                            (   ( $pad{I2050} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 2006 2007
                             ( ( substr( $s, $pos, 1 ) eq 'o' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2050} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I2049} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2009 2012
                            (   ( $pad{I2051} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 2010 2011
                             ( ( substr( $s, $pos, 1 ) eq 'O' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I2051} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2048} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2014 2017
              (   ( $pad{I2052} = $pos or 1 ) &&

               ## <constant>
               ## pos: 2014 2016
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2052} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2017 2023
              (   ( $pad{I2053} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 2018 2021
                       (
                        (   ( $pad{I2054} = $pos or 1 ) &&
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I2054} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I2054} = $pos or 1 ) &&
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I2054} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I2053} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2023 2079
              (   ( $pad{I2055} = $pos or 1 ) &&

               ## <constant>
               ## pos: 2023 2025
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2055} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2079 2136
              (   ( $pad{I2056} = $pos or 1 ) &&
               ## <closure>
               ## pos: 2079 2126
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2056} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2012} ) or 1 )
           &&            ## <concat>
           ## pos: 2137 2236
           (
  
             ## <group>
             ## pos: 2137 2193
              (   ( $pad{I2057} = $pos or 1 ) &&

               ## <dot>
               ## pos: 2138 2139
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I2057} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2193 2236
              (   ( $pad{I2058} = $pos or 1 ) &&
               ## <closure>
               ## pos: 2193 2235
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2058} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for special_char
 # Data::Bind->sub_signature
#  (\&special_char, );
;
*literal = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 2259 2310
       do { while (
        (   ( $pad{I2059} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2260 2307
           (
               ( $pad{I2060} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2266 2290
               (
  
                 ## <group>
                 ## pos: 2266 2271
                  (   ( $pad{I2061} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2268 2270
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2061} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2271 2290
                  (   ( $pad{I2062} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2271 2285
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2062} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2060} ) or 1 )
               &&   
               ## <group>
               ## pos: 2291 2307
                (   ( $pad{I2063} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2063} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2059} ) && 0 ) )) {}; $bool = 1 }
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for literal
 # Data::Bind->sub_signature
#  (\&literal, );
;
*double_quoted = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 2339 2431
       do { while (
        (   ( $pad{I2064} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2340 2428
           (
               ( $pad{I2065} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2346 2370
               (
  
                 ## <group>
                 ## pos: 2346 2351
                  (   ( $pad{I2066} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2348 2350
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2066} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2351 2370
                  (   ( $pad{I2067} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2351 2365
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2067} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2065} ) or 1 )
               &&   
               ## <group>
               ## pos: 2371 2411
                (   ( $pad{I2068} = $pos or 1 ) &&
                ## <metasyntax>
                 ## pos: 2373 2406
                 do{
                my $match = 
          ## <variable>
          ## pos: 2373 2406
          do {
            our $I2069;
            our $I2069_sizes;
            unless ( $I2069 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2069_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2069 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2069_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2069->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2069, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                ## </metasyntax>
 ||    ( ( $pos = $pad{I2068} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2065} ) or 1 )
               &&   
               ## <group>
               ## pos: 2412 2428
                (   ( $pad{I2070} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2070} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2064} ) && 0 ) )) {}; $bool = 1 }
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for double_quoted
 # Data::Bind->sub_signature
#  (\&double_quoted, );
;
*metasyntax = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 2457 2635
       (
        (   ( $pad{I2071} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2458 2632
           (
               ( $pad{I2072} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2464 2488
               (
  
                 ## <group>
                 ## pos: 2464 2469
                  (   ( $pad{I2073} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2466 2468
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2073} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2469 2488
                  (   ( $pad{I2074} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2469 2483
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2074} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2489 2517
               (
  
                 ## <group>
                 ## pos: 2489 2495
                  (   ( $pad{I2075} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2491 2493
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2075} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2495 2510
                  (   ( $pad{I2076} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2495 2505
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2076} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2510 2517
                  (   ( $pad{I2077} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2510 2512
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2077} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2518 2550
               (
  
                 ## <group>
                 ## pos: 2518 2524
                  (   ( $pad{I2078} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2520 2522
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2078} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2524 2543
                  (   ( $pad{I2079} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2524 2540
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2079} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2543 2550
                  (   ( $pad{I2080} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2543 2545
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2080} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2551 2586
               (
  
                 ## <group>
                 ## pos: 2551 2557
                  (   ( $pad{I2081} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2553 2555
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2081} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2557 2579
                  (   ( $pad{I2082} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2557 2571
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2082} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2579 2586
                  (   ( $pad{I2083} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2579 2581
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2083} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2587 2615
               (
  
                 ## <group>
                 ## pos: 2587 2593
                  (   ( $pad{I2084} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2589 2591
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2084} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2593 2608
                  (   ( $pad{I2085} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2593 2606
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2085} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2608 2615
                  (   ( $pad{I2086} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2608 2610
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2086} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&   
               ## <group>
               ## pos: 2616 2632
                (   ( $pad{I2087} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2087} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2071} ) && 0 ) )
       && do { while (
        (   ( $pad{I2071} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2458 2632
           (
               ( $pad{I2072} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2464 2488
               (
  
                 ## <group>
                 ## pos: 2464 2469
                  (   ( $pad{I2073} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2466 2468
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2073} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2469 2488
                  (   ( $pad{I2074} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2469 2483
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2074} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2489 2517
               (
  
                 ## <group>
                 ## pos: 2489 2495
                  (   ( $pad{I2075} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2491 2493
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2075} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2495 2510
                  (   ( $pad{I2076} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2495 2505
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2076} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2510 2517
                  (   ( $pad{I2077} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2510 2512
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2077} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2518 2550
               (
  
                 ## <group>
                 ## pos: 2518 2524
                  (   ( $pad{I2078} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2520 2522
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2078} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2524 2543
                  (   ( $pad{I2079} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2524 2540
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2079} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2543 2550
                  (   ( $pad{I2080} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2543 2545
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2080} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2551 2586
               (
  
                 ## <group>
                 ## pos: 2551 2557
                  (   ( $pad{I2081} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2553 2555
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2081} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2557 2579
                  (   ( $pad{I2082} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2557 2571
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2082} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2579 2586
                  (   ( $pad{I2083} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2579 2581
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2083} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&                ## <concat>
               ## pos: 2587 2615
               (
  
                 ## <group>
                 ## pos: 2587 2593
                  (   ( $pad{I2084} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2589 2591
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2084} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2593 2608
                  (   ( $pad{I2085} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2593 2606
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2085} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2608 2615
                  (   ( $pad{I2086} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2608 2610
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2086} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2072} ) or 1 )
               &&   
               ## <group>
               ## pos: 2616 2632
                (   ( $pad{I2087} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2087} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2071} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for metasyntax
 # Data::Bind->sub_signature
#  (\&metasyntax, );
;
*char_range = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 2661 2712
       (
        (   ( $pad{I2088} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2662 2709
           (
               ( $pad{I2089} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2668 2692
               (
  
                 ## <group>
                 ## pos: 2668 2673
                  (   ( $pad{I2090} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2670 2672
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2090} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2673 2692
                  (   ( $pad{I2091} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2673 2687
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2091} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2089} ) or 1 )
               &&   
               ## <group>
               ## pos: 2693 2709
                (   ( $pad{I2092} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2092} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2088} ) && 0 ) )
       && do { while (
        (   ( $pad{I2088} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2662 2709
           (
               ( $pad{I2089} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2668 2692
               (
  
                 ## <group>
                 ## pos: 2668 2673
                  (   ( $pad{I2090} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2670 2672
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2090} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2673 2692
                  (   ( $pad{I2091} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2673 2687
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2091} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2089} ) or 1 )
               &&   
               ## <group>
               ## pos: 2693 2709
                (   ( $pad{I2092} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2092} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2088} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_range
 # Data::Bind->sub_signature
#  (\&char_range, );
;
*char_class = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 2738 2780
       (
           ( $pad{I2093} = $pos or 1 )
           && (
           ## <quant>
           ## pos: 2739 2755
           (
            (   ( $pad{I2094} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 2741 2749
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2094} ) && 0 ) )
           && do { while (
            (   ( $pad{I2094} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 2741 2749
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2094} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2093} ) or 1 )
           &&            ## <concat>
           ## pos: 2756 2780
           (
  
             ## <group>
             ## pos: 2756 2762
              (   ( $pad{I2095} = $pos or 1 ) &&

               ## <constant>
               ## pos: 2758 2760
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2095} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2762 2777
              (   ( $pad{I2096} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 2762 2775
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2096} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 2777 2780
              (   ( $pad{I2097} = $pos or 1 ) &&

               ## <constant>
               ## pos: 2777 2779
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2097} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_class
 # Data::Bind->sub_signature
#  (\&char_class, );
;
*string_code = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 2850 3134
       (
        (   ( $pad{I2098} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2851 3131
           (
               ( $pad{I2099} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2857 2881
               (
  
                 ## <group>
                 ## pos: 2857 2862
                  (   ( $pad{I2100} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2859 2861
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2100} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2862 2881
                  (   ( $pad{I2101} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2862 2876
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2101} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2882 2910
               (
  
                 ## <group>
                 ## pos: 2882 2888
                  (   ( $pad{I2102} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2884 2886
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2888 2903
                  (   ( $pad{I2103} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2888 2898
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2903 2910
                  (   ( $pad{I2104} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2903 2905
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2104} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2911 2943
               (
  
                 ## <group>
                 ## pos: 2911 2917
                  (   ( $pad{I2105} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2913 2915
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2105} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2917 2936
                  (   ( $pad{I2106} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2917 2933
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2106} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2936 2943
                  (   ( $pad{I2107} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2936 2938
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2107} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2944 2982
               (
  
                 ## <group>
                 ## pos: 2944 2950
                  (   ( $pad{I2108} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2946 2948
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2950 2975
                  (   ( $pad{I2109} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 2951 2972
                   (
                       ( $pad{I2110} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 2951 2967
                        (   ( $pad{I2111} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 2952 2966
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2111} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2110} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 2968 2972
                        (   ( $pad{I2112} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2112} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2975 2982
                  (   ( $pad{I2113} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2975 2977
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2113} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2983 3021
               (
  
                 ## <group>
                 ## pos: 2983 2989
                  (   ( $pad{I2114} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2985 2987
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2989 3014
                  (   ( $pad{I2115} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 2990 3011
                   (
                       ( $pad{I2116} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 2990 3006
                        (   ( $pad{I2117} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 2991 3005
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2117} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2116} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3007 3011
                        (   ( $pad{I2118} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2118} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3014 3021
                  (   ( $pad{I2119} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3014 3016
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 3022 3060
               (
  
                 ## <group>
                 ## pos: 3022 3028
                  (   ( $pad{I2120} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3024 3026
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3028 3053
                  (   ( $pad{I2121} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 3029 3050
                   (
                       ( $pad{I2122} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 3029 3045
                        (   ( $pad{I2123} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 3030 3044
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2123} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2122} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3046 3050
                        (   ( $pad{I2124} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2124} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3053 3060
                  (   ( $pad{I2125} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3053 3055
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2125} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 3061 3095
               (
  
                 ## <group>
                 ## pos: 3061 3088
                  (   ( $pad{I2126} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 3064 3086
                   (
                       ( $pad{I2127} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 3064 3071
                        (   ( $pad{I2128} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 3065 3070
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2128} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3072 3076
                        (   ( $pad{I2129} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3073 3075
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2129} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3077 3081
                        (   ( $pad{I2130} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3078 3080
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2130} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3082 3086
                        (   ( $pad{I2131} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3083 3085
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2131} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2126} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3088 3095
                  (   ( $pad{I2132} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3088 3090
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2132} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&   
               ## <group>
               ## pos: 3096 3108
                (   ( $pad{I2133} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 3098 3103
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2133} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&   
               ## <group>
               ## pos: 3109 3131
                (   ( $pad{I2134} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2134} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2098} ) && 0 ) )
       && do { while (
        (   ( $pad{I2098} = $pos or 1 ) &&
           ## <alt>
           ## pos: 2851 3131
           (
               ( $pad{I2099} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2857 2881
               (
  
                 ## <group>
                 ## pos: 2857 2862
                  (   ( $pad{I2100} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2859 2861
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2100} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2862 2881
                  (   ( $pad{I2101} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 2862 2876
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2101} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2882 2910
               (
  
                 ## <group>
                 ## pos: 2882 2888
                  (   ( $pad{I2102} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2884 2886
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2102} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2888 2903
                  (   ( $pad{I2103} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2888 2898
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2103} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2903 2910
                  (   ( $pad{I2104} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2903 2905
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2104} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2911 2943
               (
  
                 ## <group>
                 ## pos: 2911 2917
                  (   ( $pad{I2105} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2913 2915
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2105} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2917 2936
                  (   ( $pad{I2106} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2917 2933
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2106} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2936 2943
                  (   ( $pad{I2107} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2936 2938
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2107} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2944 2982
               (
  
                 ## <group>
                 ## pos: 2944 2950
                  (   ( $pad{I2108} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2946 2948
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2108} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2950 2975
                  (   ( $pad{I2109} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 2951 2972
                   (
                       ( $pad{I2110} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 2951 2967
                        (   ( $pad{I2111} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 2952 2966
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2111} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2110} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 2968 2972
                        (   ( $pad{I2112} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2112} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2109} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2975 2982
                  (   ( $pad{I2113} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2975 2977
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2113} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 2983 3021
               (
  
                 ## <group>
                 ## pos: 2983 2989
                  (   ( $pad{I2114} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 2985 2987
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2114} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 2989 3014
                  (   ( $pad{I2115} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 2990 3011
                   (
                       ( $pad{I2116} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 2990 3006
                        (   ( $pad{I2117} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 2991 3005
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2117} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2116} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3007 3011
                        (   ( $pad{I2118} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2118} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2115} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3014 3021
                  (   ( $pad{I2119} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3014 3016
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2119} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 3022 3060
               (
  
                 ## <group>
                 ## pos: 3022 3028
                  (   ( $pad{I2120} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3024 3026
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2120} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3028 3053
                  (   ( $pad{I2121} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 3029 3050
                   (
                       ( $pad{I2122} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 3029 3045
                        (   ( $pad{I2123} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 3030 3044
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2123} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2122} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3046 3050
                        (   ( $pad{I2124} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2124} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2121} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3053 3060
                  (   ( $pad{I2125} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3053 3055
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2125} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&                ## <concat>
               ## pos: 3061 3095
               (
  
                 ## <group>
                 ## pos: 3061 3088
                  (   ( $pad{I2126} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 3064 3086
                   (
                       ( $pad{I2127} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 3064 3071
                        (   ( $pad{I2128} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 3065 3070
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2128} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3072 3076
                        (   ( $pad{I2129} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3073 3075
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2129} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3077 3081
                        (   ( $pad{I2130} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3078 3080
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2130} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2127} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3082 3086
                        (   ( $pad{I2131} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3083 3085
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2131} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2126} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3088 3095
                  (   ( $pad{I2132} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3088 3090
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2132} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&   
               ## <group>
               ## pos: 3096 3108
                (   ( $pad{I2133} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 3098 3103
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2133} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2099} ) or 1 )
               &&   
               ## <group>
               ## pos: 3109 3131
                (   ( $pad{I2134} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I2134} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2098} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for string_code
 # Data::Bind->sub_signature
#  (\&string_code, );
;
*parsed_code = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 3204 3249
       (
  
         ## <group>
         ## pos: 3204 3223
          (   ( $pad{I2135} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 3204 3218
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2135} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 3223 3249
          (   ( $pad{I2136} = $pos or 1 ) &&
           ## <closure>
           ## pos: 3223 3248
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return('{' . $::_V6_MATCH_ . '}');
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2136} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parsed_code
 # Data::Bind->sub_signature
#  (\&parsed_code, );
;
*named_capture_body = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 3283 3588
       (
           ( $pad{I2137} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 3284 3355
           (
  
             ## <group>
             ## pos: 3284 3289
              (   ( $pad{I2138} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3285 3287
               ( ( substr( $s, $pos, 1 ) eq '(' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2138} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3289 3303
              (   ( $pad{I2139} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3289 3295
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2139} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3303 3307
              (   ( $pad{I2140} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3303 3305
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2140} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3307 3355
              (   ( $pad{I2141} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3307 3350
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2141} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
           &&            ## <concat>
           ## pos: 3356 3403
           (
  
             ## <group>
             ## pos: 3356 3361
              (   ( $pad{I2142} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3357 3359
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2142} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3361 3375
              (   ( $pad{I2143} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3361 3367
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2143} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3375 3379
              (   ( $pad{I2144} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3375 3377
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2144} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3379 3403
              (   ( $pad{I2145} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3379 3398
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2145} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
           &&            ## <concat>
           ## pos: 3404 3465
           (
  
             ## <group>
             ## pos: 3404 3409
              (   ( $pad{I2146} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3405 3407
               ( ( substr( $s, $pos, 1 ) eq '<' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2146} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3409 3429
              (   ( $pad{I2147} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3409 3427
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2147} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3429 3465
              (   ( $pad{I2148} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3429 3460
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2148} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
           &&            ## <concat>
           ## pos: 3466 3554
           (
  
             ## <group>
             ## pos: 3466 3471
              (   ( $pad{I2149} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3467 3469
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2149} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3471 3485
              (   ( $pad{I2150} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 3471 3481
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I2150} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3485 3496
              (   ( $pad{I2151} = $pos or 1 ) &&

               ## <constant>
               ## pos: 3485 3487
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2151} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 3496 3554
              (   ( $pad{I2152} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3496 3549
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2152} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2137} ) or 1 )
           &&   
           ## <group>
           ## pos: 3555 3588
            (   ( $pad{I2153} = $pos or 1 ) &&
             ## <closure>
             ## pos: 3556 3587
             do { 
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               sub { my $_V6_SELF = shift;  { die("invalid alias syntax");
 } }->( $m );
               1;
             }
             ## </closure>
 ||    ( ( $pos = $pad{I2153} ) && 0 ) )
           ## </group>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_capture_body
 # Data::Bind->sub_signature
#  (\&named_capture_body, );
;
*parse_metasyntax = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 3624 5942
       (
  
         ## <group>
         ## pos: 3624 3668
          (   ( $pad{I2154} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 3624 3663
           do{
                my $from = $pos;
                my $bool =                    ## <alt>
                   ## pos: 3640 3662
                   (
                       ( $pad{I2155} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 3640 3645
                        (   ( $pad{I2156} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3641 3644
                         ( ( substr( $s, $pos, 1 ) eq '!' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2156} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3646 3651
                        (   ( $pad{I2157} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3647 3650
                         ( ( substr( $s, $pos, 1 ) eq '?' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2157} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3652 3657
                        (   ( $pad{I2158} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 3653 3656
                         ( ( substr( $s, $pos, 1 ) eq '.' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2158} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2155} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 3658 3662
                        (   ( $pad{I2159} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I2159} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
;
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'modifier'} = $match;
                $bool
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2154} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 3668 5942
          (   ( $pad{I2160} = $pos or 1 ) &&
           ## <alt>
           ## pos: 3669 5940
           (
               ( $pad{I2161} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 3669 3832
               (
  
                 ## <group>
                 ## pos: 3669 3683
                  (   ( $pad{I2162} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3678 3681
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2162} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3683 3698
                  (   ( $pad{I2163} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3683 3696
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2163} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3698 3711
                  (   ( $pad{I2164} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3698 3702
                   ( ( substr( $s, $pos, 2 ) eq '}>' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2164} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3711 3832
                  (   ( $pad{I2165} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3711 3827
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I2165} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
               &&                ## <concat>
               ## pos: 3833 4326
               (
  
                 ## <group>
                 ## pos: 3833 3863
                  (   ( $pad{I2166} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3842 3854
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2166} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 3863 3896
                 (
                  (   ( $pad{I2167} = $pos or 1 ) &&

                     ## <capture>
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             ## <concat>
                             ## pos: 3864 3885
                             (
  
                               ## <group>
                               ## pos: 3864 3872
                                (   ( $pad{I2168} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2168} ) && 0 ) )
                               ## </group>

                             &&
  
                               ## <group>
                               ## pos: 3872 3885
                                (   ( $pad{I2169} = $pos or 1 ) &&
                                 ## <named_capture>
                                 ## pos: 3872 3884
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                 ## </named_capture>
 ||    ( ( $pos = $pad{I2169} ) && 0 ) )
                               ## </group>

                             )
                             ## </concat>
;
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     }
                     ## </capture>
 ||    ( ( $pos = $pad{I2167} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I2167} = $pos or 1 ) &&

                     ## <capture>
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             ## <concat>
                             ## pos: 3864 3885
                             (
  
                               ## <group>
                               ## pos: 3864 3872
                                (   ( $pad{I2168} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2168} ) && 0 ) )
                               ## </group>

                             &&
  
                               ## <group>
                               ## pos: 3872 3885
                                (   ( $pad{I2169} = $pos or 1 ) &&
                                 ## <named_capture>
                                 ## pos: 3872 3884
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                 ## </named_capture>
 ||    ( ( $pos = $pad{I2169} ) && 0 ) )
                               ## </group>

                             )
                             ## </concat>
;
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     }
                     ## </capture>
 ||    ( ( $pos = $pad{I2167} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>

               &&
  
                 ## <group>
                 ## pos: 3896 3907
                  (   ( $pad{I2170} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 3896 3898
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2170} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 3907 4326
                  (   ( $pad{I2171} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3907 4321
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if(${ $::_V6_MATCH_->{'modifier'}} eq '!') { return({'negate' => {'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]}});
 } 
;
return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I2171} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
               &&                ## <concat>
               ## pos: 4327 5773
               (
  
                 ## <group>
                 ## pos: 4327 4352
                  (   ( $pad{I2172} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 4336 4343
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2172} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 4352 5773
                  (   ( $pad{I2173} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 4353 5767
                   (
                       ( $pad{I2174} = $pos or 1 )
                       && (
                       ## <concat>
                       ## pos: 4353 4790
                       (
  
                         ## <group>
                         ## pos: 4353 4370
                          (   ( $pad{I2175} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 4364 4369
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
 ||    ( ( $pos = $pad{I2175} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 4370 4377
                          (   ( $pad{I2176} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 4370 4376
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I2176} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 4377 4390
                          (   ( $pad{I2177} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 4377 4379
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2177} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 4390 4790
                          (   ( $pad{I2178} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 4390 4781
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I2178} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2174} ) or 1 )
                       &&                        ## <concat>
                       ## pos: 4791 5555
                       (
  
                         ## <group>
                         ## pos: 4791 4806
                          (   ( $pad{I2179} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 4802 4805
                           ( ( substr( $s, $pos, 1 ) eq ':' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2179} ) && 0 ) )
                         ## </group>

                       &&
                         ## <quant>
                         ## pos: 4806 4823
                         (
                          (   ( $pad{I2180} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 4806 4811
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
 ||    ( ( $pos = $pad{I2180} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>

                       &&
  
                         ## <group>
                         ## pos: 4823 4993
                          (   ( $pad{I2181} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 4823 4982
                           do{
                my $from = $pos;
                my $bool =                                    ## <quant>
                                   ## pos: 4834 4981
                                   do { while (
                                    (   ( $pad{I2182} = $pos or 1 ) &&
                                       ## <alt>
                                       ## pos: 4848 4968
                                       (
                                           ( $pad{I2183} = $pos or 1 )
                                           && (
                                           ## <concat>
                                           ## pos: 4862 4894
                                           (
  
                                             ## <group>
                                             ## pos: 4862 4867
                                              (   ( $pad{I2184} = $pos or 1 ) &&

                                               ## <constant>
                                               ## pos: 4864 4866
                                               ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                   ? ( $pos += 1 or 1 )
                                                   : 0
                                               )
                                               ## </constant>
 ||    ( ( $pos = $pad{I2184} ) && 0 ) )
                                             ## </group>

                                           &&
  
                                             ## <group>
                                             ## pos: 4867 4894
                                              (   ( $pad{I2185} = $pos or 1 ) &&
                                               ## <named_capture>
                                               ## pos: 4867 4881
                                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                               ## </named_capture>
 ||    ( ( $pos = $pad{I2185} ) && 0 ) )
                                             ## </group>

                                           )
                                           ## </concat>

                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I2183} ) or 1 )
                                           &&   
                                           ## <group>
                                           ## pos: 4895 4943
                                            (   ( $pad{I2186} = $pos or 1 ) &&
                                            ## <metasyntax>
                                             ## pos: 4897 4930
                                             do{
                my $match = 
          ## <variable>
          ## pos: 4897 4930
          do {
            our $I2187;
            our $I2187_sizes;
            unless ( $I2187 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2187_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2187 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2187_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2187->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2187, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                            ## </metasyntax>
 ||    ( ( $pos = $pad{I2186} ) && 0 ) )
                                           ## </group>

                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I2183} ) or 1 )
                                           &&   
                                           ## <group>
                                           ## pos: 4944 4968
                                            (   ( $pad{I2188} = $pos or 1 ) &&
                                             ## <perl5>
                                             ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                 ? ( $pos += length( $1 ) or 1 )
                                                 : 0
                                             )
                                             ## </perl5>
 ||    ( ( $pos = $pad{I2188} ) && 0 ) )
                                           ## </group>

                                         )
                                       )
                                       ## </alt>
 ||    ( ( $pos = $pad{I2182} ) && 0 ) )) {}; $bool = 1 }
                                   ## </quant>
;
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'str'} = $match;
                $bool
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I2181} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 4993 5006
                          (   ( $pad{I2189} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 4993 4995
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2189} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 5006 5555
                          (   ( $pad{I2190} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 5006 5546
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => {'metasyntax' => {'metasyntax' => '\'' . ${ $::_V6_MATCH_->{'str'}} . '\''}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'string' => ${ $::_V6_MATCH_->{'str'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I2190} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2174} ) or 1 )
                       &&                        ## <concat>
                       ## pos: 5556 5767
                       (
  
                         ## <group>
                         ## pos: 5556 5571
                          (   ( $pad{I2191} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 5567 5569
                           ( ( substr( $s, $pos, 1 ) eq '(' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2191} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 5571 5586
                          (   ( $pad{I2192} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 5571 5584
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I2192} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 5586 5589
                          (   ( $pad{I2193} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 5586 5588
                           ( ( substr( $s, $pos, 1 ) eq ')' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2193} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 5589 5602
                          (   ( $pad{I2194} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 5589 5591
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I2194} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 5602 5767
                          (   ( $pad{I2195} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 5602 5758
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'call' => {'method' => ${ $::_V6_MATCH_->{'ident'}}, 'params' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I2195} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I2173} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I2161} ) or 1 )
               &&                ## <concat>
               ## pos: 5774 5940
               (
  
                 ## <group>
                 ## pos: 5774 5797
                  (   ( $pad{I2196} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 5783 5795
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I2196} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 5797 5808
                  (   ( $pad{I2197} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 5797 5799
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I2197} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 5808 5940
                  (   ( $pad{I2198} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 5808 5935
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${ $::_V6_MATCH_->{'metasyntax'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I2198} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I2160} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parse_metasyntax
 # Data::Bind->sub_signature
#  (\&parse_metasyntax, );
;
%variables = ('$<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 5990 6063
       (
  
         ## <group>
         ## pos: 5990 5998
          (   ( $pad{I2199} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 5990 5997
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2199} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 5998 6009
          (   ( $pad{I2200} = $pos or 1 ) &&

           ## <constant>
           ## pos: 5998 6000
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2200} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 6009 6063
          (   ( $pad{I2201} = $pos or 1 ) &&
           ## <closure>
           ## pos: 6009 6058
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' .  $::_V6_MATCH_->{'ident'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2201} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 6093 6255
       (
           ( $pad{I2202} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 6093 6158
           (
             ## <quant>
             ## pos: 6093 6111
             (
              (   ( $pad{I2203} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6093 6101
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2203} ) && 0 ) )
             && do { while (
              (   ( $pad{I2203} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6093 6101
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2203} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6111 6158
              (   ( $pad{I2204} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6111 6153
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2204} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2202} ) or 1 )
           &&            ## <concat>
           ## pos: 6159 6255
           (
             ## <quant>
             ## pos: 6159 6180
             (
              (   ( $pad{I2205} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 6168 6170
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2205} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 6180 6214
             (
              (   ( $pad{I2206} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6181 6203
                 (
                     ( $pad{I2207} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6181 6191
                      (   ( $pad{I2208} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6182 6190
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2208} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6192 6195
                      (   ( $pad{I2209} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6193 6194
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6196 6203
                     (
  
                       ## <group>
                       ## pos: 6196 6200
                        (   ( $pad{I2210} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6197 6199
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6200 6203
                        (   ( $pad{I2211} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6200 6202
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2206} ) && 0 ) )
             && do { while (
              (   ( $pad{I2206} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6181 6203
                 (
                     ( $pad{I2207} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6181 6191
                      (   ( $pad{I2208} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6182 6190
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2208} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6192 6195
                      (   ( $pad{I2209} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6193 6194
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2209} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2207} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6196 6203
                     (
  
                       ## <group>
                       ## pos: 6196 6200
                        (   ( $pad{I2210} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6197 6199
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2210} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6200 6203
                        (   ( $pad{I2211} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6200 6202
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2211} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2206} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6214 6255
              (   ( $pad{I2212} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6214 6250
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2212} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'@' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 6285 6447
       (
           ( $pad{I2213} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 6285 6350
           (
             ## <quant>
             ## pos: 6285 6303
             (
              (   ( $pad{I2214} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6285 6293
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2214} ) && 0 ) )
             && do { while (
              (   ( $pad{I2214} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6285 6293
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2214} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6303 6350
              (   ( $pad{I2215} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6303 6345
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2215} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2213} ) or 1 )
           &&            ## <concat>
           ## pos: 6351 6447
           (
             ## <quant>
             ## pos: 6351 6372
             (
              (   ( $pad{I2216} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 6360 6362
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2216} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 6372 6406
             (
              (   ( $pad{I2217} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6373 6395
                 (
                     ( $pad{I2218} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6373 6383
                      (   ( $pad{I2219} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6374 6382
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2219} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6384 6387
                      (   ( $pad{I2220} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6385 6386
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6388 6395
                     (
  
                       ## <group>
                       ## pos: 6388 6392
                        (   ( $pad{I2221} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6389 6391
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6392 6395
                        (   ( $pad{I2222} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6392 6394
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2217} ) && 0 ) )
             && do { while (
              (   ( $pad{I2217} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6373 6395
                 (
                     ( $pad{I2218} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6373 6383
                      (   ( $pad{I2219} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6374 6382
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2219} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6384 6387
                      (   ( $pad{I2220} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6385 6386
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2220} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2218} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6388 6395
                     (
  
                       ## <group>
                       ## pos: 6388 6392
                        (   ( $pad{I2221} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6389 6391
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2221} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6392 6395
                        (   ( $pad{I2222} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6392 6394
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2222} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2217} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6406 6447
              (   ( $pad{I2223} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6406 6442
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2223} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'%' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 6477 6639
       (
           ( $pad{I2224} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 6477 6542
           (
             ## <quant>
             ## pos: 6477 6495
             (
              (   ( $pad{I2225} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6477 6485
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2225} ) && 0 ) )
             && do { while (
              (   ( $pad{I2225} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 6477 6485
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2225} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6495 6542
              (   ( $pad{I2226} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6495 6537
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2226} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2224} ) or 1 )
           &&            ## <concat>
           ## pos: 6543 6639
           (
             ## <quant>
             ## pos: 6543 6564
             (
              (   ( $pad{I2227} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 6552 6554
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2227} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 6564 6598
             (
              (   ( $pad{I2228} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6565 6587
                 (
                     ( $pad{I2229} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6565 6575
                      (   ( $pad{I2230} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6566 6574
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2230} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6576 6579
                      (   ( $pad{I2231} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6577 6578
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2231} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6580 6587
                     (
  
                       ## <group>
                       ## pos: 6580 6584
                        (   ( $pad{I2232} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6581 6583
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2232} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6584 6587
                        (   ( $pad{I2233} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6584 6586
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2233} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2228} ) && 0 ) )
             && do { while (
              (   ( $pad{I2228} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 6565 6587
                 (
                     ( $pad{I2229} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 6565 6575
                      (   ( $pad{I2230} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 6566 6574
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I2230} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 6576 6579
                      (   ( $pad{I2231} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 6577 6578
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2231} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I2229} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 6580 6587
                     (
  
                       ## <group>
                       ## pos: 6580 6584
                        (   ( $pad{I2232} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6581 6583
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2232} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 6584 6587
                        (   ( $pad{I2233} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 6584 6586
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2233} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I2228} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 6598 6639
              (   ( $pad{I2234} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6598 6634
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2234} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
%rule_terms = ('{*}' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 6751 6810
        (   ( $pad{I2235} = $pos or 1 ) &&
         ## <closure>
         ## pos: 6751 6805
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => 'null'}});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2235} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\'' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 6842 6931
       (
  
         ## <group>
         ## pos: 6842 6857
          (   ( $pad{I2236} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 6842 6852
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2236} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 6857 6868
          (   ( $pad{I2237} = $pos or 1 ) &&

           ## <constant>
           ## pos: 6857 6859
           ( ( substr( $s, $pos, 1 ) eq chr(39) )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2237} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 6868 6931
          (   ( $pad{I2238} = $pos or 1 ) &&
           ## <closure>
           ## pos: 6868 6926
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => '\'' . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2238} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'(' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 6961 7027
       (
  
         ## <group>
         ## pos: 6961 6968
          (   ( $pad{I2239} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 6961 6967
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2239} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 6968 6979
          (   ( $pad{I2240} = $pos or 1 ) &&

           ## <constant>
           ## pos: 6968 6970
           ( ( substr( $s, $pos, 1 ) eq ')' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2240} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 6979 7027
          (   ( $pad{I2241} = $pos or 1 ) &&
           ## <closure>
           ## pos: 6979 7022
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2241} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<(' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 7058 7129
       (
  
         ## <group>
         ## pos: 7058 7066
          (   ( $pad{I2242} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 7058 7064
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2242} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7066 7079
          (   ( $pad{I2243} = $pos or 1 ) &&

           ## <constant>
           ## pos: 7066 7070
           ( ( substr( $s, $pos, 2 ) eq ')>' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2243} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7079 7129
          (   ( $pad{I2244} = $pos or 1 ) &&
           ## <closure>
           ## pos: 7079 7124
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capture_as_result' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2244} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<+' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 7160 7378
       (
  
         ## <group>
         ## pos: 7160 7181
          (   ( $pad{I2245} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 7160 7172
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2245} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 7181 7214
         do { while (
          (   ( $pad{I2246} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 7182 7203
                     (
  
                       ## <group>
                       ## pos: 7182 7190
                        (   ( $pad{I2247} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2247} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 7190 7203
                        (   ( $pad{I2248} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 7190 7202
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I2248} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I2246} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 7214 7225
          (   ( $pad{I2249} = $pos or 1 ) &&

           ## <constant>
           ## pos: 7214 7216
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2249} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7225 7378
          (   ( $pad{I2250} = $pos or 1 ) &&
           ## <closure>
           ## pos: 7225 7373
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2250} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<-' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 7409 7627
       (
  
         ## <group>
         ## pos: 7409 7430
          (   ( $pad{I2251} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 7409 7421
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2251} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 7430 7463
         do { while (
          (   ( $pad{I2252} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 7431 7452
                     (
  
                       ## <group>
                       ## pos: 7431 7439
                        (   ( $pad{I2253} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2253} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 7439 7452
                        (   ( $pad{I2254} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 7439 7451
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I2254} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I2252} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 7463 7474
          (   ( $pad{I2255} = $pos or 1 ) &&

           ## <constant>
           ## pos: 7463 7465
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2255} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7474 7627
          (   ( $pad{I2256} = $pos or 1 ) &&
           ## <closure>
           ## pos: 7474 7622
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['-' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2256} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<[' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 7658 7887
       (
  
         ## <group>
         ## pos: 7658 7672
          (   ( $pad{I2257} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 7658 7670
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_range'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2257} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7672 7683
          (   ( $pad{I2258} = $pos or 1 ) &&

           ## <constant>
           ## pos: 7672 7674
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2258} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 7683 7716
         do { while (
          (   ( $pad{I2259} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 7684 7705
                     (
  
                       ## <group>
                       ## pos: 7684 7692
                        (   ( $pad{I2260} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I2260} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 7692 7705
                        (   ( $pad{I2261} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 7692 7704
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I2261} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I2259} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 7716 7727
          (   ( $pad{I2262} = $pos or 1 ) &&

           ## <constant>
           ## pos: 7716 7718
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2262} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7727 7887
          (   ( $pad{I2263} = $pos or 1 ) &&
           ## <closure>
           ## pos: 7727 7882
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+[' .  $::_V6_MATCH_->{'char_range'} . ']',
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2263} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 7917 7980
       (
  
         ## <group>
         ## pos: 7917 7944
          (   ( $pad{I2264} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 7917 7935
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2264} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 7944 7980
          (   ( $pad{I2265} = $pos or 1 ) &&
           ## <closure>
           ## pos: 7944 7975
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2265} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'{' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 8010 8151
       (
  
         ## <group>
         ## pos: 8010 8025
          (   ( $pad{I2266} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 8010 8023
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2266} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 8025 8036
          (   ( $pad{I2267} = $pos or 1 ) &&

           ## <constant>
           ## pos: 8025 8027
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2267} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 8036 8151
          (   ( $pad{I2268} = $pos or 1 ) &&
           ## <closure>
           ## pos: 8036 8146
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => 'plain'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2268} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\\' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 8182 8237
       (
  
         ## <group>
         ## pos: 8182 8205
          (   ( $pad{I2269} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 8182 8196
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'special_char'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2269} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 8205 8237
          (   ( $pad{I2270} = $pos or 1 ) &&
           ## <closure>
           ## pos: 8205 8232
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'special_char'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2270} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'.' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8267 8298
        (   ( $pad{I2271} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8267 8293
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'dot' => 1});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2271} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'[' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 8328 8370
       (
  
         ## <group>
         ## pos: 8328 8335
          (   ( $pad{I2272} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 8328 8334
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2272} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 8335 8346
          (   ( $pad{I2273} = $pos or 1 ) &&

           ## <constant>
           ## pos: 8335 8337
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2273} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 8346 8370
          (   ( $pad{I2274} = $pos or 1 ) &&
           ## <closure>
           ## pos: 8346 8365
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2274} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':::' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8394 8425
        (   ( $pad{I2275} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8394 8424
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2275} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':?' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8449 8479
        (   ( $pad{I2276} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8449 8478
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':?'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2276} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':+' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8503 8533
        (   ( $pad{I2277} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8503 8532
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':+'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2277} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'::' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8557 8587
        (   ( $pad{I2278} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8557 8586
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2278} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8611 8641
        (   ( $pad{I2279} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8611 8640
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2279} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8665 8695
        (   ( $pad{I2280} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8665 8694
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2280} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8719 8749
        (   ( $pad{I2281} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8719 8748
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2281} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^^' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8773 8803
        (   ( $pad{I2282} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8773 8802
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2282} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8827 8857
        (   ( $pad{I2283} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8827 8856
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2283} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'>>' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8882 8912
        (   ( $pad{I2284} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8882 8911
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2284} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'»' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8936 8966
        (   ( $pad{I2285} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8936 8965
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2285} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 8991 9021
        (   ( $pad{I2286} = $pos or 1 ) &&
         ## <closure>
         ## pos: 8991 9020
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2286} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'«' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 9045 9075
        (   ( $pad{I2287} = $pos or 1 ) &&
         ## <closure>
         ## pos: 9045 9074
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I2287} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':i' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9108 9197
       (
  
         ## <group>
         ## pos: 9108 9114
          (   ( $pad{I2288} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9108 9113
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2288} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9114 9129
          (   ( $pad{I2289} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9114 9120
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2289} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9129 9197
          (   ( $pad{I2290} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9129 9196
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2290} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':ignorecase' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9238 9327
       (
  
         ## <group>
         ## pos: 9238 9244
          (   ( $pad{I2291} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9238 9243
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2291} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9244 9259
          (   ( $pad{I2292} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9244 9250
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2292} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9259 9327
          (   ( $pad{I2293} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9259 9326
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2293} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':s' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9359 9432
       (
  
         ## <group>
         ## pos: 9359 9365
          (   ( $pad{I2294} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9359 9364
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2294} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9365 9380
          (   ( $pad{I2295} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9365 9371
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2295} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9380 9432
          (   ( $pad{I2296} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9380 9431
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2296} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':sigspace' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9473 9546
       (
  
         ## <group>
         ## pos: 9473 9479
          (   ( $pad{I2297} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9473 9478
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2297} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9479 9494
          (   ( $pad{I2298} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9479 9485
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2298} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9494 9546
          (   ( $pad{I2299} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9494 9545
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2299} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':P5' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9578 9647
       (
  
         ## <group>
         ## pos: 9578 9584
          (   ( $pad{I2300} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9578 9583
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2300} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9584 9599
          (   ( $pad{I2301} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9584 9590
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2301} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9599 9647
          (   ( $pad{I2302} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9599 9646
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2302} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':Perl5' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9688 9757
       (
  
         ## <group>
         ## pos: 9688 9694
          (   ( $pad{I2303} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9688 9693
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2303} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9694 9709
          (   ( $pad{I2304} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9694 9700
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2304} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9709 9757
          (   ( $pad{I2305} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9709 9756
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2305} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':bytes' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9798 9867
       (
  
         ## <group>
         ## pos: 9798 9804
          (   ( $pad{I2306} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9798 9803
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2306} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9804 9819
          (   ( $pad{I2307} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9804 9810
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2307} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9819 9867
          (   ( $pad{I2308} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9819 9866
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'bytes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2308} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':codes' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 9908 9977
       (
  
         ## <group>
         ## pos: 9908 9914
          (   ( $pad{I2309} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 9908 9913
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2309} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9914 9929
          (   ( $pad{I2310} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 9914 9920
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2310} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 9929 9977
          (   ( $pad{I2311} = $pos or 1 ) &&
           ## <closure>
           ## pos: 9929 9976
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'codes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2311} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':graphs' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 10018 10087
       (
  
         ## <group>
         ## pos: 10018 10024
          (   ( $pad{I2312} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 10018 10023
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2312} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 10024 10039
          (   ( $pad{I2313} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 10024 10030
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2313} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 10039 10087
          (   ( $pad{I2314} = $pos or 1 ) &&
           ## <closure>
           ## pos: 10039 10086
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'graphs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2314} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':langs' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 10128 10197
       (
  
         ## <group>
         ## pos: 10128 10134
          (   ( $pad{I2315} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 10128 10133
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2315} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 10134 10149
          (   ( $pad{I2316} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 10134 10140
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2316} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 10149 10197
          (   ( $pad{I2317} = $pos or 1 ) &&
           ## <closure>
           ## pos: 10149 10196
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'langs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2317} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
*term = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 10237 10921
       (
           ( $pad{I2318} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 10238 10616
           (
  
             ## <group>
             ## pos: 10238 10281
              (   ( $pad{I2319} = $pos or 1 ) &&
              ## <metasyntax>
               ## pos: 10240 10273
               do{
                my $match = 
          ## <variable>
          ## pos: 10240 10273
          do {
            our $I2320;
            our $I2320_sizes;
            unless ( $I2320 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2320_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2320 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2320_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2320->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2320, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
              ## </metasyntax>
 ||    ( ( $pos = $pad{I2319} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10281 10616
              (   ( $pad{I2321} = $pos or 1 ) &&
               ## <alt>
               ## pos: 10282 10610
               (
                   ( $pad{I2322} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 10282 10523
                   (
                     ## <quant>
                     ## pos: 10282 10291
                     (
                      (   ( $pad{I2323} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 10284 10289
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2323} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>

                   &&
  
                     ## <group>
                     ## pos: 10291 10296
                      (   ( $pad{I2324} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 10291 10295
                       ( ( substr( $s, $pos, 2 ) eq ':=' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I2324} ) && 0 ) )
                     ## </group>

                   &&
                     ## <quant>
                     ## pos: 10296 10303
                     (
                      (   ( $pad{I2325} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 10296 10301
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I2325} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>

                   &&
  
                     ## <group>
                     ## pos: 10303 10334
                      (   ( $pad{I2326} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 10303 10323
                       do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                   $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_capture_body'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                       ## </named_capture>
 ||    ( ( $pos = $pad{I2326} ) && 0 ) )
                     ## </group>

                   &&
  
                     ## <group>
                     ## pos: 10334 10523
                      (   ( $pad{I2327} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 10334 10515
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'named_capture' => {'rule' => ${ $::_V6_MATCH_->{'named_capture_body'}}, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}}}});
 } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
 ||    ( ( $pos = $pad{I2327} ) && 0 ) )
                     ## </group>

                   )
                   ## </concat>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I2322} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 10524 10610
                    (   ( $pad{I2328} = $pos or 1 ) &&
                     ## <closure>
                     ## pos: 10535 10602
                     do {
                       local $::_V6_SUCCEED = 1;
                       $::_V6_MATCH_ = $m;
                       $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}});
 } }->( $m ) ); 
                       $bool = $::_V6_SUCCEED;
                       $::_V6_MATCH_ = $m if $bool; 
                       return $m if $bool; 
                     }
                     ## </closure>
 ||    ( ( $pos = $pad{I2328} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I2321} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2318} ) or 1 )
           &&            ## <concat>
           ## pos: 10617 10776
           (
  
             ## <group>
             ## pos: 10617 10662
              (   ( $pad{I2329} = $pos or 1 ) &&
              ## <metasyntax>
               ## pos: 10619 10653
               do{
                my $match = 
          ## <variable>
          ## pos: 10619 10653
          do {
            our $I2330;
            our $I2330_sizes;
            unless ( $I2330 ) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I2330_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I2330 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I2330_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I2330->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I2330, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
              ## </metasyntax>
 ||    ( ( $pos = $pad{I2329} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10662 10776
              (   ( $pad{I2331} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10662 10771
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2331} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2318} ) or 1 )
           &&            ## <concat>
           ## pos: 10777 10921
           (
  
             ## <group>
             ## pos: 10777 10824
              (   ( $pad{I2332} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I2332} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10824 10921
              (   ( $pad{I2333} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10824 10920
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'constant' => ${$::_V6_MATCH_}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2333} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for term
 # Data::Bind->sub_signature
#  (\&term, );
;
*quant = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 10942 11057
       (
           ( $pad{I2334} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 10943 11035
           (
  
             ## <group>
             ## pos: 10943 10951
              (   ( $pad{I2335} = $pos or 1 ) &&

               ## <constant>
               ## pos: 10946 10950
               ( ( substr( $s, $pos, 2 ) eq '**' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2335} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 10951 10958
             (
              (   ( $pad{I2336} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 10951 10956
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I2336} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 10958 10962
              (   ( $pad{I2337} = $pos or 1 ) &&

               ## <constant>
               ## pos: 10958 10960
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2337} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10962 10977
              (   ( $pad{I2338} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10962 10975
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2338} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10977 10988
              (   ( $pad{I2339} = $pos or 1 ) &&

               ## <constant>
               ## pos: 10977 10979
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I2339} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 10988 11035
              (   ( $pad{I2340} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10988 11030
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2340} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2334} ) or 1 )
           &&            ## <quant>
           ## pos: 11036 11057
           (
            (   ( $pad{I2341} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I2341} ) && 0 ) )
           || ( $bool = 1 )
           )
           ## </quant>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quant
 # Data::Bind->sub_signature
#  (\&quant, );
;
*quantifier = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 11083 11751
       (
  
         ## <group>
         ## pos: 11083 11108
          (   ( $pad{I2342} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11083 11103
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 11096 11102
                           (
                            (   ( $pad{I2343} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 11096 11101
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2343} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws1'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2342} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11108 11143
          (   ( $pad{I2344} = $pos or 1 ) &&
           ## <negate>
           ## pos: 11108 11138
           do{
               my $pos1 = $pos;
               do {
                 my $pos = $pos1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 
                     ## <before>
                     ## pos: 11118 11137
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
  
                               ## <group>
                               ## pos: 11118 11137
                                (   ( $pad{I2345} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I2345} ) && 0 ) )
                               ## </group>
;
                           $bool;
                         };
                     }
                     ## </before>
 ? 0 : 1;
                 $bool;
               };
           }
           ## </negate>
 ||    ( ( $pos = $pad{I2344} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11143 11154
          (   ( $pad{I2346} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11143 11149
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'term'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2346} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11154 11179
          (   ( $pad{I2347} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11154 11174
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 11167 11173
                           (
                            (   ( $pad{I2348} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 11167 11172
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2348} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws2'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2347} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11179 11191
          (   ( $pad{I2349} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11179 11186
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'quant'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2349} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11191 11225
          (   ( $pad{I2350} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11191 11220
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 11205 11219
                           (
                            (   ( $pad{I2351} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
 ||    ( ( $pos = $pad{I2351} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'greedy'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2350} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11225 11250
          (   ( $pad{I2352} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 11225 11245
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 11238 11244
                           (
                            (   ( $pad{I2353} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 11238 11243
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I2353} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws3'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2352} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 11250 11751
          (   ( $pad{I2354} = $pos or 1 ) &&
           ## <closure>
           ## pos: 11250 11750
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'quant'}} eq '' && (${ $::_V6_MATCH_->{'greedy'}} eq '' && (${ $::_V6_MATCH_->{'ws1'}} eq '' && (${ $::_V6_MATCH_->{'ws2'}} eq '' && ${ $::_V6_MATCH_->{'ws3'}} eq ''))))) { return(${ $::_V6_MATCH_->{'term'}});
 } 
;
return({'quant' => {'term' => ${ $::_V6_MATCH_->{'term'}}, 'quant' => ${ $::_V6_MATCH_->{'quant'}}, 'greedy' => ${ $::_V6_MATCH_->{'greedy'}}, 'ws1' => ${ $::_V6_MATCH_->{'ws1'}}, 'ws2' => ${ $::_V6_MATCH_->{'ws2'}}, 'ws3' => ${ $::_V6_MATCH_->{'ws3'}}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2354} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quantifier
 # Data::Bind->sub_signature
#  (\&quantifier, );
;
*concat = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 11773 11972
       (
         ## <quant>
         ## pos: 11773 11791
         (
          (   ( $pad{I2355} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 11773 11785
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2355} ) && 0 ) )
         && do { while (
          (   ( $pad{I2355} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 11773 11785
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2355} ) && 0 ) )) {}; $bool = 1 }
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 11791 11972
          (   ( $pad{I2356} = $pos or 1 ) &&
           ## <closure>
           ## pos: 11791 11971
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
        return { concat => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2356} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for concat
 # Data::Bind->sub_signature
#  (\&concat, );
;
*conjunctive1 = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 12000 12281
       (
         ## <quant>
         ## pos: 12000 12034
         (
          (   ( $pad{I2357} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12001 12026
             (
               ## <quant>
               ## pos: 12001 12009
               (
                (   ( $pad{I2358} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 12002 12007
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2358} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 12009 12012
                (   ( $pad{I2359} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12009 12011
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2359} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12012 12026
                (   ( $pad{I2360} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 12012 12025
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 12021 12024
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 12021 12024
                                      (   ( $pad{I2361} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 12021 12023
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2361} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I2360} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2357} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12034 12052
         (
          (   ( $pad{I2362} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 12034 12042
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2362} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12052 12101
         do { while (
          (   ( $pad{I2363} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12053 12093
             (
  
               ## <group>
               ## pos: 12053 12065
                (   ( $pad{I2364} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12062 12064
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2364} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12065 12080
                (   ( $pad{I2365} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 12065 12078
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 12074 12077
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 12074 12077
                                      (   ( $pad{I2366} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 12074 12076
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2366} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I2365} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12080 12093
                (   ( $pad{I2367} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 12080 12088
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2367} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2363} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 12101 12281
          (   ( $pad{I2368} = $pos or 1 ) &&
           ## <closure>
           ## pos: 12101 12280
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
        return { conjunctive1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2368} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive1
 # Data::Bind->sub_signature
#  (\&conjunctive1, );
;
*disjunctive1 = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 12309 12599
       (
         ## <quant>
         ## pos: 12309 12343
         (
          (   ( $pad{I2369} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12310 12335
             (
               ## <quant>
               ## pos: 12310 12318
               (
                (   ( $pad{I2370} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 12311 12316
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2370} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 12318 12321
                (   ( $pad{I2371} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12318 12320
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2371} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12321 12335
                (   ( $pad{I2372} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 12321 12334
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 12330 12333
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 12330 12333
                                      (   ( $pad{I2373} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 12330 12332
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2373} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I2372} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2369} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12343 12367
         (
          (   ( $pad{I2374} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 12343 12357
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2374} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12367 12421
         do { while (
          (   ( $pad{I2375} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12368 12413
             (
  
               ## <group>
               ## pos: 12368 12380
                (   ( $pad{I2376} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12377 12379
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2376} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12380 12394
                (   ( $pad{I2377} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 12380 12393
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 12389 12392
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 12389 12392
                                      (   ( $pad{I2378} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 12389 12391
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I2378} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I2377} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12394 12413
                (   ( $pad{I2379} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 12394 12408
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2379} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2375} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 12421 12599
          (   ( $pad{I2380} = $pos or 1 ) &&
           ## <closure>
           ## pos: 12421 12598
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
        return { alt1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2380} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for disjunctive1
 # Data::Bind->sub_signature
#  (\&disjunctive1, );
;
*conjunctive = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 12626 12901
       (
         ## <quant>
         ## pos: 12626 12649
         (
          (   ( $pad{I2381} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12627 12641
             (
               ## <quant>
               ## pos: 12627 12635
               (
                (   ( $pad{I2382} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 12628 12633
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2382} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 12635 12638
                (   ( $pad{I2383} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12635 12637
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2383} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12638 12641
                (   ( $pad{I2384} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12638 12640
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2384} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2381} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12649 12673
         (
          (   ( $pad{I2385} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 12649 12663
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2385} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12673 12716
         do { while (
          (   ( $pad{I2386} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12674 12708
             (
  
               ## <group>
               ## pos: 12674 12686
                (   ( $pad{I2387} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12683 12685
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2387} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12686 12689
                (   ( $pad{I2388} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12686 12688
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2388} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12689 12708
                (   ( $pad{I2389} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 12689 12703
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2389} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2386} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 12716 12901
          (   ( $pad{I2390} = $pos or 1 ) &&
           ## <closure>
           ## pos: 12716 12900
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
        return { conjunctive => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2390} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive
 # Data::Bind->sub_signature
#  (\&conjunctive, );
;
*rule = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 12921 13185
       (
         ## <quant>
         ## pos: 12921 12944
         (
          (   ( $pad{I2391} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12922 12936
             (
               ## <quant>
               ## pos: 12922 12930
               (
                (   ( $pad{I2392} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 12923 12928
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2392} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 12930 12933
                (   ( $pad{I2393} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12930 12932
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2393} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12933 12936
                (   ( $pad{I2394} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12933 12935
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2394} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2391} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12944 12967
         (
          (   ( $pad{I2395} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 12944 12957
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2395} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 12967 13009
         do { while (
          (   ( $pad{I2396} = $pos or 1 ) &&
             ## <concat>
             ## pos: 12968 13001
             (
  
               ## <group>
               ## pos: 12968 12980
                (   ( $pad{I2397} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12977 12979
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2397} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12980 12983
                (   ( $pad{I2398} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 12980 12982
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I2398} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 12983 13001
                (   ( $pad{I2399} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 12983 12996
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2399} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2396} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13009 13185
          (   ( $pad{I2400} = $pos or 1 ) &&
           ## <closure>
           ## pos: 13009 13184
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
        return { alt => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2400} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for rule
 # Data::Bind->sub_signature
#  (\&rule, );
;
*named_regex = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 13212 13432
       (
  
         ## <group>
         ## pos: 13212 13247
          (   ( $pad{I2401} = $pos or 1 ) &&

           ## <capture>
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <alt>
                   ## pos: 13213 13241
                   (
                       ( $pad{I2402} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 13213 13222
                        (   ( $pad{I2403} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 13214 13221
                         ( ( substr( $s, $pos, 5 ) eq 'token' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2403} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2402} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 13223 13232
                        (   ( $pad{I2404} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 13224 13231
                         ( ( substr( $s, $pos, 5 ) eq 'regex' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2404} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I2402} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 13233 13241
                        (   ( $pad{I2405} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 13234 13240
                         ( ( substr( $s, $pos, 4 ) eq 'rule' )
                             ? ( $pos += 4 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I2405} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           }
           ## </capture>
 ||    ( ( $pos = $pad{I2401} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13247 13253
          (   ( $pad{I2406} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 13247 13252
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2406} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13253 13261
          (   ( $pad{I2407} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 13253 13260
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2407} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 13261 13268
         (
          (   ( $pad{I2408} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 13261 13266
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2408} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13268 13280
          (   ( $pad{I2409} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13268 13271
           ( ( substr( $s, $pos, 1 ) eq '{' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2409} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 13280 13295
         (
          (   ( $pad{I2410} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 13280 13285
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2410} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13295 13306
          (   ( $pad{I2411} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 13295 13301
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2411} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13306 13310
          (   ( $pad{I2412} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13306 13309
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2412} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 13310 13320
         (
          (   ( $pad{I2413} = $pos or 1 ) &&

             ## <constant>
             ## pos: 13310 13313
             ( ( substr( $s, $pos, 1 ) eq ';' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>
 ||    ( ( $pos = $pad{I2413} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13320 13432
          (   ( $pad{I2414} = $pos or 1 ) &&
           ## <closure>
           ## pos: 13320 13431
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => ${$::_V6_MATCH_->[0]}, 'name' => ${ $::_V6_MATCH_->{'ident'}}, 'ast' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2414} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_regex
 # Data::Bind->sub_signature
#  (\&named_regex, );
;
*verbatim = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 13499 13621
       (
  
         ## <group>
         ## pos: 13499 13504
          (   ( $pad{I2415} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13499 13503
           ( ( substr( $s, $pos, 2 ) eq '%{' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2415} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13504 13530
          (   ( $pad{I2416} = $pos or 1 ) &&

           ## <capture>
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <quant>
                   ## pos: 13505 13528
                   do { while (
                    (   ( $pad{I2417} = $pos or 1 ) &&
                       ## <concat>
                       ## pos: 13507 13525
                       (
  
                         ## <group>
                         ## pos: 13507 13523
                          (   ( $pad{I2418} = $pos or 1 ) &&
                           ## <negate>
                           ## pos: 13508 13522
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 
                                     ## <before>
                                     ## pos: 13517 13521
                                     do{
                                         my $pos1 = $pos;
                                         do {
                                           my $pos = $pos1;
                                           my $from = $pos;
                                           my @match;
                                           my %named;
                                           $bool = 0 unless

                                               ## <constant>
                                               ## pos: 13517 13521
                                               ( ( substr( $s, $pos, 2 ) eq '%}' )
                                                   ? ( $pos += 2 or 1 )
                                                   : 0
                                               )
                                               ## </constant>
;
                                           $bool;
                                         };
                                     }
                                     ## </before>
 ? 0 : 1;
                                 $bool;
                               };
                           }
                           ## </negate>
 ||    ( ( $pos = $pad{I2418} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 13523 13525
                          (   ( $pad{I2419} = $pos or 1 ) &&

                           ## <dot>
                           ## pos: 13523 13524
                           ( substr( $s, $pos++, 1 ) ne '' )
                           ## </dot>
 ||    ( ( $pos = $pad{I2419} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>
 ||    ( ( $pos = $pad{I2417} ) && 0 ) )) {}; $bool = 1 }
                   ## </quant>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           }
           ## </capture>
 ||    ( ( $pos = $pad{I2416} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13530 13539
          (   ( $pad{I2420} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13530 13534
           ( ( substr( $s, $pos, 2 ) eq '%}' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2420} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13539 13621
          (   ( $pad{I2421} = $pos or 1 ) &&
           ## <closure>
           ## pos: 13539 13620
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => 'block', 'value' => ${$::_V6_MATCH_->[0]}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2421} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for verbatim
 # Data::Bind->sub_signature
#  (\&verbatim, );
;
*item = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 13641 13733
       (
           ( $pad{I2422} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 13642 13689
           (
  
             ## <group>
             ## pos: 13642 13660
              (   ( $pad{I2423} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13643 13653
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'verbatim'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2423} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 13660 13689
              (   ( $pad{I2424} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13660 13684
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'verbatim'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2424} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2422} ) or 1 )
           &&            ## <concat>
           ## pos: 13690 13733
           (
  
             ## <group>
             ## pos: 13690 13705
              (   ( $pad{I2425} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13691 13704
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_regex'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2425} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 13705 13733
              (   ( $pad{I2426} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13705 13732
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'named_regex'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2426} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for item
 # Data::Bind->sub_signature
#  (\&item, );
;
*grammar = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 13756 13872
       (
         ## <quant>
         ## pos: 13756 13763
         (
          (   ( $pad{I2427} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 13756 13761
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2427} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13763 13773
          (   ( $pad{I2428} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13763 13772
           ( ( substr( $s, $pos, 7 ) eq 'grammar' )
               ? ( $pos += 7 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2428} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13773 13779
          (   ( $pad{I2429} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 13773 13778
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2429} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 13779 13787
          (   ( $pad{I2430} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 13779 13786
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2430} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 13787 13794
         (
          (   ( $pad{I2431} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 13787 13792
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2431} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13794 13802
          (   ( $pad{I2432} = $pos or 1 ) &&

           ## <constant>
           ## pos: 13794 13797
           ( ( substr( $s, $pos, 1 ) eq ';' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2432} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 13802 13813
         (
          (   ( $pad{I2433} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 13802 13807
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2433} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 13813 13836
         do { while (
          (   ( $pad{I2434} = $pos or 1 ) &&
             ## <concat>
             ## pos: 13814 13829
             (
  
               ## <group>
               ## pos: 13814 13822
                (   ( $pad{I2435} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 13815 13821
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->item( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'item'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2435} ) && 0 ) )
               ## </group>

             &&
               ## <quant>
               ## pos: 13822 13829
               (
                (   ( $pad{I2436} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 13822 13827
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2436} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2434} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13836 13872
          (   ( $pad{I2437} = $pos or 1 ) &&
           ## <closure>
           ## pos: 13836 13871
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({${ $::_V6_MATCH_->{'ident'}} =>  $::_V6_MATCH_->{'item'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2437} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for grammar
 # Data::Bind->sub_signature
#  (\&grammar, );
;
*spec = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 13892 14012
       (
         ## <quant>
         ## pos: 13892 13908
         (
          (   ( $pad{I2438} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 13892 13902
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'verbatim'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2438} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 13908 13923
         do { while (
          (   ( $pad{I2439} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 13908 13917
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'grammar'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2439} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 13923 14012
          (   ( $pad{I2440} = $pos or 1 ) &&
           ## <closure>
           ## pos: 13923 14011
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'block' =>  $::_V6_MATCH_->{'verbatim'}, 'grammar' =>  $::_V6_MATCH_->{'grammar'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2440} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for spec
 # Data::Bind->sub_signature
#  (\&spec, );
;

; 1;
