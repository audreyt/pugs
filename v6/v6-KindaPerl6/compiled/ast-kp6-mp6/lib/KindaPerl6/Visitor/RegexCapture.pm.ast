::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'visit',
                block => ::Lit::Code(
                    body => [
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '0', ), ::Val::Int( int => '0', ), ::Call( hyper => '', arguments => [ ::Lit::Hash( hash => [], ), ], method => 'new', invocant => ::Proto( name => 'Hash', ), ), ],
                                        method    => 'capture_count',
                                        invocant  => ::Call( hyper => '', arguments => '', method => 'regex', invocant => ::Var( namespace => [], name => 'node', twigil => '', sigil => '$', ), ),
                                    ),
                                    ::Return( result => ::Var( namespace => [], name => 'node', twigil => '', sigil => '$', ), ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "KindaPerl6::Visitor::RegexCapture", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond => ::Apply(
                                arguments => [ ::Var( namespace => [], name => 'node_name',  twigil => '', sigil => '$', ), ::Val::Buf( buf => 'Token', ), ],
                                code      => ::Var( namespace   => [], name => 'infix:<eq>', twigil => '', sigil => '&', ),
                            ),
                            otherwise => '',
                        ),
                        ::Return( result => ::Val::Undef(), ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'node', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'node_name', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',         twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'node',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'node_name', twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "KindaPerl6::Visitor::RegexCapture",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "KindaPerl6::Visitor::RegexCapture", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'KindaPerl6::Visitor::RegexCapture',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "P5Token",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "P5Token", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'P5Token',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Call(
                            hyper     => '',
                            arguments => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ::Val::Int( int => '1', ), ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ],
                            method    => 'capture_count',
                            invocant => ::Var( namespace => [], name => 'term', twigil => '.', sigil => '$', ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Quantifier",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Quantifier", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Quantifier',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Bind( parameters => ::Var( namespace => [], name => 'max', twigil => '', sigil => '$', ), arguments => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ),
                        ::Call(
                            hyper     => '',
                            arguments => [
                                ::Sub(
                                    name  => '',
                                    block => ::Lit::Code(
                                        body => [
                                            ::Bind(
                                                parameters => ::Var( namespace => [], name => 'last', twigil => '', sigil => '$', ),
                                                arguments  => ::Call(
                                                    hyper     => '',
                                                    arguments => [
                                                        ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ),
                                                        ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                                        ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ),
                                                    ],
                                                    method   => 'capture_count',
                                                    invocant => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ),
                                                ),
                                            ),
                                            ::If(
                                                body => ::Lit::Code(
                                                    body => [ ::Bind( parameters => ::Var( namespace => [], name => 'max', twigil => '', sigil => '$', ), arguments => ::Var( namespace => [], name => 'last', twigil => '', sigil => '$', ), ), ],
                                                    sig => ::Sig( invocant => '', positional => [], ),
                                                    pad   => ::Pad( lexicals => [], namespace => "Rule::Or", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                                    CATCH => '',
                                                    state => {},
                                                ),
                                                cond => ::Apply(
                                                    arguments => [ ::Var( namespace => [], name => 'last',      twigil => '', sigil => '$', ), ::Var( namespace => [], name => 'max', twigil => '', sigil => '$', ), ],
                                                    code      => ::Var( namespace   => [], name => 'infix:<>>', twigil => '', sigil => '&', ),
                                                ),
                                                otherwise => '',
                                            ),
                                        ],
                                        sig => ::Sig(
                                            invocant   => ::Val::Undef(),
                                            positional => [
                                                ::Lit::SigArgument(
                                                    is_multidimensional => ::Val::Bit( bit => '0', ),
                                                    has_default         => ::Val::Bit( bit => '0', ),
                                                    value               => ::Val::Undef(),
                                                    is_slurpy           => ::Val::Bit( bit => '0', ),
                                                    is_optional         => ::Val::Bit( bit => '0', ),
                                                    key           => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ),
                                                    is_copy       => ::Val::Bit( bit  => '0', ),
                                                    is_named_only => ::Val::Bit( bit  => '0', ),
                                                    type          => '',
                                                    is_rw => ::Val::Bit( bit => '0', ),
                                                ),
                                            ],
                                        ),
                                        pad => ::Pad(
                                            lexicals => [
                                                ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'last',  twigil => '', sigil => '$', ), type => '', ),
                                                ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',     twigil => '', sigil => '@', ), type => '', ),
                                                ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ), type => '', )
                                            ],
                                            namespace => "Rule::Or",
                                            parent    => ::Pad(...),
                                            evaluator => ::Sub(...),
                                        ),
                                        CATCH => '',
                                        state => {},
                                    ),
                                ),
                            ],
                            method   => 'map',
                            invocant => ::Var( namespace => [], name => 'or', twigil => '.', sigil => '@', ),
                        ),
                        ::Var( namespace => [], name => 'max', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'max',        twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Or",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Or", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Or',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Call(
                            hyper     => '',
                            arguments => [
                                ::Sub(
                                    name  => '',
                                    block => ::Lit::Code(
                                        body => [
                                            ::Bind(
                                                parameters => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                                arguments  => ::Call(
                                                    hyper     => '',
                                                    arguments => [
                                                        ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ),
                                                        ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                                        ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ),
                                                    ],
                                                    method   => 'capture_count',
                                                    invocant => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ),
                                                ),
                                            ),
                                        ],
                                        sig => ::Sig(
                                            invocant   => ::Val::Undef(),
                                            positional => [
                                                ::Lit::SigArgument(
                                                    is_multidimensional => ::Val::Bit( bit => '0', ),
                                                    has_default         => ::Val::Bit( bit => '0', ),
                                                    value               => ::Val::Undef(),
                                                    is_slurpy           => ::Val::Bit( bit => '0', ),
                                                    is_optional         => ::Val::Bit( bit => '0', ),
                                                    key           => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ),
                                                    is_copy       => ::Val::Bit( bit  => '0', ),
                                                    is_named_only => ::Val::Bit( bit  => '0', ),
                                                    type          => '',
                                                    is_rw => ::Val::Bit( bit => '0', ),
                                                ),
                                            ],
                                        ),
                                        pad => ::Pad(
                                            lexicals => [
                                                ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',     twigil => '', sigil => '@', ), type => '', ),
                                                ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'regex', twigil => '', sigil => '$', ), type => '', )
                                            ],
                                            namespace => "Rule::Concat",
                                            parent    => ::Pad(...),
                                            evaluator => ::Sub(...),
                                        ),
                                        CATCH => '',
                                        state => {},
                                    ),
                                ),
                            ],
                            method   => 'map',
                            invocant => ::Var( namespace => [], name => 'concat', twigil => '.', sigil => '@', ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Concat",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Concat", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Concat',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::SubruleNoCapture",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::SubruleNoCapture", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::SubruleNoCapture',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Var",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Var", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Var',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Constant",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Constant", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Constant',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Dot",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Dot", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Dot',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::SpecialChar",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::SpecialChar", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::SpecialChar',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Block",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Block", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Block',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::InterpolateVar",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::InterpolateVar", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::InterpolateVar',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::If(
                            body => ::Lit::Code(
                                body => [ ::Return( result => ::Var( namespace => [],     name => 'count', twigil => '', sigil => '$', ), ), ],
                                sig  => ::Sig( invocant    => '',              positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::Before", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond => ::Apply(
                                arguments => [ ::Var( namespace => [], name => 'assertion_modifier', twigil => '.', sigil => '$', ), ::Val::Buf( buf => '', ), ],
                                code      => ::Var( namespace   => [], name => 'infix:<ne>',         twigil => '',  sigil => '&', ),
                            ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'capture_to_array', twigil => '.', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                    ::Apply(
                                        arguments => [
                                            ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'before', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                                            ::Val::Int( int => '1', ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<&&>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'infix:<||>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '1', ), ],
                                        method    => 'capture_to_array',
                                        invocant  => ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'before', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                                    ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::Before", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond      => ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'before', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters => ::Call( hyper      => '', arguments => [ ::Val::Buf( buf => 'before', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            arguments  => ::Apply( arguments => [], code      => ::Var( namespace  => [],             name   => 'self',   twigil   => '',              sigil  => '&', ), ),
                        ),
                        ::Call(
                            hyper     => '',
                            arguments => [ ::Val::Int( int => '0', ), ::Val::Int( int => '0', ), ::Call( hyper => '', arguments => [ ::Lit::Hash( hash => [], ), ], method => 'new', invocant => ::Proto( name => 'Hash', ), ), ],
                            method    => 'capture_count',
                            invocant => ::Var( namespace => [], name => 'rule', twigil => '.', sigil => '$', ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Before",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Before", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Before',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::If(
                            body => ::Lit::Code(
                                body => [ ::Return( result => ::Var( namespace => [],     name => 'count', twigil => '', sigil => '$', ), ), ],
                                sig  => ::Sig( invocant    => '',              positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::After", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond => ::Apply(
                                arguments => [ ::Var( namespace => [], name => 'assertion_modifier', twigil => '.', sigil => '$', ), ::Val::Buf( buf => '', ), ],
                                code      => ::Var( namespace   => [], name => 'infix:<ne>',         twigil => '',  sigil => '&', ),
                            ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'capture_to_array', twigil => '.', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                    ::Apply(
                                        arguments => [
                                            ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'after', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ), ::Val::Int( int => '1', ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<&&>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'infix:<||>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '1', ), ],
                                        method    => 'capture_to_array',
                                        invocant  => ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'after', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                                    ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::After", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond      => ::Call( hyper => '', arguments => [ ::Val::Buf( buf => 'after', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters => ::Call( hyper      => '', arguments => [ ::Val::Buf( buf => 'after', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            arguments  => ::Apply( arguments => [], code      => ::Var( namespace  => [],            name   => 'self',   twigil   => '',              sigil  => '&', ), ),
                        ),
                        ::Call(
                            hyper     => '',
                            arguments => [ ::Val::Int( int => '0', ), ::Val::Int( int => '0', ), ::Call( hyper => '', arguments => [ ::Lit::Hash( hash => [], ), ], method => 'new', invocant => ::Proto( name => 'Hash', ), ), ],
                            method    => 'capture_count',
                            invocant => ::Var( namespace => [], name => 'rule', twigil => '.', sigil => '$', ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::After",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::After", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::After',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::NegateCharClass",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::NegateCharClass", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::NegateCharClass',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ],
                    sig  => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::CharClass",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::CharClass", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::CharClass',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'meth', twigil => '', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Apply(
                                        arguments => [
                                            ::Val::Int( int => '1', ),
                                            ::Apply(
                                                arguments => [ ::Var( namespace => [], name => 'metasyntax', twigil => '.', sigil => '$', ), ::Val::Buf( buf => '.', ), ],
                                                code      => ::Var( namespace   => [], name => 'index',      twigil => '',  sigil => '&', ),
                                            ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<+>', twigil => '', sigil => '&', ),
                                    ),
                                    ::Apply(
                                        arguments => [ ::Var( namespace => [], name => 'metasyntax', twigil => '.', sigil => '$', ), ::Val::Buf( buf => ' ... TODO ', ), ],
                                        code      => ::Var( namespace   => [], name => 'infix:<~>',  twigil => '',  sigil => '&', ),
                                    ),
                                    ::Apply(
                                        arguments => [
                                            ::Apply(
                                                arguments => [
                                                    ::Val::Char( char => '39', ),
                                                    ::Apply(
                                                        arguments => [
                                                            ::Val::Buf( buf => '$', ),
                                                            ::Apply(
                                                                arguments => [
                                                                    ::Val::Char( char => '39', ),
                                                                    ::Apply(
                                                                        arguments => [
                                                                            ::Val::Buf( buf => '.$GLOBAL::_Class.', ),
                                                                            ::Apply(
                                                                                arguments => [ ::Val::Char( char => '39', ), ::Val::Buf( buf => '::_regex_', ), ],
                                                                                code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                                                            ),
                                                                        ],
                                                                        code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                                                    ),
                                                                ],
                                                                code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                                            ),
                                                        ],
                                                        code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                                    ),
                                                ],
                                                code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                            ),
                                            ::Apply(
                                                arguments => [ ::Var( namespace => [], name => 'metasyntax', twigil => '.', sigil => '$', ), ::Val::Char( char => '39', ), ],
                                                code      => ::Var( namespace   => [], name => 'infix:<~>',  twigil => '',  sigil => '&', ),
                                            ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<~>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'ternary:<?? !!>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::Bind( parameters => ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), arguments => ::Var( namespace => [], name => 'metasyntax', twigil => '.', sigil => '$', ), ),
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'capture_to_array', twigil => '.', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                    ::Apply(
                                        arguments => [
                                            ::Call(
                                                hyper     => '',
                                                arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                                method    => 'LOOKUP',
                                                invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                            ),
                                            ::Val::Int( int => '1', ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<&&>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'infix:<||>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '1', ), ],
                                        method    => 'capture_to_array',
                                        invocant  => ::Call(
                                            hyper     => '',
                                            arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                            method    => 'LOOKUP',
                                            invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                        ),
                                    ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::Subrule", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            arguments => ::Apply( arguments => [], code => ::Var( namespace => [], name => 'self', twigil => '', sigil => '&', ), ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'meth',       twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Subrule",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Subrule", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Subrule',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'capture_to_array', twigil => '.', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                    ::Apply(
                                        arguments => [
                                            ::Call(
                                                hyper     => '',
                                                arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                                method    => 'LOOKUP',
                                                invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                            ),
                                            ::Val::Int( int => '1', ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<&&>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'infix:<||>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::Call(
                            hyper     => '',
                            arguments => [ ::Val::Int( int => '0', ), ::Val::Int( int => '0', ), ::Call( hyper => '', arguments => [ ::Lit::Hash( hash => [], ), ], method => 'new', invocant => ::Proto( name => 'Hash', ), ), ],
                            method    => 'capture_count',
                            invocant => ::Var( namespace => [], name => 'rule', twigil => '.', sigil => '$', ),
                        ),
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '1', ), ],
                                        method    => 'capture_to_array',
                                        invocant  => ::Call(
                                            hyper     => '',
                                            arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                            method    => 'LOOKUP',
                                            invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                        ),
                                    ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::NamedCapture", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            arguments => ::Apply( arguments => [], code => ::Var( namespace => [], name => 'self', twigil => '', sigil => '&', ), ),
                        ),
                        ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::NamedCapture",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::NamedCapture", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::NamedCapture',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    ) ::CompUnit(
    body => ::Lit::Code(
        body => [
            ::Method(
                name  => 'capture_count',
                block => ::Lit::Code(
                    body => [
                        ::Bind( parameters => ::Var( namespace => [], name => 'position', twigil => '.', sigil => '$', ), arguments => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ),
                        ::Bind(
                            parameters => ::Var( namespace => [], name => 'capture_to_array', twigil => '.', sigil => '$', ),
                            arguments  => ::Apply(
                                arguments => [
                                    ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                    ::Apply(
                                        arguments => [
                                            ::Call(
                                                hyper     => '',
                                                arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                                method    => 'LOOKUP',
                                                invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                            ),
                                            ::Val::Int( int => '1', ),
                                        ],
                                        code => ::Var( namespace => [], name => 'infix:<&&>', twigil => '', sigil => '&', ),
                                    ),
                                ],
                                code => ::Var( namespace => [], name => 'infix:<||>', twigil => '', sigil => '&', ),
                            ),
                        ),
                        ::If(
                            body => ::Lit::Code(
                                body => [
                                    ::Call(
                                        hyper     => '',
                                        arguments => [ ::Val::Int( int => '1', ), ],
                                        method    => 'capture_to_array',
                                        invocant  => ::Call(
                                            hyper     => '',
                                            arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ],
                                            method    => 'LOOKUP',
                                            invocant  => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                        ),
                                    ),
                                ],
                                sig => ::Sig( invocant => '', positional => [], ),
                                pad   => ::Pad( lexicals => [], namespace => "Rule::Capture", parent => ::Pad(...), evaluator => ::Sub(...), ),
                                CATCH => '',
                                state => {},
                            ),
                            cond =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'ident', twigil => '.', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            otherwise => '',
                        ),
                        ::Bind(
                            parameters =>
                                ::Call( hyper => '', arguments => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ], method => 'LOOKUP', invocant => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ), ),
                            arguments => ::Apply( arguments => [], code => ::Var( namespace => [], name => 'self', twigil => '', sigil => '&', ), ),
                        ),
                        ::Call(
                            hyper     => '',
                            arguments => [ ::Val::Int( int => '0', ), ::Val::Int( int => '0', ), ::Call( hyper => '', arguments => [ ::Lit::Hash( hash => [], ), ], method => 'new', invocant => ::Proto( name => 'Hash', ), ), ],
                            method    => 'capture_count',
                            invocant => ::Var( namespace => [], name => 'rule', twigil => '.', sigil => '$', ),
                        ),
                        ::Apply( arguments => [ ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ), ::Val::Int( int => '1', ), ], code => ::Var( namespace => [], name => 'infix:<+>', twigil => '', sigil => '&', ), ),
                    ],
                    sig => ::Sig(
                        invocant   => '',
                        positional => [
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'count', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                            ::Lit::SigArgument(
                                is_multidimensional => ::Val::Bit( bit => '0', ),
                                has_default         => ::Val::Bit( bit => '0', ),
                                value               => ::Val::Undef(),
                                is_slurpy           => ::Val::Bit( bit => '0', ),
                                is_optional         => ::Val::Bit( bit => '0', ),
                                key           => ::Var( namespace => [], name => 'seen', twigil => '', sigil => '$', ),
                                is_copy       => ::Val::Bit( bit  => '0', ),
                                is_named_only => ::Val::Bit( bit  => '0', ),
                                type          => '',
                                is_rw => ::Val::Bit( bit => '0', ),
                            ),
                        ],
                    ),
                    pad => ::Pad(
                        lexicals => [
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => '_',          twigil => '', sigil => '@', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'count',      twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'quantified', twigil => '', sigil => '$', ), type => '', ),
                            ::Decl( decl => 'my', var => ::Var( namespace => [], name => 'seen',       twigil => '', sigil => '$', ), type => '', )
                        ],
                        namespace => "Rule::Capture",
                        parent    => ::Pad(...),
                        evaluator => ::Sub(...),
                    ),
                    CATCH => '',
                    state => {},
                ),
            ),
        ],
        sig => ::Sig( invocant => '', positional => [], ),
        pad   => ::Pad( lexicals => [], namespace => "Rule::Capture", parent => ::Pad(...), evaluator => ::Sub(...), ),
        CATCH => '',
        state => {},
    ),
    methods    => {},
    name       => 'Rule::Capture',
    attributes => {},
    traits     => [],
    unit_type  => 'class',
    )
