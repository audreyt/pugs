{-# OPTIONS_GHC -cpp -fglasgow-exts -fno-warn-orphans -fallow-overlapping-instances -funbox-strict-fields -fallow-undecidable-instances -fallow-incoherent-instances #-}




{- 
-- WARNING WARNING WARNING --

This is an autogenerated file from src/Pugs/AST/CapInternals.hs.

Do not edit this file.

All changes made here will be lost!

-- WARNING WARNING WARNING --
-}

#ifndef HADDOCK









module Pugs.AST.CapInternals.Instances ()
where
import Pugs.AST.CapInternals
import Data.Yaml.Syck
import DrIFT.YAML
import DrIFT.JSON
import DrIFT.Perl5
import DrIFT.Perl6Class
import Control.Monad
import qualified Data.ByteString as Buf

import Pugs.AST.Scope
import Pugs.AST.Pos
import Pugs.AST.Prag
import Pugs.AST.SIO
import Pugs.Types hiding (Var)
import Pugs.Internals
import Pugs.Embed.Perl5
import qualified Data.Set       as Set
import qualified Data.Map       as Map
import Data.Array.IO
import qualified Data.Version
import qualified Network.URI

-- instance (Typeable a, Show a) => Perl6Class (IOThread a)
instance (PLit a) => PLit (Eval a) where -- XXX: very bogus
    plShow (Eval x) = plShow x

instance (PLit a) => PLit (IOThread a) where -- XXX
    plShow (IOThread x) = "<thread: " ++ (show $ plShow x) ++ ">"
instance PLit MemBuf where
    plShow _       = "<buf>"
instance Show (IOUArray Word64 Word8) where
    show _ = "<buf>"
instance YAML (VThread Val)
instance YAML ClassTree
instance YAML Dynamic
instance YAML Pragma
instance YAML Regex
instance YAML VComplex
instance YAML PerlSV
instance YAML Float
instance YAML Table
instance YAML IntSet
instance YAML (Map ValPure Val)
instance YAML (Map Ident Param)
instance YAML (Set Ident)
instance YAML (Set Val)
instance YAML (SeqOf Val)
instance YAML PureSet
instance YAML PureSeq
instance YAML (Set MultiVariant)
instance YAML (Map Var PadEntry)
instance YAML (Map Str [Exp])
instance YAML (IOUArray Word64 Word8)
instance YAML (TVar (IntMap Routine))
instance YAML CodeWrapping
instance YAML Pad
instance YAML ProcessHandle
instance YAML Data.Version.Version
instance YAML Network.URI.URI
instance YAML (Map Ident (TVar Val))
instance YAML (Map Ident Code)

{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance (YAML a) => YAML (Eval a) where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"Eval" -> do
	    let ESeq [aa] = e
	    liftM Eval (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["Eval"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (Eval aa) = asYAMLseq "Eval" [asYAML aa]

instance (Perl6Class a) => Perl6Class (Eval a) where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Eval"
	    , showPerl6ClassDef ns "Eval" "Eval" [("","$.aa","a")]
	    ]
    asPerl6Object (Eval aa) = "Eval.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance (MooseClass a) => MooseClass (Eval a) where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Eval"
	    , showMooseClassDef ns "Eval" "Eval" [("","aa","a")]
	    ]

instance YAML VThunk where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkThunk" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkThunk (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkThunk"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkThunk aa ab) = asYAMLseq "MkThunk" [asYAML aa, asYAML ab]

instance YAML VProcess where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkProcess" -> do
	    let ESeq [aa] = e
	    liftM MkProcess (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkProcess"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkProcess aa) = asYAMLseq "MkProcess" [asYAML aa]

instance YAML VRule where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkRulePCRE" -> do
	    let liftM6 f m1 m2 m3 m4 m5 m6 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; return (f x1 x2 x3 x4 x5 x6)}
	    let ESeq [aa, ab, ac, ad, ae, af] = e
	    liftM6 MkRulePCRE (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af)
	"MkRulePGE" -> do
	    let ESeq [aa, ab, ac, ad] = e
	    liftM4 MkRulePGE (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkRulePCRE","MkRulePGE"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkRulePCRE aa ab ac ad ae af) = asYAMLseq "MkRulePCRE"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af]
    asYAML (MkRulePGE aa ab ac ad) = asYAMLseq "MkRulePGE"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad]

instance Perl6Class VRule where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "VRule"
	    , showPerl6ClassDef ns "VRule" "MkRulePCRE" [("Regex","$.rxRegex",""),("Bool","$.rxGlobal",""),("Int","$.rxNumSubs",""),("Bool","$.rxStringify",""),("String","$.rxRuleStr",""),("Val","$.rxAdverbs","")]
	    , showPerl6ClassDef ns "VRule" "MkRulePGE" [("String","$.rxRule",""),("Bool","$.rxGlobal",""),("Bool","$.rxStringify",""),("Val","$.rxAdverbs","")]
	    ]
    asPerl6Object (MkRulePCRE aa ab ac ad ae af) = "MkRulePCRE.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af]) ++ ")"
    asPerl6Object (MkRulePGE aa ab ac ad) = "MkRulePGE.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad]) ++ ")"

instance MooseClass VRule where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "VRule"
	    , showMooseClassDef ns "VRule" "MkRulePCRE" [("Regex","rxRegex",""),("Bool","rxGlobal",""),("Int","rxNumSubs",""),("Bool","rxStringify",""),("String","rxRuleStr",""),("Val","rxAdverbs","")]
	    , showMooseClassDef ns "VRule" "MkRulePGE" [("String","rxRule",""),("Bool","rxGlobal",""),("Bool","rxStringify",""),("Val","rxAdverbs","")]
	    ]

instance YAML Val where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"VNative" -> do
	    let ESeq [aa] = e
	    liftM VNative (fromYAML aa)
	"VUndef" -> do
	    let ESeq [aa] = e
	    liftM VUndef (fromYAML aa)
	"VPure" -> do
	    let ESeq [aa] = e
	    liftM VPure (fromYAML aa)
	"VMut" -> do
	    let ESeq [aa] = e
	    liftM VMut (fromYAML aa)
	"VIO" -> do
	    let ESeq [aa] = e
	    liftM VIO (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["VNative","VUndef","VPure","VMut","VIO"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (VNative aa) = asYAMLseq "VNative" [asYAML aa]
    asYAML (VUndef aa) = asYAMLseq "VUndef" [asYAML aa]
    asYAML (VPure aa) = asYAMLseq "VPure" [asYAML aa]
    asYAML (VMut aa) = asYAMLseq "VMut" [asYAML aa]
    asYAML (VIO aa) = asYAMLseq "VIO" [asYAML aa]

instance Perl6Class Val where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Val"
	    , showPerl6ClassDef ns "Val" "VNative" [("ValNative","$.aa","")]
	    , showPerl6ClassDef ns "Val" "VUndef" [("ValUndef","$.aa","")]
	    , showPerl6ClassDef ns "Val" "VPure" [("ValPure","$.aa","")]
	    , showPerl6ClassDef ns "Val" "VMut" [("ValMut","$.aa","")]
	    , showPerl6ClassDef ns "Val" "VIO" [("ValIO","$.aa","")]
	    ]
    asPerl6Object (VNative aa) = "VNative.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (VUndef aa) = "VUndef.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (VPure aa) = "VPure.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (VMut aa) = "VMut.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (VIO aa) = "VIO.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass Val where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Val"
	    , showMooseClassDef ns "Val" "VNative" [("ValNative","aa","")]
	    , showMooseClassDef ns "Val" "VUndef" [("ValUndef","aa","")]
	    , showMooseClassDef ns "Val" "VPure" [("ValPure","aa","")]
	    , showMooseClassDef ns "Val" "VMut" [("ValMut","aa","")]
	    , showMooseClassDef ns "Val" "VIO" [("ValIO","aa","")]
	    ]

instance YAML Native where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"NBit" -> do
	    let ESeq [aa] = e
	    liftM NBit (fromYAML aa)
	"NInt" -> do
	    let ESeq [aa] = e
	    liftM NInt (fromYAML aa)
	"NUint" -> do
	    let ESeq [aa] = e
	    liftM NUint (fromYAML aa)
	"NBuf" -> do
	    let ESeq [aa] = e
	    liftM NBuf (fromYAML aa)
	"NNum" -> do
	    let ESeq [aa] = e
	    liftM NNum (fromYAML aa)
	"NCplx" -> do
	    let ESeq [aa] = e
	    liftM NCplx (fromYAML aa)
	"NStr" -> do
	    let ESeq [aa] = e
	    liftM NStr (fromYAML aa)
	"NBool" -> do
	    let ESeq [aa] = e
	    liftM NBool (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["NBit","NInt","NUint","NBuf","NNum","NCplx","NStr","NBool"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (NBit aa) = asYAMLseq "NBit" [asYAML aa]
    asYAML (NInt aa) = asYAMLseq "NInt" [asYAML aa]
    asYAML (NUint aa) = asYAMLseq "NUint" [asYAML aa]
    asYAML (NBuf aa) = asYAMLseq "NBuf" [asYAML aa]
    asYAML (NNum aa) = asYAMLseq "NNum" [asYAML aa]
    asYAML (NCplx aa) = asYAMLseq "NCplx" [asYAML aa]
    asYAML (NStr aa) = asYAMLseq "NStr" [asYAML aa]
    asYAML (NBool aa) = asYAMLseq "NBool" [asYAML aa]

instance Perl6Class Native where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Native"
	    , showPerl6ClassDef ns "Native" "NBit" [("NativeBit","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NInt" [("NativeInt","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NUint" [("NativeInt","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NBuf" [("NativeBuf","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NNum" [("NativeNum","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NCplx" [("NativeComplex","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NStr" [("NativeStr","$.aa","")]
	    , showPerl6ClassDef ns "Native" "NBool" [("NativeBool","$.aa","")]
	    ]
    asPerl6Object (NBit aa) = "NBit.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NInt aa) = "NInt.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NUint aa) = "NUint.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NBuf aa) = "NBuf.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NNum aa) = "NNum.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NCplx aa) = "NCplx.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NStr aa) = "NStr.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NBool aa) = "NBool.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass Native where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Native"
	    , showMooseClassDef ns "Native" "NBit" [("NativeBit","aa","")]
	    , showMooseClassDef ns "Native" "NInt" [("NativeInt","aa","")]
	    , showMooseClassDef ns "Native" "NUint" [("NativeInt","aa","")]
	    , showMooseClassDef ns "Native" "NBuf" [("NativeBuf","aa","")]
	    , showMooseClassDef ns "Native" "NNum" [("NativeNum","aa","")]
	    , showMooseClassDef ns "Native" "NCplx" [("NativeComplex","aa","")]
	    , showMooseClassDef ns "Native" "NStr" [("NativeStr","aa","")]
	    , showMooseClassDef ns "Native" "NBool" [("NativeBool","aa","")]
	    ]

instance YAML ValUndef where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"UUndef" -> do
	    return UUndef
	"UWhatever" -> do
	    return UWhatever
	"UFailure" -> do
	    let ESeq [aa] = e
	    liftM UFailure (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["UUndef","UWhatever","UFailure"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (UUndef) = asYAMLcls "UUndef"
    asYAML (UWhatever) = asYAMLcls "UWhatever"
    asYAML (UFailure aa) = asYAMLseq "UFailure" [asYAML aa]

instance Perl6Class ValUndef where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ValUndef"
	    , showPerl6ClassDef ns "ValUndef" "UUndef" []
	    , showPerl6ClassDef ns "ValUndef" "UWhatever" []
	    , showPerl6ClassDef ns "ValUndef" "UFailure" [("ObjId","$.aa","")]
	    ]
    asPerl6Object (UUndef) = "UUndef.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (UWhatever) = "UWhatever.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (UFailure aa) = "UFailure.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass ValUndef where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ValUndef"
	    , showMooseClassDef ns "ValUndef" "UUndef" []
	    , showMooseClassDef ns "ValUndef" "UWhatever" []
	    , showMooseClassDef ns "ValUndef" "UFailure" [("ObjId","aa","")]
	    ]

instance YAML Sign where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"SPositive" -> do
	    return SPositive
	"SNegative" -> do
	    return SNegative
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["SPositive","SNegative"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (SPositive) = asYAMLcls "SPositive"
    asYAML (SNegative) = asYAMLcls "SNegative"

instance Perl6Class Sign where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Sign"
	    , showPerl6ClassDef ns "Sign" "SPositive" []
	    , showPerl6ClassDef ns "Sign" "SNegative" []
	    ]
    asPerl6Object (SPositive) = "SPositive.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (SNegative) = "SNegative.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass Sign where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Sign"
	    , showMooseClassDef ns "Sign" "SPositive" []
	    , showMooseClassDef ns "Sign" "SNegative" []
	    ]

instance YAML NativeInt where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"IFinite" -> do
	    let ESeq [aa] = e
	    liftM IFinite (fromYAML aa)
	"IInfinite" -> do
	    let ESeq [aa] = e
	    liftM IInfinite (fromYAML aa)
	"INotANumber" -> do
	    return INotANumber
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["IFinite","IInfinite","INotANumber"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (IFinite aa) = asYAMLseq "IFinite" [asYAML aa]
    asYAML (IInfinite aa) = asYAMLseq "IInfinite" [asYAML aa]
    asYAML (INotANumber) = asYAMLcls "INotANumber"

instance Perl6Class NativeInt where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "NativeInt"
	    , showPerl6ClassDef ns "NativeInt" "IFinite" [("Integer","$.aa","")]
	    , showPerl6ClassDef ns "NativeInt" "IInfinite" [("Sign","$.aa","")]
	    , showPerl6ClassDef ns "NativeInt" "INotANumber" []
	    ]
    asPerl6Object (IFinite aa) = "IFinite.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (IInfinite aa) = "IInfinite.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (INotANumber) = "INotANumber.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass NativeInt where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "NativeInt"
	    , showMooseClassDef ns "NativeInt" "IFinite" [("Integer","aa","")]
	    , showMooseClassDef ns "NativeInt" "IInfinite" [("Sign","aa","")]
	    , showMooseClassDef ns "NativeInt" "INotANumber" []
	    ]

instance YAML NativeNum where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"NRational" -> do
	    let ESeq [aa] = e
	    liftM NRational (fromYAML aa)
	"NFloat" -> do
	    let ESeq [aa] = e
	    liftM NFloat (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["NRational","NFloat"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (NRational aa) = asYAMLseq "NRational" [asYAML aa]
    asYAML (NFloat aa) = asYAMLseq "NFloat" [asYAML aa]

instance Perl6Class NativeNum where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "NativeNum"
	    , showPerl6ClassDef ns "NativeNum" "NRational" [("Rational","$.aa","")]
	    , showPerl6ClassDef ns "NativeNum" "NFloat" [("Float","$.aa","")]
	    ]
    asPerl6Object (NRational aa) = "NRational.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (NFloat aa) = "NFloat.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass NativeNum where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "NativeNum"
	    , showMooseClassDef ns "NativeNum" "NRational" [("Rational","aa","")]
	    , showMooseClassDef ns "NativeNum" "NFloat" [("Float","aa","")]
	    ]

instance YAML NativeComplex where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkComplex" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkComplex (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkComplex"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkComplex aa ab) = asYAMLseq "MkComplex"
	   [asYAML aa, asYAML ab]

instance Perl6Class NativeComplex where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "NativeComplex"
	    , showPerl6ClassDef ns "NativeComplex" "MkComplex" [("NativeNum","$.c_real",""),("NativeNum","$.c_imaginary","")]
	    ]
    asPerl6Object (MkComplex aa ab) = "MkComplex.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass NativeComplex where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "NativeComplex"
	    , showMooseClassDef ns "NativeComplex" "MkComplex" [("NativeNum","c_real",""),("NativeNum","c_imaginary","")]
	    ]

instance YAML PureList where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkList" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkList (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkList"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkList aa ab) = asYAMLseq "MkList" [asYAML aa, asYAML ab]

instance Perl6Class PureList where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PureList"
	    , showPerl6ClassDef ns "PureList" "MkList" [("PureSeq","$.l_seq",""),("PureRange","$.l_range","")]
	    ]
    asPerl6Object (MkList aa ab) = "MkList.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass PureList where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PureList"
	    , showMooseClassDef ns "PureList" "MkList" [("PureSeq","l_seq",""),("PureRange","l_range","")]
	    ]

instance YAML PureRange where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkRange" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkRange (fromYAML aa) (fromYAML ab) (fromYAML ac)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkRange"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkRange aa ab ac) = asYAMLseq "MkRange"
	   [asYAML aa, asYAML ab, asYAML ac]

instance Perl6Class PureRange where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PureRange"
	    , showPerl6ClassDef ns "PureRange" "MkRange" [("Val","$.r_from",""),("Val","$.r_to",""),("Code","$.r_next","")]
	    ]
    asPerl6Object (MkRange aa ab ac) = "MkRange.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"

instance MooseClass PureRange where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PureRange"
	    , showMooseClassDef ns "PureRange" "MkRange" [("Val","r_from",""),("Val","r_to",""),("Code","r_next","")]
	    ]

instance YAML MemBuf where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkBuf" -> do
	    let ESeq [aa] = e
	    liftM MkBuf (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkBuf"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkBuf aa) = asYAMLseq "MkBuf" [asYAML aa]

instance Perl6Class MemBuf where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "MemBuf"
	    , showPerl6ClassDef ns "MemBuf" "MkBuf" [("","$.b_buffer","IOUArray Word64 Word8")]
	    ]
    asPerl6Object (MkBuf aa) = "MkBuf.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass MemBuf where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "MemBuf"
	    , showMooseClassDef ns "MemBuf" "MkBuf" [("","b_buffer","IOUArray Word64 Word8")]
	    ]

instance YAML PureJunc where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkJunc" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkJunc (fromYAML aa) (fromYAML ab) (fromYAML ac)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkJunc"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkJunc aa ab ac) = asYAMLseq "MkJunc"
	   [asYAML aa, asYAML ab, asYAML ac]

instance Perl6Class PureJunc where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PureJunc"
	    , showPerl6ClassDef ns "PureJunc" "MkJunc" [("JuncType","$.j_type",""),("PureSet","$.j_dup",""),("PureSet","$.j_set","")]
	    ]
    asPerl6Object (MkJunc aa ab ac) = "MkJunc.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"

instance MooseClass PureJunc where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PureJunc"
	    , showMooseClassDef ns "PureJunc" "MkJunc" [("JuncType","j_type",""),("PureSet","j_dup",""),("PureSet","j_set","")]
	    ]

instance YAML JuncType where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"JAny" -> do
	    return JAny
	"JAll" -> do
	    return JAll
	"JNone" -> do
	    return JNone
	"JOne" -> do
	    return JOne
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["JAny","JAll","JNone","JOne"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (JAny) = asYAMLcls "JAny"
    asYAML (JAll) = asYAMLcls "JAll"
    asYAML (JNone) = asYAMLcls "JNone"
    asYAML (JOne) = asYAMLcls "JOne"

instance Perl6Class JuncType where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "JuncType"
	    , showPerl6ClassDef ns "JuncType" "JAny" []
	    , showPerl6ClassDef ns "JuncType" "JAll" []
	    , showPerl6ClassDef ns "JuncType" "JNone" []
	    , showPerl6ClassDef ns "JuncType" "JOne" []
	    ]
    asPerl6Object (JAny) = "JAny.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (JAll) = "JAll.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (JNone) = "JNone.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (JOne) = "JOne.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass JuncType where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "JuncType"
	    , showMooseClassDef ns "JuncType" "JAny" []
	    , showMooseClassDef ns "JuncType" "JAll" []
	    , showMooseClassDef ns "JuncType" "JNone" []
	    , showMooseClassDef ns "JuncType" "JOne" []
	    ]

instance YAML PurePair where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkPair" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkPair (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkPair"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkPair aa ab) = asYAMLseq "MkPair" [asYAML aa, asYAML ab]

instance Perl6Class PurePair where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PurePair"
	    , showPerl6ClassDef ns "PurePair" "MkPair" [("Val","$.p_key",""),("Val","$.p_val","")]
	    ]
    asPerl6Object (MkPair aa ab) = "MkPair.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass PurePair where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PurePair"
	    , showMooseClassDef ns "PurePair" "MkPair" [("Val","p_key",""),("Val","p_val","")]
	    ]

instance YAML PureMap where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"Map" -> do
	    let ESeq [aa, ab] = e
	    liftM2 Map (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["Map"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (Map aa ab) = asYAMLseq "Map" [asYAML aa, asYAML ab]

instance Perl6Class PureMap where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PureMap"
	    , showPerl6ClassDef ns "PureMap" "Map" [("Val","$.aa",""),("Val","$.ab","")]
	    ]
    asPerl6Object (Map aa ab) = "Map.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass PureMap where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PureMap"
	    , showMooseClassDef ns "PureMap" "Map" [("Val","aa",""),("Val","ab","")]
	    ]

instance YAML ValPure where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"PBit" -> do
	    let ESeq [aa] = e
	    liftM PBit (fromYAML aa)
	"PInt" -> do
	    let ESeq [aa] = e
	    liftM PInt (fromYAML aa)
	"PStr" -> do
	    let ESeq [aa] = e
	    liftM PStr (fromYAML aa)
	"PNum" -> do
	    let ESeq [aa] = e
	    liftM PNum (fromYAML aa)
	"PComplex" -> do
	    let ESeq [aa] = e
	    liftM PComplex (fromYAML aa)
	"PBool" -> do
	    let ESeq [aa] = e
	    liftM PBool (fromYAML aa)
	"PException" -> do
	    let ESeq [aa] = e
	    liftM PException (fromYAML aa)
	"PCode" -> do
	    let ESeq [aa] = e
	    liftM PCode (fromYAML aa)
	"PBlock" -> do
	    let ESeq [aa] = e
	    liftM PBlock (fromYAML aa)
	"PList" -> do
	    let ESeq [aa] = e
	    liftM PList (fromYAML aa)
	"PSeq" -> do
	    let ESeq [aa] = e
	    liftM PSeq (fromYAML aa)
	"PRange" -> do
	    let ESeq [aa] = e
	    liftM PRange (fromYAML aa)
	"PSet" -> do
	    let ESeq [aa] = e
	    liftM PSet (fromYAML aa)
	"PJunc" -> do
	    let ESeq [aa] = e
	    liftM PJunc (fromYAML aa)
	"PPair" -> do
	    let ESeq [aa] = e
	    liftM PPair (fromYAML aa)
	"PMap" -> do
	    let ESeq [aa] = e
	    liftM PMap (fromYAML aa)
	"PSig" -> do
	    let ESeq [aa] = e
	    liftM PSig (fromYAML aa)
	"PCap" -> do
	    let ESeq [aa] = e
	    liftM PCap (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["PBit","PInt","PStr","PNum","PComplex","PBool","PException","PCode","PBlock","PList","PSeq","PRange","PSet","PJunc","PPair","PMap","PSig","PCap"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (PBit aa) = asYAMLseq "PBit" [asYAML aa]
    asYAML (PInt aa) = asYAMLseq "PInt" [asYAML aa]
    asYAML (PStr aa) = asYAMLseq "PStr" [asYAML aa]
    asYAML (PNum aa) = asYAMLseq "PNum" [asYAML aa]
    asYAML (PComplex aa) = asYAMLseq "PComplex" [asYAML aa]
    asYAML (PBool aa) = asYAMLseq "PBool" [asYAML aa]
    asYAML (PException aa) = asYAMLseq "PException" [asYAML aa]
    asYAML (PCode aa) = asYAMLseq "PCode" [asYAML aa]
    asYAML (PBlock aa) = asYAMLseq "PBlock" [asYAML aa]
    asYAML (PList aa) = asYAMLseq "PList" [asYAML aa]
    asYAML (PSeq aa) = asYAMLseq "PSeq" [asYAML aa]
    asYAML (PRange aa) = asYAMLseq "PRange" [asYAML aa]
    asYAML (PSet aa) = asYAMLseq "PSet" [asYAML aa]
    asYAML (PJunc aa) = asYAMLseq "PJunc" [asYAML aa]
    asYAML (PPair aa) = asYAMLseq "PPair" [asYAML aa]
    asYAML (PMap aa) = asYAMLseq "PMap" [asYAML aa]
    asYAML (PSig aa) = asYAMLseq "PSig" [asYAML aa]
    asYAML (PCap aa) = asYAMLseq "PCap" [asYAML aa]

instance Perl6Class ValPure where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ValPure"
	    , showPerl6ClassDef ns "ValPure" "PBit" [("PureBit","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PInt" [("PureInt","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PStr" [("PureStr","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PNum" [("PureNum","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PComplex" [("PureComplex","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PBool" [("PureBool","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PException" [("PureException","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PCode" [("PureCode","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PBlock" [("PureCode","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PList" [("PureList","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PSeq" [("PureSeq","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PRange" [("PureRange","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PSet" [("PureSet","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PJunc" [("PureJunc","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PPair" [("PurePair","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PMap" [("PureMap","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PSig" [("PureSig","$.aa","")]
	    , showPerl6ClassDef ns "ValPure" "PCap" [("PureCap","$.aa","")]
	    ]
    asPerl6Object (PBit aa) = "PBit.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PInt aa) = "PInt.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PStr aa) = "PStr.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PNum aa) = "PNum.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PComplex aa) = "PComplex.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PBool aa) = "PBool.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PException aa) = "PException.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PCode aa) = "PCode.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PBlock aa) = "PBlock.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PList aa) = "PList.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PSeq aa) = "PSeq.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PRange aa) = "PRange.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PSet aa) = "PSet.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PJunc aa) = "PJunc.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PPair aa) = "PPair.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PMap aa) = "PMap.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PSig aa) = "PSig.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (PCap aa) = "PCap.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass ValPure where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ValPure"
	    , showMooseClassDef ns "ValPure" "PBit" [("PureBit","aa","")]
	    , showMooseClassDef ns "ValPure" "PInt" [("PureInt","aa","")]
	    , showMooseClassDef ns "ValPure" "PStr" [("PureStr","aa","")]
	    , showMooseClassDef ns "ValPure" "PNum" [("PureNum","aa","")]
	    , showMooseClassDef ns "ValPure" "PComplex" [("PureComplex","aa","")]
	    , showMooseClassDef ns "ValPure" "PBool" [("PureBool","aa","")]
	    , showMooseClassDef ns "ValPure" "PException" [("PureException","aa","")]
	    , showMooseClassDef ns "ValPure" "PCode" [("PureCode","aa","")]
	    , showMooseClassDef ns "ValPure" "PBlock" [("PureCode","aa","")]
	    , showMooseClassDef ns "ValPure" "PList" [("PureList","aa","")]
	    , showMooseClassDef ns "ValPure" "PSeq" [("PureSeq","aa","")]
	    , showMooseClassDef ns "ValPure" "PRange" [("PureRange","aa","")]
	    , showMooseClassDef ns "ValPure" "PSet" [("PureSet","aa","")]
	    , showMooseClassDef ns "ValPure" "PJunc" [("PureJunc","aa","")]
	    , showMooseClassDef ns "ValPure" "PPair" [("PurePair","aa","")]
	    , showMooseClassDef ns "ValPure" "PMap" [("PureMap","aa","")]
	    , showMooseClassDef ns "ValPure" "PSig" [("PureSig","aa","")]
	    , showMooseClassDef ns "ValPure" "PCap" [("PureCap","aa","")]
	    ]

instance YAML Bogus where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"Bogus" -> do
	    return Bogus
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["Bogus"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (Bogus) = asYAMLcls "Bogus"

instance Perl6Class Bogus where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Bogus"
	    , showPerl6ClassDef ns "Bogus" "Bogus" []
	    ]
    asPerl6Object (Bogus) = "Bogus.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass Bogus where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Bogus"
	    , showMooseClassDef ns "Bogus" "Bogus" []
	    ]

instance YAML ValMut where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MScalar" -> do
	    let ESeq [aa] = e
	    liftM MScalar (fromYAML aa)
	"MArray" -> do
	    let ESeq [aa] = e
	    liftM MArray (fromYAML aa)
	"MHash" -> do
	    let ESeq [aa] = e
	    liftM MHash (fromYAML aa)
	"MBuf" -> do
	    let ESeq [aa] = e
	    liftM MBuf (fromYAML aa)
	"MRoutine" -> do
	    let ESeq [aa] = e
	    liftM MRoutine (fromYAML aa)
	"MSub" -> do
	    let ESeq [aa] = e
	    liftM MSub (fromYAML aa)
	"MMethod" -> do
	    let ESeq [aa] = e
	    liftM MMethod (fromYAML aa)
	"MSubmethod" -> do
	    let ESeq [aa] = e
	    liftM MSubmethod (fromYAML aa)
	"MMacro" -> do
	    return MMacro
	"MRegex" -> do
	    let ESeq [aa] = e
	    liftM MRegex (fromYAML aa)
	"MMatch" -> do
	    let ESeq [aa] = e
	    liftM MMatch (fromYAML aa)
	"MPackage" -> do
	    let ESeq [aa] = e
	    liftM MPackage (fromYAML aa)
	"MModule" -> do
	    let ESeq [aa] = e
	    liftM MModule (fromYAML aa)
	"MClass" -> do
	    let ESeq [aa] = e
	    liftM MClass (fromYAML aa)
	"MRole" -> do
	    let ESeq [aa] = e
	    liftM MRole (fromYAML aa)
	"MGrammar" -> do
	    let ESeq [aa] = e
	    liftM MGrammar (fromYAML aa)
	"MObject" -> do
	    let ESeq [aa] = e
	    liftM MObject (fromYAML aa)
	"MForeign" -> do
	    let ESeq [aa] = e
	    liftM MForeign (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MScalar","MArray","MHash","MBuf","MRoutine","MSub","MMethod","MSubmethod","MMacro","MRegex","MMatch","MPackage","MModule","MClass","MRole","MGrammar","MObject","MForeign"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MScalar aa) = asYAMLseq "MScalar" [asYAML aa]
    asYAML (MArray aa) = asYAMLseq "MArray" [asYAML aa]
    asYAML (MHash aa) = asYAMLseq "MHash" [asYAML aa]
    asYAML (MBuf aa) = asYAMLseq "MBuf" [asYAML aa]
    asYAML (MRoutine aa) = asYAMLseq "MRoutine" [asYAML aa]
    asYAML (MSub aa) = asYAMLseq "MSub" [asYAML aa]
    asYAML (MMethod aa) = asYAMLseq "MMethod" [asYAML aa]
    asYAML (MSubmethod aa) = asYAMLseq "MSubmethod" [asYAML aa]
    asYAML (MMacro) = asYAMLcls "MMacro"
    asYAML (MRegex aa) = asYAMLseq "MRegex" [asYAML aa]
    asYAML (MMatch aa) = asYAMLseq "MMatch" [asYAML aa]
    asYAML (MPackage aa) = asYAMLseq "MPackage" [asYAML aa]
    asYAML (MModule aa) = asYAMLseq "MModule" [asYAML aa]
    asYAML (MClass aa) = asYAMLseq "MClass" [asYAML aa]
    asYAML (MRole aa) = asYAMLseq "MRole" [asYAML aa]
    asYAML (MGrammar aa) = asYAMLseq "MGrammar" [asYAML aa]
    asYAML (MObject aa) = asYAMLseq "MObject" [asYAML aa]
    asYAML (MForeign aa) = asYAMLseq "MForeign" [asYAML aa]

instance Perl6Class ValMut where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ValMut"
	    , showPerl6ClassDef ns "ValMut" "MScalar" [("MutScalar","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MArray" [("MutArray","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MHash" [("MutHash","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MBuf" [("MutBuf","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MRoutine" [("MutRoutine","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MSub" [("MutRoutine","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MMethod" [("MutRoutine","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MSubmethod" [("MutRoutine","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MMacro" []
	    , showPerl6ClassDef ns "ValMut" "MRegex" [("MutVRule","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MMatch" [("MutVMatch","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MPackage" [("MutPackage","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MModule" [("MutModule","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MClass" [("MutClass","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MRole" [("MutRole","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MGrammar" [("MutGrammar","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MObject" [("MutObject","$.aa","")]
	    , showPerl6ClassDef ns "ValMut" "MForeign" [("MutDynamic","$.aa","")]
	    ]
    asPerl6Object (MScalar aa) = "MScalar.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MArray aa) = "MArray.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MHash aa) = "MHash.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MBuf aa) = "MBuf.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MRoutine aa) = "MRoutine.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MSub aa) = "MSub.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MMethod aa) = "MMethod.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MSubmethod aa) = "MSubmethod.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MMacro) = "MMacro.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MRegex aa) = "MRegex.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MMatch aa) = "MMatch.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MPackage aa) = "MPackage.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MModule aa) = "MModule.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MClass aa) = "MClass.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MRole aa) = "MRole.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MGrammar aa) = "MGrammar.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MObject aa) = "MObject.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (MForeign aa) = "MForeign.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass ValMut where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ValMut"
	    , showMooseClassDef ns "ValMut" "MScalar" [("MutScalar","aa","")]
	    , showMooseClassDef ns "ValMut" "MArray" [("MutArray","aa","")]
	    , showMooseClassDef ns "ValMut" "MHash" [("MutHash","aa","")]
	    , showMooseClassDef ns "ValMut" "MBuf" [("MutBuf","aa","")]
	    , showMooseClassDef ns "ValMut" "MRoutine" [("MutRoutine","aa","")]
	    , showMooseClassDef ns "ValMut" "MSub" [("MutRoutine","aa","")]
	    , showMooseClassDef ns "ValMut" "MMethod" [("MutRoutine","aa","")]
	    , showMooseClassDef ns "ValMut" "MSubmethod" [("MutRoutine","aa","")]
	    , showMooseClassDef ns "ValMut" "MMacro" []
	    , showMooseClassDef ns "ValMut" "MRegex" [("MutVRule","aa","")]
	    , showMooseClassDef ns "ValMut" "MMatch" [("MutVMatch","aa","")]
	    , showMooseClassDef ns "ValMut" "MPackage" [("MutPackage","aa","")]
	    , showMooseClassDef ns "ValMut" "MModule" [("MutModule","aa","")]
	    , showMooseClassDef ns "ValMut" "MClass" [("MutClass","aa","")]
	    , showMooseClassDef ns "ValMut" "MRole" [("MutRole","aa","")]
	    , showMooseClassDef ns "ValMut" "MGrammar" [("MutGrammar","aa","")]
	    , showMooseClassDef ns "ValMut" "MObject" [("MutObject","aa","")]
	    , showMooseClassDef ns "ValMut" "MForeign" [("MutDynamic","aa","")]
	    ]

instance YAML IOFile where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"Handle" -> do
	    return Handle
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["Handle"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (Handle) = asYAMLcls "Handle"

instance Perl6Class IOFile where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "IOFile"
	    , showPerl6ClassDef ns "IOFile" "Handle" []
	    ]
    asPerl6Object (Handle) = "Handle.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass IOFile where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "IOFile"
	    , showMooseClassDef ns "IOFile" "Handle" []
	    ]

instance YAML IOSocket where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"Socket" -> do
	    return Socket
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["Socket"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (Socket) = asYAMLcls "Socket"

instance Perl6Class IOSocket where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "IOSocket"
	    , showPerl6ClassDef ns "IOSocket" "Socket" []
	    ]
    asPerl6Object (Socket) = "Socket.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass IOSocket where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "IOSocket"
	    , showMooseClassDef ns "IOSocket" "Socket" []
	    ]

instance (YAML a) => YAML (IOThread a) where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"IOThread" -> do
	    let ESeq [aa] = e
	    liftM IOThread (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["IOThread"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (IOThread aa) = asYAMLseq "IOThread" [asYAML aa]

instance (Perl6Class a) => Perl6Class (IOThread a) where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "IOThread"
	    , showPerl6ClassDef ns "IOThread" "IOThread" [("","$.aa","a")]
	    ]
    asPerl6Object (IOThread aa) = "IOThread.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance (MooseClass a) => MooseClass (IOThread a) where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "IOThread"
	    , showMooseClassDef ns "IOThread" "IOThread" [("","aa","a")]
	    ]

instance YAML IOProcess where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"ProcessHandle" -> do
	    return ProcessHandle
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["ProcessHandle"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (ProcessHandle) = asYAMLcls "ProcessHandle"

instance Perl6Class IOProcess where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "IOProcess"
	    , showPerl6ClassDef ns "IOProcess" "ProcessHandle" []
	    ]
    asPerl6Object (ProcessHandle) = "ProcessHandle.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass IOProcess where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "IOProcess"
	    , showMooseClassDef ns "IOProcess" "ProcessHandle" []
	    ]

instance YAML ValIO where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"IFile" -> do
	    let ESeq [aa] = e
	    liftM IFile (fromYAML aa)
	"ISocket" -> do
	    let ESeq [aa] = e
	    liftM ISocket (fromYAML aa)
	"IThread" -> do
	    let ESeq [aa] = e
	    liftM IThread (fromYAML aa)
	"IProcess" -> do
	    let ESeq [aa] = e
	    liftM IProcess (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["IFile","ISocket","IThread","IProcess"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (IFile aa) = asYAMLseq "IFile" [asYAML aa]
    asYAML (ISocket aa) = asYAMLseq "ISocket" [asYAML aa]
    asYAML (IThread aa) = asYAMLseq "IThread" [asYAML aa]
    asYAML (IProcess aa) = asYAMLseq "IProcess" [asYAML aa]

instance Perl6Class ValIO where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ValIO"
	    , showPerl6ClassDef ns "ValIO" "IFile" [("IOFile","$.aa","")]
	    , showPerl6ClassDef ns "ValIO" "ISocket" [("IOSocket","$.aa","")]
	    , showPerl6ClassDef ns "ValIO" "IThread" [("","$.aa","IOThread Val")]
	    , showPerl6ClassDef ns "ValIO" "IProcess" [("IOProcess","$.aa","")]
	    ]
    asPerl6Object (IFile aa) = "IFile.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (ISocket aa) = "ISocket.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (IThread aa) = "IThread.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (IProcess aa) = "IProcess.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass ValIO where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ValIO"
	    , showMooseClassDef ns "ValIO" "IFile" [("IOFile","aa","")]
	    , showMooseClassDef ns "ValIO" "ISocket" [("IOSocket","aa","")]
	    , showMooseClassDef ns "ValIO" "IThread" [("","aa","IOThread Val")]
	    , showMooseClassDef ns "ValIO" "IProcess" [("IOProcess","aa","")]
	    ]

instance YAML SubType where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"SubMethod" -> do
	    return SubMethod
	"SubCoroutine" -> do
	    return SubCoroutine
	"SubMacro" -> do
	    return SubMacro
	"SubRoutine" -> do
	    return SubRoutine
	"SubBlock" -> do
	    return SubBlock
	"SubPointy" -> do
	    return SubPointy
	"SubPrim" -> do
	    return SubPrim
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["SubMethod","SubCoroutine","SubMacro","SubRoutine","SubBlock","SubPointy","SubPrim"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (SubMethod) = asYAMLcls "SubMethod"
    asYAML (SubCoroutine) = asYAMLcls "SubCoroutine"
    asYAML (SubMacro) = asYAMLcls "SubMacro"
    asYAML (SubRoutine) = asYAMLcls "SubRoutine"
    asYAML (SubBlock) = asYAMLcls "SubBlock"
    asYAML (SubPointy) = asYAMLcls "SubPointy"
    asYAML (SubPrim) = asYAMLcls "SubPrim"

instance YAML Stmt where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkStmt" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkStmt (fromYAML aa) (fromYAML ab) (fromYAML ac)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkStmt"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkStmt aa ab ac) = asYAMLseq "MkStmt"
	   [asYAML aa, asYAML ab, asYAML ac]

instance Perl6Class Stmt where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Stmt"
	    , showPerl6ClassDef ns "Stmt" "MkStmt" [("Ident","$.label",""),("Table","$.pragmas",""),("Exp","$.expression","")]
	    ]
    asPerl6Object (MkStmt aa ab ac) = "MkStmt.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"

instance MooseClass Stmt where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Stmt"
	    , showMooseClassDef ns "Stmt" "MkStmt" [("Ident","label",""),("Table","pragmas",""),("Exp","expression","")]
	    ]

instance YAML Exp where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"ENoop" -> do
	    return ENoop
	"EVar" -> do
	    let ESeq [aa] = e
	    liftM EVar (fromYAML aa)
	"EVal" -> do
	    let ESeq [aa] = e
	    liftM EVal (fromYAML aa)
	"EDeref" -> do
	    let ESeq [aa] = e
	    liftM EDeref (fromYAML aa)
	"EBind" -> do
	    let ESeq [aa, ab] = e
	    liftM2 EBind (fromYAML aa) (fromYAML ab)
	"EAssign" -> do
	    let ESeq [aa, ab] = e
	    liftM2 EAssign (fromYAML aa) (fromYAML ab)
	"EControl" -> do
	    let ESeq [aa] = e
	    liftM EControl (fromYAML aa)
	"EFlatten" -> do
	    let ESeq [aa] = e
	    liftM EFlatten (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["ENoop","EVar","EVal","EDeref","EBind","EAssign","EControl","EFlatten"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (ENoop) = asYAMLcls "ENoop"
    asYAML (EVar aa) = asYAMLseq "EVar" [asYAML aa]
    asYAML (EVal aa) = asYAMLseq "EVal" [asYAML aa]
    asYAML (EDeref aa) = asYAMLseq "EDeref" [asYAML aa]
    asYAML (EBind aa ab) = asYAMLseq "EBind" [asYAML aa, asYAML ab]
    asYAML (EAssign aa ab) = asYAMLseq "EAssign" [asYAML aa, asYAML ab]
    asYAML (EControl aa) = asYAMLseq "EControl" [asYAML aa]
    asYAML (EFlatten aa) = asYAMLseq "EFlatten" [asYAML aa]

instance Perl6Class Exp where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Exp"
	    , showPerl6ClassDef ns "Exp" "ENoop" []
	    , showPerl6ClassDef ns "Exp" "EVar" [("ExpVar","$.aa","")]
	    , showPerl6ClassDef ns "Exp" "EVal" [("ExpVal","$.aa","")]
	    , showPerl6ClassDef ns "Exp" "EDeref" [("ExpVar","$.aa","")]
	    , showPerl6ClassDef ns "Exp" "EBind" [("Exp","$.aa",""),("Exp","$.ab","")]
	    , showPerl6ClassDef ns "Exp" "EAssign" [("Exp","$.aa",""),("Exp","$.ab","")]
	    , showPerl6ClassDef ns "Exp" "EControl" [("ExpControl","$.aa","")]
	    , showPerl6ClassDef ns "Exp" "EFlatten" [("Exp","@.aa","")]
	    ]
    asPerl6Object (ENoop) = "ENoop.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (EVar aa) = "EVar.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (EVal aa) = "EVal.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (EDeref aa) = "EDeref.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (EBind aa ab) = "EBind.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (EAssign aa ab) = "EAssign.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (EControl aa) = "EControl.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (EFlatten aa) = "EFlatten.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass Exp where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Exp"
	    , showMooseClassDef ns "Exp" "ENoop" []
	    , showMooseClassDef ns "Exp" "EVar" [("ExpVar","aa","")]
	    , showMooseClassDef ns "Exp" "EVal" [("ExpVal","aa","")]
	    , showMooseClassDef ns "Exp" "EDeref" [("ExpVar","aa","")]
	    , showMooseClassDef ns "Exp" "EBind" [("Exp","aa",""),("Exp","ab","")]
	    , showMooseClassDef ns "Exp" "EAssign" [("Exp","aa",""),("Exp","ab","")]
	    , showMooseClassDef ns "Exp" "EControl" [("ExpControl","aa","")]
	    , showMooseClassDef ns "Exp" "EFlatten" [("ArrayRef","aa","[Exp]")]
	    ]

instance YAML ExpControl where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"CCall" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CCall (fromYAML aa) (fromYAML ab)
	"CApply" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CApply (fromYAML aa) (fromYAML ab)
	"CCond" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CCond (fromYAML aa) (fromYAML ab)
	"CTrenaryCond" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 CTrenaryCond (fromYAML aa) (fromYAML ab) (fromYAML ac)
	"CCondBlock" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 CCondBlock (fromYAML aa) (fromYAML ab) (fromYAML ac)
	"CGoto" -> do
	    let ESeq [aa] = e
	    liftM CGoto (fromYAML aa)
	"CWhile" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CWhile (fromYAML aa) (fromYAML ab)
	"CGiven" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CGiven (fromYAML aa) (fromYAML ab)
	"CWhen" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CWhen (fromYAML aa) (fromYAML ab)
	"CForeign" -> do
	    return CForeign
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["CCall","CApply","CCond","CTrenaryCond","CCondBlock","CGoto","CWhile","CGiven","CWhen","CForeign"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (CCall aa ab) = asYAMLseq "CCall" [asYAML aa, asYAML ab]
    asYAML (CApply aa ab) = asYAMLseq "CApply" [asYAML aa, asYAML ab]
    asYAML (CCond aa ab) = asYAMLseq "CCond" [asYAML aa, asYAML ab]
    asYAML (CTrenaryCond aa ab ac) = asYAMLseq "CTrenaryCond"
	   [asYAML aa, asYAML ab, asYAML ac]
    asYAML (CCondBlock aa ab ac) = asYAMLseq "CCondBlock"
	   [asYAML aa, asYAML ab, asYAML ac]
    asYAML (CGoto aa) = asYAMLseq "CGoto" [asYAML aa]
    asYAML (CWhile aa ab) = asYAMLseq "CWhile" [asYAML aa, asYAML ab]
    asYAML (CGiven aa ab) = asYAMLseq "CGiven" [asYAML aa, asYAML ab]
    asYAML (CWhen aa ab) = asYAMLseq "CWhen" [asYAML aa, asYAML ab]
    asYAML (CForeign) = asYAMLcls "CForeign"

instance Perl6Class ExpControl where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ExpControl"
	    , showPerl6ClassDef ns "ExpControl" "CCall" [("Ident","$.aa",""),("Cap","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CApply" [("Exp","$.aa",""),("Cap","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CCond" [("Exp","$.aa",""),("Code","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CTrenaryCond" [("Exp","$.aa",""),("Code","$.ab",""),("Code","$.ac","")]
	    , showPerl6ClassDef ns "ExpControl" "CCondBlock" [("","$.aa","(Exp,Code)"),("","@.ab","[(Exp,Code)]"),("Code","$.ac","")]
	    , showPerl6ClassDef ns "ExpControl" "CGoto" [("Ident","$.aa","")]
	    , showPerl6ClassDef ns "ExpControl" "CWhile" [("Exp","$.aa",""),("Code","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CGiven" [("Exp","$.aa",""),("Code","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CWhen" [("Exp","$.aa",""),("Code","$.ab","")]
	    , showPerl6ClassDef ns "ExpControl" "CForeign" []
	    ]
    asPerl6Object (CCall aa ab) = "CCall.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CApply aa ab) = "CApply.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CCond aa ab) = "CCond.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CTrenaryCond aa ab ac) = "CTrenaryCond.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"
    asPerl6Object (CCondBlock aa ab ac) = "CCondBlock.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"
    asPerl6Object (CGoto aa) = "CGoto.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"
    asPerl6Object (CWhile aa ab) = "CWhile.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CGiven aa ab) = "CGiven.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CWhen aa ab) = "CWhen.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CForeign) = "CForeign.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass ExpControl where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ExpControl"
	    , showMooseClassDef ns "ExpControl" "CCall" [("Ident","aa",""),("Cap","ab","")]
	    , showMooseClassDef ns "ExpControl" "CApply" [("Exp","aa",""),("Cap","ab","")]
	    , showMooseClassDef ns "ExpControl" "CCond" [("Exp","aa",""),("Code","ab","")]
	    , showMooseClassDef ns "ExpControl" "CTrenaryCond" [("Exp","aa",""),("Code","ab",""),("Code","ac","")]
	    , showMooseClassDef ns "ExpControl" "CCondBlock" [("","aa","(Exp,Code)"),("ArrayRef","ab","[(Exp,Code)]"),("Code","ac","")]
	    , showMooseClassDef ns "ExpControl" "CGoto" [("Ident","aa","")]
	    , showMooseClassDef ns "ExpControl" "CWhile" [("Exp","aa",""),("Code","ab","")]
	    , showMooseClassDef ns "ExpControl" "CGiven" [("Exp","aa",""),("Code","ab","")]
	    , showMooseClassDef ns "ExpControl" "CWhen" [("Exp","aa",""),("Code","ab","")]
	    , showMooseClassDef ns "ExpControl" "CForeign" []
	    ]

instance YAML Param where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkParam" -> do
	    let liftM10 f m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; x7 <- m7; x8 <- m8; x9 <- m9; x10 <- m10; return (f x1 x2 x3 x4 x5 x6 x7 x8 x9 x10)}
	    let ESeq [aa, ab, ac, ad, ae, af, ag, ah, ai, aj] = e
	    liftM10 MkParam (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af) (fromYAML ag) (fromYAML ah) (fromYAML ai) (fromYAML aj)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkParam"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkParam aa ab ac ad ae af ag ah ai aj) =
	   asYAMLseq "MkParam"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af,
	    asYAML ag, asYAML ah, asYAML ai, asYAML aj]

instance Perl6Class Param where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Param"
	    , showPerl6ClassDef ns "Param" "MkParam" [("Ident","$.p_variable",""),("Class","@.p_types",""),("Code","@.p_constraints",""),("Sig","$.p_unpacking",""),("Exp","$.p_default",""),("Ident","$.p_label",""),("Table","$.p_slots",""),("ParamAccess","$.p_hasAccess",""),("Bool","$.p_isRef",""),("Bool","$.p_isLazy","")]
	    ]
    asPerl6Object (MkParam aa ab ac ad ae af ag ah ai aj) = "MkParam.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af, plShow ag, plShow ah, plShow ai, plShow aj]) ++ ")"

instance MooseClass Param where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Param"
	    , showMooseClassDef ns "Param" "MkParam" [("Ident","p_variable",""),("ArrayRef","p_types","[Class]"),("ArrayRef","p_constraints","[Code]"),("Sig","p_unpacking",""),("Exp","p_default",""),("Ident","p_label",""),("Table","p_slots",""),("ParamAccess","p_hasAccess",""),("Bool","p_isRef",""),("Bool","p_isLazy","")]
	    ]

instance YAML ParamAccess where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"AccRO" -> do
	    return AccRO
	"AccRW" -> do
	    return AccRW
	"AccCopy" -> do
	    return AccCopy
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["AccRO","AccRW","AccCopy"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (AccRO) = asYAMLcls "AccRO"
    asYAML (AccRW) = asYAMLcls "AccRW"
    asYAML (AccCopy) = asYAMLcls "AccCopy"

instance Perl6Class ParamAccess where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "ParamAccess"
	    , showPerl6ClassDef ns "ParamAccess" "AccRO" []
	    , showPerl6ClassDef ns "ParamAccess" "AccRW" []
	    , showPerl6ClassDef ns "ParamAccess" "AccCopy" []
	    ]
    asPerl6Object (AccRO) = "AccRO.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AccRW) = "AccRW.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AccCopy) = "AccCopy.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass ParamAccess where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "ParamAccess"
	    , showMooseClassDef ns "ParamAccess" "AccRO" []
	    , showMooseClassDef ns "ParamAccess" "AccRW" []
	    , showMooseClassDef ns "ParamAccess" "AccCopy" []
	    ]

instance YAML CodeAssoc where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"AssLeft" -> do
	    return AssLeft
	"AssRight" -> do
	    return AssRight
	"AssNon" -> do
	    return AssNon
	"AssChain" -> do
	    return AssChain
	"AssList" -> do
	    return AssList
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["AssLeft","AssRight","AssNon","AssChain","AssList"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (AssLeft) = asYAMLcls "AssLeft"
    asYAML (AssRight) = asYAMLcls "AssRight"
    asYAML (AssNon) = asYAMLcls "AssNon"
    asYAML (AssChain) = asYAMLcls "AssChain"
    asYAML (AssList) = asYAMLcls "AssList"

instance Perl6Class CodeAssoc where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "CodeAssoc"
	    , showPerl6ClassDef ns "CodeAssoc" "AssLeft" []
	    , showPerl6ClassDef ns "CodeAssoc" "AssRight" []
	    , showPerl6ClassDef ns "CodeAssoc" "AssNon" []
	    , showPerl6ClassDef ns "CodeAssoc" "AssChain" []
	    , showPerl6ClassDef ns "CodeAssoc" "AssList" []
	    ]
    asPerl6Object (AssLeft) = "AssLeft.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AssRight) = "AssRight.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AssNon) = "AssNon.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AssChain) = "AssChain.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (AssList) = "AssList.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass CodeAssoc where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "CodeAssoc"
	    , showMooseClassDef ns "CodeAssoc" "AssLeft" []
	    , showMooseClassDef ns "CodeAssoc" "AssRight" []
	    , showMooseClassDef ns "CodeAssoc" "AssNon" []
	    , showMooseClassDef ns "CodeAssoc" "AssChain" []
	    , showMooseClassDef ns "CodeAssoc" "AssList" []
	    ]

instance YAML Sig where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"SigMethSingle" -> do
	    let liftM10 f m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; x7 <- m7; x8 <- m8; x9 <- m9; x10 <- m10; return (f x1 x2 x3 x4 x5 x6 x7 x8 x9 x10)}
	    let ESeq [aa, ab, ac, ad, ae, af, ag, ah, ai, aj] = e
	    liftM10 SigMethSingle (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af) (fromYAML ag) (fromYAML ah) (fromYAML ai) (fromYAML aj)
	"SigSubSingle" -> do
	    let liftM9 f m1 m2 m3 m4 m5 m6 m7 m8 m9 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; x7 <- m7; x8 <- m8; x9 <- m9; return (f x1 x2 x3 x4 x5 x6 x7 x8 x9)}
	    let ESeq [aa, ab, ac, ad, ae, af, ag, ah, ai] = e
	    liftM9 SigSubSingle (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af) (fromYAML ag) (fromYAML ah) (fromYAML ai)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["SigMethSingle","SigSubSingle"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (SigMethSingle aa ab ac ad ae af ag ah ai aj) =
	   asYAMLseq "SigMethSingle"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af,
	    asYAML ag, asYAML ah, asYAML ai, asYAML aj]
    asYAML (SigSubSingle aa ab ac ad ae af ag ah ai) =
	   asYAMLseq "SigSubSingle"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af,
	    asYAML ag, asYAML ah, asYAML ai]

instance Perl6Class Sig where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Sig"
	    , showPerl6ClassDef ns "Sig" "SigMethSingle" [("Param","$.s_invocant",""),("Int","$.s_requiredPositionalCount",""),("","$.s_requiredNames","Set Ident"),("Param","@.s_positionalList",""),("","$.s_namedSet","Map Ident Param"),("Param","@.s_slurpyScalarList",""),("Param","$.s_slurpyArray",""),("Param","$.s_slurpyHash",""),("Param","$.s_slurpyCode",""),("Param","$.s_slurpyCapture","")]
	    , showPerl6ClassDef ns "Sig" "SigSubSingle" [("Int","$.s_requiredPositionalCount",""),("","$.s_requiredNames","Set Ident"),("Param","@.s_positionalList",""),("","$.s_namedSet","Map Ident Param"),("Param","@.s_slurpyScalarList",""),("Param","$.s_slurpyArray",""),("Param","$.s_slurpyHash",""),("Param","$.s_slurpyCode",""),("Param","$.s_slurpyCapture","")]
	    ]
    asPerl6Object (SigMethSingle aa ab ac ad ae af ag ah ai aj) = "SigMethSingle.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af, plShow ag, plShow ah, plShow ai, plShow aj]) ++ ")"
    asPerl6Object (SigSubSingle aa ab ac ad ae af ag ah ai) = "SigSubSingle.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af, plShow ag, plShow ah, plShow ai]) ++ ")"

instance MooseClass Sig where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Sig"
	    , showMooseClassDef ns "Sig" "SigMethSingle" [("Param","s_invocant",""),("Int","s_requiredPositionalCount",""),("","s_requiredNames","Set Ident"),("ArrayRef","s_positionalList","[Param]"),("","s_namedSet","Map Ident Param"),("ArrayRef","s_slurpyScalarList","[Param]"),("Param","s_slurpyArray",""),("Param","s_slurpyHash",""),("Param","s_slurpyCode",""),("Param","s_slurpyCapture","")]
	    , showMooseClassDef ns "Sig" "SigSubSingle" [("Int","s_requiredPositionalCount",""),("","s_requiredNames","Set Ident"),("ArrayRef","s_positionalList","[Param]"),("","s_namedSet","Map Ident Param"),("ArrayRef","s_slurpyScalarList","[Param]"),("Param","s_slurpyArray",""),("Param","s_slurpyHash",""),("Param","s_slurpyCode",""),("Param","s_slurpyCapture","")]
	    ]

instance YAML Routine where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"RoutineSimple" -> do
	    let ESeq [aa, ab] = e
	    liftM2 RoutineSimple (fromYAML aa) (fromYAML ab)
	"RoutineMulti" -> do
	    let ESeq [aa, ab] = e
	    liftM2 RoutineMulti (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["RoutineSimple","RoutineMulti"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (RoutineSimple aa ab) = asYAMLseq "RoutineSimple"
	   [asYAML aa, asYAML ab]
    asYAML (RoutineMulti aa ab) = asYAMLseq "RoutineMulti"
	   [asYAML aa, asYAML ab]

instance Perl6Class Routine where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Routine"
	    , showPerl6ClassDef ns "Routine" "RoutineSimple" [("CodeWrapping","$.wrappings",""),("Code","$.routineCode","")]
	    , showPerl6ClassDef ns "Routine" "RoutineMulti" [("CodeWrapping","$.wrappings",""),("","$.routineVariants","Set MultiVariant")]
	    ]
    asPerl6Object (RoutineSimple aa ab) = "RoutineSimple.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (RoutineMulti aa ab) = "RoutineMulti.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass Routine where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Routine"
	    , showMooseClassDef ns "Routine" "RoutineSimple" [("CodeWrapping","wrappings",""),("Code","routineCode","")]
	    , showMooseClassDef ns "Routine" "RoutineMulti" [("CodeWrapping","wrappings",""),("","routineVariants","Set MultiVariant")]
	    ]

instance YAML Code where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"CodePerl" -> do
	    let liftM16 f m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12 m13 m14 m15 m16 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; x7 <- m7; x8 <- m8; x9 <- m9; x10 <- m10; x11 <- m11; x12 <- m12; x13 <- m13; x14 <- m14; x15 <- m15; x16 <- m16; return (f x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16)}
	    let ESeq [aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap] = e
	    liftM16 CodePerl (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af) (fromYAML ag) (fromYAML ah) (fromYAML ai) (fromYAML aj) (fromYAML ak) (fromYAML al) (fromYAML am) (fromYAML an) (fromYAML ao) (fromYAML ap)
	"CodePrim" -> do
	    let ESeq [aa, ab, ac, ad, ae] = e
	    liftM5 CodePrim (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["CodePerl","CodePrim"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (CodePerl aa ab ac ad ae af ag ah ai aj ak al am an ao ap) =
	   asYAMLseq "CodePerl"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af,
	    asYAML ag, asYAML ah, asYAML ai, asYAML aj, asYAML ak, asYAML al,
	    asYAML am, asYAML an, asYAML ao, asYAML ap]
    asYAML (CodePrim aa ab ac ad ae) = asYAMLseq "CodePrim"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae]

instance Perl6Class Code where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Code"
	    , showPerl6ClassDef ns "Code" "CodePerl" [("Sig","$.c_signature",""),("Rational","$.c_precedence",""),("CodeAssoc","$.c_assoc",""),("Bool","$.c_isRW",""),("Bool","$.c_isSafe",""),("Bool","$.c_isCached",""),("Stmt","@.c_body",""),("Pad","$.c_pad",""),("Table","$.c_traits",""),("Code","@.c_preBlocks",""),("Code","@.c_postBlocks",""),("Code","@.c_firstBlocks",""),("Code","@.c_lastBlocks",""),("Code","@.c_nextBlocks",""),("Code","@.c_keepBlocks",""),("Code","@.c_undoBlocks","")]
	    , showPerl6ClassDef ns "Code" "CodePrim" [("Sig","$.c_signature",""),("Rational","$.c_precedence",""),("CodeAssoc","$.c_assoc",""),("Bool","$.c_isRW",""),("Bool","$.c_isSafe","")]
	    ]
    asPerl6Object (CodePerl aa ab ac ad ae af ag ah ai aj ak al am an ao ap) = "CodePerl.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af, plShow ag, plShow ah, plShow ai, plShow aj, plShow ak, plShow al, plShow am, plShow an, plShow ao, plShow ap]) ++ ")"
    asPerl6Object (CodePrim aa ab ac ad ae) = "CodePrim.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae]) ++ ")"

instance MooseClass Code where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Code"
	    , showMooseClassDef ns "Code" "CodePerl" [("Sig","c_signature",""),("Rational","c_precedence",""),("CodeAssoc","c_assoc",""),("Bool","c_isRW",""),("Bool","c_isSafe",""),("Bool","c_isCached",""),("ArrayRef","c_body","[Stmt]"),("Pad","c_pad",""),("Table","c_traits",""),("ArrayRef","c_preBlocks","[Code]"),("ArrayRef","c_postBlocks","[Code]"),("ArrayRef","c_firstBlocks","[Code]"),("ArrayRef","c_lastBlocks","[Code]"),("ArrayRef","c_nextBlocks","[Code]"),("ArrayRef","c_keepBlocks","[Code]"),("ArrayRef","c_undoBlocks","[Code]")]
	    , showMooseClassDef ns "Code" "CodePrim" [("Sig","c_signature",""),("Rational","c_precedence",""),("CodeAssoc","c_assoc",""),("Bool","c_isRW",""),("Bool","c_isSafe","")]
	    ]

instance YAML MultiVariant where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkMultiVariant" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkMultiVariant (fromYAML aa) (fromYAML ab) (fromYAML ac)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkMultiVariant"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkMultiVariant aa ab ac) = asYAMLseq "MkMultiVariant"
	   [asYAML aa, asYAML ab, asYAML ac]

instance Perl6Class MultiVariant where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "MultiVariant"
	    , showPerl6ClassDef ns "MultiVariant" "MkMultiVariant" [("IntSet","$.m_semicolonOffsets",""),("Code","$.m_callable",""),("CodeWrapping","$.m_extraWrappings","")]
	    ]
    asPerl6Object (MkMultiVariant aa ab ac) = "MkMultiVariant.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"

instance MooseClass MultiVariant where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "MultiVariant"
	    , showMooseClassDef ns "MultiVariant" "MkMultiVariant" [("IntSet","m_semicolonOffsets",""),("Code","m_callable",""),("CodeWrapping","m_extraWrappings","")]
	    ]

instance YAML EntryDeclarator where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"DeclMy" -> do
	    return DeclMy
	"DeclOur" -> do
	    return DeclOur
	"DeclHas" -> do
	    return DeclHas
	"DeclState" -> do
	    return DeclState
	"DeclConstant" -> do
	    return DeclConstant
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["DeclMy","DeclOur","DeclHas","DeclState","DeclConstant"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (DeclMy) = asYAMLcls "DeclMy"
    asYAML (DeclOur) = asYAMLcls "DeclOur"
    asYAML (DeclHas) = asYAMLcls "DeclHas"
    asYAML (DeclState) = asYAMLcls "DeclState"
    asYAML (DeclConstant) = asYAMLcls "DeclConstant"

instance Perl6Class EntryDeclarator where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "EntryDeclarator"
	    , showPerl6ClassDef ns "EntryDeclarator" "DeclMy" []
	    , showPerl6ClassDef ns "EntryDeclarator" "DeclOur" []
	    , showPerl6ClassDef ns "EntryDeclarator" "DeclHas" []
	    , showPerl6ClassDef ns "EntryDeclarator" "DeclState" []
	    , showPerl6ClassDef ns "EntryDeclarator" "DeclConstant" []
	    ]
    asPerl6Object (DeclMy) = "DeclMy.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (DeclOur) = "DeclOur.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (DeclHas) = "DeclHas.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (DeclState) = "DeclState.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (DeclConstant) = "DeclConstant.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass EntryDeclarator where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "EntryDeclarator"
	    , showMooseClassDef ns "EntryDeclarator" "DeclMy" []
	    , showMooseClassDef ns "EntryDeclarator" "DeclOur" []
	    , showMooseClassDef ns "EntryDeclarator" "DeclHas" []
	    , showMooseClassDef ns "EntryDeclarator" "DeclState" []
	    , showMooseClassDef ns "EntryDeclarator" "DeclConstant" []
	    ]

instance YAML PadEntry where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkEntry" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkEntry (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkEntry"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkEntry aa ab) = asYAMLseq "MkEntry" [asYAML aa, asYAML ab]

instance Perl6Class PadEntry where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "PadEntry"
	    , showPerl6ClassDef ns "PadEntry" "MkEntry" [("EntryDeclarator","$.e_declarator",""),("EntryStorage","$.e_storage","")]
	    ]
    asPerl6Object (MkEntry aa ab) = "MkEntry.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass PadEntry where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "PadEntry"
	    , showMooseClassDef ns "PadEntry" "MkEntry" [("EntryDeclarator","e_declarator",""),("EntryStorage","e_storage","")]
	    ]

instance YAML MutObject where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"ObjInstance" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 ObjInstance (fromYAML aa) (fromYAML ab) (fromYAML ac)
	"MkForeign" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkForeign (fromYAML aa) (fromYAML ab) (fromYAML ac)
	"MkPrototype" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkPrototype (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["ObjInstance","MkForeign","MkPrototype"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (ObjInstance aa ab ac) = asYAMLseq "ObjInstance"
	   [asYAML aa, asYAML ab, asYAML ac]
    asYAML (MkForeign aa ab ac) = asYAMLseq "MkForeign"
	   [asYAML aa, asYAML ab, asYAML ac]
    asYAML (MkPrototype aa ab) = asYAMLseq "MkPrototype"
	   [asYAML aa, asYAML ab]

instance Perl6Class MutObject where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "MutObject"
	    , showPerl6ClassDef ns "MutObject" "ObjInstance" [("ObjId","$.o_id",""),("ObjClass","$.o_meta",""),("ObjSlots","$.o_slots","")]
	    , showPerl6ClassDef ns "MutObject" "MkForeign" [("ObjId","$.o_id",""),("ObjClass","$.o_meta",""),("ObjPayload","$.o_payload","")]
	    , showPerl6ClassDef ns "MutObject" "MkPrototype" [("ObjId","$.o_id",""),("ObjClass","$.o_meta","")]
	    ]
    asPerl6Object (ObjInstance aa ab ac) = "ObjInstance.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"
    asPerl6Object (MkForeign aa ab ac) = "MkForeign.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"
    asPerl6Object (MkPrototype aa ab) = "MkPrototype.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass MutObject where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "MutObject"
	    , showMooseClassDef ns "MutObject" "ObjInstance" [("ObjId","o_id",""),("ObjClass","o_meta",""),("ObjSlots","o_slots","")]
	    , showMooseClassDef ns "MutObject" "MkForeign" [("ObjId","o_id",""),("ObjClass","o_meta",""),("ObjPayload","o_payload","")]
	    , showMooseClassDef ns "MutObject" "MkPrototype" [("ObjId","o_id",""),("ObjClass","o_meta","")]
	    ]

instance YAML Cap where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"CaptMeth" -> do
	    let ESeq [aa, ab] = e
	    liftM2 CaptMeth (fromYAML aa) (fromYAML ab)
	"CaptSub" -> do
	    let ESeq [aa] = e
	    liftM CaptSub (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["CaptMeth","CaptSub"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (CaptMeth aa ab) = asYAMLseq "CaptMeth"
	   [asYAML aa, asYAML ab]
    asYAML (CaptSub aa) = asYAMLseq "CaptSub" [asYAML aa]

instance Perl6Class Cap where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Cap"
	    , showPerl6ClassDef ns "Cap" "CaptMeth" [("Exp","$.c_invocant",""),("Arglist","@.c_argstack","")]
	    , showPerl6ClassDef ns "Cap" "CaptSub" [("Arglist","@.c_argstack","")]
	    ]
    asPerl6Object (CaptMeth aa ab) = "CaptMeth.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (CaptSub aa) = "CaptSub.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass Cap where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Cap"
	    , showMooseClassDef ns "Cap" "CaptMeth" [("Exp","c_invocant",""),("ArrayRef","c_argstack","[Arglist]")]
	    , showMooseClassDef ns "Cap" "CaptSub" [("ArrayRef","c_argstack","[Arglist]")]
	    ]

instance YAML Arglist where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkArglist" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkArglist (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkArglist"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkArglist aa ab) = asYAMLseq "MkArglist"
	   [asYAML aa, asYAML ab]

instance Perl6Class Arglist where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Arglist"
	    , showPerl6ClassDef ns "Arglist" "MkArglist" [("Exp","@.a_positional",""),("","$.a_named","Map Str [Exp]")]
	    ]
    asPerl6Object (MkArglist aa ab) = "MkArglist.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass Arglist where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Arglist"
	    , showMooseClassDef ns "Arglist" "MkArglist" [("ArrayRef","a_positional","[Exp]"),("","a_named","Map Str [Exp]")]
	    ]

instance YAML Var where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"VarLexical" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 VarLexical (fromYAML aa) (fromYAML ab) (fromYAML ac)
	"VarDynamic" -> do
	    let ESeq [aa, ab] = e
	    liftM2 VarDynamic (fromYAML aa) (fromYAML ab)
	"VarMagic" -> do
	    let ESeq [aa] = e
	    liftM VarMagic (fromYAML aa)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["VarLexical","VarDynamic","VarMagic"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (VarLexical aa ab ac) = asYAMLseq "VarLexical"
	   [asYAML aa, asYAML ab, asYAML ac]
    asYAML (VarDynamic aa ab) = asYAMLseq "VarDynamic"
	   [asYAML aa, asYAML ab]
    asYAML (VarMagic aa) = asYAMLseq "VarMagic" [asYAML aa]

instance Perl6Class Var where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Var"
	    , showPerl6ClassDef ns "Var" "VarLexical" [("Ident","$.v_name",""),("Int","$.v_callerCount",""),("Int","$.v_outerCount","")]
	    , showPerl6ClassDef ns "Var" "VarDynamic" [("Ident","$.v_name",""),("Ident","@.v_packageName","")]
	    , showPerl6ClassDef ns "Var" "VarMagic" [("Magic","$.v_magic","")]
	    ]
    asPerl6Object (VarLexical aa ab ac) = "VarLexical.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"
    asPerl6Object (VarDynamic aa ab) = "VarDynamic.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"
    asPerl6Object (VarMagic aa) = "VarMagic.new(" ++ (concat $ intersperse ", " [plShow aa]) ++ ")"

instance MooseClass Var where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Var"
	    , showMooseClassDef ns "Var" "VarLexical" [("Ident","v_name",""),("Int","v_callerCount",""),("Int","v_outerCount","")]
	    , showMooseClassDef ns "Var" "VarDynamic" [("Ident","v_name",""),("ArrayRef","v_packageName","[Ident]")]
	    , showMooseClassDef ns "Var" "VarMagic" [("Magic","v_magic","")]
	    ]

instance YAML Magic where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MOS" -> do
	    return MOS
	"MOSVer" -> do
	    return MOSVer
	"MPerlVer" -> do
	    return MPerlVer
	"MFile" -> do
	    return MFile
	"MLine" -> do
	    return MLine
	"MScalarPackage" -> do
	    return MScalarPackage
	"MArrayPackages" -> do
	    return MArrayPackages
	"MScalarModule" -> do
	    return MScalarModule
	"MArrayModules" -> do
	    return MArrayModules
	"MScalarClass" -> do
	    return MScalarClass
	"MArrayClasses" -> do
	    return MArrayClasses
	"MScalarRole" -> do
	    return MScalarRole
	"MArrayRoles" -> do
	    return MArrayRoles
	"MScalarGrammar" -> do
	    return MScalarGrammar
	"MArrayGrammars" -> do
	    return MArrayGrammars
	"MParser" -> do
	    return MParser
	"MScalarRoutine" -> do
	    return MScalarRoutine
	"MArrayRoutines" -> do
	    return MArrayRoutines
	"MScalarBlock" -> do
	    return MScalarBlock
	"MArrayBlocks" -> do
	    return MArrayBlocks
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MOS","MOSVer","MPerlVer","MFile","MLine","MScalarPackage","MArrayPackages","MScalarModule","MArrayModules","MScalarClass","MArrayClasses","MScalarRole","MArrayRoles","MScalarGrammar","MArrayGrammars","MParser","MScalarRoutine","MArrayRoutines","MScalarBlock","MArrayBlocks"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MOS) = asYAMLcls "MOS"
    asYAML (MOSVer) = asYAMLcls "MOSVer"
    asYAML (MPerlVer) = asYAMLcls "MPerlVer"
    asYAML (MFile) = asYAMLcls "MFile"
    asYAML (MLine) = asYAMLcls "MLine"
    asYAML (MScalarPackage) = asYAMLcls "MScalarPackage"
    asYAML (MArrayPackages) = asYAMLcls "MArrayPackages"
    asYAML (MScalarModule) = asYAMLcls "MScalarModule"
    asYAML (MArrayModules) = asYAMLcls "MArrayModules"
    asYAML (MScalarClass) = asYAMLcls "MScalarClass"
    asYAML (MArrayClasses) = asYAMLcls "MArrayClasses"
    asYAML (MScalarRole) = asYAMLcls "MScalarRole"
    asYAML (MArrayRoles) = asYAMLcls "MArrayRoles"
    asYAML (MScalarGrammar) = asYAMLcls "MScalarGrammar"
    asYAML (MArrayGrammars) = asYAMLcls "MArrayGrammars"
    asYAML (MParser) = asYAMLcls "MParser"
    asYAML (MScalarRoutine) = asYAMLcls "MScalarRoutine"
    asYAML (MArrayRoutines) = asYAMLcls "MArrayRoutines"
    asYAML (MScalarBlock) = asYAMLcls "MScalarBlock"
    asYAML (MArrayBlocks) = asYAMLcls "MArrayBlocks"

instance Perl6Class Magic where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Magic"
	    , showPerl6ClassDef ns "Magic" "MOS" []
	    , showPerl6ClassDef ns "Magic" "MOSVer" []
	    , showPerl6ClassDef ns "Magic" "MPerlVer" []
	    , showPerl6ClassDef ns "Magic" "MFile" []
	    , showPerl6ClassDef ns "Magic" "MLine" []
	    , showPerl6ClassDef ns "Magic" "MScalarPackage" []
	    , showPerl6ClassDef ns "Magic" "MArrayPackages" []
	    , showPerl6ClassDef ns "Magic" "MScalarModule" []
	    , showPerl6ClassDef ns "Magic" "MArrayModules" []
	    , showPerl6ClassDef ns "Magic" "MScalarClass" []
	    , showPerl6ClassDef ns "Magic" "MArrayClasses" []
	    , showPerl6ClassDef ns "Magic" "MScalarRole" []
	    , showPerl6ClassDef ns "Magic" "MArrayRoles" []
	    , showPerl6ClassDef ns "Magic" "MScalarGrammar" []
	    , showPerl6ClassDef ns "Magic" "MArrayGrammars" []
	    , showPerl6ClassDef ns "Magic" "MParser" []
	    , showPerl6ClassDef ns "Magic" "MScalarRoutine" []
	    , showPerl6ClassDef ns "Magic" "MArrayRoutines" []
	    , showPerl6ClassDef ns "Magic" "MScalarBlock" []
	    , showPerl6ClassDef ns "Magic" "MArrayBlocks" []
	    ]
    asPerl6Object (MOS) = "MOS.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MOSVer) = "MOSVer.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MPerlVer) = "MPerlVer.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MFile) = "MFile.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MLine) = "MLine.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarPackage) = "MScalarPackage.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayPackages) = "MArrayPackages.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarModule) = "MScalarModule.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayModules) = "MArrayModules.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarClass) = "MScalarClass.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayClasses) = "MArrayClasses.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarRole) = "MScalarRole.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayRoles) = "MArrayRoles.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarGrammar) = "MScalarGrammar.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayGrammars) = "MArrayGrammars.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MParser) = "MParser.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarRoutine) = "MScalarRoutine.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayRoutines) = "MArrayRoutines.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MScalarBlock) = "MScalarBlock.new(" ++ (concat $ intersperse ", " []) ++ ")"
    asPerl6Object (MArrayBlocks) = "MArrayBlocks.new(" ++ (concat $ intersperse ", " []) ++ ")"

instance MooseClass Magic where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Magic"
	    , showMooseClassDef ns "Magic" "MOS" []
	    , showMooseClassDef ns "Magic" "MOSVer" []
	    , showMooseClassDef ns "Magic" "MPerlVer" []
	    , showMooseClassDef ns "Magic" "MFile" []
	    , showMooseClassDef ns "Magic" "MLine" []
	    , showMooseClassDef ns "Magic" "MScalarPackage" []
	    , showMooseClassDef ns "Magic" "MArrayPackages" []
	    , showMooseClassDef ns "Magic" "MScalarModule" []
	    , showMooseClassDef ns "Magic" "MArrayModules" []
	    , showMooseClassDef ns "Magic" "MScalarClass" []
	    , showMooseClassDef ns "Magic" "MArrayClasses" []
	    , showMooseClassDef ns "Magic" "MScalarRole" []
	    , showMooseClassDef ns "Magic" "MArrayRoles" []
	    , showMooseClassDef ns "Magic" "MScalarGrammar" []
	    , showMooseClassDef ns "Magic" "MArrayGrammars" []
	    , showMooseClassDef ns "Magic" "MParser" []
	    , showMooseClassDef ns "Magic" "MScalarRoutine" []
	    , showMooseClassDef ns "Magic" "MArrayRoutines" []
	    , showMooseClassDef ns "Magic" "MScalarBlock" []
	    , showMooseClassDef ns "Magic" "MArrayBlocks" []
	    ]

instance YAML Package where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkPackage" -> do
	    let ESeq [aa, ab] = e
	    liftM2 MkPackage (fromYAML aa) (fromYAML ab)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkPackage"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkPackage aa ab) = asYAMLseq "MkPackage"
	   [asYAML aa, asYAML ab]

instance Perl6Class Package where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Package"
	    , showPerl6ClassDef ns "Package" "MkPackage" [("Ident","$.p_name",""),("Package","$.p_parent","")]
	    ]
    asPerl6Object (MkPackage aa ab) = "MkPackage.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab]) ++ ")"

instance MooseClass Package where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Package"
	    , showMooseClassDef ns "Package" "MkPackage" [("Ident","p_name",""),("Package","p_parent","")]
	    ]

instance YAML Module where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkModule" -> do
	    let ESeq [aa, ab, ac] = e
	    liftM3 MkModule (fromYAML aa) (fromYAML ab) (fromYAML ac)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkModule"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkModule aa ab ac) = asYAMLseq "MkModule"
	   [asYAML aa, asYAML ab, asYAML ac]

instance Perl6Class Module where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Module"
	    , showPerl6ClassDef ns "Module" "MkModule" [("Data.Version.Version","$.m_version",""),("Network.URI.URI","$.m_authority",""),("Package","$.m_package","")]
	    ]
    asPerl6Object (MkModule aa ab ac) = "MkModule.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac]) ++ ")"

instance MooseClass Module where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Module"
	    , showMooseClassDef ns "Module" "MkModule" [("Data.Version.Version","m_version",""),("Network.URI.URI","m_authority",""),("Package","m_package","")]
	    ]

instance YAML Class where
    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
	"MkClass" -> do
	    let liftM6 f m1 m2 m3 m4 m5 m6 = do
		{x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; x5 <- m5; x6 <- m6; return (f x1 x2 x3 x4 x5 x6)}
	    let ESeq [aa, ab, ac, ad, ae, af] = e
	    liftM6 MkClass (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae) (fromYAML af)
	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkClass"] ++ " in node " ++ show e
    fromYAML _ = fail "no tag found"
    asYAML (MkClass aa ab ac ad ae af) = asYAMLseq "MkClass"
	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae, asYAML af]

instance Perl6Class Class where
    showPerl6TypeDef ns _ = unlines
	    [ showPerl6RoleDef ns "Class"
	    , showPerl6ClassDef ns "Class" "MkClass" [("Module","$.c_module",""),("Class","@.c_superClasses",""),("","$.c_runtimeSuperClasses","Eval [Class]"),("","$.c_methodTable","Map Ident Code"),("","$.c_runtimeMethodtable","Eval Map Ident Code"),("","$.c_runtimeSlots","Eval Map Ident TVar Val")]
	    ]
    asPerl6Object (MkClass aa ab ac ad ae af) = "MkClass.new(" ++ (concat $ intersperse ", " [plShow aa, plShow ab, plShow ac, plShow ad, plShow ae, plShow af]) ++ ")"

instance MooseClass Class where
    showMooseTypeDef ns _ = unlines
	    [ showMooseRoleDef ns "Class"
	    , showMooseClassDef ns "Class" "MkClass" [("Module","c_module",""),("ArrayRef","c_superClasses","[Class]"),("","c_runtimeSuperClasses","Eval [Class]"),("","c_methodTable","Map Ident Code"),("","c_runtimeMethodtable","Eval Map Ident Code"),("","c_runtimeSlots","Eval Map Ident TVar Val")]
	    ]

--  Imported from other files :-

type Buf = Buf.ByteString

#endif
