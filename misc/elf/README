A development story (a tale of two compilers)

  Say someone hands you a working perl6.
  What can you do with it?

  If you alrady have your own implementation of p6, written in p6,
  you could now compile it.
    six -o mysix -x MySix.pm

  But you could *not*, in general, do
    six MySix.pm
  If you tried, as MySix was compiled (which can involve running) and
  run, it would stomp all over the implementation of six.  In general,
  breaking it.

  If you instead wanted to make small, *compatible* changes to six,
  you could do
    six TweakSix.pm ...
  Which would likely give you 'mumble was redefined' warnings, but
  could otherwise be harmless and helpful.

  But what if you have something inbetween.  More than a compatible
  tweak, but less than a full implementation.  Some hook apis are
  provided to permit larger changes.

  To make it easier to work on new compilers, the compiler for
  internal use need not be the same one used to provide external
  compiled code.  And the compiler used for each, can be independently
  hot-swapped at runtime.  That's why there are conceptually two
  compilers.  And $*compiler0, $*compiler1, $*emitter0, $*emitter1, etc.


Cast of Characters

After elf_d - subsequent objectives:
 Sufficient IR analysis for near-term backend goals.
 Facilitate start of various backends - smop, conformant p5, maybe ruby.
 Facilitate other components:
   Prelude.
   regex.
   Better command line.
   Start of STD5 integration.

elf_d
Purpose:
  Switch to a new IR.
  Metaprogramming infrastructure for new IR and for ast-to-ir conversion.
  External development of new backends becomes easy.
Maybe:
  Alternate emitter for faster p5 (mostly to shakedown backend creation story).
  IR analysis.
  Address some inconvenient implementation limitations.
  Start of p6 Prelude.
Comparison: Like elf_c, but with new IR nodes.
Written in: elf_c dialect.
Can be compiled by: elf_d, elf_c.
Status: active development (eventually).

elf_c
Purpose:
  Refactor implementation classes, now that has() is available.
  Add use() support, for both runtime and whole-program compilation.
  Makes creation of derivative implementations easier.
Comparison: Like elf_b, but written in elf_b p6, not elf_a p6 (basically +has).
Written in: elf_b dialect.
Emits: Currently same as elf_b, but that may change.
Can be compiled by: elf_c only.
Linkages:
  ast_handlers and ir_nodes are copies of those in std_b.
  They can't be regenerated, but only recopied by hand.
  The hope is elf_c won't remain active long enough for that to be a problem.
Status: active development.

elf_b
Purpose: Switch implementation language from p5 to p6.
Comparison: Like elf_a, but written in p6.
Written in: p6, elf_a dialect.
Emits: Slighly less simple and less fast p5 than elf_a.
Can be compiled by: elf_b, elf_a.
Linkages:
  Uses elf_a ast_handlers, mechanically massaged into p6.
  Uses elf_a's copy of STD_red.
Status: slushy.

elf_a
Why: First step.
Written in: p5
Emits: Simple and fast p5.
Status: slushy.
