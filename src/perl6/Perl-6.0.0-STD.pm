grammar Perl-6.0.0-STD;          # (XXX maybe should be -PROTO or some such)

=begin things todo

    regexen
    colon pairs
    WHICH etc.
    contextualizers
    Array of Int
    bracket matching incl Unicode Ps/Pe
    Captures
    Signatures
    string literals
    heredocs
    generalized quotes
    quote declarator
    radix nums
    &foo:(Int,Num)
    &foo\($a,$b)
    \c[LATIN CAPITAL LETTER A]
    add parsing this file to sanity tests :)

=end things todo

# XXX need to figure out how to export language:
# method export_language {
#     $?COMPILING::<$?COMPILER> := $?GRAMMAR;
# }
# with variants for override vs extend

# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via
# the following #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to $/ within the action block, so we need not mention it explicitly.

# This grammar also assumes transitive longest-token semantics, though
# we make a feeble attempt to order rules so a procedural | can usually
# produce a correct parse.

rule TOP { <compunit> {*} }                             #= TOP

# Built-in or autogenerated rules:
#      <EXPR>: the operator precedence parser
#  <CATEGORY>: the rule matching any valid category names
#       <foo>: all tokens of foo category |-ed together

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implmentation; they may change at any time.
# Users should only specify precedence in relation to existing levels.

my %term              ::= { :prec<z=>                           };
my %methodcall        ::= { :prec<v=>                           };
my %autoincrement     ::= { :prec<u=>, :assoc<non>, :lvalue     };
my %exponentiation    ::= { :prec<t=>, :assoc<right>            };
my %symbolic_unary    ::= { :prec<s=>                           };
my %multiplicative    ::= { :prec<r=>, :assoc<left>             };
my %additive          ::= { :prec<q=>, :assoc<left>             };
my %junctive_and      ::= { :prec<p=>, :assoc<list>             };
my %junctive_or       ::= { :prec<o=>, :assoc<list>             };
my %named_unary       ::= { :prec<n=>, :assoc<left>             };
my %nonchaining       ::= { :prec<m=>, :assoc<non>              };
my %chaining          ::= { :prec<l=>, :assoc<chain>            };
my %tight_and         ::= { :prec<k=>, :assoc<left>             };
my %tight_or          ::= { :prec<j=>, :assoc<left>             };
my %conditional       ::= { :prec<i=>, :assoc<right>            };
my %item_assignment   ::= { :prec<h=>, :assoc<right>, :lvalue   };
my %loose_unary       ::= { :prec<g=>, :assoc<right>            };
my %comma             ::= { :prec<f=>, :assoc<list>             };
my %list_infix        ::= { :prec<e=>                           };
my %list_prefix       ::= { :prec<d=>                           };
my %loose_and         ::= { :prec<c=>                           };
my %loose_or          ::= { :prec<b=>                           };
my %terminator        ::= { :prec<a=>, :assoc<list>             };

role Term {...}
role Methodcall {...}
role Autoincrement {...}
role Exponentiation {...}
role Symbolic_unary {...}
role Multiplicative {...}
role Additive {...}
role Junctive_and {...}
role Junctive_or {...}
role Named_unary {...}
role Nonchaining {...}
role Chaining {...}
role Tight_and {...}
role Tight_or {...}
role Conditional {...}
role Item_assignment {...}
role Loose_unary {...}
role Comma {...}
role List_infix {...}
role List_prefix {...}
role Loose_and {...}
role Loose_or {...}
role Terminator {...}

# Categories are designed to be extensible in derived grammars.

# The endsym trait, if specified, says what to implicitly check for in each
# rule right after the initial :<symbol>.  Normally this is used to make sure
# there's appropriate whitespace, though Perl 6 also uses it to rule out
# the => (fatarrow) construct.

category noun_prefix_sigil;
category noun_prefix_twigil;
category special_variable;
category nameroot;
category version;

category term;
category quote;
category prefix  is defequiv(%symbolic_unary);
category infix   is defequiv(%additive);
category postfix is defequiv(%autoincrement);

category circumfix;
category postcircumfix;

category regex_metachar;
category regex_backslash;
category regex_assertion;
category regex_mod_internal;
category regex_mod_external;

category q_backslash;
category qq_backslash;

category trait_verb         is endsym(/ \s+ <nofat> /);
category trait_auxiliary    is endsym(/ \s+ <nofat> /);

category type_declarator    is endsym(/ \b <nofat> /);
category scope_declarator   is endsym(/ \b <nofat> /);
category package_declarator is endsym(/ \b <nofat> /);
category routine_declarator is endsym(/ \b <nofat> /);
category statement_prefix   is endsym(/ \b <nofat> /);
category statement_control  is endsym(/ \s <nofat> /);
category statement_cond     is endsym(/ \b <nofat> /);
category statement_loop     is endsym(/ \b <nofat> /);

category infix_prefix_meta_operator;
category infix_postfix_meta_operator;
category postfix_prefix_meta_operator;
category prefix_postfix_meta_operator;
category prefix_circumfix_meta_operator;

# Lexical routines

# make sure we're not an autoquoted identifier
regex nofat { <!before \h* <?unsp> =\> > }

method heredoc {
    while my $heredoc = shift @heredoc_queue {
        my $delim = $heredoc.delim;
        my $text = "";
        # XXX wrong, wrong, wrong
        if m:p/(.*?) ^^ (\h*) $delim \h* $$ \n?/ {
            $text = $0;
            $white = $1;
            $text ~~ s:g/^^ $white //;
            $heredoc.text = $text;
        }
        else {
            fail("Ending delimiter $delim not found");
        }
    }
}

token ws {
    || <?after \w> <?before \w> ::: <fail>        # must \s+ between words
    || [
       | <unsp>              {*}                        #= ws unsp
       | \v                  {*} <heredoc>              #= ws vwhite
       | <unv>               {*}                        #= ws unv
       ]*  {*}                                          #= ws all
}

token unsp {
    \\ <?before [\s|\#]>
    [
    | \v                     {*}                        #= unsp vwhite
    | <unv>                  {*}                        #= unsp unv
    ]*  {*}                                             #= unsp all
}

token unv {
       | \h+                 {*}                        #= unv hwhite
       | ^^ [
            | \# \N*         {*}                        #= unv comment line
            | <?pod_comment> {*}                        #= unv comment pod
            ]
       | <'#'> [
            # assuming <bracketed> defaults to standard set
            | <?bracketed>   {*}                        #= unv comment inline
            | \N*            {*}                        #= unv comment end
            ]
}

# XXX We need to parse the pod eventually to support $= variables.

token pod_comment {
    ^^ =
    [
    | begin <?ws> <ident> .*? \n
      =end <?ws> $<ident> \N* \n?                   {*} #= pod block
    | \N* \n?                                       {*} #= pod misc
    ]
                                                    {*} #= pod comment
}

# Top-level rules

rule comp_unit {
    ^
    [ <package_declarator> <module_name> <trait>* ; ]?
    <statement_list>
    [ $ || <panic: Parse terminated early> ]
                                                    {*} #= comp_unit
}

token block {
    \{
    <statement_list>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp> <?before <[,:]>> {*}                       #= block
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= block endline
    | {*} { let $<endlist> := 1; }                       #= block endlist
    ]
                                                        {*} #= block
}

token regex_block {  # perhaps parameterize and combine with block someday
    \{
    <regex>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp> <?before <[,:]>> {*}                       #= rxblock
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= rxblock endline
    | {*} { let $<endlist> := 1; }                       #= rxblock endlist
    ]
                                                        {*} #= rxblock
}

rule statement_list {
    <statement>*
                                                    {*} #= statement_list
}

token label { <ident> \: \s <?ws> {*} }                 #= label

rule statement {
    <label>*                                     {*}    #= label
    [
    | <statement_control>                        {*}    #= statement control
    | <block>                                    {*}    #= statement block
    | <EXPR>                                     {*}    #= statement expr
        [<statement_cond> <EXPR> {*} ]?                 #= statement mod cond
        [<statement_loop> <EXPR> {*} ]?                 #= statement mod loop
    ]
                                                        {*} #= statement
}

rule statement_control {
    :<use>
    <module_name_wild> <EXPR>? ;?                       {*} #? #= sc use
}

rule statement_control {
    :<if>
    <EXPR>                           {*}                #= sc if expr
    <block>                          {*}                #= sc if block
    @<elsif> := [ elsif <EXPR>       {*}                #= sc if elsif expr
                        <block>      {*} ]*             #= sc if elsif block
    @<else> := [ else <block>        {*} ]?             #= sc if else
                                                        {*} #= sc if
}

rule statement_control {
    :<unless>
    <EXPR>                           {*}                #= sc unless expr
    <block>                          {*}                #= sc unless block
                                                        {*} #= sc unless
}

rule statement_control {
    :<while>
    <EXPR>                             {*}                #= sc while expr
    <block>                            {*}                #= sc while block
                                                          {*} #= sc while
}

rule statement_control {
    :<until>
    <EXPR>                             {*}                #= sc until expr
    <block>                            {*}                #= sc until block
                                                          {*} #= sc until
}
rule statement_control {
    :<repeat>
    [
        | (while|until) <EXPR>         {*}              #= sc repeat wu expr
          <block>                      {*}              #= sc repeat wu block
        | <block>                      {*}              #= sc repeat block wu
          (while|until) <EXPR>         {*}              #= sc repeat expr wu
    ]
                                                          {*} #= sc repeat
}
rule statement_control {
    :<loop>
    $<eee> := [
        \(
            $<e1> := <EXPR> ;   {*}                     #= sc loop e1
            $<e2> := <EXPR> ;   {*}                     #= sc loop e2
            $<e3> := <EXPR>     {*}                     #= sc loop e3
        \)                      {*}                     #= sc loop eee
    ]?
    <block>                     {*}                     #= sc loop block
                                                        {*} #= sc loop
}

rule statement_control { :<for>     <block> {*} }        #= sc for
rule statement_control { :<when>    <block> {*} }        #= sc when
rule statement_control { :<BEGIN>   <block> {*} }        #= sc BEGIN
rule statement_control { :<CHECK>   <block> {*} }        #= sc CHECK
rule statement_control { :<INIT>    <block> {*} }        #= sc INIT
rule statement_control { :<END>     <block> {*} }        #= sc END
rule statement_control { :<START>   <block> {*} }        #= sc START
rule statement_control { :<ENTER>   <block> {*} }        #= sc ENTER
rule statement_control { :<LEAVE>   <block> {*} }        #= sc LEAVE
rule statement_control { :<KEEP>    <block> {*} }        #= sc KEEP
rule statement_control { :<UNDO>    <block> {*} }        #= sc UNDO
rule statement_control { :<FIRST>   <block> {*} }        #= sc FIRST
rule statement_control { :<NEXT>    <block> {*} }        #= sc NEXT
rule statement_control { :<LAST>    <block> {*} }        #= sc LAST
rule statement_control { :<PRE>     <block> {*} }        #= sc PRE
rule statement_control { :<POST>    <block> {*} }        #= sc POST
rule statement_control { :<CATCH>   <block> {*} }        #= sc CATCH
rule statement_control { :<CONTROL> <block> {*} }        #= sc CONTROL

token statement_control { %statement_control }

rule modifier_expr { <EXPR> ;? {*} }                    #? #= modifier_expr

token statement_modifier { <statement_cond> | <statement_loop> }

rule statement_cond { :<if>     <modifier_expr> {*} };     #= scond if
rule statement_cond { :<unless> <modifier_expr> {*} };     #= scond unless
rule statement_cond { :<when>   <modifier_expr> {*} };     #= scond for

rule statement_loop { :<for>    <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<given>  <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<while>  <modifier_expr> {*} };     #= sloop while
rule statement_loop { :<until>  <modifier_expr> {*} };     #= sloop until

token nameroot { <'perl6'> }
token nameroot { <'perl5'> }
token nameroot { <'parrot'> }
token nameroot { <'ruby'> }
token nameroot { <'python'> }
token nameroot { <'tcl'> }
token nameroot { <'js'> }
token nameroot { <'scheme'> }
token nameroot { <'lisp'> }
token nameroot { <'haskell'> }
token nameroot { <'java'> }
token nameroot { <'c'> }
token nameroot { <'cplusplus'> }
token nameroot { <'csharp'> }
token nameroot { <'ada'> }
token nameroot { <'lua'> }
token nameroot { <'php'> }

token module_name {
    <name>                                          {*} #= modulename name
    [- <version>                                    {*} #= modulename version
        [-
            <authority>                             {*} #= modulename auth
        ]?
    ]?
                                                    {*} #= modulename
}

token authority { <-[ \s ; \{ ]>+ }

token module_name_wild {
    [ <nameroot> \: {*} ]?                              #= modulewild root
    <name>                                          {*} #= modulewild name
    [- <version_wild>                               {*} #= modulewild version
        [-
            <authority_wild>                        {*} #= modulewild auth
        ]?
    ]?
                                                    {*} #= modwild
}

token version_wild   { <block> | <whatever> | <version> }
token authority_wild { <block> | <whatever> | <authority> }

token whatever { \* }

token version {
    v \d+ [ \. \d+ ]*                 {*}             #= version vstyle
}
token version {
    \d+ \. \d+ \. \d+ [ \. \d+]*      {*}             #= version dotted
}

###################################################

token expect_term {
    <?ws>

    [
        [
        | <prefix>                                      {*} #= Xterm prefix
        | <prefix_circumfix_meta_operator>              {*} #= Xterm precircum
        ]
        <prefix_postfix_meta_operator>*                 {*} #= Xterm prepost
    ]*

    <noun>                                              {*} #= Xterm noun
    <expect_postfix>*                                   {*} #= Xterm postfix
                                                        {*} #= Xterm
}

token noun {
    | <ident> <before \h* =\> >     # XXX sufficient in face of precedence?
    | <circumfix>
    | <package_block>
    | <variable>
    | <value>
    | <quote>
    | <term>
    | <scope_declarator>
    | <routine_block>
    | <regex_block>
    | <statement_prefix>
}

token expect_infix ($minprec) {
    <?ws>
    <infix_prefix_meta_operator>*
    <infix>
    <infix_postfix_meta_operator>*
    ::: <?{ $<infix>.prec gt $minprec }>
                                                    {*} #= Xinfix
}

token dotty {
    | <'.+'>                                  {*}     #= dotty plus
    | <'.*'>                                  {*}     #= dotty star
    | <'.?'>                                  {*}     #= dotty query
    | <'.='>                                  {*}     #= dotty equals
    | <'.^'>                                  {*}     #= dotty caret
    | <'.:'>                                  {*}     #= dotty colon
    | <'.'>                                   {*}     #= dotty plain
}

token expect_postfix {
    [
    | \\ <?before \.>
    | <?unsp>
    | <null>
    ]

    [ [\. <?unsp>?]? <postfix_prefix_meta_operator> <?unsp>? ]*

    [
    | $<dot> := <dotty> <?unsp>? <methodop>
    | $<dot> := [ \.]   <?unsp>? <postop>
    |                            <postop>
    ]
                                                    {*} #= Xpostfix
}
token prefix_circumfix_meta_operator {
    :<[> <infix> :<]>                               {*}  #= precircum square
}

token prefix_postfix_meta_operator { :<«>     {*} }  #» #= prepost hyper
token prefix_postfix_meta_operator { :['<<'] {*} }      #= prepost HYPER

token postfix_prefix_meta_operator { :<»>     {*} }     #= postpre hyper
token postfix_prefix_meta_operator { :['>>'] {*} }      #= postpre HYPER

token infix_prefix_meta_operator { :<!>     {*} }       #= inpre not
token infix_prefix_meta_operator { :<«>     {*} }    #» #= inpre hyper dwim
token infix_prefix_meta_operator { :<»>     {*} }       #= inpre hyper asis
token infix_prefix_meta_operator { :['<<'] {*} }        #= inpre HYPER dwim
token infix_prefix_meta_operator { :['>>'] {*} }        #= inpre HYPER asis

token infix_postfix_meta_operator { :<=>     {*} }      #= inpost assign
token infix_postfix_meta_operator { :<«>     {*} }   #» #= inpost hyper asis
token infix_postfix_meta_operator { :<»>     {*} }      #= inpost hyper dwim
token infix_postfix_meta_operator { :['<<']  {*} }      #= inpost HYPER asis
token infix_postfix_meta_operator { :['>>']  {*} }      #= inpost HYPER dwim

token postfix { :<i> {*} }                              #= postfix i
token postfix { :<++> {*} }                             #= postfix incr
token postfix { :<--> {*} }                             #= postfix decr

token postcircumfix { :<(> <EXPR> :<)> {*} }            #= postcircumfix ( )

token postcircumfix { :<[> <EXPR> :<]> {*} }            #= postcircumfix [ ]

token postcircumfix { :<{> <EXPR> :<}> {*} }            #= postcircumfix { }
token postcircumfix { :['<'] <anglewords> :['>']
                                                    {*} #= postcircumfix < >
}

token postcircumfix { :['<'] <shellwords> :['>']
                                                    {*} #= postcircumfix << >>
}

token postcircumfix { :<«> <shellwords> :<»> {*} }      #= postcircumfix « »

token postop { <postfix> | <postcircumfix> }

token dot {
    (
    | \\ <?before \.>
    | <?unsp>
    )
    (\. [\>\>|»] )?
    \. (<[= * + ?]> <?unsp>? <?before \w>)?
                                                    {*} #= dot
}

token methodop {
    <ident>
    [
    | \.? \( <EXPR> \)
    | \: <?before \s> <listop_expr>
    | <null>
    ]
}

token circumfix { :<(> <EXPR> :<)> {*} }                #= circumfix ( )
token circumfix { :<[> <EXPR> :<]> {*} }                #= circumfix [ ]
token circumfix { :['<']  <anglewords>  :['>'] {*} }    #= circumfix < >
token circumfix { :['<<'] <shellwords> :['>>'] {*} }    #= circumfix << >>
token circumfix { :<«>    <shellwords> :<»>    {*} }    #= circumfix « »
token circumfix is Circumfix[:symbol<{ }>]
    { <block>         {*} }                             #= circumfix { }

rule scoped_variables {
    <scope_declarator> <variable>
}

token scope_declarator { :<my>       {*} }     #= sd my
token scope_declarator { :<our>      {*} }     #= sd our
token scope_declarator { :<state>    {*} }     #= sd state
token scope_declarator { :<constant> {*} }     #= sd constant
token scope_declarator { :<has>      {*} }     #= sd has

token package_declarator { :<class>     {*} }     #= td class
token package_declarator { :<grammar>   {*} }     #= td grammar
token package_declarator { :<module>    {*} }     #= td module
token package_declarator { :<role>      {*} }     #= td role
token package_declarator { :<package>   {*} }     #= td package

token package_block {
    <scope_declarator>?
    <package_declarator>
    <module_name>?              # XXX maybe shouldn't have version/auth?
    <trait>*
    <block>
}

token special_variable { :<$!>  {*} }
token special_variable { :<$/>  {*} }

token variable {
    | <special_variable>
    | <sigiltwigil> <name>
    | <name> <'::'> <hashpostfix>
}

token sigiltwigil {
    <noun_prefix_sigil>
    <noun_prefix_twigil>?
}

token noun_prefix_sigil { :<$>   {*} }               #= sigil $
token noun_prefix_sigil { :<@>   {*} }               #= sigil @
token noun_prefix_sigil { :<@@>  {*} }               #= sigil @@
token noun_prefix_sigil { :<%>   {*} }               #= sigil %
token noun_prefix_sigil { :<&>   {*} }               #= sigil &
token noun_prefix_sigil { :<::>  {*} }               #= sigil ::

token noun_prefix_twigil { :<.>  {*} }               #= twigil .
token noun_prefix_twigil { :<!>  {*} }               #= twigil !
token noun_prefix_twigil { :<^>  {*} }               #= twigil ^
token noun_prefix_twigil { :<*>  {*} }               #= twigil *
token noun_prefix_twigil { :<+>  {*} }               #= twigil +
token noun_prefix_twigil { :<?>  {*} }               #= twigil ?
token noun_prefix_twigil { :<=>  {*} }               #= twigil =

token name {
    | <ident> <nofat> [ <'::'> <ident> ]*
    | [ <'::'> <ident> ]+
}

token subname {
    | <name>
    | <CATEGORY> \: <postcurcumfix>
}

token value {
    | <string>
    | <number>
    | <integer>
    | <version>
    | <typename>
}

regex typename {
    <name>
    <?{
        is_type($<name>)
    }>
}

token integer {
    | 0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]*
        ]
    | \d+[_\d+]*
}

token number {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
}

token quote_term {
    | ' <quote_expr> '
    | " <quote_expr> "
    | \<\< <quote_expr> \>\>
    | \<   <quote_expr> \>
}

##  rules for parsing interpolated values in quotes.
##  The first part of the rule handles non-scalar
##  interpolation (which must end with a postcircumfix operator);
##  the second part handles scalar interpolation.

token quote_interpolation {
    | <![$]> ::: <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )+
    | <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )*
}

rule routine_block {
    <scope_declarator>?
    <subintro>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <block>
}

rule regex_method {
    <scope_declarator>?
    <regex_declarator>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <regex_block>
}

rule subintro { <routine_modifier> <routine_type>? | <routine_type> }

token routine_modifier { multi | proto }

token routine_declarator { :<sub> }
token routine_declarator { :<method> }
token routine_declarator { :<submethod> }
token routine_declarator { :<macro> }

token regex_declarator { :<regex> }
token regex_declarator { :<token> }
token regex_declarator { :<rule> }

rule trait { <trait_verb> | <trait_auxiliary> }

token trait_auxiliary { :<is>   <ident>[\( <EXPR> \)]? }
token trait_auxiliary { :<will> <ident> <block> }

token trait_verb { :<of>        <type> }
token trait_verb { :<returns>   <type> }

rule signature {
    [<parameter> [ [ \, | \: | ; | ;; ] <parameter> ]* ]?
    [ --\> <type> ]?
}

rule type_declarator {
    :<subset>
    <name>
    [ of <type_name> ]?
    where <subset>
}

rule type_constraint {
    | <value>
    | <type_name>
    | where <subset>
}

token parameter {
    <slurp>?
    <type_constraint>*
    [
    | \: <ident>? \(
      <sigiltwigil>  <ident>?
      \)
    | <sigiltwigil>  <ident>?
    ]
    <default_value>
}

rule statement_prefix { :<do>      <statement> {*} }    #= sp do
rule statement_prefix { :<try>     <statement> {*} }    #= sp try
rule statement_prefix { :<gather>  <statement> {*} }    #= sp gather
rule statement_prefix { :<contend> <statement> {*} }    #= sp contend
rule statement_prefix { :<async>   <statement> {*} }    #= sp async
rule statement_prefix { :<lazy>    <statement> {*} }    #= sp lazy

## term
token term is Term[]                            #= term:<*> def
    { :<*> {*} }                                #= term:<*>

token circumfix is Term[]                       #= circumfix:<( )> def
    { :<( )> {*} }                              #= circumfix:<( )>

token postcircumfix is Term[]                   #= postcircumfix:<( )> def
    is abstract('call')
    { :<( )> {*} }                              #= postcircumfix:<( )>

## autoincrement
token postfix is Autoincrement[]                #= postfix:<++> def
    { :<++> {*} }                               #= postfix:<++>

token postfix is Autoincrement[]                #= postfix:<--> def
    { :<--> {*} }                               #= postfix:<-->

token prefix is Autoincrement[]                 #= prefix:<++> def
    { :<++> {*} }                               #= prefix:<++>

token prefix is Autoincrement[]                 #= prefix:<--> def
    { :<--> {*} }                               #= prefix:<-->


## exponentiation
token infix is Exponentiate[]                   #= infix:<**> def
    { :<**> {*} }                               #= infix:<**>

## symbolic unary
token prefix is Symbolic_unary[]                #= prefix:<!> def
    { :<!> {*} }                                #= prefix:<!>

token prefix is Symbolic_unary[]                #= prefix:<+> def
    { :<+> {*} }                                #= prefix:<+>

token prefix is Symbolic_unary[]                #= prefix:<-> def
    { :<-> {*} }                                #= prefix:<->

token prefix is Symbolic_unary[]                #= prefix:<~> def
    { :<~> {*} }                                #= prefix:<~>

token prefix is Symbolic_unary[]                #= prefix:<?> def
    { :<?> {*} }                                #= prefix:<?>

token prefix is Symbolic_unary[]                #= prefix:<=> def
    { :<=> {*} }                                #= prefix:<=>

token prefix is Symbolic_unary[]                #= prefix:<*> def
    { :<*> {*} }                                #= prefix:<*>

token prefix is Symbolic_unary[]                #= prefix:<**> def
    { :<**> {*} }                               #= prefix:<**>

token prefix is Symbolic_unary[]                #= prefix:<~^> def
    { :<~^> {*} }                               #= prefix:<~^>

token prefix is Symbolic_unary[]                #= prefix:<+^> def
    { :<+^> {*} }                               #= prefix:<+^>

token prefix is Symbolic_unary[]                #= prefix:<?^> def
    { :<?^> {*} }                               #= prefix:<?^>

token prefix is Symbolic_unary[]                #= prefix:<^> def
    { :<^> {*} }                                #= prefix:<^>


## multiplicative
token infix is Multiplicative[]                 #= infix:<*> def
    { :<*> {*} }                                #= infix:<*>

token infix is Multiplicative[]                 #= infix:</> def
    { :</> {*} }                                #= infix:</>

token infix is Multiplicative[]                 #= infix:<%> def
    { :<%> {*} }                                #= infix:<%>

token infix is Multiplicative[]                 #= infix:<x> def
    { :<x> {*} }                                #= infix:<x>

token infix is Multiplicative[]                 #= infix:<xx> def
    { :<xx> {*} }                               #= infix:<xx>

token infix is Multiplicative[]                 #= infix:<+&> def
    { :<+&> {*} }                               #= infix:<+&>

token infix is Multiplicative[]                 #= infix:['+<'] def
    { :['+<'] {*} }                             #= infix:['+<']

token infix is Multiplicative[]                 #= infix:['+>'] def
    { :['+>'] {*} }                             #= infix:['+>']

token infix is Multiplicative[]                 #= infix:<~&> def
    { :<~&> {*} }                               #= infix:<~&>

token infix is Multiplicative[]                 #= infix:['~<'] def
    { :['~<'] {*} }                             #= infix:['~<']

token infix is Multiplicative[]                 #= infix:['~>'] def
    { :['~>'] {*} }                             #= infix:['~>']


## additive
token infix is Additive[]                       #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Additive[]                       #= infix:<-> def
    { :<-> {*} }                                #= infix:<->

token infix is Additive[]                       #= infix:<~> def
    { :<~> {*} }                                #= infix:<~>

token infix is Additive[]                       #= infix:<+|> def
    { :<+|> {*} }                               #= infix:<+|>

token infix is Additive[]                       #= infix:<+^> def
    { :<+^> {*} }                               #= infix:<+^>

token infix is Additive[]                       #= infix:<~|> def
    { :<~|> {*} }                               #= infix:<~|>

token infix is Additive[]                       #= infix:<~^> def
    { :<~^> {*} }                               #= infix:<~^>

token infix is Additive[]                       #= infix:<?|> def
    { :<?|> {*} }                               #= infix:<?|>

token infix is Additive[]                       #= infix:<?^> def
    { :<?^> {*} }                               #= infix:<?^>


## junctive and (all)
token infix is Junctive_and[]                   #= infix:<&> def
    { :<&> {*} }                                #= infix:<&>


## junctive or (any)
token infix is Junctive_or[]                    #= infix:<|> def
    { :<|> {*} }                                #= infix:<|>

token infix is Junctive_or[]                    #= infix:<^> def
    { :<^> {*} }                                #= infix:<^>


## named unary examples
token prefix is Named_unary[]                   #= prefix:<rand> def
    { :<rand> {*} }                             #= prefix:<rand>

token prefix is Named_unary[]                   #= prefix:<sleep> def
    { :<sleep> {*} }                            #= prefix:<sleep>

token prefix is Named_unary[]                   #= prefix:<abs> def
    { :<abs> {*} }                              #= prefix:<abs>

## nonchaining binary
token infix is Nonchaining[]                    #= infix:['<=>'] def
    { :['<=>'] {*} }                            #= infix:['<=>']

token infix is Nonchaining[]                    #= infix:<cmp> def
    { :<cmp> {*} }                              #= infix:<cmp>

token infix is Nonchaining[]                    #= infix:<is> def
    { :<is> {*} }                               #= infix:<is>

token infix is Nonchaining[]                    #= infix:<but> def
    { :<but> {*} }                              #= infix:<but>

token infix is Nonchaining[]                    #= infix:<does> def
    { :<does> {*} }                             #= infix:<does>

token infix is Nonchaining[]                    #= infix:<..> def
    { :<..> {*} }                               #= infix:<..>

token infix is Nonchaining[]                    #= infix:<^..> def
    { :<^..> {*} }                              #= infix:<^..>

token infix is Nonchaining[]                    #= infix:<..^> def
    { :<..^> {*} }                              #= infix:<..^>

token infix is Nonchaining[]                    #= infix:<^..^> def
    { :<^..^> {*} }                             #= infix:<^..^>

token infix is Nonchaining[]                    #= infix:<ff> def
    { :<ff> {*} }                               #= infix:<ff>

token infix is Nonchaining[]                    #= infix:<^ff> def
    { :<^ff> {*} }                              #= infix:<^ff>

token infix is Nonchaining[]                    #= infix:<ff^> def
    { :<ff^> {*} }                              #= infix:<ff^>

token infix is Nonchaining[]                    #= infix:<^ff^> def
    { :<^ff^> {*} }                             #= infix:<^ff^>

token infix is Nonchaining[]                    #= infix:<fff> def
    { :<fff> {*} }                              #= infix:<fff>

token infix is Nonchaining[]                    #= infix:<^fff> def
    { :<^fff> {*} }                             #= infix:<^fff>

token infix is Nonchaining[]                    #= infix:<fff^> def
    { :<fff^> {*} }                             #= infix:<fff^>

token infix is Nonchaining[]                    #= infix:<^fff^> def
    { :<^fff^> {*} }                            #= infix:<^fff^>


## chaining binary
token infix is Chaining[]                       #= infix:<==> def
    { :<==> {*} }                               #= infix:<==>

token infix is Chaining[]                       #= infix:<!=> def
    { :<!=> {*} }                               #= infix:<!=>

token infix is Chaining[]                       #= infix:['<'] def
    { :['<'] {*} }                              #= infix:['<']

token infix is Chaining[]                       #= infix:['<='] def
    { :['<='] {*} }                             #= infix:['<=']

token infix is Chaining[]                       #= infix:['>'] def
    { :['>'] {*} }                              #= infix:['>']

token infix is Chaining[]                       #= infix:['>='] def
    { :['>='] {*} }                             #= infix:['>=']

token infix is Chaining[]                       #= infix:<~~> def
    { :<~~> {*} }                               #= infix:<~~>

token infix is Chaining[]                       #= infix:<!~> def
    { :<!~> {*} }                               #= infix:<!~>

token infix is Chaining[]                       #= infix:<=~> def
    { :<=~> {*} }                               #= infix:<=~>

token infix is Chaining[]                       #= infix:<eq> def
    { :<eq> {*} }                               #= infix:<eq>

token infix is Chaining[]                       #= infix:<ne> def
    { :<ne> {*} }                               #= infix:<ne>

token infix is Chaining[]                       #= infix:<lt> def
    { :<lt> {*} }                               #= infix:<lt>

token infix is Chaining[]                       #= infix:<le> def
    { :<le> {*} }                               #= infix:<le>

token infix is Chaining[]                       #= infix:<gt> def
    { :<gt> {*} }                               #= infix:<gt>

token infix is Chaining[]                       #= infix:<ge> def
    { :<ge> {*} }                               #= infix:<ge>

token infix is Chaining[]                       #= infix:<=:=> def
    { :<=:=> {*} }                              #= infix:<=:=>

token infix is Chaining[]                       #= infix:<===> def
    { :<===> {*} }                              #= infix:<===>


## tight and
token infix is Tight_and[]                      #= infix:<&&> def
    is abstract('if')
    { :<&&> {*} }                               #= infix:<&&>


## tight or
token infix is Tight_or[]                       #= infix:<||> def
    is abstract('unless')
    { :<||> {*} }                               #= infix:<||>

token infix is Tight_or[:assoc<list>]           #= infix:<^^> def
    is assoc('list')
    is abstract('xor')
    { :<^^> {*} }                               #= infix:<^^>

token infix is Tight_or[]                       #= infix:<//> def
    { :<//> {*} }                               #= infix:<//>


## conditional
token infix is Conditional[]                    #= infix:<?? !!> def
    is abstract('if')
    { :<??> <EXPR(|%conditional)> :<!!> {*} }   #= infix:<?? !!>


## assignment
token infix is Assignment[]                     #= infix:<=> def
    is abstract('assign')
    is lvalue(1)
    { :<=> {*} }                                #= infix:<=>

token infix is Assignment[]                     #= infix:<:=> def
    is abstract('bind')
    { :<:=> {*} }                               #= infix:<:=>

token infix is Assignment[]                     #= infix:<::=> def
    { :<::=> {*} }                              #= infix:<::=>

token infix is Assignment[]                     #= infix:<.=> def
    { :<.=> {*} }                               #= infix:<.=>

token infix is Assignment[]                     #= infix:<~=> def
    { :<~=> {*} }                               #= infix:<~=>

token infix is Assignment[]                     #= infix:<+=> def
    { :<+=> {*} }                               #= infix:<+=>

token infix is Assignment[]                     #= infix:<-=> def
    { :<-=> {*} }                               #= infix:<-=>

token infix is Assignment[]                     #= infix:<*=> def
    { :<*=> {*} }                               #= infix:<*=>

token infix is Assignment[]                     #= infix:</=> def
    { :</=> {*} }                               #= infix:</=>

token infix is Assignment[]                     #= infix:<%=> def
    { :<%=> {*} }                               #= infix:<%=>

token infix is Assignment[]                     #= infix:<x=> def
    { :<x=> {*} }                               #= infix:<x=>

token infix is Assignment[]                     #= infix:<Y=> def
    { :<Y=> {*} }                               #= infix:<Y=>

token infix is Assignment[]                     #= infix:<**=> def
    { :<**=> {*} }                              #= infix:<**=>

token infix is Assignment[]                     #= infix:<xx=> def
    { :<xx=> {*} }                              #= infix:<xx=>

token infix is Assignment[]                     #= infix:<||=> def
    { :<||=> {*} }                              #= infix:<||=>

token infix is Assignment[]                     #= infix:<&&=> def
    { :<&&=> {*} }                              #= infix:<&&=>

token infix is Assignment[]                     #= infix:<//=> def
    { :<//=> {*} }                              #= infix:<//=>

token infix is Assignment[]                     #= infix:<^^=> def
    { :<^^=> {*} }                              #= infix:<^^=>

token infix is Assignment[]                     #= infix:<+<=> def
    { :<+<=> {*} }                           #> #= infix:<+<=>

token infix=> is Assignment[]                   #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Assignment[]                     #= infix:<+|=> def
    { :<+|=> {*} }                              #= infix:<+|=>

token infix is Assignment[]                     #= infix:<+&=> def
    { :<+&=> {*} }                              #= infix:<+&=>

token infix is Assignment[]                     #= infix:<+^=> def
    { :<+^=> {*} }                              #= infix:<+^=>

token infix is Assignment[]                     #= infix:<~|=> def
    { :<~|=> {*} }                              #= infix:<~|=>

token infix is Assignment[]                     #= infix:<~&=> def
    { :<~&=> {*} }                              #= infix:<~&=>

token infix is Assignment[]                     #= infix:<~^=> def
    { :<~^=> {*} }                              #= infix:<~^=>

token infix is Assignment[]                     #= infix:<?|=> def
    { :<?|=> {*} }                              #= infix:<?|=>

token infix is Assignment[]                     #= infix:<?&=> def
    { :<?&=> {*} }                              #= infix:<?&=>

token infix is Assignment[]                     #= infix:<?^=> def
    { :<?^=> {*} }                              #= infix:<?^=>

token infix is Assignment[]                     #= infix:<|=> def
    { :<|=> {*} }                               #= infix:<|=>

token infix is Assignment[]                     #= infix:<&=> def
    { :<&=> {*} }                               #= infix:<&=>

token infix is Assignment[]                     #= infix:<^=> def
    { :<^=> {*} }                               #= infix:<^=>

## list item separator
token infix is Comma[]                          #= infix:<,> def
    { :<,> {*} }                                #= infix:<,>

## loose unary
token prefix is Loose_unary[]                   #= prefix:<true> def
    { :<true> {*} }                             #= prefix:<true>

token prefix is Loose_unary[]                   #= prefix:<not> def
    { :<not> {*} }                              #= prefix:<not>

## list prefix (really sub calls)
token prefix is List_prefix[]                   #= prefix:<print> def
    { :<print> {*} }                            #= prefix:<print>

## loose and
token infix is Loose_and[]                      #= infix:<and> def
    is abstract('if')
    { :<and> {*} }                              #= infix:<and>

## loose or
token infix is Loose_or[]                       #= infix:<or> def
    is abstract('unless')
    { :<or> {*} }                               #= infix:<or>

token infix is Loose_or[]                       #= infix:<xor> def
    is abstract('xor')
    { :<xor> {*} }                              #= infix:<xor>

token infix is Loose_or[]                       #= infix:<err> def
    { :<err> {*} }                              #= infix:<err>

## expression terminator

# XXX correct to eat semicolon here?
token terminator is Terminator[]                #= terminator:<;> def
    { :<;> {*} }                                #= terminator:<;>

token terminator is Terminator[:symbol['<==']]  #= terminator:['<=='] def
    { <before \<==> {*} }                       #= terminator:['<==']

token terminator is Terminator[:symbol['==>']]  #= terminator:['==>'] def
    { <?before :['==>'] > {*} }              #' #= terminator:['==>']

token terminator is Terminator[:symbol<)>]      #= terminator:<)> def
    { <?before :<)> > {*} }                     #= terminator:<)>

token terminator is Terminator[:symbol<]>]      #= terminator:<]> def
    { <?before \] > {*} }                       #= terminator:<]>

token terminator is Terminator[:symbol<\}>]     #= terminator:<}> def
    { <?before \} > {*} }                       #= terminator:<}>

token terminator is Terminator[:symbol<!!>]     #= terminator:<!!> def
    { <?before !! > {*} }                       #= terminator:<!!>

token stdstopper { <terminator> | <statement_cond> | <statement_loop> | $ }
token assertstopper { <stdstopper> | \> }

# XXX skeleton of operator precedence parser

method EXPR (:$prec = "a=", :$stop = &stdstoppers) {
    if m:p/ <?before <$stop>> / {
        return;
    }
    my @termstack;
    my @opstack;
    push @termstack, $.expect_term();
    while not m:p/ <?before <$stop> > / {
        my $infix := $.expect_infix($prec) err last;
        if @opstack and $infix.prec gt @opstack[-1].prec {   # reduce
            # XXX your ad here
        }
        else {                                  # shift
            push @opstack, $infix;
            if m:p/ <?before <$stop>> / {
                fail("$infix.perl() is missing right term");
            }
            push @termstack, $.expect_term();
        }
    }
    return @opstack;
}

#############################################3333
## Regex
#############################################3333

rule regex {
    <regex_ordered_disjunction>
}

rule regex_ordered_disjunction {
    <'||'>?
    <regex_ordered_conjunction>
    [ :<||> <regex_ordered_conjunction> ]*
}

rule regex_ordered_conjunction {
    <regex_unordered_disjunction>
    [ :<&&> <regex_unordered_disjunction> ]*
}

rule regex_unordered_disjunction {
    <'|'>?
    <regex_unordered_conjunction>
    [ :<|> <regex_unordered_conjunction> ]*
}

rule regex_unordered_conjunction {
    <regex_sequence>
    [ :<&> <regex_sequence> ]*
}

rule regex_sequence {
    <regex_quantified_atom>+
    # Could combine unquantified atoms into one here...
}

rule regex_quantified_atom {
    <regex_atom>
    [ <regex_quantifier>
        <?{ $<regex_atom>.max_width }>
            || <panic: "Can't quantify zero-width atom")
    ]?
}

rule <regex_atom> {
    || <regex_metachar>
    || (.)
}

# sequence stoppers
token regex_metachar { :['>'] :: <fail> }
token regex_metachar { :<&&>  :: <fail> }
token regex_metachar { :<&>   :: <fail> }
token regex_metachar { :<||>  :: <fail> }
token regex_metachar { :<|>   :: <fail> }
token regex_metachar { :<}>   :: <fail> }
token regex_metachar { :<]>   :: <fail> }
token regex_metachar { :<)>   :: <fail> }

# "normal" metachars
token regex_metachar { <block> }
token regex_metachar { <quantifier> <panic: quantifier quantifies nothing> }
token regex_metachar { <regex_mod_internal> }
token regex_metachar { :<[> <regex> :<]> }
token regex_metachar { :<(> <regex> :<)> }
token regex_metachar { :<\>> <regex_rightangle> }
token regex_metachar { :['>>'] }
token regex_metachar { :['<<'] }
token regex_metachar { :['<'] <regex_assertion> :['>'] }
token regex_metachar { :<\\> <regex_backslash> }
token regex_metachar { :<.> }
token regex_metachar { :<^^> }
token regex_metachar { :<^> }
token regex_metachar { :<$$> }
token regex_metachar {
    | :<$> <before $
                 | \s
                 | \|
                 | \)
                 | \]
                 | \>
           >
    | <variable>
}

token q_backslash { :<qq> <qq_bracketed> }
token q_backslash { :<\> }

token qq_backslash { :<a> }
token qq_backslash { :<b> }
token qq_backslash { :<c> <bracket_named_unicode> }
token qq_backslash { :<e> }
token qq_backslash { :<f> }
token qq_backslash { :<n> }
token qq_backslash { :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token qq_backslash { :<r> }
token qq_backslash { :<t> }
token qq_backslash { :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token qq_backslash { :: \W || <panic: unrecognized backslash sequence> }

token regex_backslash { :i :<a> }
token regex_backslash { :i :<b> }
token regex_backslash { :i :<c> <bracket_named_unicode> }
token regex_backslash { :i :<d> }
token regex_backslash { :i :<e> }
token regex_backslash { :i :<f> }
token regex_backslash { :i :<h> }
token regex_backslash { :i :<n> }
token regex_backslash { :i :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token regex_backslash { :i :<r> }
token regex_backslash { :i :<t> }
token regex_backslash { :i :<v> }
token regex_backslash { :i :<w> }
token regex_backslash { :i :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token regex_backslash { :: <panic: unrecognized regex backslash sequence> }

token regex_assertion { :<?> <regex_assertion> }
token regex_assertion { :<!> <regex_assertion> }

token regex_assertion { <block> }
token regex_assertion { <variable> }
token regex_assertion { <ident> [
                                | \: <?ws> <qq_literal(:stop«>»))>
                                | \( <EXPR> \)
                                | <?ws> <EXPR>
                                ]?
}

token regex_assertion { :<+> <cclass_elem>+ }
token regex_assertion { :<-> <cclass_elem>+ }

token regex_assertion { <panic: unrecognized regex assertion> }

token regex_mod_internal { :<:i> <regex_mod_arg>? }
token regex_mod_internal { <panic: unrecognized regex modifier> }

token regex_mod_external { :<:nth> <regex_mod_arg> }
token regex_mod_external { <panic: unrecognized regex modifier> }

token regex_quantifier { :<**> <?ws> <block> <quantmod> }
token regex_quantifier { :<*> <quantmod> }
token regex_quantifier { :<+> <quantmod> }

token quantmod { [ \? | \! | \: | \+ ]? }

# The <panic: message> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

rule panic (Str $s) { <commit> <fail($s)> }

## vim: expandtab sw=4
