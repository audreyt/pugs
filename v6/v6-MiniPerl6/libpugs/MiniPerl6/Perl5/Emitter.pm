# Do not edit this file - Generated by MiniPerl6
use v6-alpha;
class CompUnit { has $.name; has $.attributes; has $.methods; has $.body; method emit { do { [] }; ('package ' ~ ($.name ~ ('; ' ~ ('sub new { shift; bless { @_ }, "' ~ ($.name ~ ('" }' ~ (' ' ~ @.body>>.emit().join('; ')))))))) }} 
;
class Val::Int { has $.int; method emit { do { [] }; $.int }} 
;
class Val::Bit { has $.bit; method emit { do { [] }; $.bit }} 
;
class Val::Num { has $.num; method emit { do { [] }; $.num }} 
;
class Val::Buf { has $.buf; method emit { do { [] }; ('\'' ~ ($.buf ~ '\'')) }} 
;
class Val::Undef { method emit { do { [] }; '(undef)' }} 
;
class Val::Object { has $.class; has $.fields; method emit { do { [] }; ('bless(' ~ (%.fields.perl() ~ (', ' ~ ($.class.perl() ~ ')')))) }} 
;
class Lit::Seq { has $.seq; method emit { do { [] }; ('(' ~ (@.seq>>.emit().join(', ') ~ ')')) }} 
;
class Lit::Array { has $.array; method emit { do { [] }; ('[' ~ (@.array>>.emit().join(', ') ~ ']')) }} 
;
class Lit::Hash { has $.hash; method emit { do { [] }; my  $fields = @.hash; my  $str = ''; do { for ( @($fields) ) -> $field { $str = ($str ~ ($field.[0].emit() ~ (' => ' ~ ($field.[1].emit() ~ ',')))) } }; ('{ ' ~ ($str ~ ' }')) }} 
;
class Lit::Code { 1} 
;
class Lit::Object { has $.class; has $.fields; method emit { do { [] }; my  $fields = @.fields; my  $str = ''; do { for ( @($fields) ) -> $field { $str = ($str ~ ($field.[0].emit() ~ (' => ' ~ ($field.[1].emit() ~ ',')))) } }; ($.class ~ ('->new( ' ~ ($str ~ ' )'))) }} 
;
class Index { has $.obj; has $.index; method emit { do { [] }; ($.obj.emit() ~ ('->[' ~ ($.index.emit() ~ ']'))) }} 
;
class Lookup { has $.obj; has $.index; method emit { do { [] }; ($.obj.emit() ~ ('->{' ~ ($.index.emit() ~ '}'))) }} 
;
class Var { has $.sigil; has $.twigil; has $.name; method emit { do { [] }; my  $table = { '$' => '$','@' => '$List_','%' => '$Hash_','&' => '$Code_', }; (($.twigil eq '.') ?? ('$self->{' ~ ($.name ~ '}')) !! (($.name eq '/') ?? ($table.{$.sigil} ~ 'MATCH') !! ($table.{$.sigil} ~ $.name))) }; method name { do { [] }; $.name }} 
;
class Bind { has $.parameters; has $.arguments; method emit { do { [] }; do { if ($.parameters.isa('Lit::Array')) { my  $a = $.parameters.array();my  $str = 'do { ';my  $i = 0;do { for ( @($a) ) -> $var { my  $bind = Bind.new( 'parameters' => $var,'arguments' => Index.new( 'obj' => $.arguments,'index' => Val::Int.new( 'int' => $i, ), ), );$str = ($str ~ (' ' ~ ($bind.emit() ~ '; ')));$i = ($i + 1) } };return(($str ~ ($.parameters.emit() ~ ' }'))) } else {  } }; do { if ($.parameters.isa('Lit::Hash')) { my  $a = $.parameters.hash();my  $b = $.arguments.hash();my  $str = 'do { ';my  $i = 0;my  $arg;do { for ( @($a) ) -> $var { $arg = Val::Undef.new(  );do { for ( @($b) ) -> $var2 { do { if (($var2.[0].buf() eq $var.[0].buf())) { $arg = $var2.[1] } else {  } } } };my  $bind = Bind.new( 'parameters' => $var.[1],'arguments' => $arg, );$str = ($str ~ (' ' ~ ($bind.emit() ~ '; ')));$i = ($i + 1) } };return(($str ~ ($.parameters.emit() ~ ' }'))) } else {  } }; do { if ($.parameters.isa('Lit::Object')) { my  $class = $.parameters.class();my  $a = $.parameters.fields();my  $b = $.arguments;my  $str = 'do { ';my  $i = 0;my  $arg;do { for ( @($a) ) -> $var { my  $bind = Bind.new( 'parameters' => $var.[1],'arguments' => Call.new( 'invocant' => $b,'method' => $var.[0].buf(),'arguments' => [],'hyper' => 0, ), );$str = ($str ~ (' ' ~ ($bind.emit() ~ '; ')));$i = ($i + 1) } };return(($str ~ ($.parameters.emit() ~ ' }'))) } else {  } }; ($.parameters.emit() ~ (' = ' ~ $.arguments.emit())) }} 
;
class Proto { has $.name; method emit { do { [] }; ~($.name) }} 
;
class Call { has $.invocant; has $.hyper; has $.method; has $.arguments; method emit { do { [] }; my  $invocant = $.invocant.emit(); do { if (($invocant eq 'self')) { $invocant = '$self' } else {  } }; do { if ((($.method eq 'perl') || (($.method eq 'yaml') || (($.method eq 'say') || (($.method eq 'join') || (($.method eq 'chars') || ($.method eq 'isa'))))))) { do { if ($.hyper) { return(('[ map { Main::' ~ ($.method ~ ('( $_, ' ~ (', ' ~ (@.arguments>>.emit().join(', ') ~ (')' ~ (' } @{ ' ~ ($invocant ~ ' } ]'))))))))) } else { return(('Main::' ~ ($.method ~ ('(' ~ ($invocant ~ (', ' ~ (@.arguments>>.emit().join(', ') ~ ')'))))))) } } } else {  } }; my  $meth = $.method; do { if (($meth eq 'postcircumfix:<( )>')) { $meth = '' } else {  } }; my  $call = ('->' ~ ($meth ~ ('(' ~ (@.arguments>>.emit().join(', ') ~ ')')))); do { if ($.hyper) { ('[ map { $_' ~ ($call ~ (' } @{ ' ~ ($invocant ~ ' } ]')))) } else { ($invocant ~ $call) } } }} 
;
class Apply { has $.code; has $.arguments; method emit { do { [] }; my  $code = $.code; do { if ($code.isa('Str')) {  } else { return(('(' ~ ($.code.emit() ~ (')->(' ~ (@.arguments>>.emit().join(', ') ~ ')'))))) } }; do { if (($code eq 'self')) { return('$self') } else {  } }; do { if (($code eq 'say')) { return(('Main::say(' ~ (@.arguments>>.emit().join(', ') ~ ')'))) } else {  } }; do { if (($code eq 'print')) { return(('Main::print(' ~ (@.arguments>>.emit().join(', ') ~ ')'))) } else {  } }; do { if (($code eq 'array')) { return(('@{' ~ (@.arguments>>.emit().join(' ') ~ '}'))) } else {  } }; do { if (($code eq 'prefix:<~>')) { return(('("" . ' ~ (@.arguments>>.emit().join(' ') ~ ')'))) } else {  } }; do { if (($code eq 'prefix:<!>')) { return(('(' ~ (@.arguments>>.emit().join(' ') ~ ' ? 0 : 1)'))) } else {  } }; do { if (($code eq 'prefix:<?>')) { return(('(' ~ (@.arguments>>.emit().join(' ') ~ ' ? 1 : 0)'))) } else {  } }; do { if (($code eq 'prefix:<$>')) { return(('${' ~ (@.arguments>>.emit().join(' ') ~ '}'))) } else {  } }; do { if (($code eq 'prefix:<@>')) { return(('@{' ~ (@.arguments>>.emit().join(' ') ~ '}'))) } else {  } }; do { if (($code eq 'prefix:<%>')) { return(('%{' ~ (@.arguments>>.emit().join(' ') ~ '}'))) } else {  } }; do { if (($code eq 'infix:<~>')) { return(('(' ~ (@.arguments>>.emit().join(' . ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<+>')) { return(('(' ~ (@.arguments>>.emit().join(' + ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<->')) { return(('(' ~ (@.arguments>>.emit().join(' - ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<&&>')) { return(('(' ~ (@.arguments>>.emit().join(' && ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<||>')) { return(('(' ~ (@.arguments>>.emit().join(' || ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<eq>')) { return(('(' ~ (@.arguments>>.emit().join(' eq ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<ne>')) { return(('(' ~ (@.arguments>>.emit().join(' ne ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<==>')) { return(('(' ~ (@.arguments>>.emit().join(' == ') ~ ')'))) } else {  } }; do { if (($code eq 'infix:<!=>')) { return(('(' ~ (@.arguments>>.emit().join(' != ') ~ ')'))) } else {  } }; do { if (($code eq 'ternary:<?? !!>')) { return(('(' ~ (@.arguments.[0].emit() ~ (' ? ' ~ (@.arguments.[1].emit() ~ (' : ' ~ (@.arguments.[2].emit() ~ ')'))))))) } else {  } }; ($.code ~ ('(' ~ (@.arguments>>.emit().join(', ') ~ ')'))) }} 
;
class Return { has $.result; method emit { do { [] }; return(('return(' ~ ($.result.emit() ~ ')'))) }} 
;
class If { has $.cond; has $.body; has $.otherwise; method emit { do { [] }; ('do { if (' ~ ($.cond.emit() ~ (') { ' ~ (@.body>>.emit().join(';') ~ (' } else { ' ~ (@.otherwise>>.emit().join(';') ~ ' } }')))))) }} 
;
class For { has $.cond; has $.body; has $.topic; method emit { do { [] }; my  $cond = $.cond; do { if (($cond.isa('Var') && ($cond.sigil() eq '@'))) { $cond = Apply.new( 'code' => 'prefix:<@>','arguments' => [$cond], ) } else {  } }; ('do { for my ' ~ ($.topic.emit() ~ (' ( ' ~ ($cond.emit() ~ (' ) { ' ~ (@.body>>.emit().join(';') ~ ' } }')))))) }} 
;
class Decl { has $.decl; has $.type; has $.var; method emit { do { [] }; my  $decl = $.decl; my  $name = $.var.name(); (($decl eq 'has') ?? ('sub ' ~ ($name ~ (' { ' ~ ('@_ == 1 ' ~ ('? ( $_[0]->{' ~ ($name ~ ('} ) ' ~ (': ( $_[0]->{' ~ ($name ~ ('} = $_[1] ) ' ~ '}')))))))))) !! ($.decl ~ (' ' ~ ($.type ~ (' ' ~ $.var.emit()))))) }} 
;
class Sig { has $.invocant; has $.positional; has $.named; method emit { do { [] }; ' print \'Signature - TODO\'; die \'Signature - TODO\'; ' }; method invocant { do { [] }; $.invocant }; method positional { do { [] }; $.positional }} 
;
class Method { has $.name; has $.sig; has $.block; method emit { do { [] }; my  $sig = $.sig; my  $invocant = $sig.invocant(); my  $pos = $sig.positional(); my  $str = 'my $List__ = \@_; '; my  $pos = $sig.positional(); do { for ( @($pos) ) -> $field { $str = ($str ~ ('my ' ~ ($field.emit() ~ '; '))) } }; my  $bind = Bind.new( 'parameters' => Lit::Array.new( 'array' => $sig.positional(), ),'arguments' => Var.new( 'sigil' => '@','twigil' => '','name' => '_', ), ); $str = ($str ~ ($bind.emit() ~ '; ')); ('sub ' ~ ($.name ~ (' { ' ~ ('my ' ~ ($invocant.emit() ~ (' = shift; ' ~ ($str ~ (@.block>>.emit().join('; ') ~ ' }')))))))) }} 
;
class Sub { has $.name; has $.sig; has $.block; method emit { do { [] }; my  $sig = $.sig; my  $pos = $sig.positional(); my  $str = 'my $List__ = \@_; '; my  $pos = $sig.positional(); do { for ( @($pos) ) -> $field { $str = ($str ~ ('my ' ~ ($field.emit() ~ '; '))) } }; my  $bind = Bind.new( 'parameters' => Lit::Array.new( 'array' => $sig.positional(), ),'arguments' => Var.new( 'sigil' => '@','twigil' => '','name' => '_', ), ); $str = ($str ~ ($bind.emit() ~ '; ')); ('sub ' ~ ($.name ~ (' { ' ~ ($str ~ (@.block>>.emit().join('; ') ~ ' }'))))) }} 
;
class Do { has $.block; method emit { do { [] }; ('do { ' ~ (@.block>>.emit().join('; ') ~ ' }')) }} 
;
class Use { has $.mod; method emit { do { [] }; ('use ' ~ $.mod) }} 
;
