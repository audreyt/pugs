=head1 NAME

Precompilation cache in Pugs

=head1 DESCRIPTION

Rather than parse every .p6 or .pm file pugs sees over and over again as
they are needed, pugs stores the results of compilation in a cache. This
gives the benefit of speed without the awkwardness of an opaque object
file.

=head1 PHASE 1 - GET IT WORKING

=head2 Objectives

In the first version of the design, we aim for simplicity, reasonable
forward compatibility, but not kitchen sink flexibility. For now, this
is a Pugs mechanism. One cache should support several versions of Pugs,
sharing objects where possible, and allowing easy maintenance.  If it gets
screwed up, the admin should be able to delete the cache directory and
not suffer from anything but subsequent temporary cold cache slowdowns.

There are a few cache maint tools that can be added bit by bit. They
probably deserve a secion of their own but for now:

=item delete objects for Pugses older than X

=item clean least recently accessed objects (should happen as a matter of course during regular cache usage)

=item warm up cache for an entire set of modules

=item change cache size limit

=head2 What goes into the cache

Objects stored in the cache are compilation units after parsing. Perl
6 has separate compilation, and presumably every compilation unit has
one canonical abstract representation per version of Pugs. Where this is
not the case, e.g. if C<BEGIN> blocks intends to change the compilation
outcome of this unit, the author of the code should mark the unit as not
cachable. XXX: notation for this.

We now describe how cache objects are keyed in the cache, and the bytecode
format of a cached object.

=head2 Keying scheme

Example:

  ~joe/.pugscache/1/14/148071fa07847bc0de8df7d75cd03072f27239c2-9600-9658
  # $HOME/.pugscache/$H1/$H2/$SHA1-$ReleaseRev-$ParserRev

The fast path for cache usage is successful lookup of a valid precompiled
unit.

The cache is (in the first insance) a filesystem directory under the user's
C<$HOME>. A global cache would have been nice for disk and CPU performance
on multiuser machines, but since original source code is easily deducible
from the compiled version, this is a security issue we prefer to avoid.

Every compilation unit that enters the cache is stored in a file of its
own.  The file location is a function of (a hash of) the source code,
Pugs version, and Pugs parser version. This prevents us from loading
a precompiled object for a unit that has changed, or for a parser that
would have emitted a different structure than the one present in the
cache. To keep file count in a given directory managable, the file is
hashed into a directory inside the cache (XXX: figure out optimal hashing
depth? Or can this usefully be made automatic?).

For now the current keying scheme implies that the source file needs
to be read from storage even if a precompiled version of it exists in
the cache, because we require its hash. There may be ways to optimize
that part away, but they can be added in the future. I<Not> having the
compilation unit name as part of the hash key is nice, because it means
we don't have to worry about name canonicalization or source files with
similar names but different locations. It also means we can cache objects
that aren't files at all, such as C<eval $sting> results (as long as
C<$string> is the same across runs), or units received over the network
(as long as we can get their hashes before we attempt to compile them).

=head2 Bytecode format

The cached object is a compressed YAML document containing a serialized
Haskell Pugs structure.

=head3 Compression

We use gzip currently as the de-facto compression mechanism. This is the
easiest to deploy with Pugs: GHC bundles zlib, and Data.FastPackedString
which we use anyway for file IO contains enough bindings to read gzipped
files. Compression is desireable because serialized YAML for precompiled
units are large: for example, the 22 KB C<Prelude.pm> takes on the order
of 1.2 MB to serialize, but 47 KB in gzipped form. There are better
compression algorithms out there; for example, BZip2 compresses the
same file to only 20 KB. If you wish to work on a patch for changing the
compression scheme, it should not lose portability or deployability to
the current setup (i.e., must bundle or implement whatever scheme you
desire), and provide a transparent readFile function that identifies
the actual object by magic number.

=head3 Precompiled data

C<pugs -CParse-YAML File.pm> or C<Pugs::Internals::emit_yaml> output a
serialized form of the following structure. C<Pugs::Internals::eval_p6c>
or the module loader load it:

  data CompUnit = MkCompUnit
      { ver  :: Int        -- currently 1
      , desc :: String     -- e.g., the name of the contained module
      , glob :: (TVar Pad) -- pad for unit Env
      , ast  :: Exp        -- AST of unit
      }

The C<ver> field is currenly set to 1. It is always the first element in
the CompUnit structure, for forward compatibility. The C<desc> field is for
diagnostics. C<glob> is the global pad for this unit, and finally, C<ast> is
the parsed tree.


[[ TODO: loading flow etc. ]]
