#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <smop.h>
#include <smop_oo.h>
#include <smop_lowlevel.h>
#include "p6opaque.h"

SMOP__Object* SMOP__p6opaque__RI;

static SMOP__Object* p6opaque_message_REPR_CREATE(SMOP__Object* interpreter,
                                                  SMOP__ResponderInterface* self,
                                                  SMOP__Object* identifier,
                                                  SMOP__Object* capture) {
  SMOP__Object* ret = smop_lowlevel_alloc(sizeof(SMOP__p6opaque_struct));
  ret->RI = (SMOP__ResponderInterface*)SMOP__p6opaque__RI;
  return ret;
}

static SMOP__Object* p6opaque_message_REPR_how(SMOP__Object* interpreter,
                                               SMOP__ResponderInterface* self,
                                               SMOP__Object* identifier,
                                               SMOP__Object* capture) {
  SMOP__Object* ret = SMOP__NATIVE__bool_false;

  if (SMOP_RI(capture) == (SMOP__ResponderInterface*)SMOP__NATIVE__capture) {
    SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter,capture);
    SMOP__Object* set = SMOP__NATIVE__capture_positional(interpreter,capture,0);

    if (invocant == SMOP__p6opaque__RI) {
      ret = SMOP__NATIVE__bool_false;
    } else if (SMOP_RI(invocant) != (SMOP__ResponderInterface*)SMOP__p6opaque__RI) {
      fprintf(stderr, "[SMOP p6opaque] call to .^!how with non p6opaque invocant\n");
      ret = SMOP__NATIVE__bool_false;
    } else {

      if (set) {
        smop_lowlevel_wrlock(invocant);
      } else {
        smop_lowlevel_rdlock(invocant);
      }

      if (((SMOP__p6opaque_struct*)invocant)->metadata) {
        // we have our own metadata.
        SMOP__Object* old = NULL;
        if (set) {
          old = ((SMOP__p6opaque_struct*)invocant)->metadata->how;
          ((SMOP__p6opaque_struct*)invocant)->metadata->how = set;
        }
        ret = ((SMOP__p6opaque_struct*)invocant)->metadata->how;
        smop_lowlevel_unlock(invocant);

        if (old) SMOP_RELEASE(interpreter, old);
        SMOP_REFERENCE(interpreter, ret);

      } else if (((SMOP__p6opaque_struct*)invocant)->instanceof) {

        // re-dispatch to the instanceof
        SMOP__Object* super = ((SMOP__p6opaque_struct*)invocant)->instanceof;
        smop_lowlevel_unlock(invocant);

        if (set) {
          fprintf(stderr, "[SMOP p6opaque] Can't set how on a instance\n");
        } else {

          ret = SMOP__NATIVE__bool_true;
          SMOP__Object* frame;
          SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                                     SMOP__ID__continuation, SMOP_REFERENCE(interpreter,interpreter));
          frame = q:sm0p {
            $continuation;
            $super.$SMOP__ID__REPR_how();
            SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(2,(1),(),1));
            $continuation.setr();
            $interpreter.goto(|$continuation);
          };

          SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                        SMOP__ID__goto,
                        frame);
        }

      } else if (set) {
        // create the metadata struct and set the how.
        SMOP__p6opaque_LOWL_metadata* m = calloc(1,sizeof(SMOP__p6opaque_LOWL_metadata));
        assert(m);
        m->how = set;
        ((SMOP__p6opaque_struct*)invocant)->metadata = m;
        smop_lowlevel_unlock(invocant);

        ret = SMOP_REFERENCE(interpreter, set);
      } else {
        smop_lowlevel_unlock(invocant);
        fprintf(stderr,"[SMOP p6opaque] TODO: invalid .^!how call\n");
        ret = SMOP__NATIVE__bool_false;
      }
    }

    if (set) SMOP_RELEASE(interpreter,set);
    SMOP_RELEASE(interpreter,invocant);
  } else {
    fprintf(stderr,"[SMOP p6opaque] TODO: non-native captures\n");
    ret = SMOP__NATIVE__bool_false;
  }

  return ret;
}

static SMOP__Object* p6opaque_message_REPR_DESTROY(SMOP__Object* interpreter,
                                                   SMOP__ResponderInterface* self,
                                                   SMOP__Object* identifier,
                                                   SMOP__Object* capture) {
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
  if (SMOP_RI(capture) == (SMOP__ResponderInterface*)SMOP__NATIVE__capture) {
    SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter,capture);

    if (invocant == SMOP__p6opaque__RI) {
      ret = SMOP__NATIVE__bool_false;
    } else if (SMOP_RI(invocant) != (SMOP__ResponderInterface*)SMOP__p6opaque__RI) {
      fprintf(stderr, "[SMOP p6opaque] call .^!DESTROY method with non p6opaque invocant\n");
      ret = SMOP__NATIVE__bool_false;
    } else {
      smop_lowlevel_wrlock(invocant);
      SMOP__p6opaque_LOWL_metadata* m = ((SMOP__p6opaque_struct*)invocant)->metadata;
      ((SMOP__p6opaque_struct*)invocant)->metadata = NULL;
      smop_lowlevel_unlock(invocant);
      if (m) {
        if (m->how) SMOP_RELEASE(interpreter,m->how);
        free(m);
      }
    }

    SMOP_RELEASE(interpreter,invocant);
  } else {
    fprintf(stderr, "[SMOP p6opaque] TODO: non-native captures\n");
  }
  return ret;
}


static SMOP__Object* p6opaque_message_DESTROYALL(SMOP__Object* interpreter,
                                                 SMOP__ResponderInterface* self,
                                                 SMOP__Object* identifier,
                                                 SMOP__Object* capture) {
  SMOP__Object* ret = SMOP__NATIVE__bool_true;
  SMOP__Object* frame;
  SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                             SMOP__ID__continuation, 
                                             SMOP_REFERENCE(interpreter,interpreter));

  frame = q:sm0p {
    $capture; #
    $identifier; #
    $capture.$SMOP__ID__invocant(); #
    $SMOP__SLIME__CurrentFrame.copy(1); #
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(1,(),(),1));
    $SMOP__p6opaque__RI.$SMOP__ID__REPR_how(); #
    $SMOP__SLIME__CurrentFrame.$SMOP__ID__copy(1); #
    $SMOP__SLIME__CurrentFrame.$SMOP__ID__move_responder(2,2);
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(2,(6,7,8),(),1));
    $SMOP__NATIVE__bool_true.$SMOP__ID__dispatch();
    $capture.$SMOP__ID__invocant(); #
    $SMOP__SLIME__CurrentFrame.$SMOP__ID__move_responder(1,3);
    $capture.$SMOP__ID__invocant(); #
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(1,(),(),1));
    $SMOP__p6opaque__RI.$SMOP__ID__REPR_DESTROY();
    $SMOP__SLIME__CurrentFrame.$SMOP__ID__forget();
    $interpreter.goto(|$continuation);
  };

  SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                SMOP__ID__goto,
                frame);
  return ret;
}

static SMOP__Object* p6opaque_message_DISPATCH(SMOP__Object* interpreter,
                                               SMOP__ResponderInterface* self,
                                               SMOP__Object* identifier,
                                               SMOP__Object* capture) {
  // as we want to support different captures, we'll start to use a
  // sm0p frame in here, to use the capture as high-level and not as
  // low-level
  SMOP__Object* ret = SMOP__NATIVE__bool_true;
  SMOP__Object* frame;
  SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                             SMOP__ID__continuation, 
                                             SMOP_REFERENCE(interpreter,interpreter));
  frame = q:sm0p {
    $capture; #
    $identifier; # 
    $capture.$SMOP__ID__invocant(); #
    $SMOP__SLIME__CurrentFrame.copy(1); #
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(1,(),(),1));
    $SMOP__p6opaque__RI.$SMOP__ID__REPR_how(); #
    $SMOP__SLIME__CurrentFrame.copy(1); #
    $SMOP__SLIME__CurrentFrame.move_responder(2,2);
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(2,(6,7,8),(),1));
    $SMOP__NATIVE__bool_true.$SMOP__ID__dispatch(); #
    $continuation; #
    SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(1,(2),(),1));
    $continuation.$SMOP__ID__setr();
    $SMOP__SLIME__CurrentFrame.$SMOP__ID__forget();
    $interpreter.goto(|$continuation);
  };
  SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                SMOP__ID__goto,
                frame);

  return ret;
}

static SMOP__Object* p6opaque_message_REPR_methods(SMOP__Object* interpreter,
                                                   SMOP__ResponderInterface* self,
                                                   SMOP__Object* identifier,
                                                   SMOP__Object* capture) {
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
  if (SMOP_RI(capture) == (SMOP__ResponderInterface*)SMOP__NATIVE__capture) {

    SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter,capture);

    if (invocant == SMOP__p6opaque__RI ||
        SMOP_RI(invocant) != (SMOP__ResponderInterface*)SMOP__p6opaque__RI) {
      fprintf(stderr, "[SMOP p6opaque] call to .^!methods with non p6opaque invocant\n");
      ret = SMOP__NATIVE__bool_false;

    } else {
      // create the proxy array to the p6opaque object methods.
      ret = p6opaque_methods_array_create(interpreter, invocant);

    }

    SMOP_RELEASE(interpreter,invocant);
  } else {
    fprintf(stderr, "[SMOP p6opaque] TODO: non-native captures\n");
  }
  return ret;
}

static SMOP__Object* p6opaque_message(SMOP__Object* interpreter,
                                      SMOP__ResponderInterface* self,
                                      SMOP__Object* identifier,
                                      SMOP__Object* capture) {
  SMOP__Object* ret = SMOP__NATIVE__bool_false;

  if (identifier == SMOP__ID__REPR_CREATE) {
    ret = p6opaque_message_REPR_CREATE(interpreter, self, identifier, capture);

  } else if (identifier == SMOP__ID__REPR_how) {
    ret = p6opaque_message_REPR_how(interpreter, self, identifier, capture);

  } else if (identifier == SMOP__ID__REPR_DESTROY) {
    ret = p6opaque_message_REPR_DESTROY(interpreter, self, identifier, capture);

  } else if (identifier == SMOP__ID__REPR_methods) {
    ret = p6opaque_message_REPR_methods(interpreter, self, identifier, capture);

  } else if (identifier == SMOP__ID__DESTROYALL) {
    ret = p6opaque_message_DESTROYALL(interpreter, self, identifier, capture);

  } else {
    ret = p6opaque_message_DISPATCH(interpreter, self, identifier, capture);
  }

  SMOP_RELEASE(interpreter,capture);
  return ret;
}

static SMOP__Object* p6opaque_reference(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__RI != obj) {
    smop_lowlevel_refcnt_inc(interpreter, responder, obj);
  }
  return obj;
}

static SMOP__Object* p6opaque_release(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__RI != obj) {
    smop_lowlevel_refcnt_dec(interpreter, responder, obj);
  }
  return obj;
}



void smop_p6opaque_init() {

  SMOP__p6opaque__RI = calloc(1,sizeof(SMOP__ResponderInterface));
  assert(SMOP__p6opaque__RI);
  ((SMOP__ResponderInterface*)SMOP__p6opaque__RI)->MESSAGE = p6opaque_message;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__RI)->REFERENCE = p6opaque_reference;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__RI)->RELEASE = p6opaque_release;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__RI)->id = "p6opaque";

  p6opaque_methods_init();

}

void smop_p6opaque_destr() {

  p6opaque_methods_destr();

  free(SMOP__p6opaque__RI);

}
