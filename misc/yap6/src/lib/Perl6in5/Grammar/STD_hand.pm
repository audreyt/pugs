package Perl6in5::Grammar::STD_hand;

use warnings;
use strict;

use base 'Exporter';
our @EXPORT = qw ( make_parser );

#use Perl6in5::Compiler::Trace; # set env var TRACE for trace output

# isa Perl6in5::Grammar someday (to inherit some of the common features below)

use Perl6in5::Grammar;
use Perl6in5::Compiler::Stream ':all';
use Perl6in5::Compiler::Parser ':all';
use Perl6in5::Compiler::Lexer ':all';

use Data::Dumper;
#$Data::Dumper::Indent = 0;
#$Data::Dumper::Terse = 1;
#$Data::Dumper::Useqq = 1;
#$Data::Dumper::Quotekeys = 0;
#$Data::Dumper::Deparse = 1;

no warnings qw{ reserved closure recursion };

sub make_parser {
    
    my $input = shift;

    # <sigh> these "predeclaration" need to be autogenerated someday, somehow
    my ($base, $expr, $factor, $program, $term, $sVari, $stringLit, $declare,
        $usev6, $comma, $stmtList, $newline, $blkBare, $blkPrmbl, $nbexpr,
        $blkType, $blkRetT, $blkModf, $stmtTrm, $scpDecl, $block, $arg,
        $blkPrm, $compUnit, $flowCtrl, $blkLabl, $clype, $impor, $assign,
        $op_numaddt, $blkTrait, $pkgDecl, $arrowInv, $prmDecl, $vsblty,
        $invcDecl, $func_say, $bareInt, $identifier, $bareString, $blkPrms,
        $condBlk
    );

    my $Op_numaddt         = parser { $op_numaddt      ->(@_) };
    sub op_numaddt () { $Op_numaddt };
    my $Nbexpr             = parser { $nbexpr          ->(@_) };
    sub nbexpr () { $Nbexpr };
    my $Clype              = parser { $clype           ->(@_) };
    sub clype () { $Clype };
    my $Declare            = parser { $declare         ->(@_) };
    sub declare () { $Declare };
    my $Assign             = parser { $assign          ->(@_) };
    sub assign () { $Assign };
    my $Impor              = parser { $impor           ->(@_) };
    sub impor () { $Impor };
    my $Base               = parser { $base            ->(@_) };
    sub base () { $Base };
    my $Expr               = parser { $expr            ->(@_) };
    sub expr () { $Expr };
    my $Factor             = parser { $factor          ->(@_) };
    sub factor () { $Factor };
    my $Program            = parser { $program         ->(@_) };
    sub program () { $Program };
    my $Term               = parser { $term            ->(@_) };
    sub term () { $Term };
    my $SVari              = parser { $sVari           ->(@_) };
    sub sVari () { $SVari };
    my $StringLit          = parser { $stringLit       ->(@_) };
    sub stringLit () { $StringLit };
    my $Usev6              = parser { $usev6           ->(@_) };
    sub usev6 () { $Usev6 };
    my $Comma              = parser { $comma           ->(@_) };
    sub comma () { $Comma };
    my $StmtList           = parser { $stmtList        ->(@_) };
    sub stmtList () { $StmtList };
    my $BlkBare            = parser { $blkBare         ->(@_) };
    sub blkBare () { $BlkBare };
    my $BlkPrmbl           = parser { $blkPrmbl        ->(@_) };
    sub blkPrmbl () { $BlkPrmbl };
    my $BlkType            = parser { $blkType         ->(@_) };
    sub blkType () { $BlkType };
    my $BlkRetT            = parser { $blkRetT         ->(@_) };
    sub blkRetT () { $BlkRetT };
    my $BlkModf            = parser { $blkModf         ->(@_) };
    sub blkModf () { $BlkModf };
    my $StmtTrm            = parser { $stmtTrm         ->(@_) };
    sub stmtTrm () { $StmtTrm };
    my $ScpDecl            = parser { $scpDecl         ->(@_) };
    sub scpDecl () { $ScpDecl };
    my $Block              = parser { $block           ->(@_) };
    sub block () { $Block };
    my $Arg                = parser { $arg             ->(@_) };
    sub arg () { $Arg };
    my $BlkPrms            = parser { $blkPrms         ->(@_) };
    sub blkPrms () { $BlkPrms };
    my $FlowCtrl           = parser { $flowCtrl        ->(@_) };
    sub flowCtrl () { $FlowCtrl };
    my $BlkLabl            = parser { $blkLabl         ->(@_) };
    sub blkLabl () { $BlkLabl };
    my $CompUnit           = parser { $compUnit        ->(@_) };
    sub compUnit () { $CompUnit };
    my $BlkTrait           = parser { $blkTrait        ->(@_) };
    sub blkTrait () { $BlkTrait };
    my $PkgDecl            = parser { $pkgDecl         ->(@_) };
    sub pkgDecl () { $PkgDecl };
    my $ArrowInv           = parser { $arrowInv        ->(@_) };
    sub arrowInv () { $ArrowInv };
    my $PrmDecl            = parser { $prmDecl         ->(@_) };
    sub prmDecl () { $PrmDecl };
    my $Vsblty             = parser { $vsblty          ->(@_) };
    sub vsblty () { $Vsblty };
    my $InvcDecl           = parser { $invcDecl        ->(@_) };
    sub invcDecl () { $InvcDecl };
    my $Func_say           = parser { $func_say        ->(@_) };
    sub func_say () { $Func_say };
    my $BareInt           = parser { $bareInt        ->(@_) };
    sub bareInt () { $BareInt };
    my $Identifier           = parser { $identifier        ->(@_) };
    sub identifier () { $Identifier };
    my $BareString           = parser { $bareString        ->(@_) };
    sub bareString () { $BareString };
    my $CondBlk           = parser { $condBlk        ->(@_) };
    sub condBlk () { $CondBlk };

    # these hash keys are coderef (addresses)
    %N = (
        $Expr             => 'Expr',
        $Term             => 'Term',
        $Factor           => 'Factor',
        $Base             => 'Base',
        $Program          => 'Program',
        $ScpDecl          => 'ScpDecl',
        $SVari            => 'SVari',
        $StringLit        => 'StringLit',
        $Usev6            => 'Usev6',
        $Comma            => 'Comma',
        $StmtList         => 'StmtList',
        $BlkBare          => 'BlkBare',
        $BlkPrmbl         => 'BlkPrmbl',
        $BlkType          => 'BlkType',
        $BlkRetT          => 'BlkRetT',
        $BlkModf          => 'BlkModf',
        $StmtTrm          => 'StmtTrm',
        $Block            => 'Block',
        $Arg              => 'Arg',
        $BlkPrms          => 'BlkPrms',
        $FlowCtrl         => 'FlowCtrl',
        $BlkLabl          => 'BlkLabl',
        $CompUnit         => 'CompUnit',
        $Clype            => 'Class/Type',
        $Impor            => 'Import',
        $Assign           => 'Assign',
        $Nbexpr           => 'Nbexpr',
        $Declare          => 'Declare',
        $Op_numaddt       => 'Op_numaddt',
        $BlkTrait         => 'BlkTrait',
        $PkgDecl          => 'PkgDecl',
        $ArrowInv         => 'ArrowInv',
        $PrmDecl          => 'PrmDecl',
        $Vsblty           => 'Vsblty',
        $InvcDecl         => 'InvcDecl',
        $Func_say         => 'Func_say',
        $BareInt          => 'BareInt',
        $Identifier       => 'Identifier',
        $BareString       => 'BareString',
        $CondBlk          => 'CondBlk'
    );

    my @compUnits    = qw{ eval PRE POST ENTER LEAVE KEEP UNDO FIRST 
                         LAST BEGIN END INIT CHECK UNITCHECK };
    my @blkTypes     = qw{ sub method submethod regex token rule
                         macro module class package grammar};
    my @bareFuncs    = qw{ use no say };
    
    #   Rule Writing

    # The identifier of each of your rules must begin with a lowercase letter,
    # so that the source filter can transform/generate the grammar properly.

    rule program {
            # everything must start with a use v6; statement until
            # the perl5zone rule is operational.
            opt(-(usev6)
          - opt(stmtTrm
          - opt(pkgDecl)
          - opt(stmtList)))
    };

    rule pkgDecl {
            keyword('package') + identifier - stmtTrm;
    };

    rule usev6 {
            keyword('use') + keywords(qw{ v6 Perl-6 })
          | keyword('module') + opt(keyword('Main'))
          | keywords(qw{ class v6.0.0 v6 6 })
    };

    rule identifier {
            match( qr|^([A-Za-z_]\w*)| )
    };

    rule bareInt {
            match( qr|^(\d+)| )
    };

    rule sVari {
            '$' . identifier
    };

    rule comma {
            ','
    };

    rule stmtList {
           -(opt(stmtTrm)) - (   block . opt(( stmtTrm | -(hit("\n"))) . opt(stmtList))
              | nbexpr . opt(      stmtTrm          . opt(stmtList) )
            )
    };

    rule bareString {
      #  w('""',star(unmore('"'))) | w("''",star(unmore("'") . identifier))
    };

    rule nbexpr {
              one(panic(pkgDecl,
                "Can't declare a non-block package")
              , func_say
              , w('()',expr)
              , op_numaddt
              , assign
              , declare
              , impor
              , blkTrait
     #         , bareString
              , sVari
              , match( qr/^(\d+)/ )
              )
    };

    rule func_say {
            keyword('say') + expr
    };

    rule blkBare {
            w("{}",opt(stmtList))
    };

    rule block {
            opt(blkPrmbl) - blkBare
    };

    rule blkPrmbl {
            one(opt(blkModf)
            # this is an example of sometimes having to enumerate various
            # possiblities during a sequence of variously optional terms
            # in order to force the obtaining of the appropriate token set
            # (because of overlap of the patterns)
            # blkType is the only required term in the block preamble
          . (+scpDecl + (clype + blkType | blkType) | +blkType )
          . opt(+(opt('^') . identifier)) . opt(+(vsblty)) . opt(+(w('()',opt(blkPrms))))
          . opt(+(blkTrait))
          , compUnit
          , flowCtrl
          , blkLabl
          , arrowInv . opt(-',' - blkPrms))
    };

    rule arrowInv {
            hit('<-') - prmDecl
    };

    rule blkTrait {
            plus(-(keywords(qw{ is does has }) + prmDecl))
    };

    rule impor {
            keywords(qw{ no use require module class }) + identifier . opt(+nbexpr)
    };

    rule flowCtrl {
            keywords(qw{ loop do while until })
    };

    rule condBlk { # Until I die, I would cry unless unless/until were included.
            # if unless elsif else 
    };

    rule compUnit {
            keywords( @compUnits )
    };

    rule blkType {
            keywords( @blkTypes )
    };

    rule blkRetT {
            clype
    };

    rule clype {
            identifier  # just take any class/type name for now :)
            #  $Clype    # Class/Type
    };

    rule blkLabl {
            identifier . ':';
    };

    rule blkModf {
            keywords(qw{ multi proto only })
    };

    rule arg {
            'h'  #obviously this is just a stub.
    };

    # block parameter declaration
    rule blkPrms {
            opt(invcDecl) . plus(-(comma) - prmDecl)
    };
    
    # invocant declaration
    rule invcDecl {
            prmDecl . ':'
    };

    rule prmDecl {
            sVari
          | clype + sVari
    };

    rule vsblty {
            keywords(qw{ public private })
    };

    rule stmtTrm {
            plus(-';')
    };

    rule scpDecl {
            keywords(qw{ my our })
    };

    rule expr {
            block
          | nbexpr
    };

    rule declare {
            scpDecl + prmDecl
          | keywords(qw{ module class grammar }) + clype
    };

    rule assign {
            (prmDecl | scpDecl + prmDecl)
            - '=' - expr
    };

    rule op_numaddt {
            term
          - star('+' - term
               | '-' - term)
    };

    rule term {
            factor - star('*' - factor | '/' - factor )
    };

    rule factor {
            expr - opt(hit('**') - factor)
    };

    sub {
        my $r = (program->($input,eoi));
        unless ($r->{success}) {
            my $msg;
            if (ceoi($r)) {
                $msg = "incomplete statement near the end of input";
            } else {
                $msg = "syntax error (or degenerate/incomplete grammar) at line ".($r->{line}+1)." col ".$r->{col}." near ".(sprintf '%.50s', Dumper(left($r))).($r->{expected}?"\nExpected: ".Dumper($r->{expected}).".":'');
            }
            print STDERR $msg."\n".Dumper($r);
            return 255;
        } else {
            print "parse successful in $stat{rulecalls} rule executions.\n:".Dumper($r)."\n";
            return 0;
        }
    }
}

1;