grammar Perl-6.0.0-STD;          # (XXX maybe should be -PROTO or some such)

# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via
# the following comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to $/ within the action block, so we need not mention it explicitly.

rule TOP { <compunit> {*} }                             #= TOP

# Built-in or autogenerated rules:
#      <EXPR>: the operator precedence parser
#  <CATEGORY>: the rule matching any valid category names
#       <foo>: all tokens of foo category |-ed together

# Categories are designed to be extensible in derived grammars.

category variable_prefix_sigil;
category variable_prefix_twigil;
category special_variable;

category term;
category quote;
category prefix;
category infix;
category postfix;
category circumfix     is parsed(/<KEY0> <*> <KEY1>/);
category postcircumfix is parsed(/<*postcircumfix>/);

category regex_metachar;
category regex_backslash;
category regex_assertion;
category regex_mod_internal;
category regex_mod_external;

category trait_verb         is parsed(/<KEY> \s+ <nofat> /);
category trait_auxiliary    is parsed(/<KEY> \s+ <nofat> /);

category type_declarator    is parsed(/<KEY> \b <nofat> /);
category scope_declarator   is parsed(/<KEY> \b <nofat> /);
category routine_declarator is parsed(/<KEY> \b <nofat> /);
category statement_prefix   is parsed(/<KEY> \b <nofat> /);
category statement_control  is parsed(/<KEY> \s <nofat> /);
category statement_modifier is parsed(/<KEY> \b <nofat> /);

category infix_prefix_meta_operator;
category infix_postfix_meta_operator;
category postfix_prefix_meta_operator;
category prefix_postfix_meta_operator;
category infix_circumfix_meta_operator;
category prefix_circumfix_meta_operator;

# Lexical routines

regex nofat { <!before \h* <?unsp> <'=>'> > }

token ws {
    || <?after \w> <?before \w> ::: <fail>        # must \s+ between words
    || [
       | <unsp>              {*}                        #= ws unsp
       | \v                  {*}                        #= ws vwhite
       | <unv>               {*}                        #= ws unv
       ]*  {*}                                          #= ws all
}

token unsp {
    \\ <?before [\s|\#]>
    [
    | \v                     {*}                        #= unsp vwhite
    | <unv>                  {*}                        #= unsp unv
    ]*  {*}                                             #= unsp all
}

token unv {
       | \h+                 {*}                        #= unv hwhite
       | ^^ [
            | \# \N*         {*}                        #= unv comment line
            | <?pod_comment> {*}                        #= unv comment pod
            ]
       | \# [
            # assuming <bracketed> defaults to standard set
            | <?bracketed>   {*}                        #= unv comment inline
            | \N*            {*}                        #= unv comment end
            ]
}

# XXX We need to parse the pod eventually to support $= variables.

token pod_comment {
    ^^ =
    [
    | begin <?ws> <ident> .*? \n
      =end <?ws> $<ident> \N* \n?                   {*} #= pod block
    | \N* \n?                                       {*} #= pod misc
    ]
                                                    {*} #= pod comment
}

# Top-level rules

rule comp_unit {
    ^
    [ <type_declarator> <module_name> <traits> ; ]?
    <statement_list>
    [ $ || <panic: Parse terminated early> ]
                                                    {*} #= comp_unit
}

rule block {
    \{
    <statement_list>
    [ \} || <panic: Missing right brace> ]
                                                    {*} #= block
}

rule statement_list {
    <statement>*
                                                    {*} #= statement_list
}

rule statement {
    <label>*
    [
    | <statement_control>
    | <block>
    | <EXPR> <statement_modifier>?
    ]
}

rule statement_control:<use> {
    <module_name_wild> <EXPR>? ;?                      {*} #= sc use
}

rule statement_control:<if> {
    <EXPR>                           {*}                #= sc if expr
    <block>                          {*}                #= sc if block
    @<elsif> := [ elsif <EXPR>       {*}                #= sc if elsif expr
                        <block>      {*} ]*             #= sc if elsif block
    @<else> := [ else <block>        {*} ]?             #= sc if else
                                                        {*} #= sc if
}

rule statement_control:<unless> {
    <EXPR>                           {*}                #= sc unless expr
    <block>                          {*}                #= sc unless block
                                                        {*} #= sc unless
}

rule statement_control:<while> {
    <EXPR>                             {*}                #= sc while expr
    <block>                            {*}                #= sc while block
                                                          {*} #= sc while
}

rule statement_control:<until> {
    <EXPR>                             {*}                #= sc until expr
    <block>                            {*}                #= sc until block
                                                          {*} #= sc until
}
rule statement_control:<repeat> {
    [
        | (while|until) <EXPR>         {*}              #= sc repeat wu expr
          <block>                      {*}              #= sc repeat wu block
        | <block>                      {*}              #= sc repeat block wu
          (while|until) <EXPR>         {*}              #= sc repeat expr wu
    ]
                                                          {*} #= sc repeat
}
rule statement_control:<loop> {
    $<eee> := [
        \(
            $<e1> := <EXPR> ;   {*}                     #= sc loop e1
            $<e2> := <EXPR> ;   {*}                     #= sc loop e2
            $<e3> := <EXPR>     {*}                     #= sc loop e3
        \)                      {*}                     #= sc loop eee
    ]?
    <block>                     {*}                     #= sc loop block
                                                        {*} #= sc loop
}

rule statement_control:<for>     { <block> {*} }        #= sc for
rule statement_control:<when>    { <block> {*} }        #= sc when
rule statement_control:<BEGIN>   { <block> {*} }        #= sc BEGIN
rule statement_control:<CHECK>   { <block> {*} }        #= sc CHECK
rule statement_control:<INIT>    { <block> {*} }        #= sc INIT
rule statement_control:<END>     { <block> {*} }        #= sc END
rule statement_control:<START>   { <block> {*} }        #= sc START
rule statement_control:<ENTER>   { <block> {*} }        #= sc ENTER
rule statement_control:<LEAVE>   { <block> {*} }        #= sc LEAVE
rule statement_control:<KEEP>    { <block> {*} }        #= sc KEEP
rule statement_control:<UNDO>    { <block> {*} }        #= sc UNDO
rule statement_control:<FIRST>   { <block> {*} }        #= sc FIRST
rule statement_control:<NEXT>    { <block> {*} }        #= sc NEXT
rule statement_control:<LAST>    { <block> {*} }        #= sc LAST
rule statement_control:<PRE>     { <block> {*} }        #= sc PRE
rule statement_control:<POST>    { <block> {*} }        #= sc POST
rule statement_control:<CATCH>   { <block> {*} }        #= sc CATCH
rule statement_control:<CONTROL> { <block> {*} }        #= sc CONTROL

token statement_control { %statement_control }

rule modifier_expr { <EXPR> ;? {*} }              #= modifier_expr

rule statement_modifier:<if>     { <modifier_expr> {*} };        #= sm if
rule statement_modifier:<unless> { <modifier_expr> {*} };    #= sm unless
rule statement_modifier:<for>    { <modifier_expr> {*} };       #= sm for
rule statement_modifier:<given>  { <modifier_expr> {*} };     #= sm for
rule statement_modifier:<hen>    { <modifier_expr> {*} };     #= sm for
rule statement_modifier:<while>  { <modifier_expr> {*} };     #= sm while
rule statement_modifier:<until>  { <modifier_expr> {*} };     #= sm until

our @namedomain = <
    perl6
    perl5
    parrot
    ruby
    python
    tcl
    js
    scheme
    lisp
    haskell
    java
    c
    c++
    c#
    ada
    lua
    php
>;

regex namedomain { @namedomain \: }

token module_name {
    <name>
    [- <version>
        [-
            <authority>
        ]?
    ]?
                                                    {*} #= module_name
}

token authority { <-[ \s ; { ]>+ }

token module_name_wild {
    <namedomain>?
    <name>
    [- <version_wild>
        [-
            <authority_wild>
        ]?
    ]?
                                                    {*} #= usename
}

token version_wild   { <block> | <whatever> | <version> }
token authority_wild { <block> | <whatever> | <authority> }

token whatever ::= &term:<*>;                   # XXX possible?

token version {
    | v \d+ [ \. \d+ ]*                 {*}             #= version vstyle
    | \d+ \. \d+ \. \d+ [ \. \d+]*      {*}             #= version dotted
}

###################################################

token expect_term {
    [
    | <term>
    | <quote>
    | <prefix>
    | <circumfix>
    | <scope_declarator>
    | <routine_declarator>
    | <statement_prefix>
    | <statement_modifier>    # hidden if 1st term
    | <prefix_postfix_meta_operator>
    | <prefix_circumfix_meta_operator>
    | <variable>
    | <number>
    | <integer>
#    | <listop>         # XXX should be in prefix?
    ]
    <expect_postfix>*
}

token expect_infix {
    | <infix>
    | <trait_verb>
    | <trait_auxiliary>
    | <statement_modifier>
    | <infix_prefix_meta_operator>
    | <infix_circumfix_meta_operator>
}

token expect_postfix {
    [
    | \\ <?before \.>
    | <?unsp>
    | <null>
    ]

    [ [\. <?unsp>?]? <postfix_prefix_meta_operator> <?unsp>? ]?

    [
    | $<dot> := [ \. <[+*?=^:]> ] <methodop>
    | $<dot> := [ \.]             <methodop>
    | $<dot> := [ \.]             <postop>
    |                             <postop>
    ]
                                                    {*} #= postfix
}

token postfix:<++> { {*} }                              #= postfix incr
token postfix:<--> { {*} }                              #= postfix decr

token postcircumfix:<( )> { \( <EXPR> \) {*} }    #= postcircumfix ( )

token postcircumfix:<[ ]> { \[ <EXPR> \] {*} }    #= postcircumfix [ ]

token postcircumfix:<{ }> { \{ <EXPR> \} {*} }    #= postcircumfix { }
token postcircumfix:{'<','>'} { \< <anglewords> \>
                                                    {*} #= postcircumfix < >
}

token postcircumfix:{'<<','>>'} { \< <shellwords> \>
                                                    {*} #= postcircumfix << >>
}

token postcircumfix:<« »> { \< <shellwords> \> {*} }    #= postcircumfix « »

token postop { <postfix> | <postcircumfix> }

token dot {
    (
    | \\ <?before \.>
    | <?unsp>
    )
    (\. [\>\>|»] )?
    \. (<[= * + ?]> <?unsp>? <?before \w>)?
                                                    {*} #= dot
}

token methodop {
    <ident>
    [
    | \.? \( <EXPR> \)
    | \: <?before \s> <listop_expr>
    | <null>
    ]
}

# XXX how do we handle differences on non-standard prefix precedences?
token prefix: is equiv(&prefix:<print>) { <ident> [ <listop_expr> ]? }

token circumfix:<( )>     { \( <EXPR> \) {*} }         #= circumfix ( )
token circumfix:<[ ]>     { \[ <EXPR> \] {*} }         #= circumfix [ ]
token circumfix:{'<','>'} { \< <anglewords> \> {*} }   #= circumfix < >
token circumfix:<{ }>     {    <block>         {*} }   #= circumfix { }
token circumfix:{'<<','>>'} { \< <shellwords> \> {*} } #= circumfix << >>
token circumfix:<« »>     { \< <shellwords> \> {*} }   #= circumfix « »

rule scoped_variables {
    <scope_declarator> <variable>
}

token scope_declarator:<my>  { <null> {*} }     #= sd my
token scope_declarator:<our> { <null> {*} }     #= sd our

token type_declarator:<class>   { <null> {*} }  #= td class
token type_declarator:<grammar> { <null> {*} }  #= td grammar
token type_declarator:<module>  { <null> {*} }  #= td module
token type_declarator:<role>    { <null> {*} }  #= td role
token type_declarator:<package> { <null> {*} }  #= td package

token type_block {
    <scope_declarator>?
    <type_declarator>
    <module_name>?
    <traits>
    <block>
}

token special_variable:<$!> { <null> {*} }
token special_variable:<$/> { <null> {*} }

token variable {
    | <special_variable>
    | <sigiltwigil> <name>
    | <package> <'::'> <hashpostfix>
}

token sigiltwigil {
    <variable_prefix_sigil>
    <variable_prefix_twigil>            # note: can be empty
}

token variable_prefix_sigil:<$>  { <null> {*} }               #= sigil $
token variable_prefix_sigil:<@>  { <null> {*} }               #= sigil @
token variable_prefix_sigil:<@@> { <null> {*} }               #= sigil @@
token variable_prefix_sigil:<%>  { <null> {*} }               #= sigil %
token variable_prefix_sigil:<&>  { <null> {*} }               #= sigil &
token variable_prefix_sigil:<::> { <null> {*} }               #= sigil ::

token variable_prefix_twigil:<.> { <null> {*} }               #= twigil .
token variable_prefix_twigil:<!> { <null> {*} }               #= twigil !
token variable_prefix_twigil:<^> { <null> {*} }               #= twigil ^
token variable_prefix_twigil:<*> { <null> {*} }               #= twigil *
token variable_prefix_twigil:<+> { <null> {*} }               #= twigil +
token variable_prefix_twigil:<?> { <null> {*} }               #= twigil ?
token variable_prefix_twigil:<=> { <null> {*} }               #= twigil =
token variable_prefix_twigil:<> { <null> {*} }                #= twigil empty

token name {
    | <ident> [ <'::'> <ident> ]*
    | [ <'::'> <ident> ]+
}

token subname {
    | <name>
    | <CATEGORY> \: <hashpostfix>
}

token integer {
    | 0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]*
        ]
    | \d+[_\d+]*
}

token number {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
}

token quote_term {
    |    $<KEY>:=[']    <quote_expr> '
    |    $<KEY>:=["]    <quote_expr> "
    |    $<KEY>:=[\<\<] <quote_expr> \>\>
    |    $<KEY>:=[\<]   <quote_expr> \>
}

##  rules for parsing interpolated values in quotes.
##  FIXME: We're repeating the $<postfix> portion here
##  because there's apparently an aliasing bug in PGE.
##  The first part of the rule handles non-scalar
##  interpolation (which must end with a postcircumfix operator);
##  the second part handles scalar interpolation.
token quote_interpolation {
    | <![$]> ::: <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )+
    | <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )*
}


## Subroutine parsing.  This is still under development.

rule subroutine {
    <scope_declarator>?
        [ <routine_modifier> <routine_type>? | <routine_type> ]
        <ident>?
        <traits>
        [\( <signature> \)]?
        <block>}

rule subintro { <routine_modifier> <routine_type>? | <routine_type> }

token routine_modifier { multi | proto }

token routine_declarator:<sub>
token routine_declarator:<method>
token routine_declarator:<submethod>
token routine_declarator:<macro>
token routine_declarator:<regex>
token routine_declarator:<token>
token routine_declarator:<rule>

token type { <routine_type> ::: <fail> | <ident> }

rule trait { <trait_verb> | <trait_auxiliary> }

token trait_auxiliary:<is>   { <ident>[\( <EXPR> \)]? }
token trait_auxiliary:<will> { <ident> <block> }
token trait_verb:<of> { <type> }
token trait_verb:<returns> { <type> }

rule signature {
    $<invocant> := (<parameter> <':'>)?
    $<paramlist> := (<parameter>? [, <parameter>]*)
    [ <'-->'> $<rettype>:=<type> ]?
}

token parameter {
    <slurp>
    <type>*
    [
    | \: <ident>? \(
      <sigiltwigil>  <ident>?
      \)
    | <sigiltwigil>  <ident>?
    ]
    <where>*
    <default_value>
}

rule statement_prefix:<do>      { <statement> }
rule statement_prefix:<try>     { <statement> }
rule statement_prefix:<gather>  { <statement> }
rule statement_prefix:<contend> { <statement> }
rule statement_prefix:<async>   { <statement> }
rule statement_prefix:<lazy>    { <statement> }

# The <panic: message> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

rule panic (Str $s) { <commit> <fail($s)> }

## vim: expandtab sw=4
