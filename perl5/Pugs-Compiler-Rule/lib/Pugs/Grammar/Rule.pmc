        package Pugs::Grammar::Rule;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Emitter::Rule::Perl5::Ratchet;
        our %rule_terms;

*pod_begin = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1738} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1738} ) or 1 )
        && (
          ( $pos < length($s) ? ++$pos || 1 : 0 )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
          && do {
            my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_begin
#Data::Bind->sub_signature( \&pod_begin, );
*pod_other = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1739} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'c' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'u' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 't' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1739} ) or 1 )
        && (
          ( $pos < length($s) ? ++$pos || 1 : 0 )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
          && do {
            my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_other
#Data::Bind->sub_signature( \&pod_other, );
*ws = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1740} = $pos or 1 )
        && (
          (
            (
                ( substr( $s, $pos, 1 ) eq '#' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
              $bool = 1;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1740} ) or 1 )
          && (
            (
              ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
              : 0
            )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  (
                    ( $pad{I1741} = $pos or 1 )
                    && (
                      (
                        (
                          ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                        && (
                          ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                          $bool = 1;
                        }
                        && do {
                          while ( ( $pos < length($s) ? ++$pos || 1 : 0 ) ) { }
                          $bool = 1;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
              || ( $bool = 1 )
            )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1740} ) or 1 )
          && (
              ( substr( $s, $pos ) =~ m/^\s/s )
            ? ( $pos += length($&) or 1 )
            : 0
          )
        )
      )
      && do {
        while (
          (
            ( $pad{I1740} = $pos or 1 )
            && (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '#' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                  $bool = 1;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1740} ) or 1 )
              && (
                (
                  ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      (
                        ( $pad{I1741} = $pos or 1 )
                        && (
                          (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            && (
                              ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                              $bool = 1;
                            }
                            && do {
                              while ( ( $pos < length($s) ? ++$pos || 1 : 0 ) ) { }
                              $bool = 1;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1741} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1740} ) or 1 )
              && (
                  ( substr( $s, $pos ) =~ m/^\s/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
            )
          )
          )
        {
        }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ws
#Data::Bind->sub_signature( \&ws, );
*ident = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1742} = $pos or 1 )
        && (
          (
            ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 )
          && (
            ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
            : 0
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 )
          && (
            ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 )
            : 0
          )
        )
      )
      && do {
        while ( ( ( $pad{I1742} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 ) && ( ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 ) : 0 ) ) ) ) { }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ident
#Data::Bind->sub_signature( \&ident, );
*capturing_group = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
          ( substr( $s, $pos, 1 ) eq '(' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && do {
        my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'rule'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && (
          ( substr( $s, $pos, 1 ) eq ')' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { capturing_group => $_[0]{'rule'}(), } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for capturing_group
#Data::Bind->sub_signature( \&capturing_group, );
*non_capturing_group = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
          ( substr( $s, $pos, 1 ) eq '[' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && do {
        my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'rule'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && (
          ( substr( $s, $pos, 1 ) eq ']' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return $_[0]{'rule'}() }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for non_capturing_group
#Data::Bind->sub_signature( \&non_capturing_group, );
*literal = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        while ( ( ( $pad{I1743} = $pos or 1 ) && ( ( ( ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 ) : 0 ) && ( $pos < length($s) ? ++$pos || 1 : 0 ) ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1743} ) or 1 ) && ( ( substr( $s, $pos ) =~ m/^[^\']/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) ) ) { }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for literal
#Data::Bind->sub_signature( \&literal, );
*metasyntax = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          ( $pad{I1744} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && ( $pos < length($s) ? ++$pos || 1 : 0 )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
            && (
              ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
              : 0
            )
          )
        )
        && do {
          while (
            (
              ( $pad{I1744} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && ( $pos < length($s) ? ++$pos || 1 : 0 )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1744} ) or 1 )
                && (
                  ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
              )
            )
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { metasyntax => $_[0](), } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for metasyntax
#Data::Bind->sub_signature( \&metasyntax, );
*code = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          ( $pad{I1745} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && ( $pos < length($s) ? ++$pos || 1 : 0 )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
            && (
              ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
              : 0
            )
          )
        )
        && do {
          while (
            (
              ( $pad{I1745} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && ( $pos < length($s) ? ++$pos || 1 : 0 )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1745} ) or 1 )
                && (
                  ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
              )
            )
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { code => $_[0](), } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for code
#Data::Bind->sub_signature( \&code, );
*named_capture_body = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1746} = $pos or 1 )
      && (
        (
          do {
            my $match = $grammar->capturing_group( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'capturing_group'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub { return { rule => $_[0]{'capturing_group'}(), } }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1746} ) or 1 )
        && (
          do {
            my $match = $grammar->non_capturing_group( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'non_capturing_group'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub { return { rule => $_[0]{'non_capturing_group'}(), } }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1746} ) or 1 )
        && (
          (
              ( substr( $s, $pos, 1 ) eq '<' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'metasyntax'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
              ( substr( $s, $pos, 1 ) eq '>' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub { return { rule => $_[0]{'metasyntax'}(), } }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1746} ) or 1 )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          sub { die "invalid alias syntax" }
            ->($m);
          $::_V6_SUCCEED;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for named_capture_body
#Data::Bind->sub_signature( \&named_capture_body, );
%rule_terms = (
  '(' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq ')' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub { return { capturing_group => $_[0]{'rule'}(), } }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<after' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub {
              return { after => { rule => $_[0]{'rule'}(), }, };
              }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub {
              return { before => { rule => $_[0]{'rule'}(), }, };
              }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub {
              return { not_before => { rule => $_[0]{'rule'}(), }, };
              }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub {
              return { negate => { rule => $_[0]{'rule'}(), }, };
              }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'metasyntax'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub { return $_[0]{'metasyntax'}() }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'ident'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
          || ( $bool = 1 )
        )
        && (
            ( substr( $s, $pos, 2 ) eq ':=' )
          ? ( $pos += 2 or 1 )
          : 0
        )
        && (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
          || ( $bool = 1 )
        )
        && do {
          my $match = $grammar->named_capture_body( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'named_capture_body'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub {
              use v5;
              my $body = $_[0]{'named_capture_body'}();
              $body->{'ident'} = $_[0]{'ident'}();
              return { named_capture => $body, };

              # use v6

              }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1747} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { match_variable => '$' . $_[0](), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1747} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1748} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1748} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1748} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1748} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1748} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1748} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { variable => '$' . $_[0]->(), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1747} ) or 1 )
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub { return { colon => '$', } }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '@' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1749} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { match_variable => '@' . $_[0](), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1749} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1750} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1750} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1750} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1750} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1750} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1750} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { variable => '@' . $_[0]->(), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '%' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1751} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { match_variable => '%' . $_[0](), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1751} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1752} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1752} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              local $::_V6_SUCCEED = 1;
              $::_V6_MATCH_ = $m;
              $m->data->{capture} = \(
                sub { return { variable => '%' . $_[0]->(), } }
                  ->($m)
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '{' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'code'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '}' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub { return { closure => '{' . $_[0]->(), } }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '\\' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pos < length($s) ? ++$pos || 1 : 0 )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub { return { special_char => '\\' . $_[0]->(), } }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '.' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { 'dot' => 1, } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '[' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq ']' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          local $::_V6_SUCCEED = 1;
          $::_V6_MATCH_ = $m;
          $m->data->{capture} = \(
            sub { return $_[0]{'rule'}() }
              ->($m)
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => ':::', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':?' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => ':?', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':+' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => ':+', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => '::', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => ':', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => '$$', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => '^^', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub { return { colon => '^', } }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  }
);
*term = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1753} = $pos or 1 )
      && (
        (
          do {
            my $match = do {
              our $I1754;
              our $I1754_sizes;
              unless ($I1754) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1754_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1754 = $hash;
              }
              my $match = 0;
              my $key;
              for (@$I1754_sizes) {
                $key = (
                  $pos <= length($s)
                  ? substr( $s, $pos, $_ )
                  : ''
                );
                if ( exists $I1754->{$key} ) {
                  $match = Pugs::Emitter::Rule::Perl5::Ratchet::preprocess_hash( $I1754, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => {} }, undef );
                  last if $match;
                }
              }
              if ($match) {
                $pos = $match->to;

                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
              }
              ;    # else { $bool = 0 }
              $match;
            };
            if ($match) {
              $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub {

                # 866fed751b1f8640360319b983786df0d4ac1fcf
                return $_[0]{'Pugs::Grammar::Rule::rule_terms'}();
                }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1753} ) or 1 )
        && (
          (
              ( substr( $s, $pos ) =~ m/^[^\]\}\)\>\:\?\+\*\|\&]/s )
            ? ( $pos += length($&) or 1 )
            : 0
          )
          && do {
            local $::_V6_SUCCEED = 1;
            $::_V6_MATCH_ = $m;
            $m->data->{capture} = \(
              sub {

                # a5e78f733699b205ec8d236e795916bdccf2b461
                return { 'constant' => $_[0]->(), };
                }
                ->($m)
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for term
#Data::Bind->sub_signature( \&term, );
*quantifier = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws1'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $pos1 = $pos;
        do {
          my $pos  = $pos1;
          my $from = $pos;
          my @match;
          my %named;
          my $bool = 1;
          $bool = 0
            unless (
              ( substr( $s, $pos ) =~ m/^[\}\]\)\>]/s )
            ? ( $pos += length($&) or 1 )
            : 0
            );
          !$bool;
        };
      }
      && do {
        my $match = $grammar->term( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'term'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws2'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  (
                    (
                      ( substr( $s, $pos ) =~ m/^[\?\*\+]/s ) ? ( $pos += length($&) or 1 )
                      : 0
                    )
                    || ( $bool = 1 )
                  )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq '?' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    || ( $bool = 1 )
                  )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'quant'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws3'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub {
            return {
              quant => {
                term  => $_[0]{'term'}(),
                quant => $_[0]{'quant'}(),
                ws1   => $_[0]{'ws1'}(),
                ws2   => $_[0]{'ws2'}(),
                ws3   => $_[0]{'ws3'}(),
              }
            };
            }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for quantifier
#Data::Bind->sub_signature( \&quantifier, );
*concat = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        do {
          my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            push @{ $named{'quantifier'} }, $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          while (
            do {
              my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                push @{ $named{'quantifier'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub {
            use v5;
            my @a = map { $_->() } @{ $::_V6_MATCH_->{'quantifier'} };
            return { concat => \@a, } if scalar @a > 1;
            return $a[0];

            # use v6

            }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for concat
#Data::Bind->sub_signature( \&concat, );
*rule = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          (
            do {
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && (
              ( substr( $s, $pos, 1 ) eq '|' )
            ? ( $pos += 1 or 1 )
            : 0
          )
        )
        || ( $bool = 1 )
      )
      && do {
        my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          push @{ $named{'concat'} }, $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        while (
          (
            (
                ( substr( $s, $pos, 1 ) eq '|' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                push @{ $named{'concat'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
          )
          )
        {
        }
        $bool = 1;
      }
      && do {
        local $::_V6_SUCCEED = 1;
        $::_V6_MATCH_ = $m;
        $m->data->{capture} = \(
          sub {
            use v5;
            my @a = map { $_->() } @{ $::_V6_MATCH_->{'concat'} };
            return { alt => \@a, } if scalar @a > 1;
            return $a[0];

            # use v6

            }
            ->($m)
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for rule
#Data::Bind->sub_signature( \&rule, );

1;
