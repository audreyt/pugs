#!/usr/bin/perl
use strict;

use XML::Parser;
use Term::ANSIColor qw(:constants);
use Attribute::Handlers;
use Data::Dumper;
my $parser = new XML::Parser();
my %context = (choice=>0,atomify=>0);
my %atomic = ();
$parser->setHandlers(
	Char=>sub {
		my ($expat,$string) = @_;	
		return if $string =~ /^\s*$/;
		return if $context{description};
		print quotemeta($string);
	},
	Start=>sub {
		my ($expat,$element,%attrs) = @_;	
		$element =~ s/^g://;
		unless (defined $main::{$element}) {
			warn "no $element";
			return;
		}
		if ($context{choice}>0) {
			print "|" unless $context{first_choice};
			$context{first_choice} = 0 if $context{first_choice};
		}
		if ($context{atomify}>0 and !$atomic{$element}) {
			print "[";
		}
		no strict 'refs';

		&{$element};
	},
	End=>sub {
		my ($expat,$element,%attrs) = @_;	
		$element =~ s/^g://;
		unless (defined $main::{$element."_"}) {
			warn "no ${element}_";
			return;
		}

		no strict 'refs';
		&{$element."_"};

		if ($context{atomify}>0 and !$atomic{$element}) {
			print "]";
		}
	},
	Comment=>sub {}
);
$parser->parsefile(shift);

sub closed :ATTR {
	no strict 'refs';
	my ($package,$symbol) = @_;
	my $name = *{$symbol}{NAME} . "_";
	*{$name} = sub {};
}
sub atom :ATTR {
	no strict 'refs';
	my ($package,$symbol) = @_;
	my $name = *{$symbol}{NAME};
	$atomic{$name} = 1;
}

sub token {
	my ($expat,$name,%attr) = @_;
	print "#token\nrule $attr{name} {"
}
sub token_  {
	my ($expat,$name,%attr) = @_;
	print "}\n"
}
sub production {
	my ($expat,$name,%attr) = @_;
	print "#production\nrule $attr{name} {"
}
sub production_  {
	my ($expat,$name,%attr) = @_;
	print "}\n"
}
sub ignore {
	for (@_) {
		print "ignoring: $_";
		$main::{$_} = sub {};
		$main::{$_ . "_"} = sub {};
	}
}


## atoms
sub ref :closed :atom {
	my ($expat,$name,%attr) = @_;
	print "<$attr{name}>";
} 
sub string :atom {
}
sub string_ {
}

### control flow
sub choice {
	$context{choice}++;
	$context{first_choice} = 1;
}
sub choice_ {
	$context{choice}--;
}
sub sequence :atom {
	$context{choice}--;
}
sub sequence_  {
	$context{choice}++;
}
sub zeroOrMore {
	$context{atomify}++;
	print ""
}
sub zeroOrMore_ {
	$context{atomify}--;
	print "*"
}
sub oneOrMore {
	$context{atomify}++;
	print ""
}
sub oneOrMore_ {
	$context{atomify}--;
	print "+"
}
sub optional {
	$context{atomify}++;
	print ""
}
sub optional_ {
	$context{atomify}--;
	print "?"
}

sub optionalSkip :atom :closed {print " <S>* "}
sub requiredSkip :atom :closed {print " <S>+ "}

## character classes
INIT { ignore qw(char charRange charClass charCodeRange charCode) }

## things I don't understand and/or don't know how to translate 
sub description {
	$context{description}++;
}
sub description_ {
	$context{description}--;
}
INIT { ignore qw(tref transition state-list level postfix) }

=for later
}

### charackter classes
sub close_bracket {
	warn "\t\tclosing bracket:$_[0]";
	print "]" if $context{open_bracket};
}
sub open_bracket {
	print "[" unless $context{open_bracket};
	$context{open_bracket}++;
}
sub charRange {
	my ($expat,$name,%attr) = @_;
	close_bracket();
	print "[$attr{minChar}..$attr{maxChar}]";
}
sub charClass {
	$context{charClass}++;
	print "<"
}
sub charClass_ {
	close_bracket();
	$context{charClass}--;
	print ">"
}
sub char {
	if ($context{charClass}) {
		open_bracket;
	} else {
		print "<'";
	}
}
sub char_ {
	print "'>" unless $context{charClass};
}
### XXX: complete those

sub charCode {}
sub charCode_ {}
sub charCodeRange {}
sub charCodeRange_ {}

sub char {}
sub char_ {}
