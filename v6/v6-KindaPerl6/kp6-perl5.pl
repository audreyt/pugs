package main;

use lib '../v6-MiniPerl6/lib5', 'lib5';
use strict;

BEGIN {
    $::_V6_COMPILER_NAME    = 'KindaPerl6';
    $::_V6_COMPILER_VERSION = '0.001';
}

use KindaPerl6::Perl5::Runtime;
#use KindaPerl6::Perl5::Pad;
#use KindaPerl6::Perl5::Match;

package Main;
use KindaPerl6::Grammar;

use KindaPerl6::Traverse;
#use KindaPerl6::Visitor::LexicalSub;
use KindaPerl6::Visitor::Perl;
use KindaPerl6::Visitor::EmitPerl5;
use KindaPerl6::Visitor::MetaClass;
#use KindaPerl6::Visitor::CreateEnv;

use KindaPerl6::Grammar::Regex;
use KindaPerl6::Emitter::Token;

use Getopt::Long;
my ($dumpast, $perl5);
GetOptions(
    'ast'	=> \$dumpast,
    'perl5'	=> \$perl5,
    );
$perl5 = 1 unless $dumpast;

my $source = join('', <> );
my $pos = 0;

if ($perl5) {
    say( "# Do not edit this file - Generated by " . $::_V6_COMPILER_NAME );
    say( "use v5;" );
    say( "use strict;" );
    say( "no strict 'vars';" );
    say( "use KindaPerl6::Perl5::Runtime;" );
}

#my $visitor_lexical_sub = KindaPerl6::Visitor::LexicalSub->new();
my $visitor_dump_ast    = KindaPerl6::Visitor::Perl->new();
my $visitor_emit_perl5  = KindaPerl6::Visitor::EmitPerl5->new();
my $visitor_metamodel   = KindaPerl6::Visitor::MetaClass->new();
#my $visitor_create_env  = KindaPerl6::Visitor::CreateEnv->new();

use Data::Dump::Streamer;

{
    package COMPILER;
    use Data::Dumper;

    # @COMPILER::CHECK  - CHECK blocks
    # @COMPILER::PAD    - Pad structures
    # @COMPILER::BEGIN_RUNTIME - runtime side-effects of BEGIN blocks

    sub env_init {
        @COMPILER::PAD = (Pad->new( 
            outer     => undef, 
            lexicals  => [ ],  
            namespace => 'Main',
        ));
        $List_COMPILER::PAD = \@COMPILER::PAD;   # for mp6 compatibility
    }
    
    sub add_pad {
        unshift @COMPILER::PAD, Pad->new( 
            outer     => $COMPILER::PAD[0], 
            lexicals  => [ ], 
            namespace => $_[0],  # optional
        ); 
    }
    
    sub drop_pad {
        shift @COMPILER::PAD;
    }
     
    #    $PAD[0]->add_lexicals( [ $decl ] );
    #    $PAD[0]->eval( $p5_source );

    sub begin_block {
        # this routine is called by begin-blocks at compile time, in order to execute the code
        # Input: '::Lit::Code' AST node
        
        #print "PARAM: ",Dumper(\@_);
        #my $env = shift;
        my @ast = ( shift );

        #print Dump( @ast );
        #@ast = map { $_->emit( $visitor_lexical_sub )     } @ast;
        @ast = map { $_->emit( $visitor_metamodel )       } @ast;
        #@ast = map { $_->emit( $visitor_create_env )      } @ast;
        
        #print Dump( @ast );
        #say( join( ";\n", (map { $_->emit( $visitor_dump_ast    ) } @ast )));
        my $native = join( ";\n", (map { $_->emit( $visitor_emit_perl5  ) } @ast ));
    
        # execute the native code inside the current pad
        add_pad;
        my $data = $COMPILER::PAD[0]->eval( $native );  # XXX - want() context
        drop_pad;
        die "At BEGIN: " . $@ if $@;
        #print "RETURN DATA: ", Dumper($data);

        # check for side-effects
        my @begin_stmts;

        #print "=pod\n";
        #print "BEGIN ENV: ", Dumper( $env->lexicals ), "\n";
        #print "BEGIN AST: ", Dumper( \@ast );
        #print "BEGIN: Native code: $native\n\n";

        for my $pad ( @COMPILER::PAD ) {
          my $side_effects = $pad->eval( '\%_MODIFIED' ); 
          #print "MODIFIED: ", Dumper( $side_effects );
          # TODO - emit side-effects...
          my @names = keys %$side_effects;
          for my $name ( @names ) {
            my $value = $COMPILER::PAD[0]->eval( "\\$name" );
            # TODO - convert directly DATA->AST, instead of DATA->PERL->AST
            #print "BEGIN SIDE-EFFECT: $name = ",${$value}->perl," \n\n";
            # TODO - convert $$value to perl6 AST
            my $p = KindaPerl6::Grammar->exp( "$name = " . ${$value}->perl , 0);
            #print "AST: ", Dumper($$p);
            # TODO - check for shared data (BIND)
            push @begin_stmts, $$p;
          }
        }
        # TODO - emit the runtime BEGIN code 
        add_pad;
        my $initializer_name = 'Main::INIT_' . int(rand(100000));
        my $begin_ast = Sub->new(
            name  => $initializer_name,
            block => Lit::Code->new(
                sig   => Sig->new(
                                     'named' => {},
                                     'invocant' => undef,
                                     'positional' => []
                                 ),
                body  => \@begin_stmts,
                pad   => $COMPILER::PAD[0], 
                state => {},
            ),
        );
        drop_pad;
        #print "BEGIN AST: ",Dumper($begin_ast);
        #print "BEGIN native: ", join( ";\n", (map { $_->emit( $visitor_emit_perl5  ) } ($begin_ast) ));
        
        #print "\n";
        #print "=cut\n";
        
        # TODO - XXX - ignore 'CODE' for now
        #return if ref($data) eq 'CODE';
    
        # - convert the data to ast
        my $source = $data->perl;
        #print "# begin - result data: $source\n";
        my $p = KindaPerl6::Grammar->exp($source, 0);
        #say( Main::perl( $$p ) );
        add_pad;
        my $final_ast = Do->new(
                'block' => Lit::Code->new(
                    pad   => $COMPILER::PAD[0],
                    state => { },
                    sig   => Sig->new( 'invocant' => undef, 'positional' => [ ], 'named' => { } ),
                    body  => [ $begin_ast, $$p ],
                ),
        );
        drop_pad;
        #print "FINAL AST: ",Dumper($final_ast); 
        #print "FINAL native: ", join( ";\n", (map { $_->emit( $visitor_emit_perl5  ) } ($final_ast) ));

        # create the runtime initializer
        # @COMPILER::BEGIN_RUNTIME
        # TODO
        push @COMPILER::BEGIN_RUNTIME, $initializer_name;

        return $final_ast;
    }

    sub check_block {
        # this routine saves check-blocks, in order to execute the code at the end of compilation
        
        my $ast = $_[0];
        my $pad = $COMPILER::PAD[0];
        #print "CHECK saved\n";
        push @COMPILER::CHECK, [ $ast, $pad ];
        return Val::Undef->new();
    }

    sub get_var {
        # this routine is called each time a variable is parsed.
        # it checks for proper pre-declaration
        my $var = Var->new( 'sigil' => $_[0], 'twigil' => $_[1], 'name' => $_[2] );
        my $decl = $COMPILER::PAD[0]->declaration( $var );
        #print "COMPILER::get_var: @_ --> $decl\n";
        # TODO - annotate the variable with: Type, declarator
        return $var;
    }

}

package Main;

COMPILER::env_init;
while ( $pos < length( $source ) ) {
    #say( "Source code:", $source );
    my $p = KindaPerl6::Grammar->comp_unit($source, $pos);
    #say( Main::perl( $$p ) );
    my @ast = $$p;
    
    #@ast = map { $_->emit( $visitor_lexical_sub )     } @ast;
    @ast = map { $_->emit( $visitor_metamodel )       } @ast;
    #@ast = map { $_->emit( $visitor_create_env )      } @ast;
    
    #print Dump( @ast );
    if ($dumpast) {
        say( join( ";\n", (map { $_->emit( $visitor_dump_ast    ) } @ast )));
    } elsif ($perl5) {
        say( join( ";\n", (map { $_->emit( $visitor_emit_perl5  ) } @ast )));
    }

    #say( $p->to, " -- ", length($source) );
    say( ";" );
    $pos = $p->to;
}
# emit CHECK blocks
for ( @COMPILER::CHECK ) { 
    my ( $ast, $pad ) = @$_;
    unshift @COMPILER::PAD, $pad;
    my @ast = COMPILER::begin_block( $ast );

    @ast = map { $_->emit( $visitor_metamodel )       } @ast;
    say( join( ";\n", (map { $_->emit( $visitor_emit_perl5  ) } @ast )));
    say( ";" );

    shift @COMPILER::PAD;
}
# TODO: emit from AST
# emit Runtime initializers
for ( @COMPILER::BEGIN_RUNTIME ) { 
    print "$_();\n";
}

say "1;";
