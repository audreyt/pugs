#!/usr/bin/perl
package SMOP::RI;
use warnings;
use strict;
use IO::Select;
use IO::Handle;
use IPC::Open3;
use Symbol;
require 'mangle.pl';


my ($base,$m0ld) = (shift @ARGV,shift @ARGV);
sub preprocess_m0ld {
    my $code = shift;
    #warn "got m0ld code <$code>\n";
    return preprocess($code,"$m0ld");
}
sub preprocess {
    my $code = shift;
    my ($writer, $reader, $error) = map { gensym } 1..3;
    my $pid = open3($writer, $reader, $error,@_) || die "$@";
    print {$writer} $code;
    close $writer;

    my ($errbuf, $retbuf) = ('','');

    $reader->blocking(0);
    $error->blocking(0);

    my $select = IO::Select->new();
    $select->add($reader);
    $select->add($error);

    while ($select->can_read(10000) && (!eof($reader) || !eof($error))) {

        my $buf = '';
        my $returncode = read $reader, $buf, 1024;
        $retbuf .= $buf;

        $buf = '';
        my $returncode2 = read $error, $buf, 1024;
        $errbuf .= $buf;

    }

    print $errbuf;
    close $reader;
    close $error;
    waitpid($pid,0);
    die join(' ',@_).' returned failure '.$? if ($? || !$retbuf || $retbuf eq "\n") ;
    return $retbuf;
}
sub mangle {
    my $id = shift;
    return 'ID__'.::mangle($id);
}

my @properties = qw(RI RI.id prefix include prototype);
my %properties;

my %methods;
my $method;

my %mold;
my $mold;

my %attrs;
my @getters;

my %raw;

sub debug {
}
while (my $line = <>) {
    if ($line =~ /^\%\s*(\w*)\s*\{\s*$/) {
         debug "raw.$1 start\n";
         $raw{$1} = '';
         until((my $raw_line = <>) =~ /^\%}\s*$/) {
             debug "raw $raw_line";
             $raw{$1} .= $raw_line;
         }
         debug "raw.R1 stop\n";
    } elsif ($method) {
        if ($line =~ /^%/) {
            undef $method;
            redo;
        } else {
            debug "in method $line";
            $methods{$method} .= $line;
            next;
        }
    } elsif ($mold) {
        if ($line =~ /^%/) {
            undef $mold;
            redo;
        } else {
            debug "in mold $line";
            $mold{$mold} .= $line;
            next;
        }
    } elsif ($line =~ /^%method\s*(.*)$/) {
        $method = $1;
        $methods{$method} = '';
        debug "method start:$method\n";
    } elsif ($line =~ /^%mold\s*(.*)$/) {
        $mold = $1;
        debug "mold start:$mold\n";
    } elsif ($line =~ /^%attr\s*(.*?)\s*(\S+)$/) {
        $attrs{$2} = $1;
    } elsif ($line =~ /^%getter\s*(\S+)$/) {
        push(@getters,$1);
    } elsif ($line =~ / ^\s*$ | ^\# | ^\/\/ /x) {
        debug "ws/comment:$line";
    } else {
        for my $property (@properties) {
            if ($line =~ /^% \s* \Q$property\E \s+ (.*)$/x) {
                $properties{$property} = $1;
                debug "prop $property = $1\n";
                goto FOUND;
            }
        }
        die "unrecognised line: $line";
        FOUND: ;
    } 
}

die "a %prefix is required\n" unless $properties{prefix};

print qq[/* generated by tools/ri - do not edit*/
#include <smop.h>
#include <smop_lowlevel.h>
#include <smop_s1p.h>
#include <stdlib.h>
#include <stdio.h>
#include <smop_mold.h>
];
for (split (/,/,$properties{include} || '')) {
    print "#include $_\n";
}

my $id = defined $properties{"RI.id"} ? $properties{"RI.id"} : "unknown RI";

if ($properties{prototype}) {
    print "SMOP__Object* $properties{prototype};\n";
}
if ($properties{RI}) {
    print "SMOP__Object* $properties{RI};\n";
} else {
    print "static SMOP__Object* RI;\n";
}
my $RI = $properties{RI} || 'RI';
my %declared_ids;
for (keys %methods) {
    next if $declared_ids{mangle($_)}++;
    print 'static SMOP__Object* ',mangle($_),";\n";
}
for (@getters) {
    next if $declared_ids{mangle($_)}++;
    print 'static SMOP__Object* ',mangle($_),";\n";
}
for (keys %mold) {
    print 'static SMOP__Object* ',$_,";\n";
}
print qq[
typedef struct $properties{prefix}_struct {
  SMOP__Object__BASE
];
while (my ($name,$type) = each %attrs) {
    print "  $type $name;\n";
}
print "} $properties{prefix}_struct;\n";

print $raw{''} || '';


for my $getter (@getters) {
    $methods{$getter} = qq[    smop_lowlevel_rdlock(invocant);
    ret = (($properties{prefix}_struct*)invocant)->$getter;
    smop_lowlevel_unlock(invocant);
    SMOP_REFERENCE(interpreter, ret);
];
}
print q[
static SMOP__Object* message(SMOP__Object* interpreter,
                                     SMOP__ResponderInterface* self,
                                     SMOP__Object* identifier,
                                     SMOP__Object* capture) {
];

print '  ';
if ($raw{message}) {
    print $raw{message};
} else {
print q[
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;
  SMOP__Object* invocant = (SMOP__Object*) SMOP__NATIVE__capture_invocant(interpreter, capture);
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
];
    while (my ($method,$body) = each %methods) {
        print "if (",mangle($method)," == identifier) {\n$body  } else ";
    }
    print qq[{
    ___UNKNOWN_METHOD___;
  }

  if (invocant) SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return ret;
    ];
}
print q[
}
];

print qq[
void $properties{prefix}_init() {
  $RI = SMOP__RI__create(
      message,
      smop_lowlevel_generic_reference,
      smop_lowlevel_generic_release,
      "$id");
];
print "  SMOP__Object* interpreter = SMOP__GlobalInterpreter;\n";
for (keys %methods) {
    print "  ",mangle($_)," = ","SMOP__NATIVE__idconst_create(\"$_\");\n";
}
while (my ($name,$mold) = each %mold) {
    print "  $name = ",preprocess_m0ld($mold),";\n";
}

if ($properties{prototype}) {
    print qq[
  $properties{prototype} = SMOP__Proto__create($RI);
];
}
print qq[ 
}

void $properties{prefix}_destr() {
];
#printf("$properties{prefix}_destr()\\n");
if ($properties{prototype}) {
    print qq[
     free($properties{prototype});
    ];
}
while (my ($name,$mold) = each %mold) {
    print "SMOP_RELEASE(SMOP__GlobalInterpreter,$name);\n";
}
print qq[
  free($RI);
}
];
print $raw{'bottom'} || '';
