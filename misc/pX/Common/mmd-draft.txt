Here is a zeroth-draft description of the new MMD algorithm for S06.


Multi(sub/method) Dispatch

A multi is a set of variants.  Each variant is a Code, with its own
Signature.  A normal call to a multi is handled by the variant whose
signature most tightly matches the call's arguments.  If no variant is
the unambiguous best fit, an error is raised.

Variants may have arbitrarily different signatures.  The first step in
dispatch is to check for compatibility with the call's arguments.  Any
variant whose signature is incompatable with the call is ignored.  The
second and final step is to choose among the compatible variants.
Named parameters, while checked for compatibility, do not currently
affect choice.

Positional parameters can be separated by commas, semicolons, or a
double semicolon (which may appear at most once, after all
semicolons).  Parameters separated by commas are "equally important".
Parameters after a semicolon are "less important" than those
preceeding it.  Parameters after a double semicolon are "unimportant",
incidental to choice.

The choice process consists of examining parameter positions,
individually, left to right, and filtering the set of contenders.
After all the positions are processed, if there is exactly one
contender left, then it is chosen.  Otherwise an ambiguity error is
raised.

Variants can be either a contender or noncontender, and either active
or inactive.  Four states.  Contender variants are contenders for
being chosen, noncontenders are not.  Active variants help disqualify,
that is filter, the remaining contenders. Inactive variants have no
further affect on contenders.  The choice process begins with all
compatible variants as active contenders.

At any position, a contender becomes a noncontender (of the same
activeness) if the type narrowness of its current parameter's type is
not at least as narrow as that of any other active variant's parameter
type.  So unabigious best fit is a sudden death competition against
all the still active variants, contender or noncontender.

At any position, an active variant becomes a inactive (of the same
contenderness) if it reaches a double semicolon.  As the variant's
later parameters are thus "unimportant", the variant "has nothing more
to say".  Inactive contenders wait passively, hoping not to be
disqualified by some active variant, until the process ends.  Inactive
noncontenders are irrelevant, entirely gone from the process.

There is also a second way to become inactive.  If all contenders
reach a semi-colon at the same time, any active noncontenders become
inactive.  Basically, the contender variants are of concensus that the
following parameters are less important than preceeding ones.  So the
noncontenders disqualified by the preceeding ones no longer have
anything interesting to say about the remaining parameters.  But a
single contender without a semicolon prevents any of this from
occuring.  It wants the contenders, including itself, to continue to
be subject to disqualification by the current noncontenders.  [The
effect continues even if the dissenter is itself disqualified at the
very next position.  The moment has been lost, and the other
contenders, which were themselves in agreement, nonetheless remain
subject to noncontenders they consider irrelevant.  Is this the right
thing?]

Concequently, if a variant is the only contender, and it reaches a
semicolon, single or double, it will be chosen.

Parameter types are compared by their relative type narrowness.  If
implicit type conversions were needed on the type compatibility path
between a parameter type and the argument type, then the parameter
with the fewest such conversions is narrower, and we are done.  If a
parameter type is all roles, then class Any is added.  Then we
recursively add all roles, superclasses, and subtypes.  All
anonyoumous subtypes ("where" clauses) are considered distinct.  We
now have the full set of the type constraints, which are all
conceptually predicates, implied by a parameter's type.  If one set is
a superset of the other, it is narrower (more constraints listed).
Identical sets are equivalent.  If neither is a superset, then the
roles are removed, and we try again.  This is so roles listed in the
parameter types, but not associated with a listed class, are still
comparable, and all equivalently narrow.  If there is still no
superset relation, then the parameter types are incomparable.  Neither
can then be contenders, because we can't say that either one is at
least as narrow as the other.  Junctive types are treated as their
narrowest alternative.

------------------------------------------------------------
Backstory and discussion:

