grammar Perl-6.0.0-STD;          # (XXX maybe should be -PROTO or some such)

# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via
# the following comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to $/ within the action block, so we need not mention it explicitly.

# This grammar also assumes transitive longest-token semantics, though
# we make a feeble attempt to order rules so a procedural | can usually
# produce a correct parse.

rule TOP { <compunit> {*} }                             #= TOP

# Built-in or autogenerated rules:
#      <EXPR>: the operator precedence parser
#  <CATEGORY>: the rule matching any valid category names
#       <foo>: all tokens of foo category |-ed together

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implmentation; they may change at any time.
# Users should only specify precedence in relation to existing levels.

my %term              ::= { :prec<z=>                           };
my %methodcall        ::= { :prec<v=>                           };
my %autoincrement     ::= { :prec<u=>, :assoc<non>, :lvalue     };
my %exponentiation    ::= { :prec<t=>, :assoc<right>            };
my %symbolic_unary    ::= { :prec<s=>                           };
my %multiplicative    ::= { :prec<r=>, :assoc<left>             };
my %additive          ::= { :prec<q=>, :assoc<left>             };
my %junctive_and      ::= { :prec<p=>, :assoc<list>             };
my %junctive_or       ::= { :prec<o=>, :assoc<list>             };
my %named_unary       ::= { :prec<n=>, :assoc<left>             };
my %nonchaining       ::= { :prec<m=>, :assoc<non>              };
my %chaining          ::= { :prec<l=>, :assoc<chain>            };
my %tight_and         ::= { :prec<k=>, :assoc<left>             };
my %tight_or          ::= { :prec<j=>, :assoc<left>             };
my %conditional       ::= { :prec<i=>, :assoc<right>            };
my %item_assignment   ::= { :prec<h=>, :assoc<right>, :lvalue   };
my %loose_unary       ::= { :prec<g=>, :assoc<right>            };
my %comma             ::= { :prec<f=>, :assoc<list>             };
my %list_infix        ::= { :prec<e=>                           };
my %list_prefix       ::= { :prec<d=>                           };
my %loose_and         ::= { :prec<c=>                           };
my %loose_or          ::= { :prec<b=>                           };
my %terminator        ::= { :prec<a=>, :assoc<list>             };

role Term {...}
role Methodcall {...}
role Autoincrement {...}
role Exponentiation {...}
role Symbolic_unary {...}
role Multiplicative {...}
role Additive {...}
role Junctive_and {...}
role Junctive_or {...}
role Named_unary {...}
role Nonchaining {...}
role Chaining {...}
role Tight_and {...}
role Tight_or {...}
role Conditional {...}
role Item_assignment {...}
role Loose_unary {...}
role Comma {...}
role List_infix {...}
role List_prefix {...}
role Loose_and {...}
role Loose_or {...}
role Terminator {...}

# Categories are designed to be extensible in derived grammars.

# Use of <*> calls into the appropriate rule for the token.
# The key is automatically skipped unless "reparsed" is used.
# In any case the default parse pattern is / <*> /, i.e. just call
# the particular token's subrule.

category noun_prefix_sigil;
category noun_prefix_twigil;
category special_variable;
category nameroot is parsed(/ \: <*> /);

category term;
category quote;
category prefix;
category infix;
category postfix;

category circumfix     is reparsed;
category postcircumfix is reparsed;

category regex_metachar;
category regex_backslash;
category regex_assertion;
category regex_mod_internal;
category regex_mod_external;

category trait_verb         is parsed(/ \s+ <nofat> <*> /);
category trait_auxiliary    is parsed(/ \s+ <nofat> <*> /);

category type_declarator    is parsed(/ \b <nofat> <*> /);
category scope_declarator   is parsed(/ \b <nofat> <*> /);
category routine_declarator is parsed(/ \b <nofat> <*> /);
category statement_prefix   is parsed(/ \b <nofat> <*> /);
category statement_control  is parsed(/ \s <nofat> <*> /);
category statement_cond     is parsed(/ \b <nofat> <*> /);
category statement_loop     is parsed(/ \b <nofat> <*> /);

category infix_prefix_meta_operator;
category infix_postfix_meta_operator;
category postfix_prefix_meta_operator;
category prefix_postfix_meta_operator;
category prefix_circumfix_meta_operator is reparsed;

# Lexical routines

regex nofat { <!before \h* <?unsp> <'=>'> > }

token ws {
    || <?after \w> <?before \w> ::: <fail>        # must \s+ between words
    || [
       | <unsp>              {*}                        #= ws unsp
       | \v                  {*}                        #= ws vwhite
       | <unv>               {*}                        #= ws unv
       ]*  {*}                                          #= ws all
}

token unsp {
    \\ <?before [\s|\#]>
    [
    | \v                     {*}                        #= unsp vwhite
    | <unv>                  {*}                        #= unsp unv
    ]*  {*}                                             #= unsp all
}

token unv {
       | \h+                 {*}                        #= unv hwhite
       | ^^ [
            | \# \N*         {*}                        #= unv comment line
            | <?pod_comment> {*}                        #= unv comment pod
            ]
       | \# [
            # assuming <bracketed> defaults to standard set
            | <?bracketed>   {*}                        #= unv comment inline
            | \N*            {*}                        #= unv comment end
            ]
}

# XXX We need to parse the pod eventually to support $= variables.

token pod_comment {
    ^^ =
    [
    | begin <?ws> <ident> .*? \n
      =end <?ws> $<ident> \N* \n?                   {*} #= pod block
    | \N* \n?                                       {*} #= pod misc
    ]
                                                    {*} #= pod comment
}

# Top-level rules

rule comp_unit {
    ^
    [ <type_declarator> <module_name> <trait>* ; ]?
    <statement_list>
    [ $ || <panic: Parse terminated early> ]
                                                    {*} #= comp_unit
}

rule block {
    \{
    <statement_list>
    [ \} || <panic: Missing right brace> ]
                                                    {*} #= block
}

rule statement_list {
    <statement>*
                                                    {*} #= statement_list
}

token label { <ident> \: \s <?ws> {*} }                 #= label

rule statement {
    <label>*                                     {*}    #= label
    [
    | <statement_control>                        {*}    #= statement control
    | <block>                                    {*}    #= statement block
    | <EXPR>                                     {*}    #= statement expr
        [<statement_cond> <EXPR> {*} ]?                 #= statement mod cond
        [<statement_loop> <EXPR> {*} ]?                 #= statement mod loop
    ]
                                                        {*} #= statement
}

rule statement_control {
    :<use>
    <module_name_wild> <EXPR>? ;?                       {*} #= sc use
}

rule statement_control {
    :<if>
    <EXPR>                           {*}                #= sc if expr
    <block>                          {*}                #= sc if block
    @<elsif> := [ elsif <EXPR>       {*}                #= sc if elsif expr
                        <block>      {*} ]*             #= sc if elsif block
    @<else> := [ else <block>        {*} ]?             #= sc if else
                                                        {*} #= sc if
}

rule statement_control {
    :<unless>
    <EXPR>                           {*}                #= sc unless expr
    <block>                          {*}                #= sc unless block
                                                        {*} #= sc unless
}

rule statement_control {
    :<while>
    <EXPR>                             {*}                #= sc while expr
    <block>                            {*}                #= sc while block
                                                          {*} #= sc while
}

rule statement_control {
    :<until>
    <EXPR>                             {*}                #= sc until expr
    <block>                            {*}                #= sc until block
                                                          {*} #= sc until
}
rule statement_control {
    :<repeat>
    [
        | (while|until) <EXPR>         {*}              #= sc repeat wu expr
          <block>                      {*}              #= sc repeat wu block
        | <block>                      {*}              #= sc repeat block wu
          (while|until) <EXPR>         {*}              #= sc repeat expr wu
    ]
                                                          {*} #= sc repeat
}
rule statement_control {
    :<loop>
    $<eee> := [
        \(
            $<e1> := <EXPR> ;   {*}                     #= sc loop e1
            $<e2> := <EXPR> ;   {*}                     #= sc loop e2
            $<e3> := <EXPR>     {*}                     #= sc loop e3
        \)                      {*}                     #= sc loop eee
    ]?
    <block>                     {*}                     #= sc loop block
                                                        {*} #= sc loop
}

rule statement_control { :<for>     <block> {*} }        #= sc for
rule statement_control { :<when>    <block> {*} }        #= sc when
rule statement_control { :<BEGIN>   <block> {*} }        #= sc BEGIN
rule statement_control { :<CHECK>   <block> {*} }        #= sc CHECK
rule statement_control { :<INIT>    <block> {*} }        #= sc INIT
rule statement_control { :<END>     <block> {*} }        #= sc END
rule statement_control { :<START>   <block> {*} }        #= sc START
rule statement_control { :<ENTER>   <block> {*} }        #= sc ENTER
rule statement_control { :<LEAVE>   <block> {*} }        #= sc LEAVE
rule statement_control { :<KEEP>    <block> {*} }        #= sc KEEP
rule statement_control { :<UNDO>    <block> {*} }        #= sc UNDO
rule statement_control { :<FIRST>   <block> {*} }        #= sc FIRST
rule statement_control { :<NEXT>    <block> {*} }        #= sc NEXT
rule statement_control { :<LAST>    <block> {*} }        #= sc LAST
rule statement_control { :<PRE>     <block> {*} }        #= sc PRE
rule statement_control { :<POST>    <block> {*} }        #= sc POST
rule statement_control { :<CATCH>   <block> {*} }        #= sc CATCH
rule statement_control { :<CONTROL> <block> {*} }        #= sc CONTROL

token statement_control { %statement_control }

rule modifier_expr { <EXPR> ;? {*} }                    #= modifier_expr

token statement_modifier { <statement_cond> | <statement_loop> }

rule statement_cond { :<if>     <modifier_expr> {*} };     #= scond if
rule statement_cond { :<unless> <modifier_expr> {*} };     #= scond unless
rule statement_cond { :<when>   <modifier_expr> {*} };     #= scond for

rule statement_loop { :<for>    <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<given>  <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<while>  <modifier_expr> {*} };     #= sloop while
rule statement_loop { :<until>  <modifier_expr> {*} };     #= sloop until

token nameroot { <'perl6'> }
token nameroot { <'perl5'> }
token nameroot { <'parrot'> }
token nameroot { <'ruby'> }
token nameroot { <'python'> }
token nameroot { <'tcl'> }
token nameroot { <'js'> }
token nameroot { <'scheme'> }
token nameroot { <'lisp'> }
token nameroot { <'haskell'> }
token nameroot { <'java'> }
token nameroot { <'c'> }
token nameroot { <'cplusplus'> }
token nameroot { <'csharp'> }
token nameroot { <'ada'> }
token nameroot { <'lua'> }
token nameroot { <'php'> }

token module_name {
    <name>
    [- <version>
        [-
            <authority>
        ]?
    ]?
                                                    {*} #= module_name
}

token authority { <-[ \s ; \{ ]>+ }

token module_name_wild {
    <nameroot>?
    <name>
    [- <version_wild>
        [-
            <authority_wild>
        ]?
    ]?
                                                    {*} #= usename
}

token version_wild   { <block> | <whatever> | <version> }
token authority_wild { <block> | <whatever> | <authority> }

token whatever { \* }

token version {
    | v \d+ [ \. \d+ ]*                 {*}             #= version vstyle
    | \d+ \. \d+ \. \d+ [ \. \d+]*      {*}             #= version dotted
}

###################################################

token expect_term {
    <?ws>

    [
        [
        | <prefix>                                      {*} #= Xterm prefix
        | <prefix_circumfix_meta_operator>              {*} #= Xterm precircum
        ]
        <prefix_postfix_meta_operator>*                 {*} #= Xterm prepost
    ]*

    <noun>                                              {*} #= Xterm noun
    <expect_postfix>*                                   {*} #= Xterm postfix
                                                        {*} #= Xterm
}

token noun {
    | <ident> <before \h* =\> >     # XXX sufficient in face of precedence?
    | <circumfix>
    | <type_block>
    | <variable>
    | <value>
    | <quote>
    | <term>
    | <scope_declarator>
    | <routine_declarator>
    | <statement_prefix>
}

token expect_infix {
    <?ws>
    <infix_prefix_meta_operator>*
    [
    | <infix>
    | <trait_verb>
    | <trait_auxiliary>
    | <statement_modifier>
    | <infix_prefix_meta_operator>
    | <infix_circumfix_meta_operator>
    ]
    <infix_postfix_meta_operator>*
                                                    {*} #= Xinfix
}

token dotty {
    | <'.+'>                                  {*}     #= dotty plus
    | <'.*'>                                  {*}     #= dotty star
    | <'.?'>                                  {*}     #= dotty query
    | <'.='>                                  {*}     #= dotty equals
    | <'.^'>                                  {*}     #= dotty caret
    | <'.:'>                                  {*}     #= dotty colon
    | <'.'>                                   {*}     #= dotty plain
}

token expect_postfix {
    [
    | \\ <?before \.>
    | <?unsp>
    | <null>
    ]

    [ [\. <?unsp>?]? <postfix_prefix_meta_operator> <?unsp>? ]*

    [
    | $<dot> := <dotty> <?unsp>? <methodop>
    | $<dot> := [ \.]   <?unsp>? <postop>
    |                            <postop>
    ]
                                                    {*} #= Xpostfix
}
token prefix_circumfix_meta_operator {
    :<[ ]>
    \[ <infix> \]                                    {*}  #= precircum square
}

token prefix_postfix_meta_operator { :<«>     {*} }  #= prepost hyper
token prefix_postfix_meta_operator { :['<<'] {*} }  #= prepost HYPER

token postfix_prefix_meta_operator { :<»>     {*} }  #= postpre hyper
token postfix_prefix_meta_operator { :['>>'] {*} }  #= postpre HYPER

token infix_prefix_meta_operator { :<!>     {*} }    #= inpre not
token infix_prefix_meta_operator { :<«>     {*} }    #= inpre hyper dwim
token infix_prefix_meta_operator { :<»>     {*} }    #= inpre hyper asis
token infix_prefix_meta_operator { :['<<'] {*} }    #= inpre HYPER dwim
token infix_prefix_meta_operator { :['>>'] {*} }    #= inpre HYPER asis

token infix_postfix_meta_operator { :<=>     {*} }   #= inpost assign
token infix_postfix_meta_operator { :<«>     {*} }   #= inpost hyper asis
token infix_postfix_meta_operator { :<»>     {*} }   #= inpost hyper dwim
token infix_postfix_meta_operator { :['<<']  {*} }   #= inpost HYPER asis
token infix_postfix_meta_operator { :['>>']  {*} }   #= inpost HYPER dwim

token postfix { :<++> {*} }                              #= postfix incr
token postfix { :<--> {*} }                              #= postfix decr

token postcircumfix { :<(> <EXPR> :<)> {*} }    #= postcircumfix ( )

token postcircumfix { :<[> <EXPR> :<]> {*} }    #= postcircumfix [ ]

token postcircumfix { :<{> <EXPR> :<}> {*} }    #= postcircumfix { }
token postcircumfix { :['<'] <anglewords> :['>']
                                                    {*} #= postcircumfix < >
}

token postcircumfix { :['<'] <shellwords> :['>']
                                                    {*} #= postcircumfix << >>
}

token postcircumfix { :<« »> \< <shellwords> \> {*} }    #= postcircumfix « »

token postop { <postfix> | <postcircumfix> }

token dot {
    (
    | \\ <?before \.>
    | <?unsp>
    )
    (\. [\>\>|»] )?
    \. (<[= * + ?]> <?unsp>? <?before \w>)?
                                                    {*} #= dot
}

token methodop {
    <ident>
    [
    | \.? \( <EXPR> \)
    | \: <?before \s> <listop_expr>
    | <null>
    ]
}

# XXX how do we handle differences on non-standard prefix precedences?
#token prefix: is equiv(&prefix:<print>) { <ident> [ <listop_expr> ]? }

token circumfix { :<(> <EXPR> :<)> {*} }         #= circumfix ( )
token circumfix { :<[> <EXPR> :<]> {*} }         #= circumfix [ ]
token circumfix { :['<']  <anglewords>  :['>'] {*} }   #= circumfix < >
token circumfix { :['<<'] <shellwords> :['>>'] {*} } #= circumfix << >>
token circumfix { :<«>    <shellwords> :<»>    {*} }   #= circumfix « »
token circumfix is Circumfix[:symbol<{ }>]
    { <block>         {*} }                        #= circumfix { }

rule scoped_variables {
    <scope_declarator> <variable>
}

token scope_declarator { :<my>   {*} }     #= sd my
token scope_declarator { :<our>  {*} }     #= sd our

token type_declarator { :<class>    {*} }  #= td class
token type_declarator { :<grammar>  {*} }  #= td grammar
token type_declarator { :<module>   {*} }  #= td module
token type_declarator { :<role>     {*} }  #= td role
token type_declarator { :<package>  {*} }  #= td package

token type_block {
    <scope_declarator>?
    <type_declarator>
    <module_name>?              # XXX maybe shouldn't have version/auth?
    <trait>*
    <block>
}

token special_variable { :<$!>  {*} }
token special_variable { :<$/>  {*} }

token variable {
    | <special_variable>
    | <sigiltwigil> <name>
    | <name> <'::'> <hashpostfix>
}

token sigiltwigil {
    <noun_prefix_sigil>
    <noun_prefix_twigil>?
}

token noun_prefix_sigil { :<$>   {*} }               #= sigil $
token noun_prefix_sigil { :<@>   {*} }               #= sigil @
token noun_prefix_sigil { :<@@>  {*} }               #= sigil @@
token noun_prefix_sigil { :<%>   {*} }               #= sigil %
token noun_prefix_sigil { :<&>   {*} }               #= sigil &
token noun_prefix_sigil { :<::>  {*} }               #= sigil ::

token noun_prefix_twigil { :<.>  {*} }               #= twigil .
token noun_prefix_twigil { :<!>  {*} }               #= twigil !
token noun_prefix_twigil { :<^>  {*} }               #= twigil ^
token noun_prefix_twigil { :<*>  {*} }               #= twigil *
token noun_prefix_twigil { :<+>  {*} }               #= twigil +
token noun_prefix_twigil { :<?>  {*} }               #= twigil ?
token noun_prefix_twigil { :<=>  {*} }               #= twigil =

token name {
    | <ident> <nofat> [ <'::'> <ident> ]*
    | [ <'::'> <ident> ]+
}

token subname {
    | <name>
    | <CATEGORY> \: <postcurcumfix>
}

token value {
    | <string>
    | <number>
    | <integer>
    | <version>
    | <typename>
}

regex typename {
    <name> <?{ is_type($<ident>) }>
}

token integer {
    | 0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]*
        ]
    | \d+[_\d+]*
}

token number {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
}

token quote_term {
    | ' <quote_expr> '
    | " <quote_expr> "
    | \<\< <quote_expr> \>\>
    | \<   <quote_expr> \>
}

##  rules for parsing interpolated values in quotes.
##  The first part of the rule handles non-scalar
##  interpolation (which must end with a postcircumfix operator);
##  the second part handles scalar interpolation.

token quote_interpolation {
    | <![$]> ::: <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )+
    | <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )*
}

rule subroutine {
    <scope_declarator>?
    <subintro>
    <ident>?
    <trait>*
    [\( <signature> \)]?
    <block>
}

rule subintro { <routine_modifier> <routine_type>? | <routine_type> }

token routine_modifier { multi | proto }

token routine_declarator { :<sub> }
token routine_declarator { :<method> }
token routine_declarator { :<submethod> }
token routine_declarator { :<macro> }
token routine_declarator { :<regex> }
token routine_declarator { :<token> }
token routine_declarator { :<rule> }

rule trait { <trait_verb> | <trait_auxiliary> }

token trait_auxiliary { :<is>   <ident>[\( <EXPR> \)]? }
token trait_auxiliary { :<will> <ident> <block> }

token trait_verb { :<of>        <type> }
token trait_verb { :<returns>   <type> }

rule signature {
    [<parameter> [ [ \, | \: | ; | ;; ] <parameter> ]* ]?
    [ <'-->'> <type> ]?
}

rule type_constraint {
    | <value>
    | <type_name>
    | where <subset>
}

token parameter {
    <slurp>?
    <type_constraint>*
    [
    | \: <ident>? \(
      <sigiltwigil>  <ident>?
      \)
    | <sigiltwigil>  <ident>?
    ]
    <default_value>
}

rule statement_prefix { :<do>      <statement> }
rule statement_prefix { :<try>     <statement> }
rule statement_prefix { :<gather>  <statement> }
rule statement_prefix { :<contend> <statement> }
rule statement_prefix { :<async>   <statement> }
rule statement_prefix { :<lazy>    <statement> }

## term
token term is Term[]
    { :<*> }

token circumfix is Term[]
    { :<( )> }

token postcircumfix is Term[] 
    is abstract('call')
    { :<( )> }

## autoincrement
token postfix is Autoincrement[]
    { :<++> }

token postfix is Autoincrement[]
    { :<--> }

token prefix is Autoincrement[]
    { :<++> }

token prefix is Autoincrement[]
    { :<--> }


## exponentiation
token infix is Exponentiate[]
    { :<**> }

## symbolic unary
token prefix is Symbolic_unary[]
    { :<!> }

token prefix is Symbolic_unary[]
    { :<+> }

token prefix is Symbolic_unary[]
    { :<-> }

token prefix is Symbolic_unary[]
    { :<~> }

token prefix is Symbolic_unary[]
    { :<?> }

token prefix is Symbolic_unary[]
    { :<=> }

token prefix is Symbolic_unary[]
    { :<*> }

token prefix is Symbolic_unary[]
    { :<**> }

token prefix is Symbolic_unary[]
    { :<~^> }

token prefix is Symbolic_unary[] 
    { :<+^> }

token prefix is Symbolic_unary[]
    { :<?^> }

token prefix is Symbolic_unary[]
    { :<^> }


## multiplicative
token infix is Multiplicative[]
    { :<*> }

token infix is Multiplicative[]
    { :</> }

token infix is Multiplicative[]
    { :<%> }

token infix is Multiplicative[]
    { :<x> }

token infix is Multiplicative[]
    { :<xx> }

token infix is Multiplicative[]
    { :<+&> }

token infix is Multiplicative[]
    { :['+<'] }

token infix is Multiplicative[]
    { :['+>'] }

token infix is Multiplicative[]
    { :<~&> }

token infix is Multiplicative[]
    { :['~<'] }

token infix is Multiplicative[]
    { :['~>'] }


## additive
token infix is Additive[]
    { :<+> }

token infix is Additive[]
    { :<-> }

token infix is Additive[]
    { :<~> }

token infix is Additive[]
    { :<+|> }

token infix is Additive[]
    { :<+^> }

token infix is Additive[]
    { :<~|> }

token infix is Additive[]
    { :<~^> }

token infix is Additive[]
    { :<?|> }

token infix is Additive[]
    { :<?^> }


## junctive and (all)
token infix is Junctive_and[]
    { :<&> }


## junctive or (any)
token infix is Junctive_or[]
    { :<|> }

token infix is Junctive_or[]
    { :<^> }


## named unary examples
token prefix is Named_unary[]
    { :<rand> }

token prefix is Named_unary[]
    { :<sleep> }

token prefix is Named_unary[]
    { :<abs> }

## nonchaining binary
token infix is Nonchaining[]
    { :['<=>'] }

token infix is Nonchaining[]
    { :<cmp> }

token infix is Nonchaining[]
    { :<is> }

token infix is Nonchaining[]
    { :<but> }

token infix is Nonchaining[]
    { :<does> }

token infix is Nonchaining[]
    { :<..> }

token infix is Nonchaining[]
    { :<^..> }

token infix is Nonchaining[]
    { :<..^> }

token infix is Nonchaining[]
    { :<^..^> }

token infix is Nonchaining[]
    { :<ff> }

token infix is Nonchaining[]
    { :<^ff> }

token infix is Nonchaining[]
    { :<ff^> }

token infix is Nonchaining[]
    { :<^ff^> }

token infix is Nonchaining[]
    { :<fff> }

token infix is Nonchaining[]
    { :<^fff> }

token infix is Nonchaining[]
    { :<fff^> }

token infix is Nonchaining[]
    { :<^fff^> }


## chaining binary
token infix is Chaining[]
    { :<==> }

token infix is Chaining[]
    { :<!=> }

token infix is Chaining[]
    { :['<'] }

token infix is Chaining[]
    { :['<='] }

token infix is Chaining[]
    { :['>'] }

token infix is Chaining[]
    { :['>='] }

token infix is Chaining[]
    { :<~~> }

token infix is Chaining[]
    { :<!~> }

token infix is Chaining[]
    { :<=~> }

token infix is Chaining[]
    { :<eq> }

token infix is Chaining[]
    { :<ne> }

token infix is Chaining[]
    { :<lt> }

token infix is Chaining[]
    { :<le> }

token infix is Chaining[]
    { :<gt> }

token infix is Chaining[]
    { :<ge> }

token infix is Chaining[]
    { :<=:=> }

token infix is Chaining[]
    { :<===> }


## tight and
token infix is Tight_and[]
    is abstract('if')
    { :<&&> }


## tight or
token infix is Tight_or[]
    is abstract('unless')
    { :<||> }

token infix is Tight_or[:assoc<list>]
    is assoc('list')
    is abstract('xor')
    { :<^^> }

token infix is Tight_or[]
    { :<//> }


## conditional
token infix is Conditional[]
    is abstract('if')
    { :<??> <EXPR(|%conditional> :<!!> }


## assignment
token infix is Assignment[]
    is abstract('assign')
    is lvalue(1)
    { :<=> }

token infix is Assignment[]
    is abstract('bind')
    { :<:=> }

token infix is Assignment[]
    { :<::=> }

token infix is Assignment[]
    { :<.=> }

token infix is Assignment[]
    { :<~=> }

token infix is Assignment[]
    { :<+=> }

token infix is Assignment[]
    { :<-=> }

token infix is Assignment[]
    { :<*=> }

token infix is Assignment[]
    { :</=> }

token infix is Assignment[]
    { :<%=> }

token infix is Assignment[]
    { :<x=> }

token infix is Assignment[]
    { :<Y=> }

token infix is Assignment[]
    { :<**=> }

token infix is Assignment[]
    { :<xx=> }

token infix is Assignment[]
    { :<||=> }

token infix is Assignment[]
    { :<&&=> }

token infix is Assignment[]
    { :<//=> }

token infix is Assignment[]
    { :<^^=> }

token infix is Assignment[]
    { :<+<=> }

token infix=> is Assignment[]
    { :<+> }

token infix is Assignment[]
    { :<+|=> }

token infix is Assignment[]
    { :<+&=> }

token infix is Assignment[]
    { :<+^=> }

token infix is Assignment[]
    { :<~|=> }

token infix is Assignment[]
    { :<~&=> }

token infix is Assignment[]
    { :<~^=> }

token infix is Assignment[]
    { :<?|=> }

token infix is Assignment[]
    { :<?&=> }

token infix is Assignment[]
    { :<?^=> }

token infix is Assignment[]
    { :<|=> }

token infix is Assignment[]
    { :<&=> }

token infix is Assignment[]
    { :<^=> }

## list item separator
token infix is Comma[]
    { :<,> }

## loose unary
token prefix is Loose_unary[]
    { :<true> }

token prefix is Loose_unary[]
    { :<not> }

## list prefix (really sub calls)
token prefix is List_prefix[]
    { :<print> }

## loose and
token infix is Loose_and[]
    is abstract('if')
    { :<and> }

## loose or
token infix is Loose_or[]
    is abstract('unless')
    { :<or> }

token infix is Loose_or[]
    is abstract('xor')
    { :<xor> }

token infix is Loose_or[]
    { :<err> }

## expression terminator

token terminator is Terminator[]
    { :<;> }                                # XXX correct to eat semicolon?

token terminator is Terminator[:symbol['<==']]
    { <before \<==> }

token terminator is Terminator[:symbol['==>']]
    { <?before :['==>'] > }

token terminator is Terminator[:symbol<)>]
    { <?before :<)> > }

token terminator is Terminator[:symbol<]>]
    { <?before \] > }

token terminator is Terminator[:symbol<\}>]
    { <?before \} > }

token terminator is Terminator[:symbol<!!>]
    { <?before !! > }

token stdstopper { <terminator> | <statement_cond> | <statement_loop> | $ }
token assertstopper { <stdstopper> | \> }

# XXX skeleton of operator precedence parser

method EXPR (:$prec = "a=", :$stop = &stdstoppers) {
    if m:p/ <?before $stoppers> / {
	return;
    }
    my @termstack;
    my @opstack;
    push @termstack, $.expect_term();
    while not m:p/ <?before <$stoppers> > / {
	my $infix := $.expect_infix();
	if $infix.prec gt $opstack[-1].prec {	# reduce
            # XXX your ad here
	}
	else {					# shift
            push @opstack, $infix;
            if m:p/ <?before $stoppers> / {
                fail("$infix.perl() is missing right term");
            }
            push @termstack, $.expect_term();
	}
    }
}

# The <panic: message> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

rule panic (Str $s) { <commit> <fail($s)> }

## vim: expandtab sw=4
