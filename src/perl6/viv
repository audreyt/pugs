#!/usr/local/bin/perl

# The start of a gimme5 replacement based on STD parsing.
#
use strict;
use warnings;

use STD;
use utf8;
use YAML::XS;
use feature 'say';

$::ACTIONS = 'Actions';

sub MAIN {
    my $output = 'ast';
    while (@ARGV) {
	last unless $ARGV[0] =~ /^--/;
	my $switch = shift @ARGV;
	if ($switch eq '--ast') {
	    $output = 'ast';
	}
	elsif ($switch eq '--p5') {
	    $output = 'p5';
	}
	elsif ($switch eq '--p6') {
	    $output = 'p6';
	}
    }
    my $r = STD->parsefile($ARGV[0])->item;
    if ($output eq 'ast') {
	print Dump($r);
    }
    elsif ($output eq 'p6') {
	print $r->emit_p6;
    }
    elsif ($output eq 'p5') {
	print $r->emit_p5;
    }
    else {
	die "Unknown output mode";
    }
}

###################################################################

{ package Actions;

    # Generic ast translation done via autoload

    our $AUTOLOAD;

    sub AUTOLOAD {
	my $self = shift;
	my $match = shift;
	my $r = hoist($match);
	(my $class = $AUTOLOAD) =~ s/^Actions/VAST/;
	gen_class($class);
	bless $r, $class unless ref($r) =~ /^VAST/;
	$match->{''} = $r;
    }

    # propagate ->{''} nodes upward
    # (untransformed STD nodes in output indicate bugs)

    sub hoist {
	my $node = shift;
	my $text = $node->text;
	my %r;
	for my $k (keys %$node) {
	    my $v = $node->{$k};
	    if ($k eq 'O') {
		for my $key (keys %$v) {
		    $r{$key} = $$v{$key};
		}
	    }
	    elsif ($k eq '_arity') {
		$r{arity} = $v;
	    }
	    elsif ($k =~ /^[a-zA-Z]/) {
		if (ref $v eq 'ARRAY') {
		    my $zyg = [];
		    for my $z (@$v) {
			if (ref $z) {
			    if (ref $z eq 'ARRAY') {
				push @$zyg, $z;
			    }
			    elsif (exists $z->{''}) {
				push @$zyg, $z->{''};
			    }
			}
			else {
			    push @$zyg, $z;
			}
		    }
		    $r{$k} = $zyg;
		}
		elsif (ref $v) {
		    if (exists $v->{''}) {
			$r{$k} = $v->{''};
		    }
		    else {
			$r{$k} = $v;
		    }
		    unless (ref($r{$k}) =~ /^VAST/) {
			my $class = "VAST::$k";
			gen_class($class);
			bless $r{$k}, $class;
		    }
		}
		else {
		    $r{$k} = $v;
		    $r{TEXT} = $text;
		}
	    }
	}
	$r{TEXT} = $text unless keys %r;
	\%r;
    }

    sub EXPR {
	my $self = shift;
	my $match = shift;
	my $r = hoist($match);
	(my $class = $r->{kind} // "STD::TERM") =~ s/^STD/VAST/;
	gen_class($class);
	$match->{''} = bless $r, $class;
    }

    sub gen_class {
	my $class = shift;
	no strict 'refs';
	return if @{$class . '::ISA'};
	warn "Generating $class\n";
	@{$class . '::ISA'} = 'VAST::Base';
    }

}

###################################################################

{ package VAST::Base;
    sub emit_p5 { die "Perl 5 emitter unimplemented" }

    sub emit_p6 { my $self = shift;
	my $text;
	# XXX bogus
	if (exists $self->{TEXT}) {
	    $text = $self->{TEXT};
	}
	elsif (exists $self->{sym}) {
	    my $sym = $self->{sym};
	    if (ref $sym eq 'ARRAY') {
		$text = join '?', @$sym;
	    }
	    else {
		$text = $sym;
	    }
	}
	else {
	    for my $key (sort keys %$self) {
		my $part = $$self{$key};
		if (ref $part eq 'ARRAY') {
		    my @kids = @$part;
		    for my $kid (@kids) {
			$text .= $kid->emit_p6;
		    }
		}
		elsif (ref $part) {
		    $text .= $part->emit_p6;
		}
		else {
		    $text = $key . '=' . $part;
		}
	    }
	}
	$text;
    }
}

{ package VAST::arglist; our @ISA = ('VAST::Base');
}

{ package VAST::args; our @ISA = ('VAST::Base');
}

{ package VAST::assertion; our @ISA = ('VAST::Base');
}

{ package VAST::atom; our @ISA = ('VAST::Base');
}

{ package VAST::babble; our @ISA = ('VAST::Base');
}

{ package VAST::backslash; our @ISA = ('VAST::Base');
}

{ package VAST::before; our @ISA = ('VAST::Base');
}

{ package VAST::binding; our @ISA = ('VAST::Base');
}

{ package VAST::block; our @ISA = ('VAST::Base');
}

{ package VAST::cclass_elem; our @ISA = ('VAST::Base');
}

{ package VAST::circumfix; our @ISA = ('VAST::Base');
}

{ package VAST::codeblock; our @ISA = ('VAST::Base');
}

{ package VAST::colonpair; our @ISA = ('VAST::Base');
}

{ package VAST::comp_unit; our @ISA = ('VAST::Base');
}

{ package VAST::declarator; our @ISA = ('VAST::Base');
}

{ package VAST::default_value; our @ISA = ('VAST::Base');
}

{ package VAST::deflongname; our @ISA = ('VAST::Base');
}

{ package VAST::desigilname; our @ISA = ('VAST::Base');
}

{ package VAST::dotty; our @ISA = ('VAST::Base');
}

{ package VAST::dottyop; our @ISA = ('VAST::Base');
}

{ package VAST::eat_terminator; our @ISA = ('VAST::Base');
}

{ package VAST::else; our @ISA = ('VAST::Base');
}

{ package VAST::escape; our @ISA = ('VAST::Base');
}

{ package VAST::EXPR; our @ISA = ('VAST::Base');
}

{ package VAST::extrapost; our @ISA = ('VAST::Base');
}

{ package VAST::fatarrow; our @ISA = ('VAST::Base');
}

{ package VAST::fulltypename; our @ISA = ('VAST::Base');
}

{ package VAST::hexint; our @ISA = ('VAST::Base');
}

{ package VAST::identifier; our @ISA = ('VAST::Base');
}

{ package VAST::infix; our @ISA = ('VAST::Base');
}

{ package VAST::infixish; our @ISA = ('VAST::Base');
}

{ package VAST::infix_postfix_meta_operator; our @ISA = ('VAST::Base');
}

{ package VAST::infix_prefix_meta_operator; our @ISA = ('VAST::Base');
}

{ package VAST::integer; our @ISA = ('VAST::Base');
}

{ package VAST::item; our @ISA = ('VAST::Base');
}

{ package VAST::key; our @ISA = ('VAST::Base');
}

{ package VAST::lambda; our @ISA = ('VAST::Base');
}

{ package VAST::left; our @ISA = ('VAST::Base');
}

{ package VAST::litchar; our @ISA = ('VAST::Base');
}

{ package VAST::longname; our @ISA = ('VAST::Base');
}

{ package VAST::metachar; our @ISA = ('VAST::Base');
}

{ package VAST::method_def; our @ISA = ('VAST::Base');
}

{ package VAST::methodop; our @ISA = ('VAST::Base');
}

{ package VAST::modifier_expr; our @ISA = ('VAST::Base');
}

{ package VAST::mod_internal; our @ISA = ('VAST::Base');
}

{ package VAST::module_name; our @ISA = ('VAST::Base');
}

{ package VAST::morename; our @ISA = ('VAST::Base');
}

{ package VAST::multi_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::multisig; our @ISA = ('VAST::Base');
}

{ package VAST::name; our @ISA = ('VAST::Base');
}

{ package VAST::named_param; our @ISA = ('VAST::Base');
}

{ package VAST::nibble; our @ISA = ('VAST::Base');
}

{ package VAST::nibbler; our @ISA = ('VAST::Base');
}

{ package VAST::noun; our @ISA = ('VAST::Base');
}

{ package VAST::nulltermish; our @ISA = ('VAST::Base');
}

{ package VAST::number; our @ISA = ('VAST::Base');
}

{ package VAST::package_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::package_def; our @ISA = ('VAST::Base');
}

{ package VAST::parameter; our @ISA = ('VAST::Base');
}

{ package VAST::param_sep; our @ISA = ('VAST::Base');
}

{ package VAST::param_var; our @ISA = ('VAST::Base');
}

{ package VAST::pblock; our @ISA = ('VAST::Base');
}

{ package VAST::post; our @ISA = ('VAST::Base');
}

{ package VAST::postcircumfix; our @ISA = ('VAST::Base');
}

{ package VAST::postfix; our @ISA = ('VAST::Base');
}

{ package VAST::postop; our @ISA = ('VAST::Base');
}

{ package VAST::pre; our @ISA = ('VAST::Base');
}

{ package VAST::prefix; our @ISA = ('VAST::Base');
}

{ package VAST::quantified_atom; our @ISA = ('VAST::Base');
}

{ package VAST::quantifier; our @ISA = ('VAST::Base');
}

{ package VAST::quantmod; our @ISA = ('VAST::Base');
}

{ package VAST::quibble; our @ISA = ('VAST::Base');
}

{ package VAST::quote; our @ISA = ('VAST::Base');
}

{ package VAST::quote_mod; our @ISA = ('VAST::Base');
}

{ package VAST::quotepair; our @ISA = ('VAST::Base');
}

{ package VAST::regex_block; our @ISA = ('VAST::Base');
}

{ package VAST::regex_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::regex_def; our @ISA = ('VAST::Base');
}

{ package VAST::right; our @ISA = ('VAST::Base');
}

{ package VAST::routine_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::rxinfix; our @ISA = ('VAST::Base');
}

{ package VAST::scoped; our @ISA = ('VAST::Base');
}

{ package VAST::scope_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::semilist; our @ISA = ('VAST::Base');
}

{ package VAST::sigil; our @ISA = ('VAST::Base');
}

{ package VAST::signature; our @ISA = ('VAST::Base');
}

{ package VAST::sigspace; our @ISA = ('VAST::Base');
}

{ package VAST::slurp; our @ISA = ('VAST::Base');
}

{ package VAST::special_variable; our @ISA = ('VAST::Base');
}

{ package VAST::statement; our @ISA = ('VAST::Base');
}

{ package VAST::statement_control; our @ISA = ('VAST::Base');
}

{ package VAST::statementlist; our @ISA = ('VAST::Base');
}

{ package VAST::statement_mod_cond; our @ISA = ('VAST::Base');
}

{ package VAST::statement_mod_loop; our @ISA = ('VAST::Base');
}

{ package VAST::statement_prefix; our @ISA = ('VAST::Base');
}

{ package VAST::stopper; our @ISA = ('VAST::Base');
}

{ package VAST::sublongname; our @ISA = ('VAST::Base');
}

{ package VAST::subshortname; our @ISA = ('VAST::Base');
}

{ package VAST::sym; our @ISA = ('VAST::Base');
}

{ package VAST::term; our @ISA = ('VAST::Base');
}

{ package VAST::termish; our @ISA = ('VAST::Base');
}

{ package VAST::text; our @ISA = ('VAST::Base');
}

{ package VAST::trait; our @ISA = ('VAST::Base');
}

{ package VAST::trait_auxiliary; our @ISA = ('VAST::Base');
}

{ package VAST::twigil; our @ISA = ('VAST::Base');
}

{ package VAST::type_constraint; our @ISA = ('VAST::Base');
}

{ package VAST::typename; our @ISA = ('VAST::Base');
}

{ package VAST::val; our @ISA = ('VAST::Base');
}

{ package VAST::value; our @ISA = ('VAST::Base');
}

{ package VAST::variable; our @ISA = ('VAST::Base');
}

{ package VAST::variable_declarator; our @ISA = ('VAST::Base');
}

{ package VAST::ws; our @ISA = ('VAST::Base');
}

{ package VAST::xblock; our @ISA = ('VAST::Base');
}



if ($0 eq __FILE__) {
    ::MAIN();
}

# vim: ts=8 sw=4 noexpandtab smarttab
