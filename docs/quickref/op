== PRECEDENCE

    terms               42 "eek" $x /abc/ (1+2) a(1) :by(2) .meth listop
    method postfix      . .+ .? .* .+ .() .[] .{} .«» .=
    autoincrement       ++ --
    exponentiation      **
    symbolic unary      ! + - ~ ? * ** +^ ~^ ?^ \
    multiplicative      * / % x xx +& +< +> ~& ~< ~>
    additive            + - ~ +| +^ ~| ~^
    junctive and (all)  &
    junctive or (any)   | ^
    named unary         rand sleep abs etc.
    nonchaining binary  => but does cmp <=> .. ^.. ..^ ^..^
    chaining binary     != == < <= > >= ~~ !~ eq ne lt le gt ge =:=
    tight and           &&
    tight or            || ^^ //
    ternary             ?? ::
    assignment          = := ::= += -= **= xx= etc.
    list item separator , ¥
    list op (rightward) <== [+] print push any all true not etc.
    pipe forward        ==>
    loose and           and
    loose or            or xor err
    expr terminator     ; {} as control block, statement modifiers

== SIMPLE ARITHMETIC OPERATORS

    4 + 2        # 6, addition
    4 - 2        # 2, substraction
    4 * 2        # 8, multiplication
    4 / 2        # 2, division
    4 ** 2       # 16, exponentiation
    4 % 2        # 0, modulo

== BIT OPERATORS

    Numeric   Stringy   Boolean
    ---------------------------
    +|        ~|        ?|           # OR
    +&        ~&        ?&           # AND
    +^        ~^        ?^           # XOR
    +^        ~^        ?^           # Negation (prefix unary)
    +<        ~<                     # Shift left
    +>        ~>                     # Shift right

== UNARY CONTEXT OPERATORS

    +           # Num
    ~           # Str
    ?           # Bool
    int         # Int
    scalar      # Scalar
    list        # List
    hash        # Hash
    pair        # Pair

== HYPER META-OPERATORS

    @foo >>op $bar    # loop over left side
    $foo op<< @bar    # loop over right side
    @foo >>op<< @bar  # loop over both sides, parallel

== ASSIGNMENT OPERATORS

    $copy = $foo     # assign
    $alias := $foo   # bind, runtime
    $alias ::= $foo  # bind, compile time
    $foo++           # postincrement
    $foo--           # postdecrement
    ++$foo           # preincrement
    --$foo           # predecrement
    $foo op= $bar    # mutate ($foo = $foo op $bar), where op is any infix

== COMPARISON OPERATORS

    Num   Str   Generic
    -------------------
    ==    eq            # equality (value)
    !=    ne            # negated equality (value)
    <     lt            # less than
    >     gt            # greater than
    <=    le            # less than or equal to
    >=    ge            # greater than or equal to
    <=>   cmp           # lt => -1, eq => 0, gt => 1
                ~~      # smart match
                !~      # negated smart match
                =:=     # equality (container)

== LOGIC OPERATORS

    HighPrec  LowPrec
    -----------------
    &&        and       # infix
    ||        or        # infix
    ^^        xor       # infix
    //        err       # infix (defined-or)
    !         not       # prefix
    ?         true      # prefix
    ?? ::               # ternary

== QUOTE-LIKE OPERATORS

    Generalized Short   Shorter
    -----------------------------
    q:0
    q:1         q       ''
    q:2         qq      ""
    q:to
    q:0:w       qw      <>
    q:2:w       qqw     «» <<>>
                rx      //

== MISCELLANEOUS

    x           # repeat string
    xx          # repeat element, returns list
    ¥           # zip (also written as Y)

== JUNCTIVE OPERATORS

    $foo | $bar | $baz   # any($foo, $bar, $baz)
    $foo & $bar & $baz   # all($foo, $bar, $baz)
    $foo ^ $bar ^ $baz   # one($foo, $bar, $baz)
    $foo ! $bar ! $baz   # none($foo, $bar, $baz)

== YADA YADA YADA OPERATORS (terms)

    ...  # fail "$?BLOCKNAME is not yet implemented"
    ???  # warn "$?BLOCKNAME is not yet implemented"
    !!!  # die  "$?BLOCKNAME is not yet implemented"

== MISCELLANEOUS OPERATORS

    \$foo               # reference
    $foo ~ $bar         # string concat
    $foo x 3            # $foo ~ $foo ~ $foo
    $foo xx 3           # ($foo, $foo, $foo)
    @foo Y @bar Y @baz  # zip(@foo, @bar, @baz)
    scalar($foo, $bar)  # [ $foo, $bar ]
    1..5                # (1, 2, 3, 4, 5)
    ;                   # statement separator

== SEE ALSO

    .method         # oo
    ^method         # oo
    .=method        # oo
    .()             # sub
    .[]             # data
    .{}             # data
    .<>             # data
    .<<>>           # data
    $, @, %, &, ::  # data
    k => $v         # data
    :k($v)          # data
    <==, ==>        # sub

