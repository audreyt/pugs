= Laziness

A draft on the runtime view of how Lazy things (like Arrays) work.

# by fglock - still trying to sort some things out

The text assumes a knowledge of terms like "Container", "Scalar", "Cell", "Role".

References: 
- S09 Data Structures
- A bit of each of the other AES

TODO - include drawings
TODO - compare with Ruby/Python should help explaining some concepts

== Notes

Array/List are Lazy by default - but Hash and Scalar can be lazy too (just not by default).

== Definitions

TODO:
Scalar / Array / Hash Container
Tuple / List / Generator / Iterator / Range
file iterator
Signature / Argument List
Array / Hash slice
enum
tie / proxy / rw / env
Constrained Types (eg: Int / Even / 0..100 where Even)
Piddle
lazy string / int / num

- native array / native hash

These are fast, in-memory structures provided by the virtual machine.
These structures are assumed to be one-dimensional.

Native hash doesn't need to be indexable by Objects - this can be emulated 
by the Hash class.

- Array Container Class

The Array class defines all objects that implement the Array API.

Array is a subclass of "Container"
Array contains an ordered set of Cells.
Array is multi-dimensional.

Array is not meant to be subclassed - use "roles" to make different implementations.

The actual implementation depends on the "Eager" or the "Lazy" roles.
Other implementations can be specified.

-- Eager Role

An Array object that wraps a native array.

-- Lazy Role

An Array object that generates Cells on demand.
This is the default implementation.

-- Shape (Role or parameter? trait?)

-- Compact Array Role (piddle)

TODO - piddle is different from Compact

- Tuple ("List") class

List is implemented as a native Array, or as a contiguous Stack area if this
is supported by the virtual machine.

List is set of things.
List is a subclass of "Value".
List is one-dimensional.

# At runtime, you only access List elements through Containers.

A List may be built with a mix of Values and Containers.

A List might exist in 3 "states":

  @a = ( 7, 20..30 );
    - this is the Array that will be used in the examples
  @a = ( 
         ( (Cell = 7), ), 
         ( Generator 20..30) 
       );
    - this is more-or-less what it looks like internally

- unflattened List

  ( 1, 5..10, @a ) 
    - a List built from a Scalar, a Range, and an Array

- lazily flattened with "*" operator

  ( 1, 5..10, (Scalar := @a[0]), (Generator (Scalar := @a[1])..(Scalar := @a[10])) ) 
    - the Array was "flattened", but we still have generators.
    
- non-lazily flattened (eager) with "**" operator

  ( 1, 5, 6, 7, 8, 9, 10, (Scalar := @a[0]), (Scalar := @a[1]), (Scalar := @a[1]),  ..... 
    - everything is flattened

List only implements a subset of the Array API.
A List slice is a new List - elements are shallow copied.
List don't support adding, removing or substituting elements.

List has no Cells - thus you can't bind a Container to a List element or slice. ???

  $a := (1,2,3)[2];  # compile error - or is this creating a Constant ???

If a List is built with Generators, it is a Lazy List.

- Generator / Range

Generator is an object that creates Values on demand.
Generator is "functional" rather than "physical memory"

Range is a special case, in which there is a start, an end, and a step.

#At runtime, you only access Generator elements through Containers.

Generator also implements "match":

  5 ~~ 1..10

TODO - detail the behaviour of "Str Range"

- Iterator

TODO

  =<>

- List Slice

A List Slice is a shallow copy of a part of a List.

A List Slice is just a List - there is not a separate Class for it.

- Container Slice

A Container Slice is a specialized Array/Hash, in which all the elements 
are bound to objects inside other Containers (Array, Hash or Scalar).

A Lazy Container Slice contains pointers to Generators that are inside other 
Containers.

Container Slice is multi-dimensional.

- Hash

The Hash class defines all objects that implement the hash API.

Hash is like an Array, in which the Cell indexes can be of any type 
(not just numbers).

Hash is multi-dimensional.

== Generator Internals

- TODO


== Generator API

- match

This operator is used in a match statement:

    5 ~~ 1..10

- shift / pop

TODO - not sure if "Generator" is an iterator (read-only) or uses destructive 
read (shift/pop)

- sum / reverse / map / zip

- flatten

Takes all Values from the Generator, and returns an Array (possibly Native).

- elems

The number of elements

=== This part of the Generator API is only used by the runtime internals.

- head(n)

This operator is used by the Array splice operator.

Takes "n" Values from the Generator, like "shift" does. 
The result can be a Generator (when n is big), an Array (possibly Native), 
a single Value (when n == 1), or Void (when n <= 0).

TODO - not sure if "Generator" is an iterator (read-only) or uses destructive 
read (head/tail)

- tail(n)

This operator is used by the Array splice operator.

Takes "n" Values from the back of the Generator, like "pop" does. 
The result can be a Generator (when n is big), an Array (possibly Native), 
a single Value (when n == 1), or Void (when n <= 0).

TODO - check if "Generator" is an iterator (read-only) or uses destructive 
read (head/tail)

- is_contiguous

This is used for the optimization of Slice, when the sequence is used
as a slice index.

is_contiguous() is True is the generated sequence is like "2 .. 10".


= Array internals

== Array (base Class)

TODO

== Eager (Role)

An Eager Array contains a Native Array.

TODO - explain "Cell"

   Contents:  1 2 3
   Internals: [ 1, 2, 3 ] 

== Lazy (Role)

A Lazy Array contains a "specs" Array, which contains Generators, or Native Arrays.

   Contents:  1 2 3
   Internals: [ 
                [ 1, 2, 3 ] 
              ]

   Contents:  10 20 30 100..10000 50 400..900
   Internals: [
                [ 10, 20, 30 ],
                Generator( 100, 10000 ),
                [ 50 ],
                Generator( 400, 900 )
              ]


= Array API

- TODO
Array can do "map", "grep", splice, push, pop, store, fetch. 
Array can be "bound" and "tied".


== splice

This pseudo-code implements splice().
It assumes that the internal representation of Array can do .head(n) and .tail(n) - 
see "Generator" for details.

    sub splice ( @array, $offset? = 0, $length? = Inf, @list? = () ) { 
        my ( @head, @body, @tail );
        if ( $offset >= 0 ) {
            @head = @array.head( $offset );
            if ( $length >= 0 ) {
                @body = @array.head( $length );
                @tail = @array;
            }
            else {
                @tail = @array.tail( -$length );
                @body = @array;
            }
        }
        else {
            @tail = @array.tail( -$offset );
            @head = @array;
            if ( $length >= 0 ) {
                @body = $tail.head( $length );
            }
            else {
                @body = @tail;
                @tail = $body.tail( -$length );
            }
        };
        @array = ( @head, @list, @tail );
        return @body;
    }

= Hash internals

A Hash contains a Native Hash.

Hash keys can be objects, but the objects must be immutable

   Contents:  a:1 b:2 c:3
   Internals: { a:1 b:2 c:3 } 

A Hash may contain Lazy items. 
This structure contains a Native Array, which contains Generators or Native Hashes.
This structure permits near O(1) complexity for most operations.

   Contents:  a:1 b:2 c:3
   Internals: [ 
                { a:1, b:2, c:3 }
              ]

   Contents:  a:10 b:20 c:30 (1:100 .. 10000:10100) d:50 
   Internals: [
                { a:10 b:20 c:30 },
                Generator( 1:100, 10000:10100 ),
                { d:50 },
              ]


= Hash API

- TODO


= Slice API

- TODO


= Slice Internals

- TODO - hash slice / array slice

... ... more ...
