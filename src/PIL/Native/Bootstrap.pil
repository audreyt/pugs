#!pil

=pod

=head1 NEXT STEPS

=head2 dispatcher

We need to figure out the dispatcher next. In the p5 version it is a closure
based iterator, it could also be a coroutine/continuation too. It needs to
be easily resumable to support "next METHOD". 

This will allow us to define WALKCLASS and WALKMETH, and then we can write
BUILDALL and DESTROYALL, then BUILD will work. WALKCLASS will also help to
simplify CREATE as well.

In fact, we need to the dispatcher for just about everything :)

=cut

## ------------------------------------------------------------------------- ##
## Class and Method iterators
## ------------------------------------------------------------------------- ##

&WALKCLASS := -> &dispatcher         { &dispatcher.() };
&WALKMETH  := -> &dispatcher, $label {
    -> { 
        &redo  := &?SUB;
        $class := &WALKCLASS.(&dispatcher);
        -> { 
            $method := $class.get_method($label);
            $method.is_nil.cond(
                -> { &redo.() },
                -> { $method  } 
            );
        }.do_if($class.not_nil);
    }.();
};

## ------------------------------------------------------------------------- ##
## Class
## ------------------------------------------------------------------------- ##
## We assume that ::Class and ::Class.add_method are already defined
## ------------------------------------------------------------------------- ##

## class construction methods

::Class.add_method('new', -> %params { 
    self.bless(nil, %params);
});

::Class.add_method('bless', -> $repr, %params { 
    $obj := self.CREATE($repr, %params);
    $obj.BUILDALL(%params); 
    $obj;     
});

::Class.add_method('CREATE', -> $repr, %params {
    $obj := self.new_opaque({});
    -> $class {
        -> $key {
            $obj.set_attr($key, $class.get_attribute($key));
        }.do_for($class.get_attribute_list);
    }.do_for(self.dispatcher('descendant'));
    $obj;
});

# NOTE: 
# we can convert CREATE to use this  
# &WALKCLASS once that is working 
=pod
::Class.add_method('CREATE', -> $repr, %params {
    $obj := self.new_opaque({});
    &dispatcher := $?CLASS.dispatcher('descendant');
    -> {
        &redo  := &?SUB;
        $class := &WALKCLASS.(&dispatcher);
        -> {
            -> $key {
                $obj.set_attr($key, $class.get_attribute($key));
            }.do_for($class.get_attribute_list);
        }.do_if($class.not_nil);
    }.();
    $obj;
});
=cut

::Class.add_method('BUILDALL', -> %params {
    -> $class {
        -> {
            $method := $class.get_method('BUILD');        
            $method.(%params);
        }.do_if($class.has_method('BUILD'))
    }.do_for($?CLASS.dispatcher('descendant'));
});

# NOTE: 
# we can convert BUILDALL to use this  
# &WALKMETH once that is working 
=pod
::Class.add_method('BUILDALL', -> %params {
    &dispatcher := $?CLASS.dispatcher('descendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH.(&dispatcher, 'BUILD');
        -> {
            $method.($self, %params);
            &redo.();
        }.do_if($method.not_nil);
    }.();
});
=cut

::Class.add_method('BUILD', -> %params {
    -> $key {
        -> {
            self.set_attr($key, %params.fetch($key));
        }.do_if(self.has_attr($key))
    }.do_for(%params.keys);
});

## class destruction

# NOTE:
# since nothing is getting destroyed yet
# this can wait until WALKMETH is working
::Class.add_method('DESTROYALL', -> { 
    &dispatcher := $?CLASS.dispatcher('ascendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH.(&dispatcher, 'DESTROY');
        -> {
            $method.($self);
            &redo.();
        }.do_if($method.not_nil);
    }.();
});

## informational methods

::Class.add_method('is_a', -> $class { 
    self.eq($class).cond(
        -> { true },
        -> {
            &dispatcher := $?CLASS.dispatcher('descendant');
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS.(&dispatcher);
                -> {
                    $ancestor.eq($class).cond(
                        -> { true     },
                        -> { &redo.() }
                    );
                }.do_if($ancestor.not_nil)
            }.();
        }
    );
});

## (super|sub)classes

::Class.add_method('superclasses', -> { self.get_attr('@!superclasses') });
::Class.add_method('set_superclasses', -> @superclasses { 
    -> $super { 
        $super.add_subclass(self); 
    }.do_for(@superclasses);
    self.set_attr('@!superclasses', @superclasses);
    self.set_attr('@!MRO', self.mro_merge);    
});

::Class.add_method('MRO', -> {
    @mro := self.get_attr('@!MRO');
    @mro.is_empty.cond(
        ->{ self.set_attr('@!MRO', self.mro_merge) },
        ->{ @mro }
    );
});

::Class.add_method('subclasses',   ->        { self.get_attr('@!subclasses') });
::Class.add_method('add_subclass', -> $class { 
    self.set_attr('@!subclasses', self.get_attr('@!subclasses').push($class));
});

## dispatching

::Class.add_method('dispatcher', -> $order {
    $order := $order.is_nil.or($order.eq('canonical')).cond(
        ->{ 'ascendant' }, ->{ $order },
    );
    $order.eq('descendant').cond(
        ->{ self._make_descendant_dispatcher; },
        ->{ $order.eq('ascendant').cond(
            ->{ self._make_ascent_dispatcher; },
            ->{ self._unsupported_dispatch_order($order); },
        ) }
    );
});

# ... should the dispatcher be implemented here? or Haskell
# I think it is easier in Haskell, but still extendable if 
# we have this method here 

::Class.add_method('_make_ascent_dispatcher', -> { self.MRO; });
::Class.add_method('_make_descendant_dispatcher', -> { self.MRO.reverse; });


## method related methods

::Class.add_method('has_method', -> $name { 
    self.get_attr('%!methods').exists($name);
});

::Class.add_method('get_method', -> $name { 
    self.get_attr('%!methods').fetch($name); 
});

::Class.add_method('get_method_list', -> { 
    self.get_attr('%!methods').keys(); 
});

## can we actually do remove_method??
# ::Class.add_method('remove_method', -> $name { 
#     self.get_attr('%!methods').delete($name); 
# });

## attribute related methods

::Class.add_method('add_attribute', -> $name, $attr { 
    self.set_attr_hash('%!attributes', $name, $attr);
});

::Class.add_method('has_attribute', -> $name { 
    self.get_attr('%!attributes').exists($name);
});

::Class.add_method('get_attribute', -> $name { 
    self.get_attr('%!attributes').fetch($name); 
});

::Class.add_method('get_attribute_list', -> { 
    self.get_attr('%!attributes').keys(); 
});

::Class.add_method('get_attributes', -> { 
    self.get_attr('%!attributes').values(); 
});

## NOTE:
## we assume that when ::Class was defined, that it's attributes
## were also defined, but only in the Instance type, and not in 
## it's meta-self

::Class.add_attribute('@!MRO', []);
::Class.add_attribute('@!superclasses', []);
::Class.add_attribute('@!subclasses', []);
::Class.add_attribute('%!private_methods', {});
::Class.add_attribute('%!methods', {});
::Class.add_attribute('%!attributes', {});

## ------------------------------------------------------------------------- ##
## Object
## ------------------------------------------------------------------------- ##

::Object := ::Class.new({});

# NOTE:
# these three methods need to also live as ::Object instance
# methods too. They would normally be inherited from ::Object
# by ::Class, but becuase they need to exist prior to the 
# creation of ::Object, we have to duplicate them. Better 
# suggestions welcome :)

::Object.add_method('BUILD',      ::Class.get_method('BUILD'));
::Object.add_method('BUILDALL',   ::Class.get_method('BUILDALL'));
::Object.add_method('DESTORYALL', ::Class.get_method('DESTROYALL'));

::Object.add_method('isa', -> { });
::Object.add_method('can', -> { });

## ------------------------------------------------------------------------- ##
## Package
## ------------------------------------------------------------------------- ##

::Package := ::Class.new({});
::Package.set_superclasses([ ::Object ]);

::Package.add_attribute('$!name',      '');
::Package.add_attribute('%!namespace', {});

::Package.add_method('name',     ->       { self.get_attr('$!name') });
::Package.add_method('set_name', -> $name {
    -> { self.set_attr('$!name', $name) }.do_if($name.not_nil);    
});

::Package.add_method('FETCH', -> $name { });
::Package.add_method('STORE', -> $name, $value { });

## ------------------------------------------------------------------------- ##
## Module
## ------------------------------------------------------------------------- ##

::Module := ::Class.new({});
::Module.set_superclasses([ ::Package ]);

::Module.add_attribute('$!version',   '');
::Module.add_attribute('$!authority', '');

::Module.add_method('version',     ->          { self.get_attr('$!version') });
::Module.add_method('set_version', -> $version {
    -> { self.set_attr('$!version', $version) }.do_if($version.not_nil);
});

::Module.add_method('authority',     ->            { self.get_attr('$!authority') });
::Module.add_method('set_authority', -> $authority {
    -> { self.set_attr('$!authority', $authority) }.do_if($authority.not_nil);
});

::Module.add_method('identifier', -> {
    $output := self.get_attr('$!name');
    $output := self.get_attr('$!version').not_nil.cond(
                     -> { $output.concat('-').concat(self.get_attr('$!version')) },
                     -> { $output }
               );
    $output := self.get_attr('$!authority').not_nil.cond(
                     -> { $output.concat('-').concat(self.get_attr('$!authority')) },
                     -> { $output }
               ); 
    $output;
});

## ------------------------------------------------------------------------- ##
## Role
## ------------------------------------------------------------------------- ##

# ... coming eventually 

## ------------------------------------------------------------------------- ##
## Bootstrapping
## ------------------------------------------------------------------------- ##

::Class.set_attr('@!superclasses', [ ::Module ]);
::Module.set_attr('@!subclasses',  [ ::Class ]); 

# NOTE:
# not doing this made our prototype go into 
# endless recursion, I am not sure if this
# will suffer from the same issue, it should
# be tested, but I want to make we have a 
# sizable test suite first.
::Class.set_attr('@!MRO', [ ::Class, ::Module, ::Package, ::Object ]);
::Object.set_attr('@!MRO', [ ::Object ]);

# NOTE:
# these attributes need to be added manually to the
# class instances since ::Class would have inherited 
# them, but couldn't since they had not yet been defined. 

-> $class {
    $class.set_attr('$!name',      '');
    $class.set_attr('$!namespace', {});
    $class.set_attr('$!version',   '');
    $class.set_attr('$!authority', '');
}.do_for([ ::Class, ::Object, ::Module, ::Package ]);

# ... now we can name and version all our objects

::Class.set_name('Class');     ::Class.set_version('0.0.1');   ::Class.set_authority('url:pugscode.org');
::Object.set_name('Object');   ::Object.set_version('0.0.1');  ::Object.set_authority('url:pugscode.org');
::Package.set_name('Package'); ::Package.set_version('0.0.1'); ::Package.set_authority('url:pugscode.org');
::Module.set_name('Module');   ::Module.set_version('0.0.1');  ::Module.set_authority('url:pugscode.org');

## end bootstrapping ...
## ------------------------------------------------------------------------- ##

=pod

=head1 NAME

Perl 6 Object Model Bootstrap

=head1 DESCRIPTION 

This is the bootstrap code for the Perl 6 Object Model using the Perl 6 
Object-Space mini-language. 

=head1 SEE ALSO

NOTE: all paths from the root of the Pugs source tree.

=over 4

=item Perl 5 prototype of the Perl 6 Object Model

/perl5/Perl6-MetaModel/

In particular see the /perl5/Perl6-MetaModel/docs/*.jpg.

=item Perl 5 prototype of the Perl 6 Object Space 

/perl5/Perl6-ObjectSpace/

In particular see the /perl5/Perl6-MetaModel/docs/Object_Space.jpg

=back

=head1 AUTHORS

Audrey Tang <autrijus@autrijus.org>

Stevan Little <stevan@iinteractive.com>

=cut
