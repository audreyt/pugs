#!/usr/local/bin/perl

# Core modules
use strict;
use warnings;
use utf8;
use feature qw(say);
use English;
use Getopt::Long;

# CPAN modules
use File::Slurp;

# And finally our modules
use STD;
use DumpMatch;

=head1 NAME

STD_syntax_highlight - Highlights Perl 6 source code using STD.pm

=head1 SYNOPSIS

    # print html output with inlined resources for 'comp_unit'
    STD_syntax_highlight foo.pl

    # print separate html, css and javascript files
    STD_syntax_highlight --clean-html foo.pl

    # print html for with 'statementlist' as the top-level rule
    STD_syntax_highlight foo.pl statementlist

    # write only simple html/css to simple.html
    STD_syntax_highlight --simple-html=foo.simple.html foo.pl

    # write redspans output to foo.redspans.html
    STD_syntax_highlight --redspans-html=foo.redspans.html foo.pl

=head1 SUBROUTINES

=over

=cut

my ($clean_html,$help) = (0,0);
my ($simple_html,$full_html,$redspans_html) = (0,0,'-');
my ($file, $parser, $src_text); 

# These are needed for redspans
$::ACTIONS = 'Actions';
my @loc;

=item main

Your standard main method
=cut
sub main {
    
    #process the command line
    GetOptions(
        "clean-html"=>\$clean_html,
        "simple-html=s"=>\$simple_html,
        "full-html=s"=>\$full_html,
        "redspans-html=s"=>\$redspans_html,
        "help"=>\$help
    );

    if ($#ARGV < 0 || $help) {
        die <<"HELP";
USAGE: 
    $PROGRAM_NAME [options] filename [rule]

    where options can be one of the following:

    --clean-html    
        generates separate html,css and javascript

    --simple-html=filename
        write simple-mode html to filename (disabled by default, - for STDOUT)  

    --full-html=filename   
        write full-mode html to filename (disabled by default, - for STDOUT)
 
    --redspans-html=filename   
        write redspans-mode html to filename (enabled by default, - for STDOUT)
    
HELP
    }

    #start parsing...
    $file = shift @ARGV;
    my $what = shift @ARGV // 'comp_unit';

    unless(-r $file) {
        die "Could not open '$file' for reading\n";
    }

    # slurp the file for redspans
    $src_text = read_file($file);
    $loc[length($src_text) - 1] = [];

    $parser = STD->parsefile($file,$what);

    # and finally print out the html code
    highlight_match($what=>$parser,{});
}

=item write_html_file

Writes the html file to filename or to STDOUT
=cut
sub write_html_file {
    my ($html_file, $html) = @ARG;
    if($html_file eq '-') {
        say $html;
    } else {
        open FILE, ">$html_file" or
            die "Cannot open $html_file for writing: $OS_ERROR\n";
        say FILE $html;
        close FILE;
    }
}

=item highlight_match

Returns the generated Perl6 highlighted HTML from C<highlight_perl6>
subroutine after traversing the STD parse tree using 
DumpMatch.pm C<traverse_match>.
=cut
sub highlight_match {
    my $name = shift;
    my $r = shift;
    my $opt = shift || {};
    my $events = [];

    if($simple_html) {
        traverse_match($r,$name,0,$events,$opt);
        my $html = highlight_perl6_simple($r,$::ORIG,$events,$opt);
        write_html_file $simple_html, $html;
    }
    if($full_html) {
        traverse_match($r,$name,0,$events,$opt);
        my $html = highlight_perl6_full($r,$::ORIG,$events,$opt);
        write_html_file $full_html, $html;
    }
    if($redspans_html) {
        my $html = highlight_perl6_redspans();
        write_html_file $redspans_html, $html;
    }
}

=item highlight_perl6_full

Generates the Perl6 highlighted HTML string for STD parse tree provided. 
The resources can be inlined (by default) or externalized (--clean-html). 
=cut
sub highlight_perl6_full {
    my ($r,$orig,$events,$opt,$file) = @ARG,
    my $str = "";
    my $at = 0;

    # slurp libraries and javascript to inline them
    my ($JQUERY_JS,$JS,$CSS) = (
        'jquery-1.2.6.pack.js', 
        'STD_syntax_highlight.js',
        'STD_syntax_highlight.css');
    my $jquery_js = qq{<script type="text/javascript" src="../$JQUERY_JS"></script>};
    my $js = qq{<script type="text/javascript" src="../$JS"></script>};
    my $css = qq{<link href="../$CSS" rel="stylesheet" type="text/css">};
    if(!$clean_html) {
        $jquery_js = read_file($JQUERY_JS) 
            or die "Error while slurping file: $OS_ERROR\n";    
        $js = read_file($JS) 
            or die "Error while slurping file: $OS_ERROR\n";
        $css = read_file($CSS)
            or die "Error while slurping file: $OS_ERROR\n";
        $jquery_js = qq{<script type="text/javascript">\n$jquery_js\n</script>};
        $js = qq{<script type="text/javascript">\n$js\n</script>};
        $css = qq{<style type="text/css">\n$css\n</style>};
    }

    my $timestamp = localtime;
    $str .= <<"HTML";
<html>
<head>
    <title>$file</title>
<!--
    Generated by $PROGRAM_NAME at $timestamp
-->
    $css
    $jquery_js
    $js
</head>
<body>
    <div id="parse_tree">
        <button id="parse_tree_expand">Show Syntax Tree</button>
        <button id="parse_tree_collapse">Hide it</button>
        <button id="parse_tree_help">Help</button>
        <div id="parse_tree_output"></div>
    </div>
    <pre>
HTML

    my $curr_rule = q{}; 
    for (sort {$a->[0] <=> $b->[0] or $a->[4] <=> $b->[4]} @{$events}) {
        my $text = substr($orig,$at,$_->[0]-$at);
        my $esc_text .= escape_html($text);
        $at = $_->[0];

        if($curr_rule eq 'identifier') {
            if($parser->is_type($text)) {
                $str .= qq{<span class="_type">$esc_text</span>};
            } elsif($parser->is_routine($text)) {
                $str .= qq{<span class="_routine">$esc_text</span>};
            } else {
                $str .= $esc_text;
            }
        } else {
            $str .= $esc_text;
        }

        if ($_->[1] eq 'from') {
            $curr_rule = $_->[2];
            $str .= '<span class="'.$curr_rule.'">';
        } elsif ($_->[1] eq 'to') {
            $str .=  '</span>';
        }
    }

    $str .= <<"HTML";
    </pre>
</body>
</html>
HTML

    $str;
}

=item highlight_perl6_simple

This is same as C<highlight_perl> when --simple is used.
No more javascript tree viewer or anything fancy. 
Only nodes that have a color are printed. Not optimal but works ;-)
=cut
sub highlight_perl6_simple {
    my ($orig,$events,$opt) = @ARG;
    my $str = "";
    my $at = 0;
    my %colors = ();

    my $CSS = "STD_syntax_highlight.css";
    open CSS_FILE, $CSS
        or die "Could not open $CSS: $OS_ERROR\n";
    my $line;
    while($line = <CSS_FILE>) {
        if($line =~ /^\s*\.(\w+)\s*{\s*color\s*:\s*(\w+)/) {
            $colors{$1} = $2;
        }
    }
    close CSS_FILE;

    # slurp libraries and javascript to inline them
    my $css = qq{<link href="../$CSS" rel="stylesheet" type="text/css">};
    if(!$clean_html) {
        $css = read_file($CSS)
            or die "Error while slurping file: $OS_ERROR\n";
        $css = qq{<style type="text/css">\n$css\n</style>};
    }

    my $timestamp = localtime;
    $str .= <<"HTML";
<html>
<head>
    <title>$file</title>
<!--
     Generated by $PROGRAM_NAME at $timestamp
-->
    $css
</head>
<body>
    <pre>
HTML
    my $curr_rule = q{};
    my @rules = (); 
    my $code = "";
    for (sort {$a->[0] <=> $b->[0] or $a->[4] <=> $b->[4]} @{$events}) {
        my $text = substr($orig,$at,$_->[0]-$at);
        my $esc_text .= escape_html($text);
        $at = $_->[0];

        # process types, routines and identifiers
        if($curr_rule eq 'identifier') {
            if($parser->is_type($text)) {
                $code .= qq{<span class="_type">$esc_text</span>};
            } elsif($parser->is_routine($text)) {
                $code .= qq{<span class="_routine">$esc_text</span>};
            } else {
                $code .= $esc_text;
            }
        } else {
            $code .= $esc_text;
        }

        if ($_->[1] eq 'from') {
            $curr_rule = $_->[2];
            push @rules, $curr_rule;
            my $has_color = $colors{$curr_rule};
            $code .= '<span class="'.$curr_rule.'">' if $has_color;
        } elsif ($_->[1] eq 'to') {
            my $rule = pop @rules;
            my $has_color = $colors{$rule};
            $code .=  '</span>' if $has_color;
        }
    }
    # process comments
    $code =~ s{(#[^\n]*)}{<span class="_comment">$1</span>}g;
    $str .= $code;
    $str .= <<"HTML";
    </pre>
</body>
</html>
HTML

   $str;
}

=item highlight_perl6_redspans

This is same as C<highlight_perl> when --redspans is used.
No more javascript tree viewer or anything fancy. 
Only nodes that have a color are printed. Not optimal but works ;-)
=cut
sub highlight_perl6_redspans {
    my $str = "";
    my %colors = ();

    my $CSS = "STD_syntax_highlight.css";
    open CSS_FILE, $CSS
        or die "Could not open $CSS: $OS_ERROR\n";
    my $line;
    while($line = <CSS_FILE>) {
        if($line =~ /^\s*\.(\w+)\s*{\s*color\s*:\s*(\w+)/) {
            $colors{$1} = $2;
        }
    }
    close CSS_FILE;

    # slurp css inline it
    my $css = qq{<link href="../$CSS" rel="stylesheet" type="text/css">};
    if(!$clean_html) {
        $css = read_file($CSS)
            or die "Error while slurping file: $OS_ERROR\n";
        $css = qq{<style type="text/css">\n$css\n</style>};
    }

    my $timestamp = localtime;
    $str .= <<"HTML";
<html>
<head>
    <title>$file</title>
<!--
     Generated by $PROGRAM_NAME at $timestamp
-->
    $css
</head>
<body>
    <pre>
HTML

    my ($last_tree,$buffer) = ("","");
    for my $i (0 .. @loc-1) {
        say("Undefined $i"),next unless defined $loc[$i];
        my $c = substr($src_text,$i,1);
        my $tree = "@{$loc[$i]}";
        if($tree ne $last_tree) {
            my $rule;
            my $rule_to_color = 0;
            $buffer = escape_html($buffer);
            my @rules = ();
            @rules = reverse(split / /,$last_tree) if $last_tree ne '';
            for $rule (@rules) {
                if($rule eq 'unv') {
                    $rule_to_color = '_comment';
                    last;
                } elsif($colors{$rule} && $buffer ne '') {
                    $rule_to_color = $rule;
                    last;
                }
            }
            if($rule_to_color) {
                if($last_tree =~ /identifier/) {
                    if($parser->is_type($buffer)) {
                        $str .= qq{<span class="_type">$buffer</span>};
                    } elsif($parser->is_routine($buffer)) {
                        $str .= qq{<span class="_routine">$buffer</span>};
                    } else {
                        $str .= qq{<span class="$rule_to_color">$buffer</span>};
                    }
                } else {              
                    $str .= qq{<span class="$rule_to_color">$buffer</span>};
                }
            } else {
                $str .= qq{$buffer};
            }
            $buffer = $c;
        } else {
            $buffer .= $c;
        }
        $last_tree = $tree;
    }
    
    $str .= <<"HTML";
    </pre>
</body>
</html>
HTML

   $str;
}

###################################################################
# R E D S P A N S
{ 
    package Actions;

    our $AUTOLOAD;

    sub AUTOLOAD {
        my $self = shift;
        my $C = shift;
        my $F = $C->{_from};
        my $P = $C->{_pos};
        $AUTOLOAD =~ s/^Actions:://;
        $loc[$P] = [] if $loc[$P];	# in case we backtracked to here
        for ($F..$P-1) {
            unshift @{$loc[$_]}, $AUTOLOAD;
        }
    }

    sub stdstopper { }
    sub terminator { }
    sub unitstopper { }
    sub comp_unit { }
}


=item escape_html

Converts some characters to their equivalent html entities 
=cut
sub escape_html {
    my $str = shift;
    my %esc = (
        '<'     => '&lt;',
        '>'     => '&gt;',
        '"'     => '&quot;',
        '&'     => '&amp;'
    );
    my $re = join '|', map quotemeta, keys %esc;
    $str =~ s/($re)/$esc{$1}/g;
    return $str;
}

=back

=head1 AUTHOR

Written by Ahmad M. Zawawi (azawawi), Moritz Lenz and Paweł Murias (pmurias)

The project idea was inspired by Moritz Lenz (moritz)
See http://www.nntp.perl.org/group/perl.perl6.users/2008/07/msg788.html

The initial STD tree traversal code was written by Paweł Murias (pmurias).

The redspans traversal code was written by Larry Wall (TimToady).

The browser code was written by Ahmad M. Zawawi (azawawi)
=cut

main @ARGV;
