#!pil

=pod

=head1 NEXT STEPS

=head2 dispatcher

We need to figure out the dispatcher next. In the p5 version it is a closure
based iterator, it could also be a coroutine/continuation too. It needs to
be easily resumable to support "next METHOD". 

This will allow us to define WALKCLASS and WALKMETH, and then we can write
BUILDALL and DESTROYALL, then BUILD will work. WALKCLASS will also help to
simplify CREATE as well.

=head2 attr.instantiate_container()

We need to get this working as well so that we don't need to check for nils
in situations which we should be just checking is_empty.

=head2 obj.id

We need to expose the id for instances to the mini-lang.

=cut

## ------------------------------------------------------------------------- ##
## Class
## ------------------------------------------------------------------------- ##
## We assume that ::Class and ::Class.add_method are already defined
## ------------------------------------------------------------------------- ##

## class construction methods

::Class.add_method('new', -> %params { 
    self.bless(nil, %params);
});

::Class.add_method('bless', -> $repr, %params { 
    $obj := self.CREATE($repr, %params);
    $obj.BUILDALL(%params); 
    $obj;     
});

::Class.add_method('CREATE', -> $repr, %params {
    -> @mro, %attrs {
        &next_dispatch := &?SUB;
        @mro.is_empty.cond(
            # done iterating - let's make something
            ->{ self.new_opaque(%attrs) },
            # not done yet - add stuff to it
            ->{
                -> @attrs, %new_attrs {
                    &redo := &?SUB;
                    @attrs.is_empty.cond(
                        -> { &next_dispatch.( @mro.splice(1), %new_attrs ) },
                        -> {
                            $attr := @attrs.fetch(0);
                            &redo.(
                                @attrs.splice(1),
                                %new_attrs.store($attr, nil), # $attr.instantiate_container),
                            );
                        },
                    );
                }.(@mro.fetch(0).get_attribute_list, %attrs);
            },
        )
    }.( $?CLASS.dispatcher('descendant'), {} );
});

::Class.add_method('BUILDALL', -> %params { });
::Class.add_method('BUILD', -> %params { });

## class destruction

::Class.add_method('DESTROYALL', -> { });

## informational methods

::Class.add_method('id', -> { });
::Class.add_method('class', -> { $?CLASS });

::Class.add_method('is_a', -> $class { });

## (super|sub)classes

::Class.add_method('superclasses', -> { self.get_attr('@!superclasses') });
::Class.add_method('set_superclasses', -> @superclasses { 
    -> $super { 
        $super.add_subclass(self); 
    }.do_for(@superclasses);
    self.set_attr('@!superclasses', @superclasses);
    self.set_attr('@!MRO', self.mro_merge);    
});

::Class.add_method('MRO', -> {
    self.mro_merge();
# NOTE:
# we don't cache it for now, not sure why
# but this just wasn't working ...
#    @mro := self.get_attr('@!MRO');
#    @mro.is_empty.cond(
#        ->{ self.set_attr('@!MRO', self.mro_merge) },
#        ->{ @mro }
#    );
});

::Class.add_method('subclasses',   ->        { self.get_attr('@!subclasses') });
::Class.add_method('add_subclass', -> $class { 
    @subclasses := self.get_attr('@!subclasses').is_nil.cond(
        -> { [ $class ] },
        -> { self.get_attr('@!subclasses').push($class) }
    );
    self.set_attr('@!subclasses', @subclasses);
});

## dispatching

::Class.add_method('dispatcher', -> $order {
    $order := $order.is_nil.or($order.eq('canonical')).cond(
        ->{ 'ascendant' }, ->{ $order },
    );
    $order.eq('descendant').cond(
        ->{ self._make_descendant_dispatcher; },
        ->{ $order.eq('ascendant').cond(
            ->{ self._make_ascent_dispatcher; },
            ->{ self._unsupported_dispatch_order($order); },
        ) }
    );
});

# ... should the dispatcher be implemented here? or Haskell
# I think it is easier in Haskell, but still extendable if 
# we have this method here 

::Class.add_method('_make_ascent_dispatcher', -> { self.MRO; });
::Class.add_method('_make_descendant_dispatcher', -> { self.MRO.reverse; });


## method related methods

::Class.add_method('has_method', -> $name { 
    self.get_attr('%!methods').exists($name);
});

::Class.add_method('get_method', -> $name { 
    self.get_attr('%!methods').fetch($name); 
});

::Class.add_method('get_method_list', -> { 
    self.get_attr('%!methods').keys(); 
});

## can we actually do remove_method??
# ::Class.add_method('remove_method', -> $name { 
#     self.get_attr('%!methods').delete($name); 
# });

## attribute related methods

::Class.add_method('add_attribute', -> $name, $attr { 
    self.set_attr_hash('%!attributes', $name, $attr);
});

::Class.add_method('has_attribute', -> $name { 
    self.get_attr('%!attributes').exists($name);
});

::Class.add_method('get_attribute', -> $name { 
    self.get_attr('%!attributes').fetch($name); 
});

::Class.add_method('get_attribute_list', -> { 
    self.get_attr('%!attributes').keys(); 
});

::Class.add_method('get_attributes', -> { 
    self.get_attr('%!attributes').values(); 
});

## NOTE:
## we assume that when ::Class was defined, that it's attributes
## were also defined, but only in the Instance type, and not in 
## it's meta-self

::Class.add_attribute('@!MRO', nil);
::Class.add_attribute('@!superclasses', nil);
::Class.add_attribute('@!subclasses', nil);
::Class.add_attribute('%!private_methods', nil);
::Class.add_attribute('%!methods', nil);
::Class.add_attribute('%!attributes', nil);

## ------------------------------------------------------------------------- ##
## Object
## ------------------------------------------------------------------------- ##

::Object := ::Class.new({});

::Object.add_method('BUILD', -> %params { });
::Object.add_method('BUILDALL', -> %params { });

::Object.add_method('DESTORYALL', -> { });

::Object.add_method('id', -> { });
::Object.add_method('class', -> { });

::Object.add_method('isa', -> { });
::Object.add_method('can', -> { });

## ------------------------------------------------------------------------- ##
## Package
## ------------------------------------------------------------------------- ##

::Package := ::Class.new({});
::Package.set_superclasses([ ::Object ]);

::Package.add_attribute('$!name', nil);
::Package.add_attribute('%!namespace', nil);

::Package.add_method('name',     ->       { self.get_attr('$!name') });
::Package.add_method('set_name', -> $name {
    -> { self.set_attr('$!name', $name) }.do_if($name.not_nil);    
});

::Package.add_method('FETCH', -> $name { });
::Package.add_method('STORE', -> $name, $value { });

## ------------------------------------------------------------------------- ##
## Module
## ------------------------------------------------------------------------- ##

::Module := ::Class.new({});
::Module.set_superclasses([ ::Package ]);

::Module.add_attribute('$!version',   nil);
::Module.add_attribute('$!authority', nil);

::Module.add_method('version',     ->          { self.get_attr('$!version') });
::Module.add_method('set_version', -> $version {
    -> { self.set_attr('$!version', $version) }.do_if($version.not_nil);
});

::Module.add_method('authority',     ->            { self.get_attr('$!authority') });
::Module.add_method('set_authority', -> $authority {
    -> { self.set_attr('$!authority', $authority) }.do_if($authority.not_nil);
});

::Module.add_method('identifier', -> {
    $output := self.get_attr('$!name');
    $output := self.get_attr('$!version').not_nil.cond(
                     -> { $output.concat('-').concat(self.get_attr('$!version')) },
                     -> { $output }
               );
    $output := self.get_attr('$!authority').not_nil.cond(
                     -> { $output.concat('-').concat(self.get_attr('$!authority')) },
                     -> { $output }
               ); 
    $output;
});

## ------------------------------------------------------------------------- ##
## Role
## ------------------------------------------------------------------------- ##

# ... coming eventually 

## ------------------------------------------------------------------------- ##
## Bootstrapping
## ------------------------------------------------------------------------- ##

::Class.set_attr('@!superclasses', [ ::Module ]);

::Module.set_attr('@!subclasses',  [ ::Class ]); 

# NOTE:
# not doing this made our prototype go into 
# endless recursion
::Class.set_attr('@!MRO', [ ::Class, ::Module, ::Package, ::Object ]);
::Object.set_attr('@!MRO', [ ::Object ]);

# NOTE:
# these attributes need to be added manually since
# ::Class would have inherited them, but couldn't 
# since they had not yet been defined. We also need
# to be sure we add them to the instance types as 
# well (no auto-vivification in the mini-lang ;)

::Class.add_attribute('$!name', nil);         ::Class.set_attr('$!name', nil);
::Class.add_attribute('$!namespace', nil);    ::Class.set_attr('$!namespace', {});
::Class.add_attribute('$!version', nil);      ::Class.set_attr('$!version', nil);
::Class.add_attribute('$!authority', nil);    ::Class.set_attr('$!authority', nil);
                                              
::Object.add_attribute('$!name', nil);        ::Object.set_attr('$!name', nil);
::Object.add_attribute('$!namespace', nil);   ::Object.set_attr('$!namespace', {});
::Object.add_attribute('$!version', nil);     ::Object.set_attr('$!version', nil);
::Object.add_attribute('$!authority', nil);   ::Object.set_attr('$!authority', nil);
                                              
::Package.add_attribute('$!name', nil);       ::Package.set_attr('$!name', nil);
::Package.add_attribute('$!namespace', nil);  ::Package.set_attr('$!namespace', {});
::Package.add_attribute('$!version', nil);    ::Package.set_attr('$!version', nil);
::Package.add_attribute('$!authority', nil);  ::Package.set_attr('$!authority', nil);
                                              
::Module.add_attribute('$!name', nil);        ::Module.set_attr('$!name', nil);
::Module.add_attribute('$!namespace', nil);   ::Module.set_attr('$!namespace', {});
::Module.add_attribute('$!version', nil);     ::Module.set_attr('$!version', nil);
::Module.add_attribute('$!authority', nil);   ::Module.set_attr('$!authority', nil);

# ... now we can name and version all our objects

::Class.set_name('Class');     ::Class.set_version('0.0.1');   ::Class.set_authority('url:pugscode.org');
::Object.set_name('Object');   ::Object.set_version('0.0.1');  ::Object.set_authority('url:pugscode.org');
::Package.set_name('Package'); ::Package.set_version('0.0.1'); ::Package.set_authority('url:pugscode.org');
::Module.set_name('Module');   ::Module.set_version('0.0.1');  ::Module.set_authority('url:pugscode.org');

## end bootstrapping ...
## ------------------------------------------------------------------------- ##

=pod

=head1 NAME

Perl 6 Meta-Model 

=head1 DESCRIPTION 

This is the bootstrap code for the Perl 6 Meta-Model using the Perl 6 
Object-Space mini-language. 

=head1 AUTHORS

Audrey Tang

Stevan Little 

=cut
