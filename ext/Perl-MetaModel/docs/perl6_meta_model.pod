=pod

=head1 Perl 6 Meta-Model

This document will attempt to codify the perl 6 meta-model. It is very
much still a work in progress and it's contents may change by the minute
at times.

=head1 The Perl 6 Object environment

The perl6 object environment will be a multi-layered environment which 
might look something like this:

 +-{Instance}-+ +---{Type}--+ +--{Class}--+ +--{MetaClass}--+
 |            | |           | |           | |               |
 |   ------   | |   -----   | |  -------  | |  -----------  |
 |  ( $foo )------>( Foo )----->( Class )---->( MetaClass ) |
 |   ------   | |   -----   | |  -------  | |  -----------  |
 |            | |::Foo      | |::Foo.meta | |::Foo.meta.meta|
 |            | |$foo.ref   | |           | |               |
 +------------+ +-----------+ +-----------+ +---------------+

The following describes some of the details of this leveled environment.

=over 4

=item B<each "level" is independant of the levels above and below it>

Relationships such as "is a", "does a", etc only make sense within a
particular level of the object system.  So, for example, it does not
make sense to describe all of these objects as descending from some
I<Ã¼ber>-Object class.  Rules and principles that apply on one level do
not necessarily transfer to the levels below.

To a type system freak, you could say that each level is seperated by
exactly one lamdba; that is, the distance between a type and a value.
By starting with a solid type definition at some level arbitrarily
designated as the "top", it is possible (in principle, at least) to
induct the lamdba calculus safely down to the lower levels.  This is
important when writing I<type-safe> compilers that are capable of
mutating their object systems at any time.

=item B<each "level" looks like Objects from Perl>

Despite this inherant heterogeneity of each level, they all look like
Objects from Perl.  They are described and accessed in exactly the
same way, and can even share type definitions and refer to each other,
to some extent.

Note that references "between" levels may inhibit the capability of the
code to be compiled so far as to run without an interpreter.

To summarise the above two principles in code;

In the below table,

   $foo = MyClass.new
   $type = ::MyClass;
   $meta = MyClass.meta;
   $meta_meta = MyClass.meta.meta;

 Topic:          $foo       $type      $meta     $meta_meta
 .ref          ::MyClass   ::Type     ::Class  ::Meta::Class
 .isa(Object)      true     false      false      false
 .does(Object)     true     true       true       true
 .isa(MyClass)     true     true       false      false
 .does(MyClass)    true     true       false      false
 .isa(Class)       false    false      true       false
 .does(Class)      false    true       true       true
 .isa(Meta::Class) false    false      false      true
 .does(Meta::Class)false    false      false      true
 .meta             dies     $meta    $meta_meta   dies(*)

(*) - this might return magic proxy objects that go on
forever, but this is not required for core operation.

Even the above is in an ideal situation; it might be that
with some weird MetaModels, you simply don't get those
guarantees.  However, such situations are probably a bit
'obstruese' so won't be mentioned further.

=back

=head2 Occupants of the Perl6 object environment
 
=over 4

=item B<Every C<Object> is an instance of some C<Class>>

These are the occupants of our environment B<O>.  Every noted
C<Object> has a uniquely associated entity called a C<Class>.

99% of code will be using C<Objects> for absolutely everything.

=item B<Every C<Class> is an instance of a C<MetaClass>>

These objects are what would normally be described as your program's
I<Model>; ie, objects that are I<Classes> (or I<Roles>, etc) will be
called "Dog", "Tree", etc.

When you write:

  class Dog {
  }

You are actually doing something like this;

  Class.new(name => Dog).apply;   # FIXME perl6ify

This is because the term C<Class> actually refers to a C<MetaClass>,
not a C<Class>.  There is nothing special about the term C<Class> that
makes it so, other than it was defined so.  If we had chosen the term
C<Qualifarniciferate> to refer to instances of C<MetaClasses>, then
the above would simply create an object of class (sorry,
Qualifarniciferate) C<Class>.

C<Class> objects are presented to Perl in much the same manner as
instances of some C<Class> called C<MetaClass> might be.  This might
fool you into thinking that they are also instances of some C<Class>,
however in truth they are only ever instances of C<MetaClass> objects.

=item B<Every C<MetaClass> is an instance of some C<MetaMetaClass>>

These objects are what would normally be described as your B<language>
I<Model>, or program I<Meta-Model>.  These will be called "Class",
"Role", etc.

It is these objects that implement methods like C<.isa>, C<.does>,
etc.  They will almost certainly provide proxy methods in the C<Class>
objects that they produce, that when compiled will produce the desired
behaviour.

=item B<Every I<MetaMetaClass> is an instance of the underlying system>

In theory, we could extend this relationship to any level.  However,
it simply does not make much sense to deal with these objects
directly; they might be Haskell definitions in the case of C<pugs>, or
perhaps in a Pure Perl Interpreter they will actually be real
C<Object>s; but you will not see the definition of C<MetaMetaClass> in
this module; in a sense, Perl 6 classes are being used as an
underlying I<Meta-Meta-Model>.

=back

=head2 Preserved from F<t/12_Perl_Meta_Class_methods.t>

    # what's a nice real-world example of a method that can be called on
    # the Model?

    # Well, .new(), .isa(), .meta(), .addMethod(), etc of course!

    # so what the hell is $mmc.new doing?  Creating a new Role, of
    # course!  this is very similar to putting the method in Role::new().
    # This method would be called by Perl when you go class { } at compile
    # time; it is NOT the default new() method for user classes.
    my $new = Perl::Meta::Method.new( # what it does exactly I'm not sure ;)
    				);

    # you might note that this can't accept a string; we need MMD for
    # that.  We do not need to complicate the M3 layer with it.

    # In a sense, the "signature" of the call is actually the key, not
    # just the method name.  But let's prototype what we can first.

    # but the lack of MMD at this level doesn't mean that the interface
    # presented to the final layer need be so strict.  In fact, we could
    # even call name the methods differently on each level, and return
    # "Facade" objects that query/manipulate the objects on the lower
    # levels that perform the actual work.
    my $isa = Perl::Meta::Method.new
        (code => sub($self: Perl::Meta::Class $other) returns Bool {
    	$self.allSuperclasses.grep :{ $other =:= $self }
        });

    my $meta = Perl::Meta::Method.new
        ( code => sub returns Any {
    	# should this return a Perl::Meta::Class, or merely a facade
    	# for Perl::Meta::Class that expresses it in terms of `Role'
    	# objects?
    	return Perl::Meta::Class;
          },
        );
 
=head2 Comments from t/11_Perl_Meta_Class_properties.t

    # note that properties of classes are called Class traits.

    # So, when you *define* a trait, it modifies the MetaModel to add the
    # possibility of the property.

    # When you *attach* a trait to a class at compile time, it modifies
    # the Model.

    # When you *attach* a trait to a class at run time, it modifies the
    # Model, possibly by making new minimal sub-class/role objects, and
    # then marks that object as being in that new minimal sub-class.

=head1 AUTHORS

Sam Vilain E<lt>samv@cpan.orgE<gt>

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=cut
