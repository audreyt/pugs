# This document is in Kwid format.  To read this, use a Kwid formatter,
# like "perl6doc perlkwid".

# This document was stolen directly from perlpod.pod. Making a diff between
# the two documents is one way to see how Pod and Kwid compare.

=kwid

= NAME

perlkwid - the Kwiki Documentation format

= DESCRIPTION

Kwid is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules. It was inspired by the Kwiki
wiki markup language.

# XXX a white lie for now :)
Translators are available for converting Kwid to various formats
like plain text, HTML, man pages, Pod, and more.

Kwid markup consists of three basic kinds of paragraphs:
[ordinary|Ordinary Paragraph],
[verbatim|Verbatim Paragraph], and 
[command|Command Paragraph].

== Ordinary Paragraph

Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.

You can use formatting codes in ordinary paragraphs, for *bold*,
/italic/, `code-style`, [perlfaq|hyperlinks], and more. Such codes are
explained in the "[Formatting Codes]" section, below.

== Verbatim Paragraph

Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.

A verbatim paragraph is distinguished by having a sequence of
spaces/tabs at the beginning of all its lines. Leading tabs are
converted to spaces on an 8-column boundary. Intermediate blank lines
count regardless of the number of spaces in them. Leading spaces are
stripped off of all lines one space at a time until one of the lines is
flush left. The remaining content should be reproduced exactly, with
tabs assumed to be on 8-column boundaries. There are no special
formatting codes, so you can't italicize or anything like that. A \
means \, and nothing else.

== Command Paragraph

A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.

All command paragraphs (which are typically only one line long) start
with "=", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are

    # A comment line
    = Heading Level 1 (Most prominent)
    == Heading Level 2
    === Heading Level 3
    ==== Heading Level 4 (Least prominent)
    * unordered list item
    + ordered list item
    # Start a block of type 'foo'
    .foo
    # End a block of type 'foo' (same as start tag)
    .foo.

To explain them each in detail:

* `# A comment line`

A comment line is thrown away by the Kwid parser. It is used by the Kwid
author to annotate the markup, or to temporarily /turn off/ lines of Kwid.

Another way to do block comments is like this:

    .comment
    == Some Heading

    Some text
    .comment.

=over

* `= Heading Level 1`
* `== Heading Level 2`
* `=== Heading Level 3`
* `==== Heading Level 4`

`=` through `====` produce headings, `=` being the highest level.
The text in the rest of this line is the content of the heading.
For example:

  == Object Attributes

The text "Object Attributes" comprises the heading there. The text in
these heading commands can use formatting codes, as seen here:

  == Possible Values for `$/`

Such commands are explained in the "[Formatting Codes]" section, below.

* `* unordered list item`
* `+ ordered list item`

These formats require little explanation: `*` is for bulleted list
items, and '+' is for ordered list items. In the /stuff/ in `* unordered
list item`, you may use formatting codes, as seen here:

  * Using `$|` to Control Buffering

Such commands are explained in the "[Formatting Codes]" section, below.

Note also that there are no silly rules to using lists (like in Pod).

* `=cut`

To end a Kwid block in Perl code, use a line beginning with "=cut". This
lets Perl (and the Kwid formatter) know that this is where Perl code is
resuming. 

* `=kwid`

The "=kwid" command by itself doesn't do much of anything, but it
signals to Perl (and Kwid formatters) that a Kwid block starts here.
For example:

  =kwid
  === stuff()

  This function does stuff.

  =cut

  sub stuff {
    ...
  }

  =kwid

  Remember to check its return value, as in:

    stuff() || die "Couldn't do stuff!";

  =cut

* `.formatname`
* `.formatname.`

`.formatname` and `.formatname.` will let you have regions of
text/code/data that are not generally interpreted as normal Kwid text,
but are passed directly to particular formatters, or are otherwise
special. A formatter that can use that format will use the region,
otherwise it will be completely ignored.

A command ".formatname", some paragraphs, and a
command ".formatname.", mean that the text/data inbetween
is meant for formatters that understand the special format
called /formatname/.  For example,

  .html
  <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>
  .html.

Here are some examples of how to use this:

  .html
  <br>Figure 1.<br><IMG SRC="figure1.png"><br>
  .html.

  .text
    ---------------
    |  foo        |
    |        bar  |
    ---------------

  ^^^^ Figure 1. ^^^^
  .text.

  .comment
  These lines are
  ignored.
  .comment.

  .over 4
  This text will be indented four spaces.
  .over 4.

The text for the beginning and ending markers is always the same, but
the ending marker ends with a period. Formatted blocks that have no
ending marker are assumed to go to the end of the available Kwid text
within that scope. (They cannot go past an `=cut` directive.)

Some formats like `.over` can take extra arguments. (In this case, the
number of spaces of 'ems' to indent.

Note the ending marker can take the same arguments as the beginning
marker. This is optional, but if the arguments are present on the ending
marker, they must exactly match the beginning marker. (This technique
can be used creatively to nest blocks of the same format, by passing
them different arguments.)

Some format names that formatters currently are known to accept
include "roff", "man", "latex", "tex", "text", and "html".  (Some
formatters will treat some of these as synonyms.)

A format name of "comment" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Kwid
document:

  .comment
  Make sure that all the available options are documented!
  .comment.

Same as:

  # Make sure that all the available options are documented!

* `.encoding encodingname`

This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII or Latin-1,
then put a `.encoding encodingname` command early in the document so
that pod formatters will know how to decode the document.  For
/encodingname/, use a name recognized by the [Encode::Supported]
module.  Examples:

  .encoding utf8

  .encoding koi8-r
  
  .encoding ShiftJIS
  
  .encoding big5

And don't forget, when using any command, that the command lasts up
until the end of its /line/, not its paragraph (like in Pod). So in the
examples below, you can see that every command doesn't need a blank
line after it, to end its paragraph.

Some examples of lists include:

  * First item
  * Second item
  .over
  Foo() - Description of Foo function
  Bar() - Description of Bar function
  .over.

== Formatting Codes

In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. "interior sequences") can be used:

.comment
 "interior sequences" is such an opaque term.
 Prefer "formatting codes" instead.
.comment.

* `/text/` -- italic text

Used for emphasis ("`be /careful!/`") and parameters ("`redo /LABEL/`")

*  `*text*` -- bold text

Used for switches ("`perl's *-n* switch`"), programs ("`some systems
provide a *chfn* for that`"), emphasis ("`be *careful!*`"), and so on
("`and that feature is known as *autovivification*`").

* `` `code` `` -- code text

Renders code in a typewriter font, or gives some other indication that
this represents program text ("`` `gmtime($^T)` ``") or some other
form of computerese ("`` `drwxr-xr-x` ``").

* `[name]` -- a hyperlink

There are various syntaxes, listed below. In the syntaxes given, `text`,
`name`, and `section` cannot contain the characters '/' and '|'; and any
'<' or '>' should be matched.

.over
* `[name]`

Link to a Perl manual page (e.g., `[Net::Ping]`). Note that `name`
should not contain spaces. This syntax is also occasionally used for
references to UNIX man pages, as in `[crontab(5)]`.

* `[name/sec]`

Link to a section in other manual page.  E.g., `[perlsyn/For Loops]`

* `[/sec]` or `[sec]`

Link to a section in this manual page.  E.g.,
`[Object Methods]`
.over.

A section is started by the named heading or item. For example,
`[perlvar/$.]` links to the section started by "`== $.`" in perlvar.
And `[perlsyn/For Loops]` links to the section started by `== For
Loops` in perlsyn.

To control what text is used for display, you use "`[text|...]`", as in:

* `[text|name]`

Link this text to that manual page. E.g., `[Perl Error Messages|perldiag]`.

* `[text|name/sec]`

Link this text to that section in that manual page.  E.g.,
`[SWITCH statements|perlsyn/Basic BLOCKs and Switch Statements]`

* `[text|/sec]`

Link this text to that section in this manual page.  E.g.,
`[the various attributes|/Member Data]`

Or you can link to a web page:

* `scheme://...`

or

* `[scheme:...]`

Links to an absolute URL.  For example, `http://www.perl.org`. 
Unlike with Pod, you can also do a named link:

    [text|scheme:...]

* `&escape;` -- a character escape

Exactly similar to HTML/XML `&foo;` "entity references":


















# XXX
OK, I am half way through this Pod to Kwid conversion. I think it is
going quite well. Kwid is much easier to read and write so far. But
there is a definite mess and smell to this POD stuff. Do I want to
support it all? Sleep will help me decide...

Some problems so far.

Kwiki lists are generally one line per item. Pod is not such. Nesting Pod
type lists makes it obvious why there is the whole:
  =over
  =item
  =item
  =back
mess. It is not optimized for simple lists, but handles non-bulleted,
not-numbered list like things. I will have to look at the generated HTML of
pod2html to grok what is really intended. 

I imagine a solution like this:

.list
- widget()
The widget function does this...
- gadget()
The gadget function does that...
.list 2
- gadget(Int)
The int form does blah...
- gadget(Str)
The str form does blech...
.list 2.
.list.

Also the *bold* and /italic/ formats will have {*bold*} and {/italic/} forms
for when things get hairy...

More tommorrow...














=over

=item *

C<EE<lt>ltE<gt>> -- a literal E<lt> (less than)

=item *

C<EE<lt>gtE<gt>> -- a literal E<gt> (greater than)

=item *

C<EE<lt>verbarE<gt>> -- a literal | (I<ver>tical I<bar>)

=item *

C<EE<lt>solE<gt>> = a literal / (I<sol>idus)

The above four are optional except in other formatting codes,
notably C<LE<lt>...E<gt>>, and when preceded by a
capital letter.

=item *

C<EE<lt>htmlnameE<gt>>

Some non-numeric HTML entity name, such as C<EE<lt>eacuteE<gt>>,
meaning the same thing as C<&eacute;> in HTML -- i.e., a lowercase
e with an acute (/-shaped) accent.

=item *

C<EE<lt>numberE<gt>>

The ASCII/Latin-1/Unicode character with that number.  A
leading "0x" means that I<number> is hex, as in
C<EE<lt>0x201EE<gt>>.  A leading "0" means that I<number> is octal,
as in C<EE<lt>075E<gt>>.  Otherwise I<number> is interpreted as being
in decimal, as in C<EE<lt>181E<gt>>.

Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin-1 characters, like
rendering C<EE<lt>eacuteE<gt>> as just a plain "e".)

=back

=item C<FE<lt>filenameE<gt>> -- used for filenames

Typically displayed in italics.  Example: "C<FE<lt>.cshrcE<gt>>"

=item C<SE<lt>textE<gt>> -- text contains non-breaking spaces

This means that the words in I<text> should not be broken
across lines.  Example: S<C<SE<lt>$x ? $y : $zE<gt>>>.

=item C<XE<lt>topic nameE<gt>> -- an index entry

This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: C<XE<lt>absolutizing relative URLsE<gt>>

=item C<ZE<lt>E<gt>> -- a null (zero-effect) formatting code

This is rarely used.  It's one way to get around using an
EE<lt>...E<gt> code sometimes.  For example, instead of
"C<NEE<lt>ltE<gt>3>" (for "NE<lt>3") you could write
"C<NZE<lt>E<gt>E<lt>3>" (the "ZE<lt>E<gt>" breaks up the "N" and
the "E<lt>" so they can't be considered
the part of a (fictitious) "NE<lt>...E<gt>" code.

=for comment
 This was formerly explained as a "zero-width character".  But it in
 most parser models, it parses to nothing at all, as opposed to parsing
 as if it were a E<zwnj> or E<zwj>, which are REAL zero-width characters.
 So "width" and "character" are exactly the wrong words.

=back

Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an C<E> code:

    C<$a E<lt>=E<gt> $b>

This will produce: "C<$a E<lt>=E<gt> $b>"

A more readable, and perhaps more "plain" way is to use an alternate
set of delimiters that doesn't require a single ">" to be escaped.  With
the Pod formatters that are standard starting with perl5.5.660, doubled
angle brackets ("<<" and ">>") may be used I<if and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!>  For example, the following will
do the trick:

    C<< $a <=> $b >>

In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:

    C<<< $a <=> $b >>>
    C<<<<  $a <=> $b     >>>>

And they all mean exactly the same as this:

    C<$a E<lt>=E<gt> $b>

As a further example, this means that if you wanted to put these bits of
code in C<C> (code) style:

    open(X, ">>thing.dat") || die $!
    $foo->bar();

you could do it like so:

    C<<< open(X, ">>thing.dat") || die $! >>>
    C<< $foo->bar(); >>

which is presumably easier to read than the old way:

    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
    C<$foo-E<gt>bar();>

This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.

=head2 The Intent

The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through C<fmt> easily to reformat
them (that's F7 in my version of B<vi>, or Esc Q in my version of
B<emacs>).  I wanted the translator to always leave the C<'> and C<`> and
C<"> quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.

The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, HTML,
TeX, and other markup languages, as used for online
documentation.  Translators exist for B<pod2text>, B<pod2html>,
B<pod2man> (that's for nroff(1) and troff(1)), B<pod2latex>, and
B<pod2fm>.  Various others are available in CPAN.


=head2 Embedding Pods in Perl Modules

You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an __END__ or __DATA__ cut mark, make sure to put an
empty line there before the first Pod command.

  __END__

  =head1 NAME

  Time::Local - efficiently compute time from local and GMT time

Without that empty line before the "=head1", many translators wouldn't
have recognized the "=head1" as starting a Pod block.

=head2 Hints for Writing Pod

=over

=item *

The B<podchecker> command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.

=item *

If you're more familiar with writing in HTML than with writing in Pod, you
can try your hand at writing documentation in simple HTML, and converting
it to Pod with the experimental L<Pod::HTML2Pod|Pod::HTML2Pod> module,
(available in CPAN), and looking at the resulting code.  The experimental
L<Pod::PXML|Pod::PXML> module in CPAN might also be useful.

=item *

Many older Pod translators require the lines before every Pod
command and after every Pod command (including "=cut"!) to be a blank
line.  Having something like this:

 # - - - - - - - - - - - -
 =item $firecracker->boom()

 This noisily detonates the firecracker object.
 =cut
 sub boom {
 ...

...will make such Pod translators completely fail to see the Pod block
at all.

Instead, have it like this:

 # - - - - - - - - - - - -

 =item $firecracker->boom()

 This noisily detonates the firecracker object.

 =cut

 sub boom {
 ...

=item *

Some older Pod translators require paragraphs (including command
paragraphs like "=head2 Functions") to be separated by I<completely>
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.

=item *

Older translators might add wording around an LE<lt>E<gt> link, so that
C<LE<lt>Foo::BarE<gt>> may become "the Foo::Bar manpage", for example.
So you shouldn't write things like C<the LE<lt>fooE<gt>
documentation>, if you want the translated document to read sensibly
-- instead write C<the LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or
C<LE<lt>the Foo::Bar documentation|Foo::BarE<gt>>, to control how the
link comes out.

=item *

Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.

=back

=head1 SEE ALSO

L<perlpodspec>, L<perlsyn/"PODs: Embedded Documentation">,
L<perlnewmod>, L<perldoc>, L<pod2html>, L<pod2man>, L<podchecker>.

=head1 AUTHOR

Larry Wall, Sean M. Burke

=cut
