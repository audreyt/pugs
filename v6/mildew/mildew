#!/usr/local/bin/perl

use lib '../../src/perl6';
use lib 'src';
use STD;
use AST;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
use strict;
use warnings;
use Getopt::Long;
use Carp 'confess';

$::ACTIONS = 'Actions';
{package Actions;
    our $AUTOLOAD;
    sub AUTOLOAD {
        my $self=shift;
        my $match=shift;
        if ($AUTOLOAD =~ /^Actions::scope_declarator.*my/) {
            warn "action $AUTOLOAD\n";
            $match->{''} = 'my';
        }
    }
}
my ($debug,$file);
GetOptions("file=s"=>\$file,"debug"=>\$debug);

sub XXX {
    confess 'unimplemented'
}
sub integer {
    my $m = shift;
    #XXX non-base 10
    AST::IntegerConstant->new(value=>$m->text);
}
sub scope_declarator {
    my $m = shift;
    if ($m->{''} eq 'my') {
        if (my $decl = $m->{scoped}{declarator}) {
            if (my $var_decl = $decl->{variable_declarator}) {
                AST::Call->new(
                    identifier => AST::StringConstant->new(value=>'STORE'),
                    capture => AST::Capture->new(
                        invocant => AST::Call->new(
                            identifier => AST::StringConstant->new(value=>'postcircumfix:{ }'),
                            capture => AST::Capture->new(invocant=>AST::Reg->new(name=>'scope'),positional=>[AST::StringConstant->new(value=>$m->text)],named=>[])
                        ),
                        positional => [
                            AST::Call->new(
                                identifier => AST::StringConstant->new(value=>'new'),
                                invocant => AST::Reg->new(name=>'$Scalar'),
                            )
                        ]
                    ),
                );
            }
        }
    } else {
        XXX;
    }
}
sub noun {
    my $m = shift;
    if ($m->{variable}) {
        variable($m->{variable});
    } elsif ($m->{value}) {
        value($m->{value});
    } elsif ($m->{routine_declarator}) {
        if ($m->{routine_declarator}{routine_def}) {
            routine_def($m->{routine_declarator}{routine_def});
        } else {
            XXX;
        }
    } elsif ($m->{term}) {
        term($m->{term});
    } elsif ($m->{scope_declarator}) {
        scope_declarator($m->{scope_declarator});
    } else {
        XXX;
    }
}
sub term {
    my $m = shift;
    if ($m->{identifier} && $m->{args}) {
        my $func = AST::Call->new(
            identifier=>AST::StringConstant->new(value=>'lookup'),
            capture=>AST::Capture->new(invocant=>AST::Reg->new(name=>'scope'),positional=>[AST::StringConstant->new(value=>'&'.$m->{identifier}->text)],named=>[]),
        );
        AST::Call->new(identifier=>AST::StringConstant->new(value=>'postcircumfix:( )'),capture=>AST::Capture->new(invocant=>$func,positional=>args($m->{args})));
    }
}
sub args {
    my $m = shift;
    return [map {EXPR($_->{EXPR})} @{$m->{arglist}}];
}
sub routine_def {
    my $m = shift;
    AST::Call->new(identifier=>AST::StringConstant->new(value => 'new'),
        capture => AST::Capture->new(
            invocant => AST::Reg->new(name=>'Code'),
            positional => [],
            named => [
                AST::StringConstant->new(value=>'mold') => block($m->{block}),
                AST::StringConstant->new(value=>'outer') => AST::Reg->new(name=>'$scope')
            ]
        ),
    );
}
sub block {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>statementlist($m->{in}{statementlist}));
}
sub value {
    my $m = shift;
    if ($m->{number}) {
        number($m->{number});
    } elsif ($m->{quote}) {
        quote($m->{quote});
    } else {
        warn Dump($m->{number});
        warn Dump($m);
        XXX;
    }
}
sub quote {
    my $m = shift;
    #XXX
    my $text = $m->{nibble}->text;
    AST::StringConstant->new(value=>$text);
}
sub number {
    my $m = shift;
    if ($m->{integer}) {
        integer($m->{integer});
    } else {
        XXX;
    }
}
sub variable {
    my $m = shift;
    AST::Call->new(
        identifier=>AST::StringConstant->new(value=>'lookup'),
        capture=>AST::Capture->new(invocant=>AST::Reg->new(name=>'scope'),positional=>[AST::StringConstant->new(value=>$m->text)],named=>[]),
    );
}
sub dottyop {
    my ($noun,$m) = @_;
    if ($m->{methodop}) {
        methodop($noun,$m->{methodop});
    } else {
        XXX
    }
}
sub dotty {
    my ($noun,$m) = @_;
    #XXX .*foo
    if ($m->{dottyop}) {
        dottyop($noun,$m->{dottyop});
    } else {
        XXX
    }
}
sub FETCH {
    my $arg = shift;
    AST::Call->new(capture=>AST::Capture->new(invocant=>$arg),identifier=>AST::StringConstant->new(value=>'FETCH'));
}
sub methodop {
    my ($noun,$m) = @_;
    if ($m->{longname}) {
        my $pos0 = $m->{in}[0]{semilist}{statement}[0];
        AST::Call->new(
            identifier=>AST::StringConstant->new(value=>$m->{longname}->text),
            capture=>AST::Capture->new(invocant=>FETCH($noun),positional=>[FETCH(EXPR($pos0->{EXPR}))],named=>[]),
        
        );
    } else {
        XXX
    }
}
sub EXPR {
    my $m = shift;
    if ($m->{noun}) {
        my $noun = noun($m->{noun});
        if ($m->{post}) {
            for (@{$m->{post}}) {
                if ($_->{dotty}) {
                    $noun = dotty($noun,$_->{dotty});
                } else {
                    XXX
                }
            }
            $noun;
        } else {
            $noun;
        }
    }
}
sub statement {
    my $m = shift;
    if ($m->{label}) {
        AST::Label->new(label=>label($m->{label}),stmt=>statement($m->{statement}));
    } elsif ($m->{statement_control}) {
    } elsif ($m->{EXPR}) {
        EXPR($m->{EXPR});
    } else {
    }
}
sub comp_unit {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>statementlist($m->{statementlist}));
}
sub statementlist {
    my $m = shift;
    [map {statement $_} @{$m->{statement}}]
}
unless ($file) {
    die "usage [--debug] --file filename\n"
}
my $r = STD->parsefile($file,'comp_unit');
print dump_match('comp_unit'=>$r,{vertical=>1,mark_arrays=>1,visit_twice=>1}),"\n" if $debug;
my $mold = comp_unit($r);
use YAML::XS;
print Dump($mold) if $debug;
print <<'BOILERPLATE';
my $void;
my $scope = ?SMOP__S1P__LexicalScope."new"();

my $OUT_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("$*OUT");
my $OUT_root = $OUT_root_scalar."FETCH"();
my $OUT_scalar = $scope."postcircumfix:{ }"("$OUT");
$void = $OUT_scalar."STORE"($OUT_root);

my $Code_scalar = $scope."postcircumfix:{ }"("Code");
my $Code_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("::Code");
my $Code = $Code_root_scalar."FETCH"();
$void = $Code_scalar."STORE"($Code);

my $Scalar_scalar = $scope."postcircumfix:{ }"("Scalar");
my $Scalar_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("::Scalar");
my $Scalar = $Scalar_root_scalar."FETCH"();
$void = $Scalar_scalar."STORE"($Scalar);

BOILERPLATE
print $mold->emit_('$main');
print <<'CALL_MAIN';
my $main_code = $Code."new"(:"outer"($scope),:"mold"($main));
my $void = $main_code."postcircumfix:( )"();
CALL_MAIN

