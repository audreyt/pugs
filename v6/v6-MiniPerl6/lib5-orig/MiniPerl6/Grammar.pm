# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package MiniPerl6::Grammar;
sub new { bless { @_ }, "MiniPerl6::Grammar" }
use MiniPerl6::Grammar::Regex;
sub array { my $data = $_[0]; use v5; @{$data}; use v6 };
my $Class_name;
sub full_ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && ((('::'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } }) || 1))); return($MATCH) };
sub to_line_end { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\N'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } }) || 1)); return($MATCH) };
sub pod_begin { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\n'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('='
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } }))))) || ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } } && do { my $m2 = $grammar->pod_begin($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_begin'
} = $m2;1 } else { 0 } } })))); return($MATCH) };
sub pod_other { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\n'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('='
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('c'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } }))))) || ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } } && do { my $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_other'
} = $m2;1 } else { 0 } } })))); return($MATCH) };
sub ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((((('#'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'to_line_end'
} = $m2;1 } else { 0 } } }) || ((('\\\\n'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('='
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ((('b'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('g'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('i'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->pod_begin($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_begin'
} = $m2;1 } else { 0 } } }))))) || ((('k'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('w'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('i'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_other'
} = $m2;1 } else { 0 } } })))) || ((('p'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_other'
} = $m2;1 } else { 0 } } }))) || ((('f'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_other'
} = $m2;1 } else { 0 } } }))) || (('h'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('1'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'pod_other'
} = $m2;1 } else { 0 } } }))))))))))) || (('\\\\n'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('\\\\s'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0))))) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } || 1))); return($MATCH) };
sub opt_ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } || 1)); return($MATCH) };
sub opt_ws2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } || 1)); return($MATCH) };
sub opt_ws3 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } || 1)); return($MATCH) };
sub parse { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->comp_unit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'comp_unit'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && (do { my $m2 = $grammar->parse($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parse'
} = $m2;1 } else { 0 } } } && do { return([${$MATCH->{'comp_unit'
}}, array(${$MATCH->{'parse'
}})]) }))) || (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([${$MATCH->{'comp_unit'
}}]) })))) || do { return([]) })); return($MATCH) };
sub comp_unit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (('v'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('6'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('-'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } })))))))))) || 1) && (((('c'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('l'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))))) || (('g'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('m'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('m'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))))))) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { $Class_name = ("" . $MATCH->{'full_ident'
}) } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && do { return(CompUnit->new( 'name'
 => ${$MATCH->{'full_ident'
}},'attributes'
 => {  },'methods'
 => {  },'body'
 => ${$MATCH->{'exp_stmts'
}}, )) })))))))))))))); return($MATCH) };
sub infix_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('+'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('-'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('*'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('/'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || ((('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('q'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || ((('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || (('=='
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('!='
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('&&'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('||'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('~~'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('~'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))))))))))))); return($MATCH) };
sub hyper_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('>>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || 1)); return($MATCH) };
sub prefix_op { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('$'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('@'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('%'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('?'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('++'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('--'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('+'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || (('-'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || ('~'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))))))))) && (('('
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || ('$'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))); return($MATCH) };
sub declarator { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('m'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('y'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || ((('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))))) || (('h'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))))); return($MATCH) };
sub exp2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'exp'
}}) })); return($MATCH) };
sub exp_stmts2 { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'exp_stmts'
}}) })); return($MATCH) };
sub exp { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->term_meth($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term_meth'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('??'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('!!'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp2'
} = $m2;1 } else { 0 } } } && do { return(Apply->new( 'code'
 => 'ternary:<?? ::>'
,'arguments'
 => [${$MATCH->{'term_meth'
}}, ${$MATCH->{'exp'
}}, ${$MATCH->{'exp2'
}}], )) })))))) || do { Main::say('*** Syntax error in ternary operation'
) }))) || ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->infix_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'infix_op'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && do { return(Apply->new( 'code'
 => ('infix:<'
 . ${($MATCH->{'infix_op'
} . '>'
)}),'arguments'
 => [${$MATCH->{'term_meth'
}}, ${$MATCH->{'exp'
}}], )) })))) || ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ((':='
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && do { return(Bind->new( 'parameters'
 => ${$MATCH->{'term_meth'
}},'arguments'
 => ${$MATCH->{'exp'
}}, )) })))) || do { return(${$MATCH->{'term_meth'
}}) }))))); return($MATCH) };
sub term_meth { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && (('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->hyper_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'hyper_op'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && (((('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))) || ((('\\\\:'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }))) || do { return(Call->new( 'invocant'
 => Proto->new( name() => ("" . $MATCH->{'full_ident'
}), ),'method'
 => ${$MATCH->{'ident'
}},'arguments'
 => (undef),'hyper'
 => ${$MATCH->{'hyper_op'
}}, )) })) && do { return(Call->new( 'invocant'
 => Proto->new( name() => ("" . $MATCH->{'full_ident'
}), ),'method'
 => ${$MATCH->{'ident'
}},'arguments'
 => ${$MATCH->{'exp_seq'
}},'hyper'
 => ${$MATCH->{'hyper_op'
}}, )) }))))) || (do { my $m2 = $grammar->term($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term'
} = $m2;1 } else { 0 } } } && ((('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->hyper_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'hyper_op'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && (((('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))) || ((('\\\\:'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }))) || do { return(Call->new( 'invocant'
 => ${$MATCH->{'term'
}},'method'
 => ${$MATCH->{'ident'
}},'arguments'
 => (undef),'hyper'
 => ${$MATCH->{'hyper_op'
}}, )) })) && do { return(Call->new( 'invocant'
 => ${$MATCH->{'term'
}},'method'
 => ${$MATCH->{'ident'
}},'arguments'
 => ${$MATCH->{'exp_seq'
}},'hyper'
 => ${$MATCH->{'hyper_op'
}}, )) })))) || ((('\\\\['
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\]'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Index->new( 'obj'
 => ${$MATCH->{'term'
}},'index'
 => ${$MATCH->{'exp'
}}, )) }))))) || ((('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Lookup->new( 'obj'
 => ${$MATCH->{'term'
}},'index'
 => ${$MATCH->{'exp'
}}, )) }))))) || do { return(${$MATCH->{'term'
}}) })))))); return($MATCH) };
sub sub_or_method_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && ((('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } }) || 1))); return($MATCH) };
sub term { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->prefix_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'prefix_op'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && do { return(Apply->new( 'code'
 => ('prefix:<'
 . ${($MATCH->{'prefix_op'
} . '>'
)}),'arguments'
 => [${$MATCH->{'exp'
}}], )) })) || ((('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(${$MATCH->{'exp'
}}) }))))) || ((('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_mapping($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_mapping'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Lit::Hash->new( 'hash'
 => ${$MATCH->{'exp_mapping'
}}, )) }))))) || ((('\\\\['
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\]'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Lit::Array->new( 'array'
 => ${$MATCH->{'exp_seq'
}}, )) }))))) || ((('\\\\$'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('\\\\<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->sub_or_method_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sub_or_method_name'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Lookup->new( 'obj'
 => Var->new( 'sigil'
 => '$'
,'twigil'
 => ''
,'name'
 => '/'
, ),'index'
 => Val::Buf->new( 'buf'
 => ${$MATCH->{'sub_or_method_name'
}}, ), )) })))) || ((('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Do->new( 'block'
 => ${$MATCH->{'exp_stmts'
}}, )) })))))))) || ((do { my $m2 = $grammar->declarator($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'declarator'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'
} = $m2;1 } else { 0 } } } && do { return(Decl->new( 'decl'
 => ${$MATCH->{'declarator'
}},'var'
 => ${$MATCH->{'var'
}}, )) }))) || ((('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && (((('-'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } }) || 1) && do { return(Use->new( 'mod'
 => ${$MATCH->{'full_ident'
}}, )) })))))) || ((do { my $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'var'
}}) }) || ((do { my $m2 = $grammar->val($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val'
}}) }) || ((do { my $m2 = $grammar->lit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'lit'
}}) }) || ((do { my $m2 = $grammar->token($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'token'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'token'
}}) }) || ((do { my $m2 = $grammar->method($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'method'
}}) }) || ((do { my $m2 = $grammar->sub($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sub'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'sub'
}}) }) || (do { my $m2 = $grammar->control($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'control'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'control'
}}) })))))))))))))))); return($MATCH) };
sub control { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->ctrl_return($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ctrl_return'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'ctrl_return'
}}) }) || ((do { my $m2 = $grammar->ctrl_leave($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ctrl_leave'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'ctrl_leave'
}}) }) || ((do { my $m2 = $grammar->if($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'if'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'if'
}}) }) || ((do { my $m2 = $grammar->when($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'when'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'when'
}}) }) || ((do { my $m2 = $grammar->for($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'for'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'for'
}}) }) || ((do { my $m2 = $grammar->while($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'while'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'while'
}}) }) || (do { my $m2 = $grammar->apply($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'apply'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'apply'
}}) })))))))); return($MATCH) };
sub if { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('i'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('f'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('l'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts2'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(If->new( 'cond'
 => ${$MATCH->{'exp'
}},'body'
 => ${$MATCH->{'exp_stmts'
}},'otherwise'
 => ${$MATCH->{'exp_stmts2'
}}, )) }))))))))))) || do { return(If->new( 'cond'
 => ${$MATCH->{'exp'
}},'body'
 => ${$MATCH->{'exp_stmts'
}},'otherwise'
 => [], )) })))))))))))); return($MATCH) };
sub when { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('w'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('h'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(When->new( 'parameters'
 => ${$MATCH->{'exp_seq'
}},'body'
 => ${$MATCH->{'exp_stmts'
}}, )) }))))))))))))); return($MATCH) };
sub for { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('f'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('->'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(For->new( 'cond'
 => ${$MATCH->{'exp'
}},'topic'
 => ${$MATCH->{'var'
}},'body'
 => ${$MATCH->{'exp_stmts'
}}, )) })))))))))))))))); return($MATCH) };
sub while { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('w'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('h'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('i'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('l'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(While->new( 'cond'
 => ${$MATCH->{'exp'
}},'body'
 => ${$MATCH->{'exp_stmts'
}}, )) })))))))))))))); return($MATCH) };
sub ctrl_leave { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('l'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('v'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Leave->new(  )) })))))); return($MATCH) };
sub ctrl_return { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && do { return(Return->new( 'result'
 => ${$MATCH->{'exp'
}}, )) })))))))) || (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Return->new( 'result'
 => Val::Undef->new(  ), )) })))))))); return($MATCH) };
sub sigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('\\\\$'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\%'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\@'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('\\\\&'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))); return($MATCH) };
sub twigil { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\!'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\^'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('\\\\*'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0))))) || 1)); return($MATCH) };
sub var { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sigil'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->twigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'twigil'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } || (('/'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) || do { my $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digit'
} = $m2;1 } else { 0 } } })) && do { return(Var->new( 'sigil'
 => ("" . $MATCH->{'sigil'
}),'twigil'
 => ("" . $MATCH->{'twigil'
}),'name'
 => ("" . $MATCH->{'name'
}), )) })))); return($MATCH) };
sub val { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->val_undef($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_undef'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val_undef'
}}) }) || ((do { my $m2 = $grammar->val_int($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_int'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val_int'
}}) }) || ((do { my $m2 = $grammar->val_bit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_bit'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val_bit'
}}) }) || ((do { my $m2 = $grammar->val_num($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_num'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val_num'
}}) }) || (do { my $m2 = $grammar->val_buf($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_buf'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'val_buf'
}}) })))))); return($MATCH) };
sub val_bit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('T'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('r'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Val::Bit->new( 'bit'
 => 1, )) })))) || (('F'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('a'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('l'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Val::Bit->new( 'bit'
 => 0, )) }))))))); return($MATCH) };
sub val_undef { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('f'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Val::Undef->new(  )) })))))); return($MATCH) };
sub val_num { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return('TODO: val_num'
) })))); return($MATCH) };
sub double_quoted { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'
} = $m2;1 } else { 0 } } })) || ((1 && do { my $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'
} = $m2;1 } else { 0 } } }) || 1))); return($MATCH) };
sub single_quoted { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'
} = $m2;1 } else { 0 } } })) || ((1 && do { my $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'
} = $m2;1 } else { 0 } } }) || 1))); return($MATCH) };
sub digits { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('\\\\d'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digits'
} = $m2;1 } else { 0 } } } || 1))); return($MATCH) };
sub val_buf { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\"'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'
} = $m2;1 } else { 0 } } } && (('\\\\"'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Val::Buf->new( 'buf'
 => ("" . $MATCH->{'double_quoted'
}), )) }))) || (('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'
} = $m2;1 } else { 0 } } } && (('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Val::Buf->new( 'buf'
 => ("" . $MATCH->{'single_quoted'
}), )) }))))); return($MATCH) };
sub val_int { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digits'
} = $m2;1 } else { 0 } } } && do { return(Val::Int->new( 'int'
 => ("" . $MATCH), )) })); return($MATCH) };
sub exp_stmts { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([${$MATCH->{'exp'
}}, array(${$MATCH->{'exp_stmts'
}})]) })))))) || (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\;'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([${$MATCH->{'exp'
}}]) })))) || do { return([]) })); return($MATCH) };
sub exp_seq { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\,'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\,'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([${$MATCH->{'exp'
}}, array(${$MATCH->{'exp_seq'
}})]) })))))) || (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\,'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([${$MATCH->{'exp'
}}]) })))) || do { return([]) })); return($MATCH) };
sub exp_mapping { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('=>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\,'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_mapping($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_mapping'
} = $m2;1 } else { 0 } } } && do { return([[${$MATCH->{'key'
}}, ${$MATCH->{'value'
}}], array(${$MATCH->{'exp_mapping'
}})]) })))) || (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (((('\\\\,'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }) || 1) && do { return([[${$MATCH->{'key'
}}, ${$MATCH->{'value'
}}]]) })))))))) || do { return([]) })); return($MATCH) };
sub lit { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->lit_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_seq'
} = $m2;1 } else { 0 } } } || (do { my $m2 = $grammar->lit_array($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_array'
} = $m2;1 } else { 0 } } } || (do { my $m2 = $grammar->lit_hash($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_hash'
} = $m2;1 } else { 0 } } } || (do { my $m2 = $grammar->lit_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_code'
} = $m2;1 } else { 0 } } } || do { my $m2 = $grammar->lit_object($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_object'
} = $m2;1 } else { 0 } } })))) && do { return(${$MATCH->{'exp'
}}) })); return($MATCH) };
sub lit_seq { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return('TODO: lit_seq'
) })))); return($MATCH) };
sub lit_array { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return('TODO: lit_array'
) })))); return($MATCH) };
sub lit_hash { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return('TODO: lit_hash'
) })))); return($MATCH) };
sub lit_code { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return('TODO - Lit::Code'
) })))); return($MATCH) };
sub lit_object { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('::'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && (('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_mapping($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_mapping'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Lit::Object->new( 'class'
 => ${$MATCH->{'full_ident'
}},'fields'
 => ${$MATCH->{'exp_mapping'
}}, )) })))))))); return($MATCH) };
sub bind { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ((':='
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp2'
} = $m2;1 } else { 0 } } } && do { return(Bind->new( 'parameters'
 => ${$MATCH->{'exp'
}},'arguments'
 => ${$MATCH->{'exp2'
}}, )) })))))); return($MATCH) };
sub call { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'
} = $m2;1 } else { 0 } } } && (('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && (('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Call->new( 'invocant'
 => ${$MATCH->{'exp'
}},'method'
 => ${$MATCH->{'ident'
}},'arguments'
 => ${$MATCH->{'exp_seq'
}}, )) }))))))))); return($MATCH) };
sub apply { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'
} = $m2;1 } else { 0 } } } && (((('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))) || (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } }))) && do { return(Apply->new( 'code'
 => ${$MATCH->{'full_ident'
}},'arguments'
 => ${$MATCH->{'exp_seq'
}}, )) }))); return($MATCH) };
sub opt_name { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } || 1)); return($MATCH) };
sub invocant { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'
} = $m2;1 } else { 0 } } } && (('\\\\:'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(${$MATCH->{'var'
}}) })) || do { return(Var->new( 'sigil'
 => '$'
,'twigil'
 => ''
,'name'
 => 'self'
, )) })); return($MATCH) };
sub sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->invocant($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'invocant'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'
} = $m2;1 } else { 0 } } } && do { return(Sig->new( 'invocant'
 => ${$MATCH->{'invocant'
}},'positional'
 => ${$MATCH->{'exp_seq'
}},'named'
 => {  }, )) })))); return($MATCH) };
sub method_sig { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sig'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(${$MATCH->{'sig'
}}) })))))) || do { return(Sig->new( 'invocant'
 => Var->new( 'sigil'
 => '$'
,'twigil'
 => ''
,'name'
 => 'self'
, ),'positional'
 => [],'named'
 => {  }, )) })); return($MATCH) };
sub method { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('m'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('h'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('d'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->method_sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method_sig'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ((('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || do { Main::say('*** Syntax Error in method \''
, $Class_name, '.'
, ${$MATCH->{'name'
}}, '\' near pos='
, $MATCH->to()); die('error in Block'
) }) && do { return(Method->new( 'name'
 => ${$MATCH->{'opt_name'
}},'sig'
 => ${$MATCH->{'method_sig'
}},'block'
 => ${$MATCH->{'exp_stmts'
}}, )) }))))))))))))))))); return($MATCH) };
sub sub { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('s'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('u'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('b'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->method_sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method_sig'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && ((('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || do { Main::say('*** Syntax Error in sub \''
, ${$MATCH->{'name'
}}, '\''
); die('error in Block'
) }) && do { return(Sub->new( 'name'
 => ${$MATCH->{'opt_name'
}},'sig'
 => ${$MATCH->{'method_sig'
}},'block'
 => ${$MATCH->{'exp_stmts'
}}, )) })))))))))))))); return($MATCH) };
sub token { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('t'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('o'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('k'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('e'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('n'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = MiniPerl6::Grammar::Regex->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar::Regex.rule'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { my $source = ('method '
 . ${($MATCH->{'opt_name'
} . (' ( $grammar: $str, $pos ) { '
 . ('my $MATCH; $MATCH := ::MiniPerl6::Perl5::Match( "str" => $str, "from" => $pos, "to" => $pos ); '
 . ('$MATCH.bool( '
 . (${$MATCH->{'MiniPerl6::Grammar::Regex.rule'
}}->emit() . ('); '
 . 'return $MATCH }'
))))))}); my $ast = MiniPerl6::Grammar->term($source); return(${$ast}) })))))))))))); return($MATCH) }
;
1;
