#!/usr/local/bin/perl

# This is a version of "metholate" that spits out Perl 5 instead of Perl 6.
# If metholate is hacky, I hate to think what this is...

# Note: expects you to pipe STD through cheat first

use 5.010;
use strict;
use warnings;

my $failover = 0;
if (@ARGV) {
    if ($ARGV[0] eq '-fo') {
        $failover = 1; shift;
    }
}

use YAML::XS;

our %OUR = ( '$CTX' => 1 );
our %RE = ();                   # turns into __DATA__ yaml

our $STOP = "";
our $REV = "";
our $NAME = "";
our $BINDING = "";
our $KIND = "";
our $PARSEBIND = 0;
our $PAREN = 0;
our %adverbs = ();
our %fixedprefix;
our $PURE;
our @ALTS;
our @TOKEN;
our $MAYBACKTRACK;
our @DECL;
our $SYM;
our $ENDSYM;
our $NEEDMATCH;
our %NEEDSEMI;
our $NEEDORIGARGS;
our $PKG = "main";
our @PKG = ();
our $ALTNAME;
our $ALTNAMES;

my $TRACE = 0;
my $METHOD = "method";

my @impure = qw/ ws fail commit before after panic /;
my %impure;

sub unangle {
    my $s = shift;
    $s =~ s/<(\w*)>/{$1}/g;
    $s =~ s/<([^>]*)>/{'$1'}/g;
    $s =~ s/«([^»]*)»/{'$1'}/g;
    $s =~ s/ /','/g;
    $s;
}

sub un6 {
    my $f = shift;
    my $t;
    while ($f ne "") {
        $f =~ s/^\)</.</                  	and $t .= ')', next;
        $f =~ s!^('.*?')!!              	and $t .= $1, next;
        $f =~ s!^(".*?")!!              	and $t .= $1, next;
        $f =~ s!^q/(.*?)/!!              	and $t .= "q/$1/", next;
        $f =~ s!^/(.+?)/!!              	and $t .= "qr/$1/", next;
        $f =~ s/^\$¢\.\$parser//                and $t .= qq/\$C->\$parser/, next;
        $f =~ s/^\$¢//                  	and $t .= qq/\$C/, next;
        $f =~ s/^\$\/</.</                  	and $t .= qq/\$M/, $NEEDMATCH++, next;
        $f =~ s/^ ::([A-Z]\w+)//        	and $t .= qq/ '$1'/, next;
        $f =~ s/^([^:]):(\w+)\((.*?)\)/ ($3)/ 	and $t .= qq/$1$2 =>/, next;
        $f =~ s/^([^:]):([\$\@%])(\w+)//        and $t .= qq/$1$3 => $2$3/, next;
        $f =~ s/^([^:]):(\w+)<(.*?)>//  	and $t .= qq/$1$2 => '$3'/, next;
        $f =~ s/^([^:]):(\w+)«(.*?)»//  	and $t .= qq/$1$2 => '$3'/, next;
        $f =~ s/^([^:]):(\w+)//         	and $t .= qq/$1$2 => 1/, next;
        $f =~ s/^([^:]):!(\w+)//        	and $t .= qq/$1$2 => 0/, next;
        $f =~ s/^\%\+?(\w+)((<[^>]*>)+)// 	and $t .= ('$' . $1 . unangle($2)), next;
        $f =~ s/^\%\+?(\w+)\{@//         	and $t .= qq/\@$1\{@/, next;    # durn slices...
        $f =~ s/^\%\+?(\w+)\{//         	and $t .= qq/\$$1\{/, next;
        $f =~ s/^\$(\w+)((<[^>]*>)+)//  	and $t .= ('$' . $1 . '->' . unangle($2)), next;
        $f =~ s/^[\$\@%]((<[^>]*>)+)//       	and $t .= ('$M->' . unangle($1)), $NEEDMATCH++, next;
        $f =~ s/^ \.((<[^>]*>)+)//      	and $t .= (' $_->' . unangle($1)), next;
        $f =~ s/^(\s)<([^>) ,]*)>//       	and $t .= qq/$1qw($2)/, next;
        $f =~ s/^(\s)<([^>),]*)>//       	and $t .= qq/$1\[qw($2)\]/, next;
        $f =~ s/^(\s)<([^> ]*)>//        	and $t .= qq/$1qw[$2]/, next;
        $f =~ s/^(\s)<([^>]*)>//        	and $t .= qq/$1\[qw[$2]\]/, next;
        $f =~ s/^«([^») ]*)»//      	        and $t .= qq/qw($1)/, next;
        $f =~ s/^«([^»)]*)»//      	        and $t .= qq/\[qw($1)\]/, next;
        $f =~ s/^«([^» ]*)»//      	        and $t .= qq/qw[$1]/, next;
        $f =~ s/^«([^»]*)»//      	        and $t .= qq/\[qw[$1]\]/, next;
        $f =~ s/^ «\s*([^»]+)»//        	and $t .= do {my $x=$1; $x =~ s! !','!g; "['$x']"}, next;
        $f =~ s/^ <\s*([^>]+)>//        	and $t .= do {my $x=$1; $x =~ s! !','!g; "['$x']"}, next;
        $f =~ s/^\.<\s*([^>]+)>//             	and $t .= do {my $x=$1; $x =~ s! !','!g; "->{'$x'}"}, next;
        $f =~ s/^<\s*([^>]+)>//             	and $t .= do {my $x=$1; $x =~ s! !','!g; "{'$x'}"}, next;
        $f =~ s/^(\w+)((<[^>]*>)+)//    	and $t .= ($1 . '->' . unangle($2)), next;
        $f =~ s/^(\w+)((«[^»]*»)+)//    	and $t .= ($1 . '->' . unangle($2)), next;
        $f =~ s/^(\$\w+)\.//            	and $t .= qq/$1->/, next;
        $f =~ s/^(\$\w+)\(/(/            	and $t .= qq/$1->/, next;
        $f =~ s/^\(\$s:\)//            	        and $t .= qq/(\$s)/, next;
        $f =~ s/^\$[!.](\w+)//          	and $t .= qq/\$self->{$1}/, next;
        $f =~ s/^\@[!.](\w+)\././               and $t .= qq/\$self->{$1}/, next;
        $f =~ s/^\%[!.](\w+)\././               and $t .= qq/\$self->{$1}/, next;
        $f =~ s/^\@[!.](\w+)([\[{<])/.$2/       and $t .= qq/\$self->{$1}/, next;
        $f =~ s/^\%[!.](\w+)([\[{<])/.$2/       and $t .= qq/\$self->{$1}/, next;
        $f =~ s/^\@[!.](\w+)//          	and $t .= qq/\@{\$self->{$1}}/, next;
        $f =~ s/^\%[!.](\w+)//          	and $t .= qq/\%{\$self->{$1}}/, next;
        $f =~ s/^\&Perl:://          		and $t .= qq/*Perl::/, next;
        $f =~ s/^\@(\w+)([\[{])/$2/             and $t .= qq/\$$1/, next;
        $f =~ s/^\%(\w+)([\[{])/$2/             and $t .= qq/\$$1/, next;
        $f =~ s/^\|%/%/                         and next;
        $f =~ s/^\.pos\b//         	        and $t .= qq/->{pos}/, next;
        $f =~ s/^\.([a-z]\w+)//         	and $t .= qq/->$1/, next;
        $f =~ s/^!===?//                	and $t .= qq/!=/, next;
        $f =~ s/^===//                  	and $t .= qq/==/, next;
        $f =~ s/^!eqv//                	        and $t .= qq/ne/, next;
        $f =~ s/^eqv//                	        and $t .= qq/eq/, next;
        $f =~ s/^item %//                	and $t .= qq/\\%/, next;
        $f =~ s/^ \+@//                        	and $t .= qq/ 0+@/, next;
        $f =~ s/^ is rw//               	and $t .= qq//, next;
        $f =~ s/^my\s+(?:[A-Z]\w+)?\s*([\$\@%]\w+)\s+is\s+context(?:<rw>)?\s*(?:is\s+rw)?\s*;//
                                        	and $t .= qq/local $1;/, $OUR{$1}++, next;
        $f =~ s/^\borelse\b//           	and $t .= qq/or/, next;
        $f =~ s/^\bfail\b//             	and $t .= qq/die/, next;
        $f =~ s/^\blet\b //             	and $t .= qq//, next;
        $f =~ s/^\bTrue\b//             	and $t .= qq/1/, next;
        $f =~ s/^\bFalse\b//             	and $t .= qq/0/, next;
        $f =~ s/^([^\$])self\.//             	and $t .= qq/$1\$self->/, next;
        $f =~ s/^([^\$])self\b//             	and $t .= qq/$1\$self/, next;
        $f =~ s/^\.panic//              	and $t .= qq/->panic/, next;
        $f =~ s/^(\s)~(\s)/$2/            	and $t .= qq/$1./, next;
        $f =~ s/^(\s):=(\s)/$2/           	and $t .= qq/$1=/, next;
        $f =~ s/^(\s)\?\?(\s)/$2/         	and $t .= qq/$1?/, next;
        $f =~ s/^(\s)!!(\s)/$2/           	and $t .= qq/$1:/, next;
        $f =~ s/^\btry \{//                     and $t .= qq/eval {/, next;
        $f =~ s/^\bloop \{//                    and $t .= qq/for (;;) {/, next;
        $f =~ s/^\bwhen\s+\*\s+\{//             and $t .= qq/else {/, next;
        $f =~ s/^\bdefault\s+\{//               and $t .= qq/else {/, next;

        # the following must do partial rescan of final expression

        $f =~ s/^\@\((.*?)\)/{$1}/      	and $t .= qq/\@/, next;
        $f =~ s/^\bif\s+(.*?) \{/($1) {/        and $t .= qq/if /, next;
        $f =~ s/^\belsif\s+(.*?) \{/($1) {/     and $t .= qq/elsif /, next;
        $f =~ s/^\bwhile\s+(.*?) \{/($1) {/     and $t .= qq/while /, next;
        $f =~ s/^\bfor\s+(.*?) \{/($1) {/       and $t .= qq/for /, next;
        $f =~ s/^\bmy\s+(?:[A-Z]\w+)?\s*([\$\@%]\w+)\s+is\s+context(?:<rw>)?\s*(?:is\s*rw)?\s*=\s*(.*);/$2;/s
                                        	and $t .= qq/local $1 = /, $OUR{$1}++, next;
        $f =~ s/^\bdo given\s+(.*?\S)\s+\{/$1; if (0) {}/
                                                and $t .= qq/do { my \$_ = /, next;
        $f =~ s/^\bgiven\s+(.*?\S)\s+\{/$1; if (0) {}/
                                                and $t .= qq/do { my \$_ = /, next;
        $f =~ s/^\bwhen\s+(.*?\S)\s+\{/$1) {/
                                                and $t .= 'elsif ($_ eq ', next;

        $f =~ s/^(.)//s                 	and $t .= $1;
    }
    $t;
}

{
    local $/;
    $_ = <>;
    push @impure, m/^method (\w+)/mg;
    @impure{@impure} = (1) x @impure;
    #warn "@impure\n";
}
my $all = $_;

sub indent {
    my $x = shift || '';
    my $i = shift || 1;
    my $s = '    ' x $i;
    $x =~ s/^/$s/mg;
    $x;
}

sub panic {
    my $line = 0;
    while (length($all) > length($_)) {
        if ($all =~ s/^#line (\d+)\n//) {
            $line = $1;
        }
        else {
            $all =~ s/^.*\n//;
            $line++;
        }
    }
    die @_,
        " at line ", $line - 1,
        " near '", /^(.{0,30}) /s,
        "'\n";
}

sub MAIN {
    my $out = "";

    s/^(\s+)// and $out .= $1;
    while ($_ ne "") {
        if ( s/^(#line.*\n)// ) { next }

        if ( s/^(#.*\n)// ) { $out .= $1; next }

        my $remaining = length($_);
        if (s/^    method new \(\*\@pedigree\).*?\n    }\n//s) {
            $out .= <<'END';

    # emulate 'handles'
    sub tweak { my $self = shift;
        my $tweaker = $self->{tweaker} . '::tweak';
        $self->$tweaker(@_);
    }
    sub parser { return shift()->{parser} }
    sub escrule { return shift()->{escrule} }
    sub option { return shift()->{option} }

    sub new { my $self = shift;
        my @pedigree = @_;
        if (@pedigree == 1) {
            my %start = eval { $self->root_of_Q } or
                Perl::panic("Quote construct " . $pedigree[0] . "not recognized");
            return bless(\%start, $self);
        }
        else {
            my $tail = pop @pedigree;
            my %stuff = %{Perl::qlang(@pedigree)};
            my $self = bless(\%stuff, $stuff{tweaker});
            my @kv;
            if ($tail =~ m/^:(\w+)$/) {
                @kv = ($1,1);
            }
            elsif ($tail =~ m/^:!(\w+)$/) {
                @kv = ($1,0);
            }
            elsif ($tail =~ m/^:(\w+)\((.*)\)$/) {
                @kv = ($1,$2);
            }
            $self->tweak(@kv);
            return $self;
        }
    }
END
	    next;
	}

        if (s/^(method heredoc[^\n{]*).*?\n}\n//s) {
            $out .= "# $1\n";
            $out .= <<'END';
sub heredoc { my $self = shift;  
    my $here = $self;
    while (my $herestub = shift @herestub_queue) {
        local $delim = $herestub->delim;
        my $lang = $herestub->lang;
        my $doc;
        my $ws = "";
        $here = $here->q_unbalanced_rule($lang, stop => \&theredoc)->MATCHIFY;
        if ($here) {
            if ($ws) {
                my $wsequiv = $ws;
                $wsequiv =~ s/^(\t+)/' ' x ($1 * 8)/e; # per spec
                $here->{text}[0] =~ s/^/\n/; # so we don't match ^^ after escapes
                for (@{$here->{text}}) {
                    s{\n($ws|[ \t]*)}!do {
                        my $white = $1;
                        if ($white eq $ws) {
                            '';
                        }
                        else {
                            $white =~ s{^(\t+)}{
                                ' ' x (length($1) * 8)
                            }e;
                            $white =~ s/^$wsequiv//
                                ? $white
                                : '';
                        }
                    }!eg;
                }
                $here->{text}[0] ~~ s/^\n//;
            }
            $herestub->orignode->{doc} = $here;
        }
        else {
            self->panic("Ending delimiter $delim not found");
        }
    }
    return $here;
}
END
            next;
        }

        if ( s/^([ \t]*)(method|rule|token|regex)(\s+)(\w+)(.*?)\s+{//s ) {
            my $indent = $1;
            local $KIND = $2;
            my $ws = $3;
            local $NAME = $4;
            my $argstuff = $5;

            my $comment = "$1$2$3$4$5\n";
            $comment =~ s/^/## /mg;
            $out .= $comment;

            local $PAREN = 0;
            local $SYM;
            local $ENDSYM;
            local $NEEDORIGARGS = 0;
            my $args = "";
            my $coercion = "";
            if ($argstuff =~ s/\((.*)\)//s) {
                $args = $1;
                $args =~ s/^\s+//;
                $args =~ s/\s+$//;
            }
            warn $argstuff if $argstuff =~ /\S/;
            my $p = "";

            local $MAYBACKTRACK = 1;  # XXX ratchet current broken
            if ($KIND eq 'regex') {
                $MAYBACKTRACK = 1;
            }

            if ($args =~ s/ --> (\w*)$//) {
                $coercion = " map { ${PKG}::$1->coerce(\$_) }";
            }
            $args .= ', ';
            my $sym = "";
            $sym .= <<'END' unless $KIND eq 'method';
    my $depth = shift;
    my $binding = shift;
    my $fate = shift;
END

            $args =~ s/is rw//g;
            while ($args =~ s/^([A-Z]\w+)?\s*([\$\@%&]\w+)\s*(is\s+context(?:<rw>)?)?\s*([^=?,]*?),\s*//) {
                my $type = $1;
                my $var = $2;
                my $decl = $3 ? ($OUR{$var}++, "local") : "my";
                warn $4 if $4;
                $sym .= "    $decl $var = shift;\n";
                $args =~ s/^,\s*//;
            }

            while ($args =~ s/^([A-Z]\w+)?\s*([\$\@%&]\w+)\s*(is\s+context(?:<rw>)?)?\s*=(.*?),\s*//) {
                my $type = $1;
                my $var = $2;
                my $decl = $3 ? ($OUR{$var}++, "local") : "my";
                my $dflt = un6($4);
                $sym .= "    $decl $var = shift() //$dflt;\n";  # XXX close enough
                $args =~ s/^,\s*//;
            }

            my $didargs = 0;
            while ($args =~ s/^([A-Z]\w+)?\s*:([\$\@%&](\w+))\s*(is\s+context(?:<rw>)?)?\s*(=((<[^>]*>|«[^»]*»|.)*?))?,\s*//) {
                my $type = $1;
                my $var = $2;
                my $name = $3;
                my $decl = $4 ? ($OUR{$var}++, "local") : "my";
                my $eq = $5;
                my $dflt = $6;
                $sym .= "    my %args = \@_;\n" unless $didargs++;   # simulate named args from variadics
                if ($name eq 'sym') {
                    warn $args unless $dflt;
                    $SYM = $dflt;
                    $SYM =~ s/^\s+//;
                    $SYM =~ s/^'(.*)'$/$1/ or
                    $SYM =~ s/^"(.*)"$/$1/ or
                    $SYM =~ s/^<(.*)>$/$1/ or
                    $SYM =~ s/^«(.*)»$/$1/ or
                    $SYM =~ s/^\{'(.*)','(.*)'\}$/$1 $2/ or
                    $SYM =~ s/^\{'(.*)'\}$/$1/;
                    $SYM =~ s/^\s+//;
                    $SYM =~ s/\s+$//;
                }
                if ($name eq 'endsym') {
                    warn $args unless $dflt;
                    $ENDSYM = $dflt;
                    $ENDSYM =~ s/^\s+//;
                    $ENDSYM =~ s/^'(.*)'$/$1/ or
                    $ENDSYM =~ s/^"(.*)"$/$1/;
                }
                if ($eq) {
                    $dflt = un6($dflt);
                    $sym .= "    $decl $var = \$args{$name} //$dflt;\n";
                }
                else {
                    $sym .= "    $decl $var = \$args{$name};\n";
                }
                $args =~ s/^,\s*//;
            }

            if ($args =~ s/^([A-Z]\w+)?\s*\*([\$\@%&]\w+)\s*(is\s+context(?:<rw>)?)?\s*([^=?,]*?),\s*//) {
                my $type = $1;
                my $var = $2;
                my $decl = $3 ? ($OUR{$var}++, "local") : "my";
                warn $4 if $4;
                $sym .= "    $decl $var = \@_;\n";
                $args =~ s/^,\s*//;
            }
            warn $comment if $args =~ /[^, ]/;

            if ($KIND eq 'method') {
                $out .= <<"END";
${indent}sub $NAME { my \$self = shift;
$sym
END
                next;
            }

            local $BINDING;
            undef $BINDING;
            local @DECL;

            local $ALTNAME = $NAME;
            local $ALTNAMES = "00";
            my $re = regex('\\}');

            my $old = substr($all, length($all) - $remaining, $remaining - length($_)+1);
            $old =~ s/^/##      /mg;
            $out .= "$old\n\n";

            local @ALTS;
            local $PURE = 1;
            my $meat = ::indent($re->walk(), 2);

            $RE{$PKG . '::' . $NAME} = $re;
    #        my $lex = Dump($re);
    #        $lex =~ s[!!perl/hash:][!pugs/Object:]g;
    #        $lex =~ s/\\x([89A-Fa-f][0-9A-Fa-f])/chr(hex($1))/eg;
    #        mkdir("yamlg5");
    #        (my $file = "${PKG}::$NAME") =~ s/::/--/g;
    #        open YAML, ">yamlg5/$file.yml" or die "Can't create yamlg5/$file.yml: $!";
    #        binmode(YAML, ":utf8");
    #        print YAML $lex;
    #        close YAML;

            $out .= <<"END";
sub$ws$NAME {
    my \$C = my \$self = shift;
END
            if ($NEEDORIGARGS) {
                $out .= "    my \@origargs = \@_;\n";
            }
            my $body = <<'END';
<<DECL>>
    local $CTX = $C->callm($fate ? $$fate[3] : '');
    if ($depth < 0) {
        return <<PEEK>>
    }

    my $tag = '';
    my $try;
    if ($fate) {
        print STDERR "Fate passed to <<NAME>>: $$fate[3]\n";
        ($tag, $try, $fate) = @$fate if $$fate[0] eq "<<NAME>>";
    }
    else {
        $fate = $C->_AUTOLEXnow('<<PKG>>::<<NAME>>')->($C);
        if ($fate) {
            print STDERR "FATE OF <<PKG>>::<<NAME>>: $$fate[3]\n";
            ($tag, $try, $fate) = @$fate;
        }
        else {
            print STDERR "NO FATE FOR <<PKG>>::<<NAME>> (may backtrack)\n";
        }
    }
    my $mydepth = $depth+1;

END

            $body .= <<"END";
    \$self->_MATCHIFY(\$depth,\$binding,$coercion
<<MEAT>>
    );
END

            my $PROTONAME = $NAME;
            $PROTONAME =~ s/__.*// or $PROTONAME = "panic";
            if ($impure{$NAME}) {
                $body =~ s/<<PEEK>>/''/;
            }
            else {
                $body =~ s/<<PEEK>>/\$C->_AUTOLEXpeek('<<PKG>>::<<NAME>>')/;
            }
            $body =~ s/<<PKG>>/$PKG/g;
            $body =~ s/<<NAME>>/$NAME/g;
            $body =~ s/<<PROPS>>//g;
            $body =~ s/<<PROTONAME>>/$PROTONAME/g;
            $body =~ s/<<DECL>>/$sym@DECL/;
            $body =~ s/<<MEAT>>/$meat/;
            $body =~ s/\$\+(\w+)/\$$1/g;
            $out .= $body;
            next;
        }

        if (s/^\s*multi method tweak\s*\((.*?)\)\s+{//) {
            my $sig = $1;
            if ($sig =~ m/^:(\w+)\(:(\$(\w+))\)$/) {
                $out .= "    elsif (\$k eq '$1' or \$k eq '$3') {\n        my $2 = \$v; ";
            }
            elsif ($sig =~ m/^:(\w+)\((\$\w+)\)$/) {
                $out .= "    elsif (\$k eq '$1') {\n        my $2 = \$v; ";
            }
            elsif ($sig =~ m/^:(\$(\w+))$/) {
                $out .= "    elsif (\$k eq '$2') {\n        my $1 = \$v; ";
            }
            elsif ($sig =~ m/^\*%x$/) {
                $out .= "    else {\n        my %x = (\$k, \$v); ";
            }
            else {
                warn "Can't translate tweak: $sig";
            }
            next;
        }

	if (s/^#begin p5\n(.*?\n)#end p5\n//s) {
	    $out .= $1;
	    next;
	}


        # from here on we assume all nibbles are line-sized or less.
        if (s/^(.*\n)//) {
            my $line = $1;
            if ($line =~ /^(\s*).*?given/) {
                my $len = length($1);
                $NEEDSEMI{$len} = 1;
            }
            elsif ($line =~ /^(\s*)}\n/) {
                my $len = length($1);
                if (delete $NEEDSEMI{$len}) {
                    $line =~ s/}/};/;
                }
            }
            if ($line =~ m/# begin tweaks/) {
                $out .= <<'END';
  sub tweak { # begin tweaks
    my $self = shift;
    my ($k, $v) = @_;

    if (0) {}
END
                next;
            }
            elsif ($line =~ m/# end tweaks/) {
                $out .= "  } # end tweaks\n";
                next;
            }
            if ($line =~ m/^#/) {
                $out .= $line;
                next;
            }
            $line = un6($line);
            if ($line =~ s/^grammar (\w+);//) {
                $PKG = $1;
                $out .= "package $PKG;\n";
                $out .= <<'END';
use Cursor5;
use base 'Cursor5';
use strict;
use warnings; no warnings 'qw';
use feature 'state';
use utf8;
sub BUILD {
    my $self = shift;
    $self->{ws_from} = 0;
    $self->{ws_to} = 0;
}

use YAML::XS;
{
    local $/;
    my $yaml = <DATA>;
    *::RE = Load($yaml);
}

END
            }
            $line =~ s/^(\s*has) /#$1 /;
            $line =~ s/^proto /#proto /;
            $line =~ s/\bsay /print / and ($line =~ s/";$/\\n";/ or $line =~ s/;$/,"\\n";/);
            $line =~ s/&reduce = ->/\$reduce = sub/;
            $line =~ s/ -> (.+?) {/sub { my ($1) = \@_;/;
            $line =~ s/ -> {/sub {/;
            $line =~ s/\breduce\(\)/\$reduce->()/;
            $line =~ s/([\$\@%])\+(\w+)/$1$2/g;       # assume localized
            if ($line =~ s/^constant %/our %/) {
                $line =~ tr/{}/()/;
                $line = ::un6($line);
            }
            $line =~ s/^constant /my /;
            $line =~ s/\bmy ([A-Z]\w+) /my /;

            $line =~ s/(?:class|role) (\w+)\s+\{/{ package ${PKG}::$1;/
                    and do { push(@PKG, $PKG); $PKG = "${PKG}::$1"; };    # "our" semantics
            $line =~ s/class (\w+)\s+does\s+(\w+)\s+\{/{ package ${PKG}::$1; our \@ISA = 'Perl::$2';/
                    and do { push(@PKG, $PKG); $PKG = "${PKG}::$1"; };

            $line =~ s/^grammar (\w+)\s+is\s+(\w+)\s*\{/{ package ${PKG}::$1; our \@ISA = '$2';/
                    and do { push(@PKG, $PKG); $PKG = "${PKG}::$1"; };

            $PKG = pop(@PKG) if @PKG and $line =~ /} # end (role|class|grammar)/;

            $line =~ s/\(state %(\w+)\)/(state \$$1)->/;
            $line =~ s/(\S+) xx /($1) x /;
            $line =~ s/(\S+) xx /($1) x /;
            $line =~ s/ x \?/ x !!/;
            $line =~ s/\|%start/%start/;
            if ($line =~ m/method UNIT/) {
                $OUR{'$unitstopper'}++;
                $line =~ s/method UNIT \(\$unitstopper is context = "_EOS"\) \{/sub UNIT {
        my \$self = shift;
        local \$unitstopper = shift || "_EOS";/;
            }
            elsif ($line =~ m/Method nounphrase/) {
                $line = <<'END';
sub nounphrase {
    my $self = shift;
    my %args = @_;
    my $noun = $args{noun};
    my $pre = $args{pre};
    my $post = $args{post};
END
            }
            elsif ($line =~ s/^(\s*)method (\w+)\s*(.*?)\{/$1sub $2 { my \$self = shift; my $3= \@_; /) {
                $out .= "# $1method $2 $3\n";
                $line =~ s/Match //g;
                $line =~ s/Str //g;
                $line =~ s/my \(\) = \@_;//g;
                $line =~ s/my *= \@_;//g;
            }
            elsif ($line =~ s/^(\s*)sub (\w+)\s*(.*?)\{/$1sub $2 { my $3= \@_; /) {
                $line =~ s/Match //g;
                $line =~ s/Str //g;
                $line =~ s/my \(\) = \@_;//g;
                $line =~ s/\*\@/\@/;
                $line =~ s/my *= \@_;//g;
            }

            $out .= $line;
        }
    }

    print "# Emulate context vars by localizing 'our' vars living in main\n";
    for (sort keys(%OUR)) {
        print "our $_;\n";
    }
    print "our \$moreinput;\n";
    print "our \$MATCHID;\n";
    print "\n";
    print $out;
    print "__DATA__\n";
    print Dump(\%RE);
}

sub here {
    print STDERR +(caller(0))[3],": ",/^(.{0,20})/,"\n" if $TRACE;
}

#############################################3333
## Regex
#############################################3333

sub ws {
    return if $KIND eq 'rule';  # meta whitespace parsed in atom
    for (;;) {
        next if s/^\s+//;
        next if s/^#\(.*?\)//s;
        next if s/^#\{.*?\}//s;
        next if s/^#\[.*?\]//s;
        next if s/^#\<.*?\>//s;
        next if s/^#.*\n//;
        last;
    }
}

sub wsany {
    for (;;) {
        next if s/^\s+//;
        next if s/^#\(.*?\)//s;
        next if s/^#\{.*?\}//s;
        next if s/^#\[.*?\]//s;
        next if s/^#\<.*?\>//s;
        next if s/^#.*\n//;
        last;
    }
}

sub regex {
    here();
    ws();
    local $STOP = shift;

    my @decl;
    while (s/^\s*:(my|state|our|constant)\b/$1/) {
        my $code = unbalanced(";");
        s/^;// or panic "Missing ;";
        push @decl, bless { text => $code, min => 0, max => 0 }, "RE_decl";
    }

    my $od = first();
    return bless { decl => [@decl], re => $od, min => $od->{min} }, "RE";
}

sub first {
    here();
    my @kids;
    my $min = 1_000_000_000;

    s/^\|\|//;

    do {
        ws();
        my $k = every();
        push @kids, $k;
        my $kidmin = $k->{min};
        $min = $kidmin if $kidmin < $min;
        ws();
    } while s/^\|\|//;

    return $kids[0] if @kids == 1;
    return bless { zyg => [@kids], min => $min}, "RE_first";
}

sub every {
    here();
    my @kids;
    my $min = 0;

    do {
        ws();
        my $k = submatch();
        push @kids, $k;
        my $kidmin = $k->{min};
        $min = $kidmin if $kidmin > $min;
        ws();
    } while s/^\&\&//;

    return $kids[0] if @kids == 1;
    return bless { zyg => [@kids], min => $min }, "RE_every";
}

sub submatch {
    here();
    my @kids;

    do {
        ws();
        push @kids, any();
        ws();
    } while s/^\!?\~\~//;

    return $kids[0] if @kids == 1;
    return bless { zyg => [@kids], min => 0 }, "RE_submatch";
}

sub any {
    here();
    my @kids;
    my $min = 1_000_000_000;
    local $ALTNAME = $NAME . '_' . $ALTNAMES++;

    s/^ \| (?!\|) //x;

    do {
        ws();
        my $k = all();
        push @kids, $k;
        my $kidmin = $k->{min};
        $min = $kidmin if $kidmin < $min;
        ws();
    } while s/^ \| (?!\|) //x;

    return $kids[0] if @kids == 1;

    return $RE{$PKG . '::' . $ALTNAME} =
        bless { zyg => [@kids], min => $min, altname => $ALTNAME },
              "RE_any";
}

sub all {
    here();
    my @kids;
    my $min = 0;

    do {
        ws();
        my $k = sequence();
        push @kids, $k;
        my $kidmin = $k->{min};
        warn "$k\n" unless defined $kidmin;
        $min = $kidmin if $kidmin > $min;
        ws();
    } while s/^ \& (?!\&) //x;

    return $kids[0] if @kids == 1;
    return bless { zyg => [@kids], min => $min }, "RE_all";
}

sub sequence {
    here();
    my @kids;
    my $k;
    my $min = 0;

    while ($k = quantified_atom()) {
        push(@kids, $k);
        my $kidmin = $k->{min};
        $min += $kidmin;
    }

    return $kids[0] if @kids == 1;
    return bless { zyg => [@kids], min => $min }, "RE_sequence";
}

sub quantified_atom {
    here();
    my $atom = atom();
    return unless defined $atom and $atom ne '';
    return $atom if $atom->{noquant};
    my $quant = quantifier();
    return $atom unless $quant;
    my $min = $atom->{min} * $quant->[3];
    return bless { atom => $atom, quant => $quant, min => $min },
        "RE_quantified_atom";
}

sub quantifier {
    if (s/^\s*(\*\*)([?!:+]?)// or
        s/^\s*(\*)([?!:+]?)// or
        s/^\s*(\+)([?!:+]?)// or
        s/^\s*(\?)([?!:+]?)//) {
        my ($q,$m) = ($1,$2);
        my $min = 0;
        if (not $m) {
            if ($KIND eq 'rule' or $KIND eq 'token') {
                $m = ':';
            }
            else {
                $m = '!';
            }
        }
        elsif ($m eq '+') {
                $m = '!';
        }
        my $x = "";
        if ($q eq '**') {
            if (s/^\s*((\d+)(\.\.(\d+|\*))?)//) {
                $x = $1;
                $min = $2;
            }
            elsif (/^\s*\{/) {
                wsany();
                $x = block('thunk');
                $min = 0;
            }
            else {
                wsany();
                $x = atom();
                $min = 1;
            }
        }
        elsif ($q eq '+') {
            $min = 1;
        }
        ws();
        $MAYBACKTRACK = 1 unless $m eq ':';
        return [$q,$m,$x,$min];
    }
}

sub atom {
    here();
    if (s/^\\\s/ /) {
        wsany();
    }
    if (/^[\s\#]/ and $KIND eq 'rule') {
        wsany();
        return bless { name => 'ws', nobind => 1, noquant => 1, min => 0 },
            "RE_method_noarg";
    }
    return if /^ [\]&|)] /x;   # XXX an approximation
    return if /^ (?:
        >(?!>) |
        !?~~
    )/x;
    return if /^ ( $STOP )/x;

    if (/^[*+?]/) { panic "quantifier quantifies nothing"; }

    if (s/^ (\w+) (?! \s* [*+?]) //x) {
        my $word = $1;
        ws();
        return bless { text => $word, min => length($word) }, "RE_string";
    }
    if (s/^ (\w) //x) {
        my $word = $1;
        ws();
        return bless { text => $word, min => length($word) }, "RE_string";
    }

    if (s/^\{\*\}//) {
        my $key = $NAME;
        if (s/^(.*?)\s*#=\s+(.*)/$1/) {
            $key .= " $2";
        }
        ws();
        $key =~ s/(['\\])/\\$1/g;
        return bless { name => '_REDUCE', args => "'$key'", min => 0, max => 0},
                     "RE_method_internal";
    }
    if (/^\{/) {
        my $b = block('void');
        ws();
        return $b;
    }

    if (s/^\\//) { my $bs = backslash(); ws(); return $bs; }

    if (s/^\[//) {
        my $re = regex('\\]');
        s/^\]// or panic "Missing ]";
        ws();
        return bless $re, "RE_bracket";
    }

    if (s/^\(//) {
        my $re = regex('\\)');
        s/^\)// or panic "Missing )";
        ws();
        $re = bless $re, "RE_paren";
        if (not $PARSEBIND) {  # XXX leaves quantifier outside?
            $re = bless { var => $PAREN++, atom => $re, min => $re->{min} },
                "RE_bindpos";
        }
        return $re;
    }

    if (s/^ (: !? \w+)//x) {
        my $adverb = $1;
        local %adverbs = %adverbs;
        
        # XXX chintzy
        if (s/^(\(.*?\))//) {
            $adverbs{$adverb} = $1;
        }
        else {
            my $not = $adverb =~ s/!//;
            $adverbs{$adverb} = !$not;
        }
        ws();

        return quantified_atom();
    }

    # check unbalanced angles before assertions

    if (s/^(<<|>>|«|»)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary, min => 0 }, "RE_meta";
    }

    if (s/^(<\(|\)>)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary, min => 0 }, "RE_meta";
    }

    if (/^<\s/) {
        my $re = unbalanced(">");
        s/^>// or panic "Missing >";
        my @elems = split(' ', $re);
        shift @elems;
        my $min = 1_000_000_000;
        for (@elems) { $min = length($_) if length($_) < $min }
        $re .= '>';
        ws();
        return bless { text => $re, min => $min }, "RE_qw";
    }

    # assertions

    s/^<(\w+)=/\$<$1>=</;
    if (s/^<//) {
        my $re = assertion();
        ws();
        return $re;
    }

    # now the rest of the metas

    if (s/^'//) {
        my $re = unbalanced("'");
        s/^'// or panic "Missing '";
        ws();
        return bless { text => $re, min => length($re) }, "RE_string";
    }
    if (s/^"//) {
        my $re = unbalanced('"');
        s/^"// or panic 'Missing "';
        my $tmp = $re;
        $tmp =~ s/\\\w/X/g;    # XXX ignoring \x and \o for now
        $tmp =~ s/\$\w+//g;    # assume vars interpolate nothing
        ws();
        return bless { text => $re, min => length($tmp) }, "RE_double";
    }

    if (/^[\$\@\%]/) {
        my $code;
        if (/^[\$\@\%]</) {
            $code = unbalanced('>');
            s/^>// or panic "Missing >";
            $code .= '>';
        }
        if (s/^([\$\@\%][.!?*+]?\w+)//) {
            $code = $1;
        }
        if (defined $code) {
            ws();
            if (s/^\s*=\s*//) {
                ws();
                local $PARSEBIND = 1;
                my $atom = quantified_atom(@_);
                $atom->{nobind} = 1;
                ws();
                if ($code =~ s/([\$\@%]<.*?>)/$1/) {
                    return bless { var => $code,
                                   atom => $atom,
                                   min => $atom->{min}
                                 }, "RE_bindnamed";
                }
                return bless { var => $code, atom => $atom, min => $atom->{min} }, "RE_bindvar";
            }
            else {
                return bless { var => $code, min => 0 }, "RE_var";
            }
        }
    }

    # must follow variables
    if (s/^([\^\$]{1,2})//) {
        my $anchor = $1;
        ws();
        return bless { text => $anchor, min => 0 }, "RE_meta";
    }
    if (s/^(:+)//) {
        my $colons = $1;
        ws();
        return bless { text => $colons, min => 0 }, "RE_meta";
    }
    if (s/^\.//) {
        ws();
        return bless { text => '.', min => 1 }, "RE_meta";
    }

    panic "unrecognized metacharacter @{[ substr($_,0,1) ]}";
}

sub backslash {
    my $ch = substr($_,0,1,"");
    
    if ($ch =~ /^\w$/) {
        if ($ch =~ /^[ftnr]/) {
            return bless { text => '\\' . $ch, min => 1  }, "RE_double";
        }
        if ($ch eq 'x') {
            s/^\[?([0-9a-fA-f]*)\]?//;
            return bless { text => '\\x' . $1, min => 1  }, "RE_double";
        }
        if ($ch eq 'o') {
            s/^\[?([0-7]*)\]?//;
            return bless { text => '\\o' . $1, min => 1  }, "RE_double";
        }
        if ($ch =~ /^[hvdswHVDSWNRTBF]/) {
            return bless { text => "\\$ch", min => 1  }, "RE_meta";
        }
        panic "Unrecognized \\$ch";
    }
    if ($ch eq '\\') {
        return bless { text => '\\', min => 1  }, "RE_string";
    }
    return bless { text => $ch, min => 1 }, "RE_string";
}

sub assertion {
    here();
    my $assert = substr($_,0,1);

    if (s/^[!?]//) {
        my $rest = assertion();
        $rest->{nobind} = 1;
        return bless { assert => $assert, re => $rest, min => 0 },
            "RE_assertion";
    }
    if (s/^>//) {
        return bless { min => 0 }, "RE_noop";
    }

    if (/^[+-]?\[/) {
        my $cclass = unbalanced(']>');
        s/^]>// or panic "Missing ]>";
        return bless { text => $cclass . ']', min => 1 }, "RE_cclass";
    }

    if (s/^\.//) {
        my $rest = assertion();
        $rest->{nobind} = 1;
        return $rest;
    }

    if (s/^([a-zA-Z]\w*)//) {
        my $word = $1;
        my $ch = substr($_,0,1);
        if ($ch eq '>') {
            s/^>// or panic "Missing >";
            if ($word eq 'sym' and $ENDSYM) {
                s/^/<.$ENDSYM>/;
                s/^/»/ if $SYM =~ /\w$/;
            }
            return bless { name => $word, min => 12345 }, "RE_method_noarg";
        }
        if ($ch eq ':') {
            s/^:\s*//;
            my $str = unbalanced('>');
            s/^>// or panic "Missing >";
            if ($word eq 'after') {
                my $x = bless { name => '_EXACT_rev', str => $str, min => 0 },
                    "RE_method_str";
                return bless { name => $word, rest => $x, min => 0 },
                    "RE_method";
            }
            return bless { name => $word, str => $str, min => 0 },
                "RE_method_str";
        }
        if ($ch eq '(') {
            my $code = code('\\)>');
            s/^\)>// or panic "Missing )>";
            $code .= ')';
            return bless { name => $word, rest => $code, min => 0 },
                "RE_method";
        }
        s/^\s*//;
        my $re = regex('\\>[^>]');
        s/^>// or panic "Missing >";
        return bless { name => $word, re => $re, min => 0 }, "RE_method_re";
    }

    if (/^[\$\@\%]/) {
        my $code = code('>');
        s/^>// or panic "Missing >";
        if ($code =~ s/\(.*\)//) {
            return bless { name => $code, rest => $1, min => 0 }, "RE_method";
        }
        else {
            return bless { name => $code, min => 0 }, "RE_method_noarg";
        }
    }

    if (/^\{/) {
        my $b = block('bool');
        s/^>// or panic "Missing >";
        ws();
        return $b;
    }

}

sub block {
    # XXX
    my $context = shift;
    s/^({+)//;
    my $term = '\\}' x length($1);
    my $block = code($term);
    s/^$term// or panic "Missing }" ;
    return bless { text => $block, context => $context, min => 0 }, "RE_block";
}

sub code {
    # XXX
    my $code = unbalanced(@_);
    return $code;
}

sub unbalanced {
    my $terminator = shift;
    s/^ ( (\\. | . )*? ) (?=$terminator)//sx;
    return $1;
}

##########################################################

{ package REbase;
    sub walk {
        my $self = shift;
        my $result = "";
        if ($$self{zyg}) {
            foreach my $kid (@{$$self{zyg}}) {
                my $x = $kid->walk(@_);
                $result .= $x if defined $x;
            }
        }
        else {
            return ref $self;
        }
        return $result;
    }

    sub binding {
        my $binding;
        my $self = shift;
        if ($$self{nobind}) {
            $binding = "\$mydepth, '', \$fate",
        }
        elsif (defined $BINDING) {
            $binding = "\$mydepth, '$BINDING', \$fate";
            undef $BINDING;
        }
        else {
            my $name = $$self{name};
            $binding = "\$mydepth, '$name', \$fate";
        }
        $binding;
    }
}

{ package RE; use base "REbase";
    sub walk {
        my $self = shift;
        if ($$self{decl}) {
            for my $decl (@{$$self{decl}}) {
                push @DECL, "    " . $decl->walk(@_) . "\n";
            }
        }
        if ($$self{re}) {
            return $$self{re}->walk(@_);
        }
    }
}

{ package RE_adverb; use base "REbase";
}

{ package RE_assertion; use base "REbase";
    sub walk {
        my $self = shift;
        local($PURE);
        local(@TOKEN);
        local(@ALTS);
        if ($$self{assert} eq '!') {
            my $re = $$self{re}->walk(@_);
            "\$C->_NOTBEFORE( \$mydepth,'',undef, sub { my \$C=shift;\n" . ::indent($re) . "\n})";
        }
        else {
            my $re = $$self{re}->walk(@_);
            return $re if $re =~ /^\$C->before/;
            "\$C->before( \$mydepth, '', \$fate, sub { my \$C=shift;\n" . ::indent($re) . "\n})";
        }
    }
}

{ package RE_assertvar; use base "REbase";
}

{ package RE_block; use base "REbase";
    sub walk {
        my $self = shift;
        local $NEEDMATCH = 0;
        %NEEDSEMI = ();
        my $text;
        for my $line (split /^/,$$self{text}) {
            if ($line =~ /^(\s*).*?given/) {
                my $len = length($1);
                $NEEDSEMI{$len} = 1;
            }
            elsif ($line =~ /^(\s*)}\n/) {
                my $len = length($1);
                if (delete $NEEDSEMI{$len}) {
                    $line =~ s/}/};/;
                }
            }
            $text .= $line;
        }
        $text = ::un6($text);
        my $ctx = $$self{context};
        $text = 'my $M = $C->matchify($mydepth)->{M}; ' . $text . ';' if $NEEDMATCH;
        if ($text =~ s/\bmake\b/scalar/g) {  # XXX hack, avoid using $<make>
            "do {$text}";
        }
        elsif ($ctx eq 'void') {
            $PURE = 0;
            "scalar(do {$text}, \$C)";
        }
        elsif ($ctx eq 'bool') {
            "((\$C) x !!do {$text})";
        }
        else {
            $PURE = 0;
            " sub { my \$C=shift;$text}";
        }
    }
}

{ package RE_bindvar; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        my $re = $$self{atom}->walk(@_);
#        $var = "my $var" unless $var =~ /::/;
        "bindvar($var,$re)" . '->matchify($mydepth)';
    }
}

{ package RE_bindnamed; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        local $BINDING = $var;
        my $re = ::indent($$self{atom}->walk(@_));
        if (defined $BINDING) {
            $re = "\$C->_BINDNAMED$REV(\$mydepth, '$var', undef, sub { my \$C=shift;\n" . $re . "\n})";
        }
        $re;
    }
}

{ package RE_bindpos; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        local $BINDING = $var;
        my $re = ::indent($$self{atom}->walk(@_));
        if (defined $BINDING) {
            $re = "\$C->_BINDPOS$REV(\$mydepth, '$var', undef, sub { my \$C=shift;\n" . $re . "\n})";
        }
        $re;
    }
}

{ package RE_bracket; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "\$C->_BRACKET$REV( \$mydepth,'',undef, sub { my \$C=shift;\n" . $re . "\n})";
    }
}

{ package RE_cclass; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s!(\/|\\\/)!\\$1!g;
        $text =~ s/\s//g;
        $text =~ s/\.\./-/g;
        "\$C->_CCLASS$REV(\$mydepth,'',undef, qr/^$text\$/)";
    }
}

{ package RE_decl; use base "REbase";
    sub walk {
        my $self = shift;
        local $NEEDMATCH = 0;
        my $text = ::un6($$self{text} . ';');
        $text = 'my $M = $C->matchify($mydepth)->{M}; ' . $text . '; ' if $NEEDMATCH;
        $text;
    }
}

{ package RE_double; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        push @TOKEN, '"' . $text . '"' if $PURE;
        '$C->_EXACT' . $REV . '($mydepth,"",undef, "' . $text . '")';
    }
}

{ package RE_string; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        push @TOKEN, "'" . $text . "'" if $PURE;
        "\$C->_EXACT$REV(\$mydepth,'',undef, '" . $text . "')";
    }
}

{ package RE_meta; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        my $not = 0;
        my $code = "";
        if ($text =~ /^(\\[A-Z])(.*)/) {
            $text = lc($1) . $2;
            $not = 1;
        }
        if ($text eq '.') {
            $code = "\$C->_ANY$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '^') {
            $code = "\$C->_BOS$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '^^') {
            $code = "\$C->_BOL$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '$') {
            $code = "\$C->_EOS$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '$$') {
            $code = "\$C->_EOL$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq ':') {
            $code = "\$C->_COMMITATOM$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '::') {
            $PURE = 0;
            $code = "\$C->_COMMITBRANCH$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq ':::') {
            $PURE = 0;
            $code = "\$C->_COMMITRULE$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '\\d') {
            $code = "\$C->_DIGIT$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '\\w') {
            $code = "\$C->_ALNUM$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '\\s') {
            $code = "\$C->_SPACE$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '\\h') {
            $code = "\$C->_HSPACE$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '\\v') {
            $code = "\$C->_VSPACE$REV(\$mydepth,'',undef, )";
        }
        elsif ($text eq '»') {
            $code = "\$C->_RIGHTWB(\$mydepth,'',undef, )";
        }
        elsif ($text eq '«') {
            $code = "\$C->_LEFTWB(\$mydepth,'',undef, )";
        }
        elsif ($text eq '>>') {
            $code = "\$C->_RIGHTWB(\$mydepth,'',undef, )";
        }
        elsif ($text eq '<<') {
            $code = "\$C->_LEFTWB(\$mydepth,'',undef, )";
        }
        if ($not) { # XXX or maybe just .NOT on the end...
            $PURE = 0;
            $code = "\$C->_NOTCHAR( \$mydepth,'',undef, sub { my \$C=shift; $code })";
        }
        $code;
    }
}

{ package RE_method_noarg; use base "REbase";
    sub walk {
        my $self = shift;
        my $name = $$self{name};
        ::panic("Can't reverse $name") if $REV;
        $PURE = 0 if $impure{$name};

        my $binding = $self->binding;
        if ($name eq "sym") {
            $$self{sym} = $SYM;
            $$self{endsym} = $ENDSYM if $ENDSYM;
        }
        elsif ($name eq "nextsame") {
            $NEEDORIGARGS++;
            return '$self->SUPER::' . $NAME . '(@origargs)';
        }
        if ($name =~ /^\w/) {
            push @TOKEN, "\$C->$name('?')" if $PURE;
            '$C->' . $name . "($binding)";
        }
        else {
            <<"END";
do {
    if (not $name) {
        \$C;
    }
    elsif (ref $name eq 'Regexp') {
        if (\${\$C->{orig}} =~ m/$name/gc) {
            \$C->cursor(\$+[0]);
        }
        else {
            ();
        }
    }
    else {
        \$C->$name($binding);
    }
}
END
        }
    }
}

{ package RE_method_internal; use base "REbase";
    sub walk {
        my $self = shift;
        my $name = $$self{name};
        local $NEEDMATCH = 0;
        my $args = ::un6($$self{args});
        ::panic("Can't reverse $name") if $REV;
        $PURE = 0 if $impure{$name};

        my $re = '$C->' . $name . "(\$mydepth,'',undef, $args)";
        $re = 'do {my $M = $C->matchify($mydepth)->{M}; ' . $re . '; }' if $NEEDMATCH;
        $re;
    }
}

{ package RE_method_re; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = $$self{re};
        my $name = $$self{name};
        ::panic("Can't reverse $name") if $REV;
        $PURE = 0 if $impure{$name};
        local $REV = '_rev' if $name eq 'after';
        $re = ::indent($re->walk(@_));
        $REV = '';

        my $binding = $self->binding;
        if ($PURE) {
            if ($name eq 'before') {
                push @TOKEN, $re;
            }
            else {
                push @TOKEN, "\$C->$name( \$mydepth,'',undef, sub { my \$C=shift;\n$re\n} )";
            }
        }
        '$C->' . $name . "($binding, sub { my \$C=shift;\n$re\n})";
    }
}

{ package RE_method_str; use base "REbase";
    sub walk {
        my $self = shift;
        my $str = $$self{str};
        my $name = $$self{name};
        ::panic("Can't reverse $name") if $REV;
        $PURE = 0 if $impure{$name};
        $str =~ s/(['\\])/\\$1/g;

        my $binding = $self->binding;
        push @TOKEN, "\$C->$name('$str','?')" if $PURE;
        '$C->' . $name . "($binding, '$str')";
    }
}

{ package RE_method; use base "REbase";
    sub walk {
        my $self = shift;
        local $NEEDMATCH = 0;
        my $rest = ::un6($$self{rest});
        my $name = $$self{name};
        ::panic("Can't reverse $name") if $REV;
        $PURE = 0 if $impure{$name};

        my $binding = $self->binding;
        $rest =~ s/\)$/, /;
        $rest =~ s/\(,? *//;
        push @TOKEN, "\$C->$name$rest'?')" if $PURE;
        my $re = "\$C->$name($binding, $rest)";
        $re = 'do { my $M = $C->matchify($mydepth)->{M}; ' . $re . '; }' if $NEEDMATCH;
        $re;
    }
}

{ package RE_noop; use base "REbase";
    sub walk {
        my $self = shift;
        '$C';
    }
}

{ package RE_every; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{zyg}) {
            $PURE = 0 if @{$$self{zyg}} > 1;
            foreach my $kid (@{$$self{zyg}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse serial conjunction") if $REV;
            my $result = ::indent(join("\nSAME\n", @result));
            $result;
        }
    };
}

{ package RE_first; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{zyg}) {
            $PURE = 0 if @{$$self{zyg}} > 1;
            foreach my $kid (@{$$self{zyg}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse serial disjunction") if $REV;
            for (@result) { s/^/push \@gather, / }
            my $result = "do { my \@gather;\n" .
                            ::indent(join("\nor\n", @result),2) .
                          ";\n  \@gather;\n}";
            $result;
        }
    }
}

{ package RE_paren; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "do { local \$MATCHID = \$C; \$C->_${REV}PAREN( \$mydepth, '', undef, sub { my \$C=shift;\n" . $re . "\n})}";
    }
}

{ package RE_quantified_atom; use base "REbase";
    sub walk {
        my $self = shift;
        my $result;
        #warn ::Dump($self);
        #warn $$self{quant},"\n";
        if (ref $$self{atom}) {
            my $quant = "";
            my $rep = "_REP";
            my $q = $$self{quant};
            if ($q) {
                my ($qfer,$how,$rest) = @{$$self{quant}};
                my $h = $how eq '!' ? 'g' :
                        $how eq '?' ? 'f' :
                                      'r';
                if ($qfer eq '*') {
                    $PURE = 0;
                    $quant = "\$C->_STAR$h$REV(";
                }
                elsif ($qfer eq '+') {
                    $quant = "\$C->_PLUS$h$REV(";
                }
                elsif ($qfer eq '?') {
                    $PURE = 0;
                    $quant = "\$C->_OPT$h$REV(";
                }
                elsif ($qfer eq '**') {
                    if (ref $rest) {
                        if (ref $rest eq "RE_block") {
                            $PURE = 0;
                            $rep = "_REPINDIRECT$REV";
                            $rest = $rest->walk();
                        }
                        else {
                            $rep = "_REPSEP$REV";
                            $rest = " sub { my \$C=shift;\n" . ::indent($rest->walk()) . "\n}";
                        }
                    }
                    else {
                        $PURE = 0 if $rest =~ /^0/;
                        $rest = "'$rest'";
                    }
                    $quant = "\$C->$rep$h(\$mydepth, '', undef, $rest, ";
                }
                $result = $quant . "\$mydepth,'',undef, sub { my \$C=shift;\n" . ::indent($$self{atom}->walk(@_)) . "\n})";
            }
            else {
                $result = $$self{atom}->walk(@_);
            }
        }
        else {
            $result = '"' . $$self{atom} . '"';
        }
        $result;
    }
}

{ package RE_qw; use base "REbase";
    sub walk {
        my $self = shift;
        "\$C->_ARRAY$REV(\$mydepth, '', undef, qw$$self{text} )";
    }
}

{ package RE_sequence; use base "REbase";
    sub wrapone {
        my ($outer, $inner) = @_;
        if ($MAYBACKTRACK) {
            "(map { my \$C=\$_;\n" .
                ::indent($inner) .
            "\n} $outer)";
        }
        else {
            "$outer andthen\n$inner\n}";
        }
    }

    sub walk {
        my $self = shift;
        my @result;
        my @decl;
        if ($$self{zyg}) {
            my @kids = @{$$self{zyg}};

            while (@kids and ref $kids[0] eq 'RE_decl') {
                push @decl, shift(@kids)->walk(@_);
            }

            @kids = reverse @kids if $REV;
            foreach my $kid (@kids) {
                my $r = $kid->walk(@_);
                push @result, $r;
            }
        }
        my $result = pop @result;
        for (reverse @result) {
            $result = wrapone($_,$result);
        }
        join('', @decl, $result || '');
    }
}

{ package RE_submatch; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{zyg}) {
            $PURE = 0 if @{$$self{zyg}} > 1;
            foreach my $kid (@{$$self{zyg}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse submatch") if $REV;
            my $against = shift @result;
            my $pattern = ::indent(shift @result);
            $against =~ s/BACK//;
            $against .= "";
            my $result = "\$C->SUBMATCH(\$mydepth, '', undef, $against, sub {\n$pattern\n})";
            $result;
        }
    }
}

{ package RE_all; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{zyg}) {
            $PURE = 0 if @{$$self{zyg}} > 1;
            foreach my $kid (@{$$self{zyg}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            my $result = ::indent(join("\nSAMEwith\n", @result));
            $result;
        }
    }
}

{ package RE_any; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        my $alt = 0;
        local @ALTS;
        my $altname = $self->{altname};
        if ($$self{zyg}) {
            $PURE = 0 if @{$$self{zyg}} > 1;
            foreach my $kid (@{$$self{zyg}}) {
                local @TOKEN;
                local $PURE = 1;
                my $r = $kid->walk(@_);
#                if ($r and $r =~ /^\$C->(\w+)/) {
#                    my $name = $1;
#                    if (my $p = $fixedprefix{$name}) {
#                        $r = "\$C->_EQ(\$C->{pos}, $p) && " . $r;
#                    }
#                }
                push @result, $r;
                my $token;
                if (@TOKEN) {
                    $token = '(' . join(' X ',@TOKEN) . ')';
                }
                else {
                    $token = "''";
                }
                $kid->{alt} = $altname . ' ' . $alt++;
                push @ALTS, $token;
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            for (@result) { $_ = "sub { my \$C=shift; $_ }," }
            my $policy;
            if ($failover) {
                $policy = <<"END"
    my \@try = @{[ '0..' . (@ALTS-1) ]};
    unshift \@try, splice(\@try,\$try,1) if \$tag eq '$altname';
END
            }
            else {
                $policy = <<"END"
    my \@try = \$tag eq '$altname' ? (\$try) : ();
END
            }
            my $result = <<"END";
do {
    if (\$fate and \$fate->[0] eq '$altname') {
        print STDERR "Fate passed to $altname: \$\$fate[3]\\n";
        (\$tag, \$try, \$fate) = \@\$fate;
    }
    else {
        \$fate = \$C->_AUTOLEXnow('${PKG}::$altname')->(\$C);
        if (\$fate) {
            print STDERR "FATE OF ${PKG}::$altname: \$\$fate[3]\\n";
            (\$tag, \$try, \$fate) = \@\$fate;
        }
        else {
            print STDERR "NO FATE FOR ${PKG}::$altname (will probe)\\n";
            \$tag = '';
        }
    }
$policy
    print STDERR "$altname will try: \@try\\n" if \@try > 1;
    my \@gather = ();
    while (\@try and not \@gather) {
        my \$try = shift(\@try);
        print STDERR "Trying \$tag \$try\\n";
        push \@gather, ((
@{[ ::indent(join("\n", @result),3) ]}
        )[\$try])->(\$C);
    }
    \@gather;
}
END
            $result;
        }
    }
}

{ package RE_var; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        $PURE = 0;
        if ($var =~ /^\$/) {
            if ($var =~ /^\$(\d+)$/) {
                "\$C->_BACKREFp$REV(\$mydepth,'',undef,$1)";
            }
            elsif ($var =~ /^\$<(.*)>$/) {
                "\$C->_BACKREFn$REV(\$mydepth,'',undef,'$1')";
            }
            else {
                "\$C->_EXACT$REV(\$mydepth,'',undef,$var)";
            }
        }
        elsif ($var =~ /^\@/) {
            "\$C->_ARRAY$REV(\$mydepth,'',undef,$var)";
        }
        elsif ($var =~ /^\%/) {
            "\$C->_HASH$REV(\$mydepth,'',undef,$var)";
        }
    }
}
MAIN();

## vim: expandtab sw=4
