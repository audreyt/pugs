#!/usr/bin/perl

use strict;
use warnings;

use YAML;

our $STOP = "";
our $REV = "";
our $NAME = "";
our $BINDING = "";
our $CONTEXT = "prog";
our $PARSEBIND = 0;
our $PAREN = 0;
our %adverbs = ();
our %fixedprefix;
our $PURE;
our $TOKEN;

my $TRACE = 0;

undef $/;

$_ = <>;
my $all = $_;

sub indent {
    my $x = shift || '';
    $x =~ s/^/    /mg;
    $x;
}

sub panic {
    my $line = 0;
    while (length($all) > length($_)) {
        if ($all =~ s/^#line (\d+)\n//) {
            $line = $1;
        }
        else {
            $all =~ s/^.*\n//;
            $line++;
        }
    }
    die @_,
        " at line ", $line - 1,
        " near '", /^(.{0,30}) /,
        "'\n";
}

my $out = "";

s/^(\s+)// and $out .= $1;
while ($_ ne "") {
    if ( s/^(#line.*\n)// ) { next }

    if ( s/^(#.*\n)// ) { $out .= $1; next }

    my $remaining = length($_);
    if ( s/^(rule|token|regex)(\s+)(\w+)(.*?)\s+{//s ) {
        local $CONTEXT = $1;
        local $PAREN = 0;
        my $ws = $2;
        local $NAME = $3;
        local $BINDING;
        undef $BINDING;
        my $args = $4;
        my $sym = "";
        my $coercion = "";
        $args =~ s/\(/(, / or
        $args =~ s/^/ () /;
        my $p = "";

        if ($args =~ s/ --> (\w*)\)/\)/) {
            $coercion = $1 . ".coerce";
        }
        if ($args =~ s/, *:\$sym is context (?:is rw )?= (.*)\)/\)/) {
            $p = $1;
            $sym = "my \$sym is context = $1;\n";
        }
        if ($args =~ s/, *:(\$endsym is context .*)\)/\)/) {
            $sym .= "my $1;\n";
        }
        if ($args =~ s/, *StrPos :(\$endargs is context .*)\)/\)/) {
            $sym .= "my StrPos $1;\n";
        }
        if ($args =~ s/, *StrPos :(\$endstmt is context .*)\)/\)/) {
            $sym .= "my StrPos $1;\n";
        }
        if ($args =~ s/, *(\$stop is context)(.*)\)/, \$stop_$2\)/) {
            $sym .= "my $1 = \$stop_;\n";
        }
        $args =~ s/(.*)\)/$1, :\$bind)/;
        $args =~ s/\(, */(/;
        $args =~ s/\((.*)\)/$1/s;
        my $callargs = $args;
        $callargs =~ s/\*([@%])/$1/g;
        $callargs =~ s/= [^,]*//g;
        $callargs =~ s/is context\s*//g;
        $callargs =~ s/is rw\s*//g;

        if ($NAME =~ /_/) {
            if ($p and /^\s*(?:<\??before>\s+)?<sym>/) {
                $fixedprefix{$NAME} = $p;
            }
            elsif (/^\s*(?:<\??before>\s+)?('\S*'\s)/) {
                $fixedprefix{$NAME} = $1;
            }
            elsif (/^\s*(?:<\??before>\s+)?("\S*"\s)/) {
                $fixedprefix{$NAME} = $1;
            }
        }

        my $re = regex('\\}');

        my $old = substr($all, length($all) - $remaining, $remaining - length($_)+1);
        $old =~ s/^/##      /mg;
        $out .= "$old\n\n";

        local $TOKEN;
        local $PURE = 1;
        my $result = ::indent($re->walk()) . "\n";

        if ($TOKEN) {
            $out .= <<"END";
sub$ws${NAME}_ACTION (\$/, \$lvl, \$FROM, $args) {
    my \$LVL is context = \$lvl;
    map { $coercion(\$_.cursor_all(\$FROM, \$_.to)).retm(\$bind) },
    map { .matchify },
$result
}

method$ws${NAME}_TOKEN ($args) {
    my \$LVL is context = self.callm();
    my \$/ := self;
    my \$¢ = self.pos;
    my \$FROM is context = \$¢;
$TOKEN
}

method$ws${NAME} ($args){
    $sym
    gather for self.${NAME}_TOKEN($callargs) -> \@m {
        say "LENGTH = ",\@m[1].pos;
        take \@m[0](\@m[1],\@m[2], \@m[3], $callargs);
    }

END
        }
        else {
            $out .= <<"END";
method$ws$NAME ($args) {
    my \$LVL is context = self.callm();
    my \$/ := self;
    my \$¢ = self.pos;
    my \$FROM is context = \$¢;
    $sym
    map { $coercion(\$_.cursor_all(\$FROM, \$_.to)).retm(\$bind) },
    map { .matchify },
$result
END
        }
        next;
    }

    if (s/^(.*\n)//) {
        my $line = $1;
        if ($line =~ s/^grammar (\w+)//) {
            $out .= "use Cursor;\ngrammar $1 is Cursor";
        }
        $out .= $line;
    }
}
print $out;

sub here {
    print +(caller(1))[3],": ",/^(.{0,20})/,"\n" if $TRACE;
}

#############################################3333
## Regex
#############################################3333

sub ws {
    for (;;) {
        next if s/^\s+//;
        next if s/^#\(.*?\)//s;
        next if s/^#\{.*?\}//s;
        next if s/^#\[.*?\]//s;
        next if s/^#\<.*?\>//s;
        next if s/^#.*\n//;
        last;
    }
}

sub regex {
    here();
    ws();
    local $STOP = shift;
    return bless { re => ordered_disjunction() }, "RE";
}

sub ordered_disjunction {
    here();
    my @kids;

    s/^\|\|//;

    do {
        ws();
        push @kids, ordered_conjunction();
        ws();
    } while s/^\|\|//;

    return bless { Kids => [@kids] }, "RE_ordered_disjunction";
}

sub ordered_conjunction {
    here();
    my @kids;

    do {
        ws();
        push @kids, submatch();
        ws();
    } while s/^\&\&//;

    return bless { Kids => [@kids] }, "RE_ordered_conjunction";
}

sub submatch {
    here();
    my @kids;

    do {
        ws();
        push @kids, unordered_disjunction();
        ws();
    } while s/^\!?\~\~//;

    return bless { Kids => [@kids] }, "RE_submatch";
}

sub unordered_disjunction {
    here();
    my @kids;

    s/^ \| (?!\|) //x;

    do {
        ws();
        push @kids, unordered_conjunction();
        ws();
    } while s/^ \| (?!\|) //x;

    return bless { Kids => [@kids] }, "RE_unordered_disjunction";
}

sub unordered_conjunction {
    here();
    my @kids;

    do {
        ws();
        push @kids, sequence();
        ws();
    } while s/^ \& (?!\&) //x;

    return bless { Kids => [@kids] }, "RE_unordered_conjunction";
}

sub sequence {
    here();
    my @kids;
    my $k;

    while ($k = quantified_atom()) {
        push(@kids, $k);
    }

    return bless { Kids => [@kids] }, "RE_sequence";
}

sub quantified_atom {
    here();
    my $atom = atom();
    return unless defined $atom;
    my $quant = quantifier();
    return bless { atom => $atom, quant => $quant }, "RE_quantified_atom";
}

sub quantifier {
    if (s/^(\*\*)([?!:+]?)// or
        s/^(\*)([?!:+]?)// or
        s/^(\+)([?!:+]?)// or
        s/^(\?)([?!:+]?)//) {
        my ($q,$m) = ($1,$2);
        if (not $m) {
            if ($CONTEXT eq 'rule' or $CONTEXT eq 'token') {
                $m = ':';
            }
            else {
                $m = '!';
            }
        }
        elsif ($m eq '+') {
                $m = '!';
        }
        my $x = "";
        ws();
        if ($q eq '**') {
            if (s/^(\d+(\.\.(\d+|\*))?)//) {
                $x = $1;
            }
            elsif (/^\{/) {
                $x = block('thunk');
            }
            else {
                $x = atom();
            }
        }
        ws();
        return [$q,$m,$x];
    }
}

sub atom {
    here();
    return if /^ [\]&|)] /x;   # XXX an approximation
    return if /^ (?:
        >(?!>) |
        !?~~
    )/x;
    return if /^ ( $STOP )/x;

    if (/^[*+?]/) { panic "quantifier quantifies nothing"; }

    if (s/^ (\w+) (?! \s* [*+?]) //x) {
        my $word = $1;
        ws();
        return bless { text => $word }, "RE_exact";
    }
    if (s/^ (\w) //x) {
        my $word = $1;
        ws();
        return bless { text => $word }, "RE_exact";
    }

    if (s/^\{\*\}//) {
        my $key = $NAME;
        if (s/^(.*?)\s*#=\s+(.*)/$1/) {
            $key .= " $2";
        }
        ws();
        $key =~ s/(['\\])/\\$1/g;
        return bless { name => '_REDUCE', nobind => 1, rest => "('$key')"}, "RE_method";
    }
    if (/^\{/) {
        my $b = block('void');
        ws();
        return $b;
    }

    if (s/^\\//) { my $bs = backslash(); ws(); return $bs; }

    if (s/^\[//) {
        my $re = regex('\\]');
        s/^\]// or panic "Missing ]";
        ws();
        return bless $re, "RE_bracket";
    }

    if (s/^\(//) {
        my $re = regex('\\)');
        s/^\)// or panic "Missing )";
        ws();
        $re = bless $re, "RE_paren";
        if (not $PARSEBIND) {  # XXX leaves quantifier outside?
            $re = bless { var => $PAREN++, atom => $re }, "RE_bindpos";
        }
        return $re;
    }

    if (s/^ (: !? \w+)//x) {
        my $adverb = $1;
        local %adverbs = %adverbs;
        
        # XXX chintzy
        if (s/^(\(.*?\))//) {
            $adverbs{$adverb} = $1;
        }
        else {
            my $not = $adverb =~ s/!//;
            $adverbs{$adverb} = !$not;
        }
        ws();

        return atom();
    }

    # check unbalanced angles before assertions

    if (s/^(<<|>>|«|»)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary }, "RE_meta";
    }

    if (s/^(<\(|\)>)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary }, "RE_meta";
    }

    if (/^<\s/) {
        my $re = unbalanced(">");
        s/^>// or panic "Missing >";
        $re .= '>';
        ws();
        return bless { text => $re }, "RE_qw";
    }

    # assertions

    if (s/^<//) {
        my $re = assertion();
        ws();
        return $re;
    }

    # now the rest of the metas

    if (s/^'//) {
        my $re = unbalanced("'");
        s/^'// or panic "Missing '";
        ws();
        return bless { text => $re }, "RE_single";
    }
    if (s/^"//) {
        my $re = unbalanced('"');
        s/^"// or panic 'Missing "';
        ws();
        return bless { text => $re }, "RE_double";
    }

    if (/^[\$\@\%]/) {
        my $code;
        if (/^[\$\@\%]</) {
            $code = unbalanced('>');
            s/^>// or panic "Missing >";
            $code .= '>';
        }
        if (s/^([\$\@\%][.!?*+]?\w+)//) {
            $code = $1;
        }
        if (defined $code) {
            ws();
            if (s/^:=//) {
                ws();
                local $PARSEBIND = 1;
                my $atom = quantified_atom(@_);
                $atom->{nobind} = 1;
                ws();
                if ($code =~ s/[\$\@%]<(.*)>/$1/) {
                    return bless { var => $code, atom => $atom }, "RE_bindnamed";
                }
                return bless { var => $code, atom => $atom }, "RE_bindvar";
            }
            else {
                return bless { var => $code }, "RE_var";
            }
        }
    }

    # must follow variables
    if (s/^([\^\$]{1,2})//) {
        my $anchor = $1;
        ws();
        return bless { text => $anchor}, "RE_meta";
    }
    if (s/^(:+)//) {
        my $colons = $1;
        ws();
        return bless { text => $colons}, "RE_meta";
    }
    if (s/^\.//) {
        ws();
        return bless { text => '.'}, "RE_meta";
    }

    panic "unrecognized metacharacter @{[ substr($_,0,1) ]}";
}

sub backslash {
    my $ch = substr($_,0,1,"");
    
    if ($ch =~ /^\w$/) {
        if ($ch =~ /^[ftnr]/) {
            $ch =~ tr/ftnr/\f\t\n\r/;
            return bless { text => $ch }, "RE_exact";
        }
        if ($ch eq 'x') {
            s/^\[?([0-9a-fA-f]*)\]?//;
            return bless { text => chr(hex($1)) }, "RE_exact";
        }
        if ($ch eq 'o') {
            s/^\[?([0-7]*)\]?//;
            return bless { text => chr(oct($1)) }, "RE_exact";
        }
        if ($ch =~ /^[hvdswHVDSWNRTBF]/) {
            return bless { text => "\\$ch"}, "RE_meta";
        }
        panic "Unrecognized \\$ch";
    }
    if ($ch eq '\\') {
        return bless { text => '\\'}, "RE_exact";
    }
    return bless { text => $ch}, "RE_exact";
}

sub assertion {
    here();
    my $assert = substr($_,0,1);

    if (s/^[!?]//) {
        my $rest = assertion();
        $rest->{nobind} = 1;
        return bless { assert => $assert, re => $rest }, "RE_assertion";
    }

    if (s/^([a-zA-Z]\w*)//) {
        my $word = $1;
        my $ch = substr($_,0,1);
        if ($ch eq '>') {
            s/^>// or panic "Missing >";
            return bless { name => $word }, "RE_method_noarg";
        }
        if ($ch eq ':') {
            s/^:\s*//;
            my $str = unbalanced('>');
            s/^>// or panic "Missing >";
            if ($word eq 'after') {
                my $x = bless { name => '_vEXACT', str => $str }, "RE_method_str";
                return bless { name => $word, rest => $x }, "RE_method";
            }
            return bless { name => $word, str => $str }, "RE_method_str";
        }
        if ($ch eq '(') {
            my $code = code('\\)>');
            s/^\)>// or panic "Missing )>";
            $code .= ')';
            return bless { name => $word, rest => $code }, "RE_method";
        }
        s/^\s*//;
        my $re = regex('\\>');
        s/^>// or panic "Missing >";
        return bless { name => $word, re => $re }, "RE_method_re";
    }

    if (/^[\$\@\%]/) {
        my $code = code('>');
        s/^>// or panic "Missing >";
        if ($code =~ s/\(.*\)//) {
            return bless { name => $code, rest => $1 }, "RE_method";
        }
        else {
            return bless { name => $code }, "RE_method_noarg";
        }
    }

    if (/^[+-]?\[/) {
        my $cclass = unbalanced('>');
        s/^>// or panic "Missing >";
        return bless { text => $cclass }, "RE_cclass";
    }
    if (/^\{/) {
        my $b = block('bool');
        s/^>// or panic "Missing >";
        ws();
        return $b;
    }

}

sub block {
    # XXX
    my $context = shift;
    s/^({+)//;
    my $term = '\\}' x length($1);
    my $block = code($term);
    s/^$term// or panic "Missing }" ;
    return bless { text => $block, context => $context }, "RE_block";
}

sub code {
    # XXX
    my $code = unbalanced(@_);
    return $code;
}

sub unbalanced {
    my $terminator = shift;
    s/^ ( (\\. | . )*? ) (?=$terminator)//sx;
    return $1;
}

##########################################################

{ package REbase;
    sub walk {
        my $self = shift;
        my $result = "";
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                my $x = $kid->walk(@_);
                $result .= $x if defined $x;
            }
        }
        else {
            return ref $self;
        }
        return $result;
    }

}

{ package RE; use base "REbase";
    sub walk {
        my $self = shift;
        if ($$self{re}) {
            return $$self{re}->walk(@_);
        }
    }
}

{ package RE_adverb; use base "REbase";
}

{ package RE_assertion; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = $$self{re}->walk(@_);
        if ($$self{assert} eq '!') {
            "\$/._NOTBEFORE(-> \$/ {\n" . ::indent($re) . "\n})";
        }
        else {
            $re;
        }
    }
}

{ package RE_assertvar; use base "REbase";
}

{ package RE_block; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        my $ctx = $$self{context};
        if ($ctx eq 'void') {
            $PURE = 0;
            "({$text}() xx 0, \$/)";
        }
        elsif ($ctx eq 'bool') {
            "(\$/ xx ?{$text}())";
        }
        else {
            $PURE = 0;
            "{$text}";
        }
    }
}

{ package RE_bindvar; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        my $re = ::indent($$self{atom}->walk(@_));
        "$var := $re.matchify";
    }
}

{ package RE_bindnamed; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        local $BINDING = $var;
        my $re = ::indent($$self{atom}->walk(@_));
        if (defined $BINDING) {
            $re = "\$/._BINDNAMED$REV(-> \$/ {\n" . $re . "\n}, :bind<$var>)";
        }
        $re;
    }
}

{ package RE_bindpos; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        local $BINDING = $var;
        my $re = ::indent($$self{atom}->walk(@_));
        if (defined $BINDING) {
            $re = "\$/._BINDPOS$REV(-> \$/ {\n" . $re . "\n}, :bind<$var>)";
        }
        $re;
    }
}

{ package RE_bracket; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "\$/._BRACKET$REV(-> \$/ {\n" . $re . "\n})";
    }
}

{ package RE_cclass; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "\$/._CCLASS$REV('" . $text . "')";
    }
}

{ package RE_double; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        '$/._EXACT' . $REV . '("' . $text . '")';
    }
}

{ package RE_exact; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "\$/._EXACT$REV('" . $text . "')";
    }
}

{ package RE_meta; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        my $not = 0;
        my $code = "";
        if ($text =~ /^(\\[A-Z])(.*)/) {
            $text = lc($1) . $2;
            $not = 1;
        }
        if ($text eq '.') {
            $code = "\$/._ANY$REV()";
        }
        elsif ($text eq '^') {
            $code = "\$/._BOS$REV()";
        }
        elsif ($text eq '^^') {
            $code = "\$/._BOL$REV()";
        }
        elsif ($text eq '$') {
            $code = "\$/._EOS$REV()";
        }
        elsif ($text eq '$$') {
            $code = "\$/._EOL$REV()";
        }
        elsif ($text eq ':') {
            $code = "\$/._COMMITATOM$REV()";
        }
        elsif ($text eq '::') {
            $PURE = 0;
            $code = "\$/._COMMITBRANCH$REV()";
        }
        elsif ($text eq ':::') {
            $PURE = 0;
            $code = "\$/._COMMITRULE$REV()";
        }
        elsif ($text eq '\\d') {
            $code = "\$/._DIGIT$REV()";
        }
        elsif ($text eq '\\w') {
            $code = "\$/._ALNUM$REV()";
        }
        elsif ($text eq '\\s') {
            $code = "\$/._SPACE$REV()";
        }
        elsif ($text eq '\\h') {
            $code = "\$/._HSPACE$REV()";
        }
        elsif ($text eq '\\v') {
            $code = "\$/._VSPACE$REV()";
        }
        if ($not) { # XXX or maybe just .NOT on the end...
            $code = "\$/._NOTBEFORE(-> \$/ { $code })";
        }
        $code;
    }
}

{ package RE_method_noarg; use base "REbase";
    sub walk {
        my $self = shift;
        my $name = $$self{name};
        ::panic("Can't reverse submatch") if $REV;

        my $binding;
        if ($$self{nobind}) {
            $binding = '',
        }
        elsif (defined $BINDING) {
            $binding = ":bind<$BINDING>";
            undef $BINDING;
        }
        else {
            $binding = ":bind<$name>";
        }

        my $re = '$/.' . $name . "($binding)";
    }
}

{ package RE_method_re; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = $$self{re};
        my $name = $$self{name};
        ::panic("Can't reverse submatch") if $REV;
        local $REV = '_rev' if $name eq 'after';
        $re = ::indent($re->walk(@_));
        $REV = '';

        my $binding;
        if ($$self{nobind}) {
            $binding = '',
        }
        elsif (defined $BINDING) {
            $binding = ", :bind<$BINDING>";
            undef $BINDING;
        }
        else {
            $binding = ", :bind<$name>";
        }

        '$/.' . $name . "(-> \$/ {\n$re\n}$binding)";
    }
}

{ package RE_method_str; use base "REbase";
    sub walk {
        my $self = shift;
        my $str = $$self{str};
        my $name = $$self{name};
        ::panic("Can't reverse submatch") if $REV;
        $str =~ s/(['\\])/\\$1/g;

        my $binding;
        if ($$self{nobind}) {
            $binding = '',
        }
        elsif (defined $BINDING) {
            $binding = ", :bind<$BINDING>";
            undef $BINDING;
        }
        else {
            $binding = ", :bind<$name>";
        }

        '$/.' . $name . "('$str'$binding)";
    }
}

{ package RE_method; use base "REbase";
    sub walk {
        my $self = shift;
        my $rest = $$self{rest};
        my $name = $$self{name};
        ::panic("Can't reverse submatch") if $REV;

        my $binding;
        if ($$self{nobind}) {
            $binding = '',
        }
        elsif (defined $BINDING) {
            $binding = ", :bind<$BINDING>";
            undef $BINDING;
        }
        else {
            $binding = ", :bind<$name>";
        }

        $rest =~ s/\)/$binding)/ or die "Oops";
        $rest =~ s/\(, */(/;
        '$/.' . $name . $rest;
    }
}

{ package RE_ordered_conjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            $PURE = 0 if @{$$self{Kids}} > 1;
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse ordered conjunction") if $REV;
            my $result = ::indent(join("\nSAME\n", @result));
            $result;
        }
    };
}

{ package RE_ordered_disjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            $PURE = 0 if @{$$self{Kids}} > 1;
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse ordered disjunction") if $REV;
            my $result = ::indent(join("\n||\n", @result));
            $result;
        }
    }
}

{ package RE_paren; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "\$/._${REV}PAREN(-> \$/ {\n" . $re . "\n})";
    }
}

{ package RE_quantified_atom; use base "REbase";
    sub walk {
        my $self = shift;
        my $result;
        #print ::Dump($self);
        #print $$self{quant},"\n";
        if (ref $$self{atom}) {
            my $quant = "";
            my $rep = "_REP";
            my $q = $$self{quant};
            if ($q) {
                my ($qfer,$how,$rest) = @{$$self{quant}};
                my $h = $how eq '!' ? 'g' :
                        $how eq '?' ? 'f' :
                                      'r';
                if ($qfer eq '*') {
                    $quant = "\$/._STAR$h$REV(";
                }
                elsif ($qfer eq '+') {
                    $quant = "\$/._PLUS$h$REV(";
                }
                elsif ($qfer eq '?') {
                    $quant = "\$/._OPT$h$REV(";
                }
                elsif ($qfer eq '**') {
                    if (ref $rest) {
                        if (ref $rest eq "RE_block") {
                            $rep = "_REPINDIRECT$REV";
                            $rest = $rest->walk();
                        }
                        else {
                            $rep = "_REPSEP$REV";
                            $rest = "-> \$/ {\n" . ::indent($rest->walk()) . "\n}";
                        }
                    }
                    else {
                        $rest = "'$rest'";
                    }
                    $quant = "$rep$h($rest, ";
                }
                $result = $quant . "-> \$/ {\n" . ::indent($$self{atom}->walk(@_)) . "\n})";
            }
            else {
                $result = $$self{atom}->walk(@_);
            }
        }
        else {
            $result = '"' . $$self{atom} . '"';
        }
        $result;
    }
}

{ package RE_qw; use base "REbase";
    sub walk {
        my $self = shift;
        "\$/._ARRAY$REV($$self{text} )";
    }
}

{ package RE_sequence; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        my @pure;
        if ($$self{Kids}) {
            my @kids = @{$$self{Kids}};
            @kids = reverse @kids if $REV;
            foreach my $kid (@kids) {
                my $pure = $PURE;
                my $r = $kid->walk(@_);
                if ($pure != $PURE) {
                    @pure = @result;
                    @result = ();
                }
                push @result, $r;
            }
        }
        my $result = pop @result;
        for (reverse @result) {
            $result = "gather for $_ -> \$/ {\n" . ::indent("take " . $result) . "\n}";
        }
        if (@pure) {
            my $pure = '[&' . $NAME . '_ACTION, $/, $LVL, $FROM, $bind]';
            for (reverse @pure) {
                $pure = "gather for $_ -> \$/ {\n" . ::indent("take " . $pure) . "\n}";
            }
            $TOKEN = ::indent($pure);
        }
        $result;
    }
}

{ package RE_single; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "\$/._EXACT$REV('" . $text . "')";
    }
}

{ package RE_submatch; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            $PURE = 0 if @{$$self{Kids}} > 1;
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse submatch") if $REV;
            my $against = shift @result;
            my $pattern = ::indent(shift @result);
            $against =~ s/BACK//;
            $against .= "";
            my $result = "\$/.SUBMATCH($against, -> \$/ {\n$pattern\n})";
            $result;
        }
    }
}

{ package RE_unordered_conjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            $PURE = 0 if @{$$self{Kids}} > 1;
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            my $result = ::indent(join("\nSAMEwith\n", @result));
            $result;
        }
    }
}

{ package RE_unordered_disjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            $PURE = 0 if @{$$self{Kids}} > 1;
            foreach my $kid (@{$$self{Kids}}) {
                my $r = $kid->walk(@_);
                if ($r and $r =~ /^\$\/\.(\w+)/) {
                    my $name = $1;
                    if (my $p = $fixedprefix{$name}) {
                        $r = "\$/._EQ(\$¢, $p) && " . $r;
                    }
                }
                push @result, $r;
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            my $result = ::indent('(' . join("\n||\n", @result) . ')');
            $result;
        }
    }
}

{ package RE_var; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        $PURE = 0;
        if ($var =~ /^\$/) {
            if ($var =~ /^\$(\d+)$/) {
                "\$/._BACKREFp$REV($1)";
            }
            elsif ($var =~ /^\$<(.*)>$/) {
                "\$/._BACKREFn$REV('$1')";
            }
            else {
                "\$/._EXACT$REV($var)";
            }
        }
        elsif ($var =~ /^\@/) {
            "\$/._ARRAY$REV($var)";
        }
        elsif ($var =~ /^\%/) {
            "\$/._HASH$REV($var)";
        }
    }
}

## vim: expandtab sw=4
