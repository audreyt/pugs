#!/usr/bin/perl

use strict;
use warnings;

use YAML;

our $STOP = "";
our $REV = "";
our $NAME = "";
our $CONTEXT = "prog";
our $PARSEBIND = 0;
our $PAREN = 0;
our %adverbs = ();

my $TRACE = 0;

undef $/;

$_ = <>;
my $all = $_;

sub indent {
    my $x = shift || '';
    $x =~ s/^/    /mg;
    $x;
}

sub panic {
    my $line = 0;
    while (length($all) > length($_)) {
        if ($all =~ s/^#line (\d+)\n//) {
            $line = $1;
        }
        else {
            $all =~ s/^.*\n//;
            $line++;
        }
    }
    die @_,
        " at line ", $line - 1,
        " near '", /^(.{0,30}) /,
        "'\n";
}

my $out = "";

s/^(\s+)// and $out .= $1;
while ($_ ne "") {
    if ( s/^(#line.*\n)// ) { next }

    if ( s/^(#.*\n)// ) { $out .= $1; next }

    my $remaining = length($_);
    if ( s/^(rule|token|regex)(\s+)(\w+)(.*?)\s+{//s ) {
        local $CONTEXT = $1;
        local $PAREN = 0;
        my $ws = $2;
        local $NAME = $3;
        my $args = $4;
        my $sym = "";
        my $coercion = "";
        $args =~ s/\(/(\$¢, / or
        $args =~ s/^/ (\$¢) /;

        if ($args =~ s/ --> (\w*)\)/\)/) {
            $coercion = $1 . ".coerce";
        }
        if ($args =~ s/, *:(\$sym is context .*)\)/\)/) {
            $sym = $1;
            $sym =~ s/is rw //;
            $sym = "my $sym;\n";
        }
        if ($args =~ s/, *:(\$endsym is context .*)\)/\)/) {
            $sym .= "my $1;\n";
        }
        my $re = regex('\\}');

        my $old = substr($all, length($all) - $remaining, $remaining - length($_)+1);
        $old =~ s/^/##      /mg;
        $out .= "$old\n\n";

        my $result = ::indent($re->walk()) . "\n";
        $out .= <<"END";
method$ws$NAME$args
{
    my \$LVL is context = callm(\$¢);
    my \$FROM is context = \$¢;
    $sym
    map { retm($coercion(self.capture(\$FROM, \$_))) },
$result
END
        next;
    }

    if (s/^(.*\n)//) {
        my $line = $1;
        if ($line =~ s/^grammar (\w+)//) {
            $out .= "use Metholated;\ngrammar $1 is Metholated";
        }
        $out .= $line;
    }
}
print $out;

sub here {
    print +(caller(1))[3],": ",/^(.{0,20})/,"\n" if $TRACE;
}

#############################################3333
## Regex
#############################################3333

sub ws {
    for (;;) {
        next if s/^\s+//;
        next if s/^#\(.*?\)//s;
        next if s/^#\{.*?\}//s;
        next if s/^#\[.*?\]//s;
        next if s/^#\<.*?\>//s;
        next if s/^#.*\n//;
        last;
    }
}

sub regex {
    here();
    ws();
    local $STOP = shift;
    return bless { re => ordered_disjunction() }, "RE";
}

sub ordered_disjunction {
    here();
    my @kids;

    s/^\|\|//;

    do {
        ws();
        push @kids, ordered_conjunction();
        ws();
    } while s/^\|\|//;

    return bless { Kids => [@kids] }, "RE_ordered_disjunction";
}

sub ordered_conjunction {
    here();
    my @kids;

    do {
        ws();
        push @kids, submatch();
        ws();
    } while s/^\&\&//;

    return bless { Kids => [@kids] }, "RE_ordered_conjunction";
}

sub submatch {
    here();
    my @kids;

    do {
        ws();
        push @kids, unordered_disjunction();
        ws();
    } while s/^\!?\~\~//;

    return bless { Kids => [@kids] }, "RE_submatch";
}

sub unordered_disjunction {
    here();
    my @kids;

    s/^ \| (?!\|) //x;

    do {
        ws();
        push @kids, unordered_conjunction();
        ws();
    } while s/^ \| (?!\|) //x;

    return bless { Kids => [@kids] }, "RE_unordered_disjunction";
}

sub unordered_conjunction {
    here();
    my @kids;

    do {
        ws();
        push @kids, sequence();
        ws();
    } while s/^ \& (?!\&) //x;

    return bless { Kids => [@kids] }, "RE_unordered_conjunction";
}

sub sequence {
    here();
    my @kids;
    my $k;

    while ($k = quantified_atom()) {
        push(@kids, $k);
    }

    return bless { Kids => [@kids] }, "RE_sequence";
}

sub quantified_atom {
    here();
    my $atom = atom();
    return unless defined $atom;
    my $quant = quantifier();
    return bless { atom => $atom, quant => $quant }, "RE_quantified_atom";
}

sub quantifier {
    if (s/^(\*\*)([?!:+]?)// or
        s/^(\*)([?!:+]?)// or
        s/^(\+)([?!:+]?)// or
        s/^(\?)([?!:+]?)//) {
        my ($q,$m) = ($1,$2);
        if (not $m) {
            if ($CONTEXT eq 'rule' or $CONTEXT eq 'token') {
                $m = ':';
            }
            else {
                $m = '!';
            }
        }
        elsif ($m eq '+') {
                $m = '!';
        }
        my $x = "";
        ws();
        if ($q eq '**') {
            if (s/^(\d+(\.\.(\d+|\*))?)//) {
                $x = $1;
            }
            elsif (/^\{/) {
                $x = block('thunk');
            }
            else {
                $x = atom();
            }
        }
        ws();
        return [$q,$m,$x];
    }
}

sub atom {
    here();
    return if /^ [\]&|)] /x;   # XXX an approximation
    return if /^ (?:
        >(?!>) |
        !?~~
    )/x;
    return if /^ ( $STOP )/x;

    if (/^[*+?]/) { panic "quantifier quantifies nothing"; }

    if (s/^ (\w+) (?! \s* [*+?]) //x) {
        my $word = $1;
        ws();
        return bless { text => $word }, "RE_exact";
    }
    if (s/^ (\w) //x) {
        my $word = $1;
        ws();
        return bless { text => $word }, "RE_exact";
    }

    if (s/^\{\*\}//) {
        my $key = $NAME;
        if (s/^(.*?)\s*#=\s+(.*)/$1/) {
            $key .= " $2";
        }
        ws();
        $key =~ s/(['\\])/\\$1/g;
        return bless { name => '_REDUCE', rest => "('$key')"}, "RE_method";
    }
    if (/^\{/) {
        my $b = block('void');
        ws();
        return $b;
    }

    if (s/^\\//) { my $bs = backslash(); ws(); return $bs; }

    if (s/^\[//) {
        my $re = regex('\\]');
        s/^\]// or panic "Missing ]";
        ws();
        return bless $re, "RE_bracket";
    }

    if (s/^\(//) {
        my $re = regex('\\)');
        s/^\)// or panic "Missing )";
        ws();
        $re = bless $re, "RE_paren";
        if (not $PARSEBIND) {  # XXX leaves quantifier outside?
            $re = bless { var => ('$' . $PAREN++), atom => $re }, "RE_bind";
        }
        return $re;
    }

    if (s/^ (: !? \w+)//x) {
        my $adverb = $1;
        local %adverbs = %adverbs;
        
        # XXX chintzy
        if (s/^(\(.*?\))//) {
            $adverbs{$adverb} = $1;
        }
        else {
            my $not = $adverb =~ s/!//;
            $adverbs{$adverb} = !$not;
        }
        ws();

        return atom();
    }

    # check unbalanced angles before assertions

    if (s/^(<<|>>|«|»)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary }, "RE_meta";
    }

    if (s/^(<\(|\)>)//) {
        my $boundary = $1;
        ws();
        return bless { text => $boundary }, "RE_meta";
    }

    if (/^<\s/) {
        my $re = unbalanced(">");
        s/^>// or panic "Missing >";
        $re .= '>';
        ws();
        return bless { text => $re }, "RE_qw";
    }

    # assertions

    if (s/^<//) {
        my $re = assertion();
        ws();
        return $re;
    }

    # now the rest of the metas

    if (s/^'//) {
        my $re = unbalanced("'");
        s/^'// or panic "Missing '";
        ws();
        return bless { text => $re }, "RE_single";
    }
    if (s/^"//) {
        my $re = unbalanced('"');
        s/^"// or panic 'Missing "';
        ws();
        return bless { text => $re }, "RE_double";
    }

    if (/^[\$\@\%]/) {
        my $code;
        if (/^[\$\@\%]</) {
            $code = unbalanced('>');
            s/^>// or panic "Missing >";
            $code .= '>';
        }
        if (s/^([\$\@\%][.!?*+]?\w+)//) {
            $code = $1;
        }
        if (defined $code) {
            ws();
            if (s/^:=//) {
                ws();
                local $PARSEBIND = 1;
                my $atom = quantified_atom(@_);
                ws();
                return bless { var => $code, atom => $atom }, "RE_bind";
            }
            else {
                return bless { var => $code }, "RE_var";
            }
        }
    }

    # must follow variables
    if (s/^([\^\$]{1,2})//) {
        my $anchor = $1;
        ws();
        return bless { text => $anchor}, "RE_meta";
    }
    if (s/^(:+)//) {
        my $colons = $1;
        ws();
        return bless { text => $colons}, "RE_meta";
    }
    if (s/^\.//) {
        ws();
        return bless { text => '.'}, "RE_meta";
    }

    panic "unrecognized metacharacter @{[ substr($_,0,1) ]}";
}

sub backslash {
    my $ch = substr($_,0,1,"");
    
    if ($ch =~ /^\w$/) {
        if ($ch =~ /^[ftnr]/) {
            $ch =~ tr/ftnr/\f\t\n\r/;
            return bless { text => $ch }, "RE_exact";
        }
        if ($ch eq 'x') {
            s/^\[?([0-9a-fA-f]*)\]?//;
            return bless { text => chr(hex($1)) }, "RE_exact";
        }
        if ($ch eq 'o') {
            s/^\[?([0-7]*)\]?//;
            return bless { text => chr(oct($1)) }, "RE_exact";
        }
        if ($ch =~ /^[hvdswHVDSWNRTBF]/) {
            return bless { text => "\\$ch"}, "RE_meta";
        }
        panic "Unrecognized \\$ch";
    }
    if ($ch eq '\\') {
        return bless { text => '\\'}, "RE_exact";
    }
    return bless { text => $ch}, "RE_exact";
}

sub assertion {
    here();
    my $assert = substr($_,0,1);

    if (s/^[!?]//) {
        my $rest = assertion();
        return bless { assert => $assert, re => $rest }, "RE_assertion";
    }

    if (s/^([a-zA-Z]\w*)//) {
        my $word = $1;
        my $ch = substr($_,0,1);
        if ($ch eq '>') {
            s/^>// or panic "Missing >";
            return bless { name => $word }, "RE_method_noarg";
        }
        if ($ch eq ':') {
            s/^:\s*//;
            my $str = unbalanced('>');
            s/^>// or panic "Missing >";
            if ($word eq 'after') {
                my $x = bless { name => '_vEXACT', str => $str }, "RE_method_str";
                return bless { name => $word, rest => $x }, "RE_method";
            }
            return bless { name => $word, str => $str }, "RE_method_str";
        }
        if ($ch eq '(') {
            my $code = code('\\)>');
            s/^\)>// or panic "Missing )>";
            $code .= ')';
            return bless { name => $word, rest => $code }, "RE_method";
        }
        s/^\s*//;
        my $re = regex('\\>');
        s/^>// or panic "Missing >";
        return bless { name => $word, re => $re }, "RE_method_re";
    }

    if (/^[\$\@\%]/) {
        my $code = code('>');
        s/^>// or panic "Missing >";
        if ($code =~ s/\(.*\)//) {
            return bless { name => $code, rest => $1 }, "RE_method";
        }
        else {
            return bless { name => $code }, "RE_method_noarg";
        }
    }

    if (/^[+-]?\[/) {
        my $cclass = unbalanced('>');
        s/^>// or panic "Missing >";
        return bless { text => $cclass }, "RE_cclass";
    }
    if (/^\{/) {
        my $b = block('bool');
        s/^>// or panic "Missing >";
        ws();
        return $b;
    }

}

sub block {
    # XXX
    my $context = shift;
    s/^({+)//;
    my $term = '\\}' x length($1);
    my $block = code($term);
    s/^$term// or panic "Missing }" ;
    return bless { text => $block, context => $context }, "RE_block";
}

sub code {
    # XXX
    my $code = unbalanced(@_);
    return $code;
}

sub unbalanced {
    my $terminator = shift;
    s/^ ( (\\. | . )*? ) (?=$terminator)//sx;
    return $1;
}

{ package REbase;
    sub walk {
        my $self = shift;
        my $result = "";
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                my $x = $kid->walk(@_);
                $result .= $x if defined $x;
            }
        }
        else {
            return ref $self;
        }
        return $result;
    };
}

##########################################################

{ package RE; use base "REbase";
    sub walk {
        my $self = shift;
        if ($$self{re}) {
            return $$self{re}->walk(@_);
        }
    };
}

{ package RE_adverb; use base "REbase";
}

{ package RE_assertion; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = $$self{re}->walk(@_);
        if ($$self{assert} eq '!') {
            "self._NOTBEFORE(\$¢, -> \$¢ {\n" . ::indent($re) . "\n})";
        }
        else {
            $re;
        }
    }
}

{ package RE_assertvar; use base "REbase";
}

{ package RE_block; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        my $ctx = $$self{context};
        if ($ctx eq 'void') {
            "({$text}() xx 0, \$¢)";
        }
        elsif ($ctx eq 'bool') {
            "(\$¢ xx ?{$text}())";
        }
        else {
            "{$text}";
        }
    }
}

{ package RE_bind; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        my $re = ::indent($$self{atom}->walk(@_));
        "self._${REV}BIND(\$¢, '$var', -> \$¢ {\n" . $re . "\n})";
    }
}

{ package RE_bracket; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "self._${REV}BRACKET(\$¢, -> \$¢ {\n" . $re . "\n})";
    }
}

{ package RE_cclass; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "self._${REV}CCLASS(\$¢, '" . $text . "')";
    }
}

{ package RE_double; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        'self._' . $REV . 'EXACT($¢, "' . $text . '")';
    }
}

{ package RE_exact; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "self._${REV}EXACT(\$¢, '" . $text . "')";
    }
}

{ package RE_meta; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        my $not = 0;
        my $code = "";
        if ($text =~ /^(\\[A-Z])(.*)/) {
            $text = lc($1) . $2;
            $not = 1;
        }
        if ($text eq '.') {
            $code = "self._${REV}ANY(\$¢)";
        }
        elsif ($text eq '^') {
            $code = "self._${REV}BOS(\$¢)";
        }
        elsif ($text eq '^^') {
            $code = "self._${REV}BOL(\$¢)";
        }
        elsif ($text eq '$') {
            $code = "self._${REV}EOS(\$¢)";
        }
        elsif ($text eq '$$') {
            $code = "self._${REV}EOL(\$¢)";
        }
        elsif ($text eq ':') {
            $code = "self._${REV}COMMITATOM(\$¢)";
        }
        elsif ($text eq '::') {
            $code = "self._${REV}COMMITBRANCH(\$¢)";
        }
        elsif ($text eq ':::') {
            $code = "self._${REV}COMMITRULE(\$¢)";
        }
        elsif ($text eq '\\d') {
            $code = "self._${REV}DIGIT(\$¢)";
        }
        elsif ($text eq '\\w') {
            $code = "self._${REV}ALNUM(\$¢)";
        }
        elsif ($text eq '\\s') {
            $code = "self._${REV}SPACE(\$¢)";
        }
        elsif ($text eq '\\h') {
            $code = "self._${REV}HSPACE(\$¢)";
        }
        elsif ($text eq '\\v') {
            $code = "self._${REV}VSPACE(\$¢)";
        }
        if ($not) { # XXX or maybe just .NOT on the end...
            $code = "self._NOTBEFORE(\$¢, -> \$¢ { $code })";
        }
        $code;
    }
}

{ package RE_method_noarg; use base "REbase";
    sub walk {
        my $self = shift;
        ::panic("Can't reverse submatch") if $REV;
        'self.' . $$self{name} . '($¢)';
    }
}

{ package RE_method_re; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = $$self{re};
        ::panic("Can't reverse submatch") if $REV;
        local $REV = 'v' if $$self{name} eq 'after';
        $re = ::indent($re->walk(@_));
        $REV = '';
        'self.' . $$self{name} . "(\$¢, -> \$¢ {\n$re\n})";
    }
}

{ package RE_method_str; use base "REbase";
    sub walk {
        my $self = shift;
        my $str = $$self{str};
        ::panic("Can't reverse submatch") if $REV;
        $str =~ s/(['\\])/\\$1/g;
        'self.' . $$self{name} . "(\$¢, '$str')";
    }
}

{ package RE_method; use base "REbase";
    sub walk {
        my $self = shift;
        my $rest = $$self{rest};
        ::panic("Can't reverse submatch") if $REV;
        substr($rest,1,0) = '$¢, ';
        'self.' . $$self{name} . $rest;
    }
}

{ package RE_ordered_conjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse ordered conjunction") if $REV;
            my $result = ::indent(join("\nSAME\n", @result));
            $result;
        }
    };
}

{ package RE_ordered_disjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse ordered disjunction") if $REV;
            my $result = ::indent(join("\n||\n", @result));
            $result;
        }
    };
}

{ package RE_paren; use base "REbase";
    sub walk {
        my $self = shift;
        my $re = ::indent($$self{re}->walk(@_));
        "self._${REV}PAREN(\$¢, -> \$¢ {\n" . $re . "\n})";
    }
}

{ package RE_quantified_atom; use base "REbase";
    sub walk {
        my $self = shift;
        my $result;
        #print ::Dump($self);
        #print $$self{quant},"\n";
        if (ref $$self{atom}) {
            my $quant = "";
            my $rep = "_REP";
            my $q = $$self{quant};
            if ($q) {
                my ($qfer,$how,$rest) = @{$$self{quant}};
                my $h = $how eq '!' ? 'g' :
                        $how eq '?' ? 'f' :
                                      'r';
                if ($qfer eq '*') {
                    $quant = "self._${REV}STAR$h(\$¢, ";
                }
                elsif ($qfer eq '+') {
                    $quant = "self._${REV}PLUS$h(\$¢, ";
                }
                elsif ($qfer eq '?') {
                    $quant = "self._${REV}OPT$h(\$¢, ";
                }
                elsif ($qfer eq '**') {
                    if (ref $rest) {
                        if (ref $rest eq "RE_block") {
                            $rep = "_${REV}REPINDIRECT";
                            $rest = $rest->walk();
                        }
                        else {
                            $rep = "_${REV}REPSEP";
                            $rest = "-> \$¢ {\n" . ::indent($rest->walk()) . "\n}";
                        }
                    }
                    else {
                        $rest = "'$rest'";
                    }
                    $quant = "$rep$h(\$¢, $rest, ";
                }
                $result = $quant . "-> \$¢ {\n" . ::indent($$self{atom}->walk(@_)) . "\n})";
            }
            else {
                $result = $$self{atom}->walk(@_);
            }
        }
        else {
            $result = '"' . $$self{atom} . '"';
        }
        $result;
    };
}

{ package RE_qw; use base "REbase";
    sub walk {
        my $self = shift;
        "self._${REV}ARRAY(\$¢, $$self{text} )";
    }
}

{ package RE_sequence; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        @result = reverse @result if $REV;
        my $result = pop @result;
        for (reverse @result) {
            $result = "gather for $_ -> \$¢ {\n" . ::indent("take " . $result) . "\n}";
        }
        $result;
    };
}

{ package RE_single; use base "REbase";
    sub walk {
        my $self = shift;
        my $text = $$self{text};
        $text =~ s/(['\\])/\\$1/g;
        "self._${REV}EXACT(\$¢, '" . $text . "')";
    }
}

{ package RE_submatch; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            ::panic("Can't reverse submatch") if $REV;
            my $against = shift @result;
            my $pattern = ::indent(shift @result);
            $against =~ s/BACK//;
            $against .= "";
            my $result = "self.SUBMATCH($against, -> \$¢ {\n$pattern\n})";
            $result;
        }
    };
}

{ package RE_unordered_conjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            my $result = ::indent(join("\nSAMEwith\n", @result));
            $result;
        }
    };
}

{ package RE_unordered_disjunction; use base "REbase";
    sub walk {
        my $self = shift;
        my @result;
        if ($$self{Kids}) {
            foreach my $kid (@{$$self{Kids}}) {
                push @result, $kid->walk(@_);
            }
        }
        if (@result == 1) {
            $result[0];
        }
        else {
            my $result = ::indent('(' . join("\n||\n", @result) . ')');
            $result;
        }
    };
}

{ package RE_var; use base "REbase";
    sub walk {
        my $self = shift;
        my $var = $$self{var};
        if ($var =~ /^\$/) {
            if ($var =~ /^\$(\d+)$/) {
                "self._${REV}BACKREFp(\$¢, $1 )";
            }
            elsif ($var =~ /^\$<(.*)>$/) {
                "self._${REV}BACKREFn(\$¢, '$1' )";
            }
            else {
                "self._${REV}EXACT(\$¢, $var )";
            }
        }
        elsif ($var =~ /^\@/) {
            "self._${REV}ARRAY(\$¢, $var )";
        }
        elsif ($var =~ /^\%/) {
            "self._${REV}HASH(\$¢, $var )";
        }
    }
}

## vim: expandtab sw=4
