#!pil

## ------------------------------------------------------------------------- ##
## Class and Method iterators
## ------------------------------------------------------------------------- ##

&WALKCLASS := -> &dispatcher         { &dispatcher.() };
&WALKMETH  := -> &dispatcher, $label {
    -> { 
        &redo  := &?SUB;
        $class := &WALKCLASS.(&dispatcher);
        -> { 
            $method := $class.get_method($label);
            $method.is_nil.cond(
                -> { &redo.() },
                -> { $method  } 
            );
        }.do_if($class.not_nil);
    }.();
};

## ------------------------------------------------------------------------- ##
## Class
## ------------------------------------------------------------------------- ##
## We assume that ::Class and ::Class.add_method are already defined
## ------------------------------------------------------------------------- ##

## class construction methods

::Class.add_method('new', -> %params { 
    self.bless(nil, %params);
});

::Class.add_method('bless', -> $repr, %params { 
    $obj := self.CREATE($repr, %params);
    $obj.BUILDALL(%params); 
    $obj;     
});

::Class.add_method('CREATE', -> $repr, %params {
    $obj := self.new_opaque({});
    &dispatcher := self.dispatcher('descendant');
    -> {
        &redo  := &?SUB;
        $class := &WALKCLASS.(&dispatcher);
        -> {
            -> $key {
                $obj.set_attr($key, $class.get_attribute($key));
            }.do_for($class.get_attribute_list);
            &redo.();
        }.do_if($class.not_nil);
    }.();
    $obj;
});

::Class.add_method('BUILDALL', -> %params {
    &dispatcher := $?CLASS.dispatcher('descendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH.(&dispatcher, 'BUILD');
        -> {
            $method.(%params);
            &redo.();
        }.do_if($method.not_nil);
    }.();
});

::Class.add_method('BUILD', -> %params {
    -> $key {
        -> {
            self.set_attr($key, %params.fetch($key));
        }.do_if(self.has_attr($key))
    }.do_for(%params.keys);
});

## class destruction

::Class.add_method('DESTROYALL', -> { 
    &dispatcher := $?CLASS.dispatcher('ascendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH.(&dispatcher, 'DESTROY');
        -> {
            $method.($self);
            &redo.();
        }.do_if($method.not_nil);
    }.();
});

## informational methods

# NOTE:
# is_a is meant to check against class instances 
::Class.add_method('is_a', -> $class { 
    self.eq($class).cond(
        -> { true },
        -> {
            &dispatcher := self.dispatcher('descendant');
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS.(&dispatcher);      
                -> {
                    $ancestor.eq($class).cond(
                        -> { true     },
                        -> { &redo.() }
                    );
                }.do_if($ancestor.not_nil)
            }.();
        }
    );
});

# NOTE:
# isa is meant to check against class names
::Class.add_method('isa', -> $class {
    self.name.eq($class).cond(
        -> { true },
        -> {
            &dispatcher := self.dispatcher('descendant');            
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS.(&dispatcher);                        
                -> {
                    $ancestor.name.eq($class).cond(
                        -> { true     },
                        -> { &redo.() }
                    );
                }.do_if($ancestor.not_nil)
            }.();
        }
    );    
});

## (super|sub)classes

::Class.add_method('superclasses', -> { self.get_attr('@!superclasses') });
::Class.add_method('set_superclasses', -> @superclasses { 
    -> $super { 
        $super.add_subclass(self); 
    }.do_for(@superclasses);
    self.set_attr('@!superclasses', @superclasses);
    self.set_attr('@!MRO', self.mro_merge);    
});

::Class.add_method('MRO', -> {
    @mro := self.get_attr('@!MRO');
    @mro.is_empty.cond(
        ->{ self.set_attr('@!MRO', self.mro_merge) },
        ->{ @mro }
    );
});

::Class.add_method('subclasses',   ->        { self.get_attr('@!subclasses') });
::Class.add_method('add_subclass', -> $class { 
    self.set_attr('@!subclasses', self.get_attr('@!subclasses').push($class));
});

## dispatching

::Class.add_method('_make_dispatcher_iterator', -> @values {
    $counter := self.new_opaque({'' => 0});
    -> {
        $idx := $counter.get_attr('');
        $counter.set_attr('', $idx.add(1));
        @values.fetch($idx);
    };
});

::Class.add_method('dispatcher', -> $order {
    $order := $order.is_nil.or($order.eq('canonical')).cond(
        ->{ 'ascendant' }, 
        ->{ $order      }
    );
    $order.eq('descendant').cond(
        ->{ self._make_descendant_dispatcher; },
        ->{ $order.eq('ascendant').cond(
            ->{ self._make_ascent_dispatcher;             },
            ->{ self._unsupported_dispatch_order($order); }
        ) }
    );
});

::Class.add_method('_make_ascent_dispatcher', -> {
    self._make_dispatcher_iterator(self.MRO);
});
::Class.add_method('_make_descendant_dispatcher', -> {
    self._make_dispatcher_iterator(self.MRO.reverse);
});


## method related methods

::Class.add_method('has_method', -> $name { 
    self.get_attr('%!methods').exists($name);
});

::Class.add_method('get_method', -> $name { 
    self.get_attr('%!methods').fetch($name); 
});

::Class.add_method('get_method_list', -> { 
    self.get_attr('%!methods').keys(); 
});

## can we actually do remove_method??
# ::Class.add_method('remove_method', -> $name { 
#     self.get_attr('%!methods').delete($name); 
# });

## attribute related methods

::Class.add_method('add_attribute', -> $name, $attr { 
    self.set_attr_hash('%!attributes', $name, $attr);
});

::Class.add_method('has_attribute', -> $name { 
    self.get_attr('%!attributes').exists($name);
});

::Class.add_method('get_attribute', -> $name { 
    self.get_attr('%!attributes').fetch($name); 
});

::Class.add_method('get_attribute_list', -> { 
    self.get_attr('%!attributes').keys(); 
});

::Class.add_method('get_attributes', -> { 
    self.get_attr('%!attributes').values(); 
});

## NOTE:
## we assume that when ::Class was defined, that it's attributes
## were also defined, but only in the Instance type, and not in 
## it's meta-self

::Class.add_attribute('@!MRO',             []);
::Class.add_attribute('@!superclasses',    []);
::Class.add_attribute('@!subclasses',      []);
::Class.add_attribute('%!private_methods', {}); # << these are not handled yet
::Class.add_attribute('%!methods',         {});
::Class.add_attribute('%!attributes',      {});

## ------------------------------------------------------------------------- ##
## Object
## ------------------------------------------------------------------------- ##

::Object := ::Class.new({});

# NOTE:
# these three methods need to also live as ::Object instance
# methods too. They would normally be inherited from ::Object
# by ::Class, but becuase they need to exist prior to the 
# creation of ::Object, we have to duplicate them. Better 
# suggestions welcome :)

::Object.add_method('BUILD',      ::Class.get_method('BUILD'));
::Object.add_method('BUILDALL',   ::Class.get_method('BUILDALL'));
::Object.add_method('DESTROYALL', ::Class.get_method('DESTROYALL'));

::Object.add_method('isa', -> $class {
    $?CLASS.name.eq($class).cond(
        -> { true },
        -> {
            &dispatcher := $?CLASS.dispatcher('descendant');            
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS.(&dispatcher);                        
                -> {
                    $ancestor.name.eq($class).cond(
                        -> { true     },
                        -> { &redo.() }
                    );
                }.do_if($ancestor.not_nil)
            }.();
        }
    );    
});

::Object.add_method('can', -> $label {
    &WALKMETH.($?CLASS.dispatcher('descendant'), $label).not_nil.cond(
        -> { true  },
        -> { false }
    );
});

## ------------------------------------------------------------------------- ##
## Package
## ------------------------------------------------------------------------- ##

::Package := ::Class.new({});
::Package.set_superclasses([ ::Object ]);

::Package.add_attribute('$!name',      '');
::Package.add_attribute('%!namespace', {});

::Package.add_method('name',     -> { self.get_attr('$!name') });
::Package.add_method('set_name', -> $name {
    -> { self.set_attr('$!name', $name) }.do_if($name.not_nil);    
});

::Package.add_method('FETCH', -> $name { });
::Package.add_method('STORE', -> $name, $value { });

## ------------------------------------------------------------------------- ##
## Module
## ------------------------------------------------------------------------- ##

::Module := ::Class.new({});
::Module.set_superclasses([ ::Package ]);

::Module.add_attribute('$!version',   '');
::Module.add_attribute('$!authority', '');

::Module.add_method('version',     -> { self.get_attr('$!version') });
::Module.add_method('set_version', -> $version {
    -> { self.set_attr('$!version', $version) }.do_if($version.not_nil);
});

::Module.add_method('authority',     -> { self.get_attr('$!authority') });
::Module.add_method('set_authority', -> $authority {
    -> { self.set_attr('$!authority', $authority) }.do_if($authority.not_nil);
});

::Module.add_method('identifier', -> {
    $output := self.get_attr('$!name');
    $output := self.get_attr('$!version').not_nil.cond(
        -> { $output.concat('-').concat(self.get_attr('$!version')) },
        -> { $output }
    );
    $output := self.get_attr('$!authority').not_nil.cond(
        -> { $output.concat('-').concat(self.get_attr('$!authority')) },
        -> { $output }
    ); 
    $output;
});

## ------------------------------------------------------------------------- ##
## Role
## ------------------------------------------------------------------------- ##

# ... coming eventually 

## ------------------------------------------------------------------------- ##
## Bootstrapping
## ------------------------------------------------------------------------- ##

::Class.set_superclasses([ ::Module ]);

# NOTE:
# this attribute needs to be added manually to the
# class instances since ::Class would have inherited 
# it, but couldn't since they had not yet been defined. 

-> $class {
    $class.set_attr('%!namespace', {});
}.do_for([ ::Class, ::Object, ::Module, ::Package ]);

# ... now we can name and version all our objects 
# which has the side effect of creating the name, 
# version and authority slots in our classes, if we
# do not do this, then we need to add $!name, $!version
# and $!authority to the list above along with %!namespace

::Class.set_name('Class');     ::Class.set_version('0.0.1');   ::Class.set_authority('url:pugscode.org');
::Object.set_name('Object');   ::Object.set_version('0.0.1');  ::Object.set_authority('url:pugscode.org');
::Package.set_name('Package'); ::Package.set_version('0.0.1'); ::Package.set_authority('url:pugscode.org');
::Module.set_name('Module');   ::Module.set_version('0.0.1');  ::Module.set_authority('url:pugscode.org');

## end bootstrapping ...
## ------------------------------------------------------------------------- ##

=pod

=head1 NAME

Perl 6 Object Model Bootstrap

=head1 DESCRIPTION 

This is the bootstrap code for the Perl 6 Object Model using the Perl 6 
Object-Space mini-language. 

=head1 SEE ALSO

NOTE: all paths from the root of the Pugs source tree.

=over 4

=item Perl 5 prototype of the Perl 6 Object Model

/perl5/Perl6-MetaModel/

In particular see the /perl5/Perl6-MetaModel/docs/*.jpg.

=item Perl 5 prototype of the Perl 6 Object Space 

/perl5/Perl6-ObjectSpace/

In particular see the /perl5/Perl6-MetaModel/docs/Object_Space.jpg

=back

=head1 AUTHORS

Audrey Tang <autrijus@autrijus.org>

Stevan Little <stevan@iinteractive.com>

=cut
