#include <smop.h>
#include <smop_lowlevel.h>
#include <smop_identifiers.h>
#include <smop_mold.h>
#include <smop_s1p.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>

SMOP__Object* SMOP__S1P__Array_Iterator;

static SMOP__Object* smop_s1p_array_iterator_mold;

typedef struct SMOP__S1P__Array_Iterator_struct {
  SMOP__Object__BASE
  SMOP__Object* input_array;
  SMOP__Object* count;
} SMOP__S1P__Array_Iterator_struct;

SMOP__Object* SMOP__S1P__Array_Iterator_create(SMOP__Object* input_array) {
    SMOP__Object* ret = smop_lowlevel_alloc(sizeof(SMOP__S1P__Array_Iterator_struct));
    ret->RI = (SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator;
    ((SMOP__S1P__Array_Iterator_struct*)ret)->input_array = input_array;
    ((SMOP__S1P__Array_Iterator_struct*)ret)->count = SMOP__NATIVE__int_create(0);
    return ret;
}

static SMOP__Object* lowlevel_array_iterator_message(SMOP__Object* interpreter,
                                                     SMOP__ResponderInterface* self,
                                                     SMOP__Object* identifier,
                                                     SMOP__Object* capture) {
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;
  ___INVOCANT_RI_SHOULD_MATCH___;

  SMOP__Object* ret = SMOP__NATIVE__bool_false;

  ___UNKNOWN_METHOD___;

  SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return ret;
}


void smop_s1p_array_iterator_init() {
  SMOP__S1P__Array_Iterator = malloc(sizeof(SMOP__ResponderInterface));
  assert(SMOP__S1P__Array_Iterator);
  ((SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator)->RI = NULL;
  ((SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator)->MESSAGE = lowlevel_array_iterator_message;
  ((SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator)->REFERENCE = smop_lowlevel_generic_reference;
  ((SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator)->RELEASE = smop_lowlevel_generic_release;
  ((SMOP__ResponderInterface*)SMOP__S1P__Array_Iterator)->id = "SMOP S1P Array Iterator";
}

void smop_s1p_array_iterator_destr() {
  free(SMOP__S1P__Array_Iterator);
}

void smop_s1p_array_iterator_mold_init() {
  SMOP__Object* interpreter = SMOP__GlobalInterpreter;
  smop_s1p_array_iterator_mold = q:m0ld {
    my $interpreter;
    my $capture;
    my $back;
    my $code;
    my $outer;
    my $signature;
    my $mold;

    my $void;

    my $lexical_proto = ¢SMOP__S1P__LexicalScope;
    my $lexical = $lexical_proto."new"();
    my $lexical_outer_container = $lexical."outer"();
    $void = $lexical_outer_container."STORE"($outer);

    my $actualcapture = $capture."positional"(0);

    $void = $signature."BIND"($actualcapture,$lexical);
    my $frame_proto = ¢SMOP__Mold__Frame;
    my $frame = $frame_proto."new"($mold);
    $void = $frame."set_reg"(0, $interpreter);
    $void = $frame."set_reg"(1, $lexical);
    $void = $frame."set_back"($back);
    $void = $interpreter."goto"($frame);
  };
}

void smop_s1p_array_iterator_mold_destr() {
  SMOP__Object* interpreter = SMOP__GlobalInterpreter;
  SMOP_RELEASE(interpreter, smop_s1p_array_iterator_mold);
}
