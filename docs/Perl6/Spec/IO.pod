
=encoding utf8

=head1 Title

DRAFT: Synopsis 16: IPC / IO / Signals

=head1 Version

 Author:        Mark Stosberg <mark@summersault.com>
 Maintainer:    Larry Wall <larry@wall.org>
 Contributions: 
 Date:          12 Sep 2006
 Last Modified: 15 Sep 2006
 Version:       12

This is a draft document. Many of these functions will work as in Perl 5,
except we're trying to rationalize everything into packages.  For now you can
assume most of the important ones will automatically be in the * namespace.

As a starting point, you can help by finding the official Perl 5 documentation
for these functions and copying it here. 

=head1 Filehandles, files, and directories

=over 4

=item -X

=item chown

=item chmod LIST
X<chmod> X<permission> X<mode>

Changes the permissions of a list of files.  The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should I<not> be a string of octal digits:
C<0644> is okay, C<'0644'> is not.  Returns the number of files
successfully changed.  See also L</oct>, if all you have is a string.

    $cnt = chmod 0755, 'foo', 'bar';
    chmod 0755, @executables;
    $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to
                                             # --w----r-T
    $mode = '0644'; chmod oct($mode), 'foo'; # this is better
    $mode = 0644;   chmod $mode, 'foo';      # this is best

=item close FILEHANDLE

Closes the file or pipe associated with the file handle, returning
true only if IO buffers are successfully flushed and closes the system
file descriptor.  Closes the currently selected filehandle if the
argument is omitted.

You don't have to close FILEHANDLE if you are immediately going to do
another C<open> on it, because C<open> will close it for you.  (See
C<open>.)  However, an explicit C<close> on an input file resets the line
counter (C<$.>), while the implicit close done by C<open> does not.

If the file handle came from a piped open, C<close> will additionally
return false if one of the other system calls involved fails, or if the
program exits with non-zero status.  (If the only problem was that the
program exited non-zero, C<$!> will be set to C<0>.)  Closing a pipe
also waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards, and
implicitly puts the exit status value of that command into C<$!>.

=item closedir

 closedir (IO::Dir $dir)  
 $dir.closedir

Closes a directory opened by C<opendir> and returns the success of that
system call.

=item fcntl

=item glob

=item ioctl

=item link

=item listen

=item lstat

=item mkdir

=item open

    # Read
    my $fh = open($filename);

    # Write
    my $fh = open($filename, :w);

=item opendir EXPR

  my $dir = opendir('.');

Opens a directory named EXPR for processing by C<readdir>, C<telldir>,
C<seekdir>, C<rewinddir>, and C<closedir>.  Returns an C<IO::Dir> object if
successful.

=item readdir

 readdir (IO::Dir $dir)  
 $dir.readdir

Returns the next directory entry for a directory opened by C<opendir>.
If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns an undefined value in
scalar context or a null list in list context.

If you're planning to filetest the return values out of a C<readdir>, you'd
better prepend the directory in question.  Otherwise, because we didn't
C<chdir> there, it would have been testing the wrong file.

=item readlink

=item rename

=item rewinddir

 rewinddir (IO::Dir $dir)  
 $dir.rewinddir

Sets the current position to the beginning of the directory for the
C<readdir> routine on DIRHANDLE.

=item rmdir FILENAME
X<rmdir> X<rd> X<directory, remove>

=item rmdir

Deletes the directory specified by FILENAME if that directory is
empty.  If it succeeds it returns true, otherwise it returns false and
sets C<$!> (errno).  If FILENAME is omitted, uses C<$_>.

=item stat

=item symlink

=item syscall

=item sysopen

=item umask

=item unlink LIST
X<unlink> X<delete> X<remove> X<rm>

=item unlink

Deletes a list of files.  Returns the number of files successfully
deleted.

    $cnt = unlink 'a', 'b', 'c';

Be warned that unlinking a directory can inflict damage on your filesystem.
Finally, using C<unlink> on directories is not supported on many operating
systems.  Use C<rmdir> instead.

If LIST is omitted, uses C<$_>.

=item utime

=back

=head1 Input and Output

=over 4

=item getc FILEHANDLE

Returns the next character from the input file attached to FILEHANDLE,
or the undefined value at end of file, or if there was an error (in
the latter case C<$!> is set). 

=item print FILEHANDLE LIST
X<print>

=item print LIST

=item print

Prints a string or a list of strings.  Returns true if successful.
FILEHANDLE may be a scalar variable name, in which case the variable
contains the name of or a reference to the filehandle, thus introducing
one level of indirection.  (NOTE: If FILEHANDLE is a variable and
the next token is a term, it may be misinterpreted as an operator
unless you interpose a C<+> or put parentheses around the arguments.)
If FILEHANDLE is omitted, prints by default to standard output (or
to the last selected output channel--see L</select>).  If LIST is
also omitted, prints C<$_> to the currently selected output channel.
To set the default output channel to something other than STDOUT
use the select operation.  

=begin comment

[ I don't know what's become of $, and $\. -markstos ] 

The current value of C<$,> (if any) is
printed between each LIST item.  The current value of C<$\> (if
any) is printed after the entire LIST has been printed. 

=end comment

Because print takes a LIST, anything in the LIST is evaluated in list context,
and any subroutine that you call will have one or more of its expressions
evaluated in list context.  Also be careful not to follow the print keyword
with a left parenthesis unless you want the corresponding right parenthesis to
terminate the arguments to the print--interpose a C<+> or put parentheses
around all the arguments.

Note that if you're storing FILEHANDLEs in an array, or if you're using
any other expression more complex than a scalar variable to retrieve it,
you will have to use a block returning the filehandle value instead:

    print { @files[$i] } "stuff\n";
    print { $OK ?? STDOUT !! STDERR } "stuff\n";

=item printf

=item say

This is a version of print() that auto-appends a newline:

    Was:    print "Hello, world!\n";
    Now:    say   "Hello, world!";

=back

=head1 Unfiled

=over 4

=item fileno

=item flock

=item getpeername

=item connect

=item eof

=item accept

=item /[get|set][host|net|proto|serv|sock].*/

=item alarm

=item bind

=item binmode

=item pipe

=item read

=item readline

=item readpipe

=item recv

=item seek

=item seekdir

=item select(both)

=item send

=item setsockopt

=item shutdown

=item slurp

=item socket

=item socketpair

=item sysread

=item sysseek

=item syswrite

=item tell

=item telldir

=item truncate

=item warn

=back

=head1 Additions

Please post errors and feedback to perl6-language.  If you are making
a general laundry list, please separate messages by topic.
