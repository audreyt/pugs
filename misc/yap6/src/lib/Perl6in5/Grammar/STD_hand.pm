package Perl6in5::Grammar::STD_hand;

use warnings;
#use strict; #haha

use base 'Exporter';
our @EXPORT = qw ( make_parser );

use Perl6in5::Compiler::Trace; # set env var TRACE for trace output

# isa Perl6in5::Grammar someday (to inherit some of the common features below)

use Perl6in5::Grammar ':all'; # heehee; a source filter.
#use P65GL;
use Perl6in5::Compiler::Stream ':all';
use Perl6in5::Compiler::Parser ':all';
use Perl6in5::Compiler::Lexer ':all';

use Data::Dumper;
$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Quotekeys = 0;

use Math::BigFloat;

no warnings qw{ reserved closure recursion };
$Data::Dumper::Deparse = 1;

sub make_parser {
    my $input = shift;
    
    my $wS = sub { "" };
    
    my $lexer = iterator_to_stream(make_lexer($input,
    [ 'USEV6'           ,qr/use\s+v6;/        ,                            ],
    [ 'NL'              ,qr/\n+/              ,                            ],
    [ 'ID'              ,qr|[A-Za-z_]\w*|     ,                            ],
    [ 'INT'             ,qr|\d+|              ,                            ],
    # someday soon I'll need to remove whitespace from here and handle it
    # in the parser (not the lexer), since there are so many special rules
    # around ws and unspace.  Actually someday soon, all that should remain
    # here is the "C" pattern (unfortunately), since there is so much that
    # will need to be redefinable at parse time, the lexing needs to go
    # character by character.  This means that the lexing step will merely
    # generate a sub generator that generates a stream of nested arrayrefs
    # (with the lexer as the tail) that each contain the next character.
    [ 'WS'              ,qr/\s+/              ,$wS                         ],
    [ "C"               ,qr#.#                ,                            ],

    )); 

    my %VAR;

    # <sigh> these "predeclaration" need to be autogenerated someday, somehow
    my ($base, $expr, $factor, $program, $term, $sVar, $stringLit,
        $usev6, $comma, $stmtList, $blockList, $newline, $blkBare, $blkPrmbl,
        $blkType, $blkRetT, $blkModf, $stmtTrm, $scpDecl, $block, $arg,
        $blkPrm, $compUnit, $flowCtrl, $blkLabl
    );

    sub eoi () { $End_of_Input };
    my $Base               = parser { $base            ->(@_) };
    sub base () { $Base };
    my $Expr               = parser { $expr            ->(@_) };
    sub expr () { $Expr };
    my $Factor             = parser { $factor          ->(@_) };
    sub factor () { $Factor };
    my $Program            = parser { $program         ->(@_) };
    sub program () { $Program };
    my $Term               = parser { $term            ->(@_) };
    sub term () { $Term };
    my $SVar               = parser { $sVar            ->(@_) };
    sub sVar () { $SVar };
    my $StringLit          = parser { $stringLit       ->(@_) };
    sub stringLit () { $StringLit };
    my $Usev6              = parser { $usev6           ->(@_) };
    sub usev6 () { $Usev6 };
    my $Comma              = parser { $comma           ->(@_) };
    sub comma () { $Comma };
    my $StmtList           = parser { $stmtList        ->(@_) };
    sub stmtList () { $StmtList };
    my $BlockList          = parser { $blockList       ->(@_) };
    sub blockList () { $BlockList };
    my $Newline            = parser { $newline         ->(@_) };
    sub newline () { $Newline };
    my $BlkBare            = parser { $blkBare         ->(@_) };
    sub blkBare () { $BlkBare };
    my $BlkPrmbl           = parser { $blkPrmbl        ->(@_) };
    sub blkPrmbl () { $BlkPrmbl };
    my $BlkType            = parser { $blkType         ->(@_) };
    sub blkType () { $BlkType };
    my $BlkRetT            = parser { $blkRetT         ->(@_) };
    sub blkRetT () { $BlkRetT };
    my $BlkModf            = parser { $blkModf         ->(@_) };
    sub blkModf () { $BlkModf };
    my $StmtTrm            = parser { $stmtTrm         ->(@_) };
    sub stmtTrm () { $StmtTrm };
    my $ScpDecl            = parser { $scpDecl         ->(@_) };
    sub scpDecl () { $ScpDecl };
    my $Block              = parser { $block           ->(@_) };
    sub block () { $Block };
    my $Arg                = parser { $arg             ->(@_) };
    sub arg () { $Arg };
    my $BlkPrms            = parser { $blkPrms         ->(@_) };
    sub blkPrms () { $BlkPrms };
    my $FlowCtrl           = parser { $flowCtrl        ->(@_) };
    sub flowCtrl () { $FlowCtrl };
    my $BlkLabl            = parser { $blkLabl         ->(@_) };
    sub blkLabl () { $BlkLabl };
    my $CompUnit           = parser { $compUnit        ->(@_) };
    sub compUnit () { $CompUnit };

    # these hash keys are coderef (addresses)
    our %N = (
        $End_of_Input     => 'EOI',
        $nothing          => 'nothing',
        $Expr             => 'Expr',
        $Term             => 'Term',
        $Factor           => 'Factor',
        $Base             => 'Base',
        $Program          => 'Program',
        $ScpDecl          => 'ScpDecl',
        $SVar             => 'SVar',
        $StringLit        => 'StringLit',
        $Usev6            => 'Usev6',
        $Comma            => 'Comma',
        $StmtList         => 'StmtList',
        $BlockList        => 'BlockList',
        $Newline          => 'Newline',
        $BlkBare          => 'BlkBare',
        $BlkPrmbl         => 'BlkPrmbl',
        $BlkType          => 'BlkType',
        $BlkRetT          => 'BlkRetT',
        $BlkModf          => 'BlkModf',
        $StmtTrm          => 'StmtTrm',
        $Block            => 'Block',
        $Arg              => 'Arg',
        $BlkPrms          => 'BlkPrms',
        $FlowCtrl         => 'FlowCtrl',
        $BlkLabl          => 'BlkLabl',
        $CompUnit         => 'CompUnit'
    );

    sub execnow (&) { $_[0]->() }

    sub say (@) { print $_."\n" for @_ }

    sub adn (@) { 
        print "Adding AST node: "; # trace
        say join('',map(Dumper($_)." ",@_));
        Dumper([map("$_",@_)]);
    }

    my $handle_say_stmt =
    sub {   adn("say($_[1])");
            1; # someday Bool::True
            };

    my $handle_assignment_stmt =
    sub { # keep a parse-time pad of declared variable names
            adn("assign(@_[0,2])");
            $_[2]; # someday this will set $_ at semantic analysis time.
            };

    sub ch { # parse for a single character.
        my $p;
        $p = l("C",$_[0]);
        $N{$p} = "$_[0]"; # trace
        $p;
    }

    sub w { # look for a wrapped entity.  first parm is split into the wrappers.
        my ($d,$e) = split(//,$_[0]);
        my $p;
        $p = concatenate(ch($d),$_[1],ch($e));
        $N{$p} = "$d ".$N{$_[1]}." $e"; # trace
        $p;
    }

    sub keyword {
        my $ins = shift;
        my $p;
        $p = l('ID',$ins);
        $N{$p} = "$ins"; # trace
        $p;
    }

    sub keywords {
        my @args = @_;
        my $p;
        $p = alternate(map(keyword($_),@args));
        $N{$p} = join("|",@args); # trace
        $p;
    }

    #sub k { goto &keyword }
    
    rule comma {
        ','
    };

    sub clist {
        my $ins = shift;
        my $p;
        $p = commalist($ins,$comma->(),', ');
        $N{$p} = "clist($N{$ins}"; # trace
        $p;
    }

    sub gt0 { # hit on 1 or more of the contained. (gt0 == greater than zero)
        my $p;
        $p = concatenate($_[0],star($_[0]));
        $N{$p} = ">=1($N{$_[0]})"; # trace
        $p;
    }

    sub word {
        my $p;
        $p = concatenate(map(ch($_),split(//, $_[0])));
        $N{$p} = $_[0];
        $p;
    }

    my $handle_declarator = 
    sub { bless([$_[0]] => 'Tuple') };

    $sVar = concatenate('$',l('ID')) >> sub {
            "$_[0]$_[1]";
        };

    my $handle_declaration_stmt =
    sub {   if ($_[0]) {
                warn "declaration of $_[1] masks ".
                "earlier declaration in the same scope" if exists $VAR{$_[1]};
                # keep a parse-time pad of declared variable names..
                # later such checking will be done during analysis
                # (after parsing)
                adn('declare',($_[0],$_[1]))
            } else {
                die "$_[1] has yet to be declared" unless exists $VAR{$_[1]};
            }
            #$_[3] = "$_[3]";
            shift;
            $VAR{$_[0]} = $_[2];
            $handle_assignment_stmt->(@_) };

    my $handle_infix_addition =
    sub { my $term = $_[1];
          sub { $_[0] + $term }};

    my $handle_infix_subtraction =
    sub { my $term = $_[1];
          sub { $_[0] - $term }};

    my $handle_infix_multiplication =
    sub { my $factor = $_[1];
          sub { $_[0] * $factor }};

    my $handle_infix_division =
    sub { my $factor = $_[1];
          warn "cannot divide by 0." unless $factor;
          $factor ||= 1; #silly, I know; this is only a toy interpreter.
          sub {$_[0] / $factor}};

    my $handle_infix_exponentiation_factor = sub { $_[1] };

    my $handle_empty_nothing = sub { 1 };

    my $handle_infix_exponentiation_operation = sub { debug Dumper(\@_)."ie";$_[0] ** $_[1] };

    my $handle_variable_lookup = sub { debug Dumper(\@_)."vl";die "Undeclared variable $_[0]" unless exists $VAR{$_[0]}; "$VAR{$_[0]}"; };

    my $handle_base_value = sub { debug Dumper(\@_)."bv";$_[1] };

    my $handle_cascade =
    sub { my ($first, $rest) = @_;
          for my $f (@$rest) {
              $first = $f->($first);
          } $first};

    my $handle_string_lit = sub { $_[1] };

    my $handle_integer_inst =
    sub { my $a = Math::BigFloat->new($_[0]);"$a"; };

    # The identifier of each of your rules must begin with a lowercase letter.   sorry.

    # rule perl5zone {
        # sl(); # grabs anything/everything...
    # }

    rule program {
        # treat everything as Perl 5 by default. haha!
        #o($Perl5zone)        -        # can't slurp "up until" until we're backtracking
                        # I need a function "until($p,$q)" that returns a parser that 
                        # iterates through the stream of tokens, trying $q against the
                        # remaining input at each token, essentially using $q as a stop
                        # phrase, then returns $p's and $q's matches, concatenated.
     #parser { sub {} }
        o(usev6 - error(o(stmtList))) - o(newline) - eoi
        # an optional Perl 5 section # use v6; # error trapper #optional Stmt list
    };

    rule usev6 {
        l('USEV6')
    };

    rule stmtList {
          (o(newline) - (expr - o(stmtTrm - o(stmtList | blockList)) - o(newline)))
        | (o(newline) - blockList)
        # the first Stmt in the list  # 0 or more Terminator-Stmt
        # since Block-NewLine includes its own implied following terminator...
    };

    rule blockList {
        block - o((newline | stmtTrm) - o(stmtList)) - o(newline)
    };

    rule newline {
        l('NL')
    };

    rule blkBare {
        w("{}",stmtList)
    };

    rule block {
        o(blkPrmbl) - blkBare
    };

    rule blkPrmbl { # block preamble
        (o(blkModf) - o(scpDecl - blkRetT) - blkType - o(l('ID')) - o(w('()',blkPrms)) #- o($BlkTrts)
        ) | compUnit | flowCtrl | blkLabl
    };

    rule flowCtrl { # Until I die, I would cry unless unless/until were included.
        keywords(qw{ if unless elsif else loop do while until })
    };

    rule compUnit {
        keywords(qw{ eval PRE POST ENTER LEAVE KEEP UNDO FIRST 
                     LAST BEGIN END INIT CHECK UNITCHECK })
    };

    rule blkType {
        keywords(qw{ sub method submethod regex token rule macro })
    };

    rule blkRetT {
        l('ID')  # just take any class/type name for now :)
      #  $Clype    # Class/Type
    };

    rule blkLabl {
        l('ID') - ':';
    };

    rule blkModf {
        keywords(qw{ multi proto only })
    };

    rule arg {
        'h'  #obviously this is just a stub.
    };

    rule blkPrms {
        star(arg)
    };

    rule stmtTrm {
        gt0(';')
    };

    rule scpDecl {
        keywords(qw{ my our })
    };

    rule expr { # or a bare expression (implied $_=Expr)
        w('()',expr) | ((keyword('say') - expr
                 >> $handle_say_stmt)
               | ((o(scpDecl) > $handle_declarator) - sVar - '=' - expr )
                 >> $handle_declaration_stmt) |
        (term - (star((('+' - term) >>  $handle_infix_addition)
               | ('-' - term >> $handle_infix_subtraction)))
                  >> $handle_cascade) | block
    };

    rule term {
        factor - star('*' - factor >> $handle_infix_multiplication
                     | '/' - factor >> $handle_infix_division)
                  >> $handle_cascade
    };

    rule factor {
        (base - (o(word('**') - (factor > $handle_infix_exponentiation_factor))))
        >> $handle_infix_exponentiation_operation
    };

    rule base {
     (l('INT') > $handle_integer_inst)
          | (sVar > $handle_variable_lookup)
          | (w('()',expr) >> $handle_base_value)
    };

    sub {
        eval { program->($lexer) };
        if ($@) {
            print "  Syntax Error near: ".Dumper(tail(head(tail($@))));
            return 255;
        } else {
            return 0;
        }
    }
}

1;