#!/usr/local/bin/perl

use Getopt::Long;
my $nocolor;
my $vertical;
my $yaml;
my $quiet;
BEGIN {
    GetOptions("nocolor"=>\$nocolor,"vertical"=>\$vertical,"quiet"=>\$quiet,"yaml"=>\$yaml);
    unless ($#ARGV <= 0) {
        die "USAGE: [--nocolor] [filename]\n";
    }
    if ($quiet) {
        $SIG{__WARN__} = sub {};
        open(STDERR,">/dev/null");
    }
}
#eval {
use lib '../../src/perl6';
use STD5;
use ElfCore5;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
require 'mangle.pl'; 
use strict;
use warnings;

if ($nocolor) {
    $DumpMatch::NOCOLOR = 1;
}

my $what = 'comp_unit';
my $text;
{
local $/;
$text = Encode::decode('utf8', scalar <>);
}

open(my $actions,"pixie_actions5") || die "can't open actions file:$!";
my (%actions,$action);
for (<$actions>) {
    if (/^### (.*?)\s*$/) {
        $action = $1;
    } else {
        $actions{$action} .= $_;
    }
}

while (my ($name,$code) = each %actions) {
    $actions{$name} = eval("sub {package pixie_actions;".$code."}");
    die "error at pixie_action5, action $name: $@\n" if $@;
}
#use Data::Dump::Streamer;
#print Dump(\%actions);


{ package pixie_actions;
    sub make($) {
        $_->{''} = $_[0];
    }
    sub EXPR {
        my $expr = shift;
        use Data::Dumper;
        if ($expr->{pre} && @{$expr->{pre}}) {
            IRx1::Apply->new(
                function => 'prefix:'.$expr->{pre}[0]->item,
                capture  => IRx1::Capture->new(arguments=>[$expr->{noun}->item]),
            );
        } elsif ($expr->{post} && @{$expr->{post}}) {
            IRx1::Apply->new(
                function => 'postfix:'.$expr->{post}[0]->item,
                capture  => IRx1::Capture->new(arguments=>[$expr->{noun}->item]),
            );
        } elsif ($expr->{noun}) {
            $expr->{noun}->item;
        } elsif ($expr->{infix}) {
            IRx1::Apply->new(
                function => 'infix:'.$expr->{infix}->item,
                capture  => IRx1::Capture->new(arguments=>[EXPR($expr->{left}),EXPR($expr->{right})]),
            );
        } else {
            warn 'unknown EXPR type';
            undef;
        }
    }
}
{ package Perl_with_actions;
    use Term::ANSIColor qw(:constants);
    BEGIN { our @ISA = qw(Perl) }
    sub _REDUCE {
        my $self = shift;
        my $tag = shift;
        $tag =~ s/__S_\d+/:/;

        if ($actions{$tag}) {
            print (GREEN,$tag,"\n",RESET) unless $quiet;
            local $_ = $self;
            $actions{$tag}->();
            $self;
        } else {
            print (RED,$tag,"\n",RESET) unless $quiet;
            $self;
        }
    }
}

my $r = Perl_with_actions->new($text)->$what();
if ($yaml) {
    print Dump($r);
    exit;
} else {
    print dump_match($what=>$r,{vertical=>1,actions=>sub {Compiler::dump_IRx1(@_)}}),"\n" unless $quiet;
}
my $ir = $r->{''};
my $code = $GLOBAL::emitter1->prelude_lexical . $ir->callback($GLOBAL::emitter1);
print $GLOBAL::emitter1->tidy($code),"\n" unless $quiet;
eval($code);
print "error: $@" if $@;
#};
#if ($@) {
#    print "fatal error: $@";
#    die;
#}

