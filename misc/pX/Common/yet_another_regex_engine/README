This is yet another rules engine implementation attempt.

$ prove -Ilib t/re_tests.t
... 59.83% okay.
$ perl -w lib/Regexp/ModuleA.pm --test
... more informative than prove, but no prove-like summary at end.
$ perl -w lib/Regexp/ModuleA.pm --repl
... interactive.


Ways you can help:

  * Explore and explain to me how to hook a new p6 regex engine into
    pugs.  I believe pugs is currently using perl5/Pugs-Compiler-Rule?
  * Are there any better p6 regexp grammars than
    misc/Grammars/rx_grammar.pm?
  *...

Objective:

  Create a fast p6 rules implementation in p5 which we can use for
  perl6 parser development.

Intent:

  * supports p5 and p6 regex
  * complete coverage, well tested
  * fast
  * quick development
  * written in p5 (so it can be used with pugs, v6.pm, and pil2js)
  * hardwired grammars - spec'ed extensibility deferred.

Architecture:

  Uses the core Regexp::Parser::ReentrantEngine.pm emitters (fast and
  tested), repackaged to use a new ast (no Regexp::Parser dependency),
  with p5 and p6 grammars expressed as m-expressions (bootstrap both
  not needed, and easily done), and a minimized ast (lean on the perl5
  engine, avoid unnecessary nodes and work).  With compilation looking
  like: some_regexp -> matcher for regexp grammar -> Match tree ->
  m-expr tree -> ast -> matcher for some_regexp.

Plan:

  * Get p5 regexp working:
     Add backref_or_char node.
     Debug using re_tests.
     Tidy up.

    Objective is a 100% okay on the re_tests p5 regexp test suite.
    Or as close as the underlying p5 implementation version comes.
    Except where it is easy, we won't try to do better than that.
    Keeping track of what test is failing and why is more trouble than
    doing ~100% now rather than later, no?
  * Get p6 rules tests.
    Can we get pugs to use us for the t/ tests?  That would be best.
    Else kludge something, perhaps from the p6-ified re_tests.  But those
    are very incomplete.
  * Create simple m-expr grammar for p6 rules.
    Start simple (eg, the pge illustrative grammar), get it working,
    then extend it to the full grammar.
  * Milestone - at this point it may be the best rules engine available.
  * Flesh out the p6 implementation.
  * Declare success.

Bugs: (some among many)

  * \10 handling

Budgeting:

  3 days to p5 test suite passing.
    Roughly 1 day writing, 1 day debugging hell, 1 day to get tests green.
  1 day to get p6 test framework.
  1 day for simple p6 rules support.
  1+fuzzy day for fleshing out rules support.

So 6+ days.  Likely spread over February '07.

Risks:

  * P6 rule spec is big.  I always underestimate this.  The "1+fuzzy"
    current estimate is silly. -> Schedule blow out.  Mitigation:
    Break functionality into chunks (eg, related to implementations -
    eg, everything pge/PCR has); Re-budget; Downscale objective (eg,
    go for pge or pcr equivalence).

  * Engine oddities, perlbug tickling. -> Exploding debug cost.
    Mitigation: perl version restriction.  Still worrisome.

  * Does this version of the engine already support commits? ->
    significant engine change, unexpected debugging hell.  Mitigation:
    Check; Scavenge if necessary (before initial debugging pass or
    after? - after - minimum path to get-it-working - worth the hit).

  * P6 rule interaction with lexical variables - have plan, but it's
    still raw.  -> rathole.  Mitigation: Flesh out plan; Punt, restricting
    interaction to symbol table.

  * Match objects are non-spec. -> non-specness.  Mitigation: I don't
    care; Might be easily fixed.

  * Implementation of grammars and rules, using packages and subs, is
    new development.  -> schedule creep, non-specness.  Mitigation:
    Don't really care how it's implemented, as long as it can support
    p6 parser development; Can even punt to flat namespace; Whatever
    is easy; Re non-spec, don't care unless there are tests.

  * Mission creep, eg, everything for everyone cpan rules module.
    Mitigation: don't; Budget separately.

  - Performance.  As of 2007-Jan-31, performance is very poor.  6 min
    to run re_test.  Cause unexplored.  Perhaps nested expressions
    producing really large parse trees?  -> potential slow speed,
    unusable for parser?  Mitigation: Look into performance; flatten
    grammars.  RESOLVED: use overload; in Match was a 100x performance
    hit.

History:

  2007-Feb-03 Some cleanup.  Added nodes.  Performance improved (7 min
  -> 12 sec by avoiding "use overload" when possible).  12 sec.  92% okay.
  Cost: 1 day.

  2007-Feb-01 Began backrefs.  Bugfixes.  Dropped in copies of the
  missing nodes which need to be adapted to the new ast.  400 sec.
  82.00% okay.  Cost: 1/4 day.

  2007-Jan-31 Added non-greedy quant, and non-capturing group
  Performance problems (re_tests now takes 6 min).  80% okay.
  Cost: 1/8 day.

  2007-Jan-30 --text and prove can now both be used.  Added interactive
  repl.  Added ast initialization phase.  Began captures, flags. 60% okay.
  Cost: 1/2 day.

  2007-Jan-29 Engine now running.  Perlbug in v5.8.8 was disappearing
  a lexical (adding an extra use "fixed").  P5 grammar tweaked.  Match
  tree to ast converter begun.  First light (ie, first time through
  the entire "p5 re pattern -> match tree -> ast -> matcher -> matcher
  works" path).  P5 re_tests added.  29.66% okay.  Cost: 1/2 day.

  2007-Jan-28 Started.  Repackaged engine around new ast, emitters, and
  m-expr dsl.  First draft of p5 rules grammar.  Engine is currently
  broken from the repackaging.  Cost: 1 day.

Misc Notes:

  With my v5.8.8, only Devel::DProfLB didn't fail.  Its granularity is
  very poor.


#; Local Variables:
#; mode: text
#; End:
