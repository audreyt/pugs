#!/usr/local/bin/perl
use lib '../../src/perl6';
use lib 'src';
use STD;
package Mildew;
do 'viv';
use AST;
use AST::Helpers;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
use strict;
use warnings;
use Getopt::Long;
use Carp 'confess';

my ($desugar,$debug,$file);
GetOptions("file=s"=>\$file,"debug"=>\$debug,"desugar"=>\$desugar);

sub XXX {
    confess 'unimplemented'
}
sub FETCH {
    my $arg = shift;
    AST::Call->new(capture=>AST::Capture->new(invocant=>$arg),identifier=>string 'FETCH');
}
sub lookup {
    my $thing = shift;
    AST::Call->new(
        identifier=>string 'lookup',
        capture=>AST::Capture->new(invocant=>reg '$scope',positional=>[string $thing]),
    );
}

sub VAST::integer::emit_m0ld {
    my $m = shift;
    #XXX non-base 10
    integer($m->{TEXT});
}
sub VAST::scope_declarator::emit_m0ld {
    my $m = shift;
    if ($m->{'sym'} eq 'my') {
        if (my $decl = $m->{scoped}{declarator}) {
            if (my $var_decl = $decl->{variable_declarator}) {
                AST::Call->new(
                    identifier => string 'STORE',
                    capture => AST::Capture->new(
                        invocant => AST::Call->new(
                            identifier => string 'postcircumfix:{ }',
                            capture => AST::Capture->new(invocant=>$var_decl->{variable}->emit_m0ld)
                        ),
                        positional => [
                            AST::Call->new(
                                identifier => string 'new',
                                capture => AST::Capture->new(invocant => lookup '$Scalar'),
                            )
                        ]
                    ),
                );
            }
        }
    } else {
        XXX;
    }
}
sub VAST::noun::emit_m0ld {
    my $m = shift;
    if ($m->{variable}) {
        $m->{variable}->emit_m0ld;
    } elsif ($m->{value}) {
        $m->{value}->emit_m0ld;
    } elsif ($m->{routine_declarator}) {
        if ($m->{routine_declarator}{routine_def}) {
            $m->{routine_declarator}{routine_def}->emit_m0ld;
        } else {
            XXX;
        }
    } elsif ($m->{term}) {
        $m->{term}->emit_m0ld;
    } elsif ($m->{scope_declarator}) {
        $m->{scope_declarator}->emit_m0ld;
    } else {
        XXX;
    }
}
sub VAST::term::emit_m0ld {
    my $m = shift;
    if ($m->{identifier} && $m->{args}) {
        my $func = lookup('&'.$m->{identifier}{TEXT});
        AST::Call->new(identifier=>string 'postcircumfix:( )',capture=>AST::Capture->new(invocant=>$func,positional=>$m->{args}->emit_m0ld));
    } elsif (my $name = $m->{longname}{name}) {
        if ($name->{morename} and !$name->{identifier}) {
            lookup join '',map {$_->{identifier}[0]{TEXT}} @{$name->{morename}};
            
        }
    }
}
sub VAST::identifier::emit_m0ld {
    my $m = shift;
}
sub VAST::Terminator::emit_m0ld {
    my $m = shift;
    if ($m->{noun}) {
        $m->{noun}->emit_m0ld;
    } else {
        XXX;
    }
}
sub VAST::args::emit_m0ld {
    my $m = shift;
    return [map {$_->{EXPR}->emit_m0ld} @{$m->{arglist}}];
}
sub VAST::routine_def::emit_m0ld {
    my $m = shift;
    AST::Call->new(identifier=>string 'new',
        capture => AST::Capture->new(
            invocant => reg '$Code',
            positional => [],
            named => [
                string 'mold' => block($m->{block}),
                string 'outer' => reg '$scope'
            ]
        ),
    );
}
sub VAST::block::emit_m0ld {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>statementlist($m->{in}{statementlist}));
}
sub VAST::value::emit_m0ld {
    my $m = shift;
    if ($m->{number}) {
        $m->{number}->emit_m0ld;
    } elsif ($m->{quote}) {
        $m->{quote}->emit_m0ld;
    } else {
        warn Dump($m);
        XXX;
    }
}
sub VAST::quote::emit_m0ld {
    my $m = shift;
    # XXX escapes
    string $m->{nibble}{nibbles}[0];
}
sub VAST::number::emit_m0ld {
    my $m = shift;
    if ($m->{integer}) {
        $m->{integer}->emit_m0ld;
    } else {
        XXX;
    }
}
sub VAST::variable::emit_m0ld {
    my $m = shift;
    my $varname = $m->{sigil}{TEXT}.$m->{desigilname}{longname}{name}{identifier}{TEXT};
    AST::Call->new(
        identifier=>string 'lookup',
        capture=>AST::Capture->new(invocant=>reg '$scope',positional=>[string $varname]),
    );
}

sub VAST::dotty::emit_m0ld {
    my ($m,$noun) = @_;
    if (my $methodop = $m->{dottyop}{methodop}) {
        if ($methodop->{longname}) {
            my @positional;
            my $pos0 = $methodop->{in}[0]{semilist}{statement}[0];
            if ($pos0) {
                @positional = (FETCH($pos0->{EXPR}->emit_m0ld));
            }
            my $ident = $methodop->{longname}{name}{identifier}{TEXT};
            if ($m->{sym} eq '^!') {
                $ident = '^!' . $ident;
            }
            AST::Call->new(
                identifier=>string $ident,
                capture=>AST::Capture->new(invocant=>FETCH($noun),positional=>[@positional]),
            );
        } else {
            XXX
        }
    } else {
        XXX;
    }
}
sub EXPR {
    my $m = shift;
    if ($m->{noun}) {
        my $noun = $m->{noun}->emit_m0ld;
        if ($m->{post}) {
            for (@{$m->{post}}) {
                if ($_->{dotty}) {
                    $noun = $_->{dotty}->emit_m0ld($noun);
                } else {
                    XXX
                }
            }
            $noun;
        } else {
            $noun;
        }
    }
} 
sub VAST::EXPR::emit_m0ld {
    EXPR(shift);
}
sub VAST::termish::emit_m0ld {
    EXPR(shift);
}
sub VAST::Methodcall::emit_m0ld {
    my $m = shift;
    $m->{arg}->emit_m0ld;
}
sub VAST::List_assignment::emit_m0ld {
    my $m = shift;
    if ($m->{infix}{TEXT} eq '=') {
        AST::Call->new(
            identifier=>string 'STORE',
            capture=>AST::Capture->new(invocant=>$m->{left}->emit_m0ld,positional=>[FETCH($m->{right}->emit_m0ld)]),
        );
    } else {
        XXX;
    }
}
sub VAST::statement::emit_m0ld {
    my $m = shift;
    if ($m->{label}) {
        AST::Label->new(label=>label($m->{label}),stmt=>statement($m->{statement}));
    } elsif ($m->{statement_control}) {
    } elsif ($m->{EXPR}) {
        $m->{EXPR}->emit_m0ld;
    } else {
    }
}
sub VAST::comp_unit::emit_m0ld {
    my $m = shift;
    AST::Block->new(regs=>['interpreter','scope'],stmts=>$m->{statementlist}->emit_m0ld);
}
sub VAST::statementlist::emit_m0ld {
    my $m = shift;
    [map {$_->emit_m0ld} @{$m->{statement}}]
}
unless ($file) {
    die "usage [--debug] [--desugar] --file filename\n"
}
my $m = STD->parsefile($file,'comp_unit');
print dump_match('comp_unit'=>$m,{vertical=>1,mark_arrays=>1,visit_twice=>1}),"\n" if $debug;
print "#################\n" if $debug;
print Dump($m->item) if $debug;
print Dump($m->item->emit_m0ld) if $debug;
print "#################\n" if $debug;
my $mold = $m->item->emit_m0ld;
use YAML::XS;
print $mold->pretty if $desugar;
exit if $desugar;
print <<'BOILERPLATE';
my $void;
my $scope = ?SMOP__S1P__LexicalScope."new"();

my $OUT_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("$*OUT");
my $OUT_root = $OUT_root_scalar."FETCH"();
my $OUT_scalar = $scope."postcircumfix:{ }"("$OUT");
$void = $OUT_scalar."STORE"($OUT_root);

my $Code_scalar = $scope."postcircumfix:{ }"("Code");
my $Code_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("::Code");
my $Code = $Code_root_scalar."FETCH"();
$void = $Code_scalar."STORE"($Code);

my $Scalar_scalar = $scope."postcircumfix:{ }"("Scalar");
my $Scalar_root_scalar = ?SMOP__S1P__RootNamespace."postcircumfix:{ }"("::Scalar");
my $Scalar = $Scalar_root_scalar."FETCH"();
$void = $Scalar_scalar."STORE"($Scalar);

BOILERPLATE
print $mold->emit_('$main');
print <<'CALL_MAIN';
my $main_code = $Code."new"(:"outer"($scope),:"mold"($main));
my $void = $main_code."postcircumfix:( )"();
CALL_MAIN

