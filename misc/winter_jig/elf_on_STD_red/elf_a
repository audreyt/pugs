#!/usr/bin/perl
# This file was mechanically written.  Your changes to it will be overwritten.
#line 3 head.pl
use strict;
use warnings;
#line 2 Match.pm
# This code was originally taken from yet_another_regex_engine/Regexp_ModuleA.pm,
# r20138.
{ package Match;
  sub new_set {
    my($cls,$r,$s,$f,$t,$h)=@_;
    bless {
      bool => 1,
      rule => $r,
      str => $s,
      from => $f,
      to => $t,
      hash => $h,
      array => [],
    },$cls;
  }
  sub new {
    my($cls)=@_;
    my $h = {
      from    => undef,
      to      => undef,
      bool => 1,
      str  => "",
      array   => [],
      hash    => {},
      };
    my $o = \$h;
    bless $o,$cls;
  }
  sub from { shift->{from} }
  sub to { shift->{to} }

  sub match_string { shift->{str} }
  sub match_array { shift->{array}||[] }
  sub match_hash { shift->{hash} }
  sub match_boolean { shift->{bool} }
  sub match_value { undef }
  sub match_describe {
    my($o,$verbosity)=@_;
    $verbosity ||= 0;
    my $vp = $verbosity;

    my $describe_thing;
    $describe_thing = sub {
      my($x)=@_;
      my $ref = ref($x);
      if(!$ref) { $x }
      elsif(UNIVERSAL::can($x,'match_describe')) {
        $x->match_describe($verbosity);
      } elsif($ref eq 'ARRAY') {
        "[\n".$o->match__indent(join(",\n",map{
          $describe_thing->($_)
          }@$x))."\n]";
      } elsif($ref eq 'HASH') {
        my $s = "";
        for my $k (keys %$x) {
          my $v = $x->{$k};
          my $vs = $describe_thing->($v);
          $s .= "\n  $k => " .$o->match__indent_except_top($vs).",";
        }
        $s .= "\n " if %$x;
        "{$s}";
      }
      else { die "bug: $ref" }
    };

    my $os = $o->match_string;
    if($verbosity > 1) {
      $os = $o->match__indent_except_top($os) if $os =~ /\n/;
    } else {
      $os =~ s/\n/\\n/g;
      $os =~ s/\t/\\t/g;
      if(length($os) > 60) {
        $os = substr($os,0,30).' ... '.substr($os,-30);
      }
    }
    my $s = $o->match__describe_name_as($verbosity);
    $s .= "<".($o->match_boolean?"1":"0").",\"$os\",[";
    for my $v (@{$o->match_array}) {
      my $vs = $describe_thing->($v);
      $s .= "\n".$o->match__indent($vs).",";
    }
    $s .= "\n " if @{$o->match_array};
    $s .= "],{";
    for my $k (keys(%{$o->match_hash})) {
      my $v = $o->match_hash->{$k};
      my $vs = $describe_thing->($v);
      $s .= "\n  $k => " .$o->match__indent_except_top($vs).",";
    }
    $s .= "\n " if %{$o->match_hash};
    $s .= "},";
    my($from,$to)=($o->from,$o->to);
    $from = "" if !defined $from;
    $to   = "" if !defined $to;
    $s .= "$from,$to";
    my $val = $o->match_value;
    $s .= defined $val ? ",$val" : "";
    $s .= ">";
    return $s;
  }
  sub match__indent {my($o,$s)=@_; $s =~ s/^(?!\Z)/  /mg; $s}
  sub match__indent_except_top {my($o,$s)=@_; $s =~ s/^(?<!\A)(?!\Z)/  /mg; $s}
  sub match__describe_name_as {
    my($o,$verbosity)=@_;
    return "" if not $verbosity;
    my $s = "";
    $s .= $o->{rule} if defined $o->{rule};
    $s = overload::StrVal($o).'{'.$s.'}' if $verbosity > 1;
    $s;
  }
}
#line 2 ir_nodes.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IR::All;
  use Data::Dumper;
  sub describe_anything {
    my($this,$x)=@_;
    my $ref = ref($x);
    if($ref) {
      if(UNIVERSAL::can($x,'describe')) {
        $x->describe
      } elsif($ref eq 'ARRAY') {
        '['.join(",",map{$this->describe_anything($_)} @$x).']'
      } else {
        die "bug: $ref";
      }
    } else {
      local $Data::Dumper::Terse = 1;
      my $s = Dumper($x); $s =~ s/\n$//; $s;
    }
  }
}
{ package IR::CompUnit;
  @IR::CompUnit::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$statements)=@_;
    my %h;
    @h{'match','statements'}=($match,$statements);
    bless \%h,$cls;
  }
  sub node_name { 'CompUnit' }
  sub match { shift->{match} }
  sub field_names { qw{ statements } }
  sub field_values { my($self)=@_; @$self{'statements'} }
  sub describe {
    my($self)=@_;
    "CompUnit(".join(",",map{$self->describe_anything($_)}@$self{'statements'}).")"
  }
}
{ package IR::Val_Int;
  @IR::Val_Int::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$text)=@_;
    my %h;
    @h{'match','text'}=($match,$text);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Int' }
  sub match { shift->{match} }
  sub field_names { qw{ text } }
  sub field_values { my($self)=@_; @$self{'text'} }
  sub describe {
    my($self)=@_;
    "Val_Int(".join(",",map{$self->describe_anything($_)}@$self{'text'}).")"
  }
}
{ package IR::PackageDeclarator;
  @IR::PackageDeclarator::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$kind,$name,$traits,$block)=@_;
    my %h;
    @h{'match','kind','name','traits','block'}=($match,$kind,$name,$traits,$block);
    bless \%h,$cls;
  }
  sub node_name { 'PackageDeclarator' }
  sub match { shift->{match} }
  sub field_names { qw{ kind name traits block } }
  sub field_values { my($self)=@_; @$self{'kind','name','traits','block'} }
  sub describe {
    my($self)=@_;
    "PackageDeclarator(".join(",",map{$self->describe_anything($_)}@$self{'kind','name','traits','block'}).")"
  }
}
{ package IR::Trait;
  @IR::Trait::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$verb,$expr)=@_;
    my %h;
    @h{'match','verb','expr'}=($match,$verb,$expr);
    bless \%h,$cls;
  }
  sub node_name { 'Trait' }
  sub match { shift->{match} }
  sub field_names { qw{ verb expr } }
  sub field_values { my($self)=@_; @$self{'verb','expr'} }
  sub describe {
    my($self)=@_;
    "Trait(".join(",",map{$self->describe_anything($_)}@$self{'verb','expr'}).")"
  }
}
{ package IR::Block;
  @IR::Block::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$statements)=@_;
    my %h;
    @h{'match','statements'}=($match,$statements);
    bless \%h,$cls;
  }
  sub node_name { 'Block' }
  sub match { shift->{match} }
  sub field_names { qw{ statements } }
  sub field_values { my($self)=@_; @$self{'statements'} }
  sub describe {
    my($self)=@_;
    "Block(".join(",",map{$self->describe_anything($_)}@$self{'statements'}).")"
  }
}
{ package IR::Quote;
  @IR::Quote::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$concat)=@_;
    my %h;
    @h{'match','concat'}=($match,$concat);
    bless \%h,$cls;
  }
  sub node_name { 'Quote' }
  sub match { shift->{match} }
  sub field_names { qw{ concat } }
  sub field_values { my($self)=@_; @$self{'concat'} }
  sub describe {
    my($self)=@_;
    "Quote(".join(",",map{$self->describe_anything($_)}@$self{'concat'}).")"
  }
}
{ package IR::Val_Bit;
  @IR::Val_Bit::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$bit)=@_;
    my %h;
    @h{'match','bit'}=($match,$bit);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Bit' }
  sub match { shift->{match} }
  sub field_names { qw{ bit } }
  sub field_values { my($self)=@_; @$self{'bit'} }
  sub describe {
    my($self)=@_;
    "Val_Bit(".join(",",map{$self->describe_anything($_)}@$self{'bit'}).")"
  }
}
{ package IR::Val_Num;
  @IR::Val_Num::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$num)=@_;
    my %h;
    @h{'match','num'}=($match,$num);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Num' }
  sub match { shift->{match} }
  sub field_names { qw{ num } }
  sub field_values { my($self)=@_; @$self{'num'} }
  sub describe {
    my($self)=@_;
    "Val_Num(".join(",",map{$self->describe_anything($_)}@$self{'num'}).")"
  }
}
{ package IR::Val_Buf;
  @IR::Val_Buf::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$buf)=@_;
    my %h;
    @h{'match','buf'}=($match,$buf);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Buf' }
  sub match { shift->{match} }
  sub field_names { qw{ buf } }
  sub field_values { my($self)=@_; @$self{'buf'} }
  sub describe {
    my($self)=@_;
    "Val_Buf(".join(",",map{$self->describe_anything($_)}@$self{'buf'}).")"
  }
}
{ package IR::Val_Char;
  @IR::Val_Char::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$char)=@_;
    my %h;
    @h{'match','char'}=($match,$char);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Char' }
  sub match { shift->{match} }
  sub field_names { qw{ char } }
  sub field_values { my($self)=@_; @$self{'char'} }
  sub describe {
    my($self)=@_;
    "Val_Char(".join(",",map{$self->describe_anything($_)}@$self{'char'}).")"
  }
}
{ package IR::Val_Undef;
  @IR::Val_Undef::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Undef' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Val_Undef()
  }
}
{ package IR::Val_Object;
  @IR::Val_Object::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$clazz,$fields)=@_;
    my %h;
    @h{'match','clazz','fields'}=($match,$clazz,$fields);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Object' }
  sub match { shift->{match} }
  sub field_names { qw{ clazz fields } }
  sub field_values { my($self)=@_; @$self{'clazz','fields'} }
  sub describe {
    my($self)=@_;
    "Val_Object(".join(",",map{$self->describe_anything($_)}@$self{'clazz','fields'}).")"
  }
}
{ package IR::Val_Rx;
  @IR::Val_Rx::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$pat)=@_;
    my %h;
    @h{'match','pat'}=($match,$pat);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Rx' }
  sub match { shift->{match} }
  sub field_names { qw{ pat } }
  sub field_values { my($self)=@_; @$self{'pat'} }
  sub describe {
    my($self)=@_;
    "Val_Rx(".join(",",map{$self->describe_anything($_)}@$self{'pat'}).")"
  }
}
{ package IR::Lit_Seq;
  @IR::Lit_Seq::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$seq)=@_;
    my %h;
    @h{'match','seq'}=($match,$seq);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Seq' }
  sub match { shift->{match} }
  sub field_names { qw{ seq } }
  sub field_values { my($self)=@_; @$self{'seq'} }
  sub describe {
    my($self)=@_;
    "Lit_Seq(".join(",",map{$self->describe_anything($_)}@$self{'seq'}).")"
  }
}
{ package IR::Lit_Array;
  @IR::Lit_Array::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$array)=@_;
    my %h;
    @h{'match','array'}=($match,$array);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Array' }
  sub match { shift->{match} }
  sub field_names { qw{ array } }
  sub field_values { my($self)=@_; @$self{'array'} }
  sub describe {
    my($self)=@_;
    "Lit_Array(".join(",",map{$self->describe_anything($_)}@$self{'array'}).")"
  }
}
{ package IR::Lit_Hash;
  @IR::Lit_Hash::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$hash)=@_;
    my %h;
    @h{'match','hash'}=($match,$hash);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Hash' }
  sub match { shift->{match} }
  sub field_names { qw{ hash } }
  sub field_values { my($self)=@_; @$self{'hash'} }
  sub describe {
    my($self)=@_;
    "Lit_Hash(".join(",",map{$self->describe_anything($_)}@$self{'hash'}).")"
  }
}
{ package IR::Lit_Pair;
  @IR::Lit_Pair::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value)=@_;
    my %h;
    @h{'match','key','value'}=($match,$key,$value);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Pair' }
  sub match { shift->{match} }
  sub field_names { qw{ key value } }
  sub field_values { my($self)=@_; @$self{'key','value'} }
  sub describe {
    my($self)=@_;
    "Lit_Pair(".join(",",map{$self->describe_anything($_)}@$self{'key','value'}).")"
  }
}
{ package IR::Lit_SigArgument;
  @IR::Lit_SigArgument::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy)=@_;
    my %h;
    @h{'match','key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'}=($match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_SigArgument' }
  sub match { shift->{match} }
  sub field_names { qw{ key value type has_default is_named_only is_optional is_slurpy is_multidimensional is_rw is_copy } }
  sub field_values { my($self)=@_; @$self{'key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'} }
  sub describe {
    my($self)=@_;
    "Lit_SigArgument(".join(",",map{$self->describe_anything($_)}@$self{'key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'}).")"
  }
}
{ package IR::Lit_NamedArgument;
  @IR::Lit_NamedArgument::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value)=@_;
    my %h;
    @h{'match','key','value'}=($match,$key,$value);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_NamedArgument' }
  sub match { shift->{match} }
  sub field_names { qw{ key value } }
  sub field_values { my($self)=@_; @$self{'key','value'} }
  sub describe {
    my($self)=@_;
    "Lit_NamedArgument(".join(",",map{$self->describe_anything($_)}@$self{'key','value'}).")"
  }
}
{ package IR::Lit_Code;
  @IR::Lit_Code::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$pad,$state,$sig,$body,$catch)=@_;
    my %h;
    @h{'match','pad','state','sig','body','catch'}=($match,$pad,$state,$sig,$body,$catch);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Code' }
  sub match { shift->{match} }
  sub field_names { qw{ pad state sig body catch } }
  sub field_values { my($self)=@_; @$self{'pad','state','sig','body','catch'} }
  sub describe {
    my($self)=@_;
    "Lit_Code(".join(",",map{$self->describe_anything($_)}@$self{'pad','state','sig','body','catch'}).")"
  }
}
{ package IR::Lit_Object;
  @IR::Lit_Object::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$clazz,$fields)=@_;
    my %h;
    @h{'match','clazz','fields'}=($match,$clazz,$fields);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Object' }
  sub match { shift->{match} }
  sub field_names { qw{ clazz fields } }
  sub field_values { my($self)=@_; @$self{'clazz','fields'} }
  sub describe {
    my($self)=@_;
    "Lit_Object(".join(",",map{$self->describe_anything($_)}@$self{'clazz','fields'}).")"
  }
}
{ package IR::Var;
  @IR::Var::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$sigil,$twigil,$name,$namespace)=@_;
    my %h;
    @h{'match','sigil','twigil','name','namespace'}=($match,$sigil,$twigil,$name,$namespace);
    bless \%h,$cls;
  }
  sub node_name { 'Var' }
  sub match { shift->{match} }
  sub field_names { qw{ sigil twigil name namespace } }
  sub field_values { my($self)=@_; @$self{'sigil','twigil','name','namespace'} }
  sub describe {
    my($self)=@_;
    "Var(".join(",",map{$self->describe_anything($_)}@$self{'sigil','twigil','name','namespace'}).")"
  }
}
{ package IR::Bind;
  @IR::Bind::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$parameters,$arguments)=@_;
    my %h;
    @h{'match','parameters','arguments'}=($match,$parameters,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Bind' }
  sub match { shift->{match} }
  sub field_names { qw{ parameters arguments } }
  sub field_values { my($self)=@_; @$self{'parameters','arguments'} }
  sub describe {
    my($self)=@_;
    "Bind(".join(",",map{$self->describe_anything($_)}@$self{'parameters','arguments'}).")"
  }
}
{ package IR::Assign;
  @IR::Assign::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$parameters,$arguments)=@_;
    my %h;
    @h{'match','parameters','arguments'}=($match,$parameters,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Assign' }
  sub match { shift->{match} }
  sub field_names { qw{ parameters arguments } }
  sub field_values { my($self)=@_; @$self{'parameters','arguments'} }
  sub describe {
    my($self)=@_;
    "Assign(".join(",",map{$self->describe_anything($_)}@$self{'parameters','arguments'}).")"
  }
}
{ package IR::Proto;
  @IR::Proto::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name)=@_;
    my %h;
    @h{'match','name'}=($match,$name);
    bless \%h,$cls;
  }
  sub node_name { 'Proto' }
  sub match { shift->{match} }
  sub field_names { qw{ name } }
  sub field_values { my($self)=@_; @$self{'name'} }
  sub describe {
    my($self)=@_;
    "Proto(".join(",",map{$self->describe_anything($_)}@$self{'name'}).")"
  }
}
{ package IR::Call;
  @IR::Call::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$hyper,$method,$arguments)=@_;
    my %h;
    @h{'match','invocant','hyper','method','arguments'}=($match,$invocant,$hyper,$method,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Call' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant hyper method arguments } }
  sub field_values { my($self)=@_; @$self{'invocant','hyper','method','arguments'} }
  sub describe {
    my($self)=@_;
    "Call(".join(",",map{$self->describe_anything($_)}@$self{'invocant','hyper','method','arguments'}).")"
  }
}
{ package IR::Apply;
  @IR::Apply::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$code,$arguments)=@_;
    my %h;
    @h{'match','code','arguments'}=($match,$code,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Apply' }
  sub match { shift->{match} }
  sub field_names { qw{ code arguments } }
  sub field_values { my($self)=@_; @$self{'code','arguments'} }
  sub describe {
    my($self)=@_;
    "Apply(".join(",",map{$self->describe_anything($_)}@$self{'code','arguments'}).")"
  }
}
{ package IR::Return;
  @IR::Return::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$result)=@_;
    my %h;
    @h{'match','result'}=($match,$result);
    bless \%h,$cls;
  }
  sub node_name { 'Return' }
  sub match { shift->{match} }
  sub field_names { qw{ result } }
  sub field_values { my($self)=@_; @$self{'result'} }
  sub describe {
    my($self)=@_;
    "Return(".join(",",map{$self->describe_anything($_)}@$self{'result'}).")"
  }
}
{ package IR::If;
  @IR::If::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$test,$body,$elsif,$else)=@_;
    my %h;
    @h{'match','test','body','elsif','else'}=($match,$test,$body,$elsif,$else);
    bless \%h,$cls;
  }
  sub node_name { 'If' }
  sub match { shift->{match} }
  sub field_names { qw{ test body elsif else } }
  sub field_values { my($self)=@_; @$self{'test','body','elsif','else'} }
  sub describe {
    my($self)=@_;
    "If(".join(",",map{$self->describe_anything($_)}@$self{'test','body','elsif','else'}).")"
  }
}
{ package IR::While;
  @IR::While::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$test,$body)=@_;
    my %h;
    @h{'match','test','body'}=($match,$test,$body);
    bless \%h,$cls;
  }
  sub node_name { 'While' }
  sub match { shift->{match} }
  sub field_names { qw{ test body } }
  sub field_values { my($self)=@_; @$self{'test','body'} }
  sub describe {
    my($self)=@_;
    "While(".join(",",map{$self->describe_anything($_)}@$self{'test','body'}).")"
  }
}
{ package IR::For;
  @IR::For::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$expr,$body)=@_;
    my %h;
    @h{'match','expr','body'}=($match,$expr,$body);
    bless \%h,$cls;
  }
  sub node_name { 'For' }
  sub match { shift->{match} }
  sub field_names { qw{ expr body } }
  sub field_values { my($self)=@_; @$self{'expr','body'} }
  sub describe {
    my($self)=@_;
    "For(".join(",",map{$self->describe_anything($_)}@$self{'expr','body'}).")"
  }
}
{ package IR::Decl;
  @IR::Decl::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$decl,$type,$var,$default)=@_;
    my %h;
    @h{'match','decl','type','var','default'}=($match,$decl,$type,$var,$default);
    bless \%h,$cls;
  }
  sub node_name { 'Decl' }
  sub match { shift->{match} }
  sub field_names { qw{ decl type var default } }
  sub field_values { my($self)=@_; @$self{'decl','type','var','default'} }
  sub describe {
    my($self)=@_;
    "Decl(".join(",",map{$self->describe_anything($_)}@$self{'decl','type','var','default'}).")"
  }
}
{ package IR::Sig;
  @IR::Sig::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$positional)=@_;
    my %h;
    @h{'match','invocant','positional'}=($match,$invocant,$positional);
    bless \%h,$cls;
  }
  sub node_name { 'Sig' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant positional } }
  sub field_values { my($self)=@_; @$self{'invocant','positional'} }
  sub describe {
    my($self)=@_;
    "Sig(".join(",",map{$self->describe_anything($_)}@$self{'invocant','positional'}).")"
  }
}
{ package IR::Lit_Capture;
  @IR::Lit_Capture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$array,$hash)=@_;
    my %h;
    @h{'match','invocant','array','hash'}=($match,$invocant,$array,$hash);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Capture' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant array hash } }
  sub field_values { my($self)=@_; @$self{'invocant','array','hash'} }
  sub describe {
    my($self)=@_;
    "Lit_Capture(".join(",",map{$self->describe_anything($_)}@$self{'invocant','array','hash'}).")"
  }
}
{ package IR::Lit_Subset;
  @IR::Lit_Subset::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$base_class,$block)=@_;
    my %h;
    @h{'match','name','base_class','block'}=($match,$name,$base_class,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Subset' }
  sub match { shift->{match} }
  sub field_names { qw{ name base_class block } }
  sub field_values { my($self)=@_; @$self{'name','base_class','block'} }
  sub describe {
    my($self)=@_;
    "Lit_Subset(".join(",",map{$self->describe_anything($_)}@$self{'name','base_class','block'}).")"
  }
}
{ package IR::Method;
  @IR::Method::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Method' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Method(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Sub;
  @IR::Sub::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Sub' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Sub(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Macro;
  @IR::Macro::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Macro' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Macro(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Coro;
  @IR::Coro::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Coro' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Coro(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::P5Token;
  @IR::P5Token::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$regex)=@_;
    my %h;
    @h{'match','regex'}=($match,$regex);
    bless \%h,$cls;
  }
  sub node_name { 'P5Token' }
  sub match { shift->{match} }
  sub field_names { qw{ regex } }
  sub field_values { my($self)=@_; @$self{'regex'} }
  sub describe {
    my($self)=@_;
    "P5Token(".join(",",map{$self->describe_anything($_)}@$self{'regex'}).")"
  }
}
{ package IR::Token;
  @IR::Token::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$regex,$sym)=@_;
    my %h;
    @h{'match','name','regex','sym'}=($match,$name,$regex,$sym);
    bless \%h,$cls;
  }
  sub node_name { 'Token' }
  sub match { shift->{match} }
  sub field_names { qw{ name regex sym } }
  sub field_values { my($self)=@_; @$self{'name','regex','sym'} }
  sub describe {
    my($self)=@_;
    "Token(".join(",",map{$self->describe_anything($_)}@$self{'name','regex','sym'}).")"
  }
}
{ package IR::Do;
  @IR::Do::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$block)=@_;
    my %h;
    @h{'match','block'}=($match,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Do' }
  sub match { shift->{match} }
  sub field_names { qw{ block } }
  sub field_values { my($self)=@_; @$self{'block'} }
  sub describe {
    my($self)=@_;
    "Do(".join(",",map{$self->describe_anything($_)}@$self{'block'}).")"
  }
}
{ package IR::Begin;
  @IR::Begin::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$block)=@_;
    my %h;
    @h{'match','block'}=($match,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Begin' }
  sub match { shift->{match} }
  sub field_names { qw{ block } }
  sub field_values { my($self)=@_; @$self{'block'} }
  sub describe {
    my($self)=@_;
    "Begin(".join(",",map{$self->describe_anything($_)}@$self{'block'}).")"
  }
}
{ package IR::Use;
  @IR::Use::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$mod,$perl5)=@_;
    my %h;
    @h{'match','mod','perl5'}=($match,$mod,$perl5);
    bless \%h,$cls;
  }
  sub node_name { 'Use' }
  sub match { shift->{match} }
  sub field_names { qw{ mod perl5 } }
  sub field_values { my($self)=@_; @$self{'mod','perl5'} }
  sub describe {
    my($self)=@_;
    "Use(".join(",",map{$self->describe_anything($_)}@$self{'mod','perl5'}).")"
  }
}
{ package IR::Rule;
  @IR::Rule::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Rule' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Rule()
  }
}
{ package IR::Rule_Quantifier;
  @IR::Rule_Quantifier::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$term,$quant,$greedy,$ws1,$ws2,$ws3)=@_;
    my %h;
    @h{'match','term','quant','greedy','ws1','ws2','ws3'}=($match,$term,$quant,$greedy,$ws1,$ws2,$ws3);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Quantifier' }
  sub match { shift->{match} }
  sub field_names { qw{ term quant greedy ws1 ws2 ws3 } }
  sub field_values { my($self)=@_; @$self{'term','quant','greedy','ws1','ws2','ws3'} }
  sub describe {
    my($self)=@_;
    "Rule_Quantifier(".join(",",map{$self->describe_anything($_)}@$self{'term','quant','greedy','ws1','ws2','ws3'}).")"
  }
}
{ package IR::Rule_Or;
  @IR::Rule_Or::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$terms)=@_;
    my %h;
    @h{'match','terms'}=($match,$terms);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Or' }
  sub match { shift->{match} }
  sub field_names { qw{ terms } }
  sub field_values { my($self)=@_; @$self{'terms'} }
  sub describe {
    my($self)=@_;
    "Rule_Or(".join(",",map{$self->describe_anything($_)}@$self{'terms'}).")"
  }
}
{ package IR::Rule_Concat;
  @IR::Rule_Concat::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$concat)=@_;
    my %h;
    @h{'match','concat'}=($match,$concat);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Concat' }
  sub match { shift->{match} }
  sub field_names { qw{ concat } }
  sub field_values { my($self)=@_; @$self{'concat'} }
  sub describe {
    my($self)=@_;
    "Rule_Concat(".join(",",map{$self->describe_anything($_)}@$self{'concat'}).")"
  }
}
{ package IR::Rule_Subrule;
  @IR::Rule_Subrule::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$metasyntax,$ident,$capture_to_array)=@_;
    my %h;
    @h{'match','metasyntax','ident','capture_to_array'}=($match,$metasyntax,$ident,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Subrule' }
  sub match { shift->{match} }
  sub field_names { qw{ metasyntax ident capture_to_array } }
  sub field_values { my($self)=@_; @$self{'metasyntax','ident','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Subrule(".join(",",map{$self->describe_anything($_)}@$self{'metasyntax','ident','capture_to_array'}).")"
  }
}
{ package IR::Rule_SubruleNoCapture;
  @IR::Rule_SubruleNoCapture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$metasyntax)=@_;
    my %h;
    @h{'match','metasyntax'}=($match,$metasyntax);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_SubruleNoCapture' }
  sub match { shift->{match} }
  sub field_names { qw{ metasyntax } }
  sub field_values { my($self)=@_; @$self{'metasyntax'} }
  sub describe {
    my($self)=@_;
    "Rule_SubruleNoCapture(".join(",",map{$self->describe_anything($_)}@$self{'metasyntax'}).")"
  }
}
{ package IR::Rule_Var;
  @IR::Rule_Var::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$sigil,$twigil,$name)=@_;
    my %h;
    @h{'match','sigil','twigil','name'}=($match,$sigil,$twigil,$name);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Var' }
  sub match { shift->{match} }
  sub field_names { qw{ sigil twigil name } }
  sub field_values { my($self)=@_; @$self{'sigil','twigil','name'} }
  sub describe {
    my($self)=@_;
    "Rule_Var(".join(",",map{$self->describe_anything($_)}@$self{'sigil','twigil','name'}).")"
  }
}
{ package IR::Rule_Constant;
  @IR::Rule_Constant::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$constant)=@_;
    my %h;
    @h{'match','constant'}=($match,$constant);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Constant' }
  sub match { shift->{match} }
  sub field_names { qw{ constant } }
  sub field_values { my($self)=@_; @$self{'constant'} }
  sub describe {
    my($self)=@_;
    "Rule_Constant(".join(",",map{$self->describe_anything($_)}@$self{'constant'}).")"
  }
}
{ package IR::Rule_Dot;
  @IR::Rule_Dot::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Dot' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Rule_Dot()
  }
}
{ package IR::Rule_SpecialChar;
  @IR::Rule_SpecialChar::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$char)=@_;
    my %h;
    @h{'match','char'}=($match,$char);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_SpecialChar' }
  sub match { shift->{match} }
  sub field_names { qw{ char } }
  sub field_values { my($self)=@_; @$self{'char'} }
  sub describe {
    my($self)=@_;
    "Rule_SpecialChar(".join(",",map{$self->describe_anything($_)}@$self{'char'}).")"
  }
}
{ package IR::Rule_Block;
  @IR::Rule_Block::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$closure)=@_;
    my %h;
    @h{'match','closure'}=($match,$closure);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Block' }
  sub match { shift->{match} }
  sub field_names { qw{ closure } }
  sub field_values { my($self)=@_; @$self{'closure'} }
  sub describe {
    my($self)=@_;
    "Rule_Block(".join(",",map{$self->describe_anything($_)}@$self{'closure'}).")"
  }
}
{ package IR::Rule_InterpolateVar;
  @IR::Rule_InterpolateVar::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$var)=@_;
    my %h;
    @h{'match','var'}=($match,$var);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_InterpolateVar' }
  sub match { shift->{match} }
  sub field_names { qw{ var } }
  sub field_values { my($self)=@_; @$self{'var'} }
  sub describe {
    my($self)=@_;
    "Rule_InterpolateVar(".join(",",map{$self->describe_anything($_)}@$self{'var'}).")"
  }
}
{ package IR::Rule_NamedCapture;
  @IR::Rule_NamedCapture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$ident,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','ident','capture_to_array'}=($match,$rule,$ident,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_NamedCapture' }
  sub match { shift->{match} }
  sub field_names { qw{ rule ident capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','ident','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_NamedCapture(".join(",",map{$self->describe_anything($_)}@$self{'rule','ident','capture_to_array'}).")"
  }
}
{ package IR::Rule_Before;
  @IR::Rule_Before::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$assertion_modifier,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','assertion_modifier','capture_to_array'}=($match,$rule,$assertion_modifier,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Before' }
  sub match { shift->{match} }
  sub field_names { qw{ rule assertion_modifier capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','assertion_modifier','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Before(".join(",",map{$self->describe_anything($_)}@$self{'rule','assertion_modifier','capture_to_array'}).")"
  }
}
{ package IR::Rule_After;
  @IR::Rule_After::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$assertion_modifier,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','assertion_modifier','capture_to_array'}=($match,$rule,$assertion_modifier,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_After' }
  sub match { shift->{match} }
  sub field_names { qw{ rule assertion_modifier capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','assertion_modifier','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_After(".join(",",map{$self->describe_anything($_)}@$self{'rule','assertion_modifier','capture_to_array'}).")"
  }
}
{ package IR::Rule_NegateCharClass;
  @IR::Rule_NegateCharClass::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$chars)=@_;
    my %h;
    @h{'match','chars'}=($match,$chars);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_NegateCharClass' }
  sub match { shift->{match} }
  sub field_names { qw{ chars } }
  sub field_values { my($self)=@_; @$self{'chars'} }
  sub describe {
    my($self)=@_;
    "Rule_NegateCharClass(".join(",",map{$self->describe_anything($_)}@$self{'chars'}).")"
  }
}
{ package IR::Rule_CharClass;
  @IR::Rule_CharClass::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$chars)=@_;
    my %h;
    @h{'match','chars'}=($match,$chars);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_CharClass' }
  sub match { shift->{match} }
  sub field_names { qw{ chars } }
  sub field_values { my($self)=@_; @$self{'chars'} }
  sub describe {
    my($self)=@_;
    "Rule_CharClass(".join(",",map{$self->describe_anything($_)}@$self{'chars'}).")"
  }
}
{ package IR::Rule_Capture;
  @IR::Rule_Capture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$position,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','position','capture_to_array'}=($match,$rule,$position,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Capture' }
  sub match { shift->{match} }
  sub field_names { qw{ rule position capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','position','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Capture(".join(",",map{$self->describe_anything($_)}@$self{'rule','position','capture_to_array'}).")"
  }
}
#line 2 ir_build.pl
{ package IRBuild;
  sub make_ir_from_Match_tree {
    my($this,$tree)=@_;
    if(not ref($tree)) {
      $tree;
    } else {
      my $ref = ref($tree);
      if($ref eq 'Match') {
        my $m = $tree;
        my $rule = $m->{rule};
        if(not $rule) {die "Bug.  Found an unlabeled Match:\n$m->match_describe";}
        my $constructor = $IRBuild::constructors{$rule};
        if($constructor) {
          #print STDERR "Calling constructor for $rule with @{[$m->match_describe]}.\n";
          $constructor->($m);
        } else {
          die "Unknown rule: $rule\nIt needs to be added to ast_handlers.\n";
        }
      }
      elsif($ref eq 'ARRAY') {
        [map{$this->make_ir_from_Match_tree($_)} @$tree]
      }
      elsif($ref eq 'HASH') {
        my %h;
        for my $k (keys %$tree) {
          my $v = $tree->{$k};
          $h{$k} = $this->make_ir_from_Match_tree($v);
        }
        \%h;
      }
      else {
        die "bug? $ref $tree";
      }
    }
  }
  sub ir {
    my($tree)=@_;
    IRBuild->make_ir_from_Match_tree($tree);
  }
}
#line 2 ast_handlers.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IRBuild;
    $IRBuild::constructors{'comp_unit'} = sub {
      my($m)=@_;
    IR::CompUnit->new($m,ir($m->{hash}{statementlist}));
    };
    $IRBuild::constructors{'statement'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe(1)."\n") if(@keys > 1);
die("Unexpectedly less than 1 field\n".
    $m->match_describe(1)."\n") if(@keys < 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'expect_term'} = sub {
      my($m)=@_;
    local $blackboard::expect_term_base = ir($m->{hash}{noun});
my $post = $m->{'hash'}{'post'} || [];
for (@{(($post))}) {
$blackboard::expect_term_base = ir($_)
}
$blackboard::expect_term_base;
    };
    $IRBuild::constructors{'post'} = sub {
      my($m)=@_;
    ir($m->{hash}{dotty}) or ir($m->{hash}{postop});
    };
    $IRBuild::constructors{'dotty:methodop'} = sub {
      my($m)=@_;
    IR::Call->new($m,$blackboard::expect_term_base,undef,ir($m->{hash}{ident}),ir($m->{hash}{semilist}));
    };
    $IRBuild::constructors{'dotty:postcircumfix'} = sub {
      my($m)=@_;
    my $s = ($m->match_string);
my $name = substr($s,0,1).' '.substr($s,-1,1);
my $ident = "postcircumfix:".$name;
IR::Call->new($m,$blackboard::expect_term_base,undef,$ident,ir($m->{hash}{kludge_name}));
    };
    $IRBuild::constructors{'postcircumfix'} = sub {
      my($m)=@_;
    my $s = ($m->match_string);
my $name = substr($s,0,1).' '.substr($s,-1,1);
my $ident = "postcircumfix:".$name;
IR::Call->new($m,$blackboard::expect_term_base,undef,$ident,ir($m->{hash}{kludge_name}));
    };
    $IRBuild::constructors{'term:expect_term'} = sub {
      my($m)=@_;
    ir($m->{hash}{noun});
    };
    $IRBuild::constructors{'term'} = sub {
      my($m)=@_;
    if(($m->match_string) eq 'self') {
IR::Apply->new($m,'self',[])
} else {
die "AST term partially unimplemented.\n";
};
    };
    $IRBuild::constructors{'integer'} = sub {
      my($m)=@_;
    IR::Val_Int->new($m,($m->match_string));
    };
    $IRBuild::constructors{'subcall'} = sub {
      my($m)=@_;
    my $t = ir($m->{hash}{subshortname}->{hash}{twigil});
if($t && $t eq '.') {
IR::Call->new($m,IR::Apply->new($m,'self',[]),undef,ir($m->{hash}{subshortname}->{hash}{desigilname}->{hash}{ident}),ir($m->{hash}{semilist}))
} else {
IR::Apply->new($m,ir($m->{hash}{subshortname}),ir($m->{hash}{semilist}))
};
    };
    $IRBuild::constructors{'name'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'statement_control:use'} = sub {
      my($m)=@_;
    IR::Use->new($m,ir($m->{hash}{module_name}));
    };
    $IRBuild::constructors{'module_name:depreciated'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'module_name:normal'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'term:listop'} = sub {
      my($m)=@_;
    my $not_really_an_arglist = ir($m->{hash}{arglist});
if(ir($m->{hash}{arglist})) {
IR::Apply->new($m,ir($m->{hash}{ident}),[$not_really_an_arglist])
} else {
IR::Apply->new($m,ir($m->{hash}{ident}),[])
};
    };
    $IRBuild::constructors{'quote:q'} = sub {
      my($m)=@_;
    IR::Val_Buf->new($m,ir($m->{hash}{text}));
    };
    $IRBuild::constructors{'quote:qq'} = sub {
      my($m)=@_;
    my $s = ir($m->{hash}{text});
$s =~ s/(?<!\\)\\n/\n/g;
$s =~ s/(?<!\\)\\t/\t/g;
IR::Val_Buf->new($m,$s);
    };
    $IRBuild::constructors{'quote:regex'} = sub {
      my($m)=@_;
    my $s = ir($m->{hash}{text});
IR::Val_Rx->new($m,$s);
    };
    $IRBuild::constructors{'infix'} = sub {
      my($m)=@_;
    my $op = ($m->match_string);
if($op eq 'str') { $op = '=' };
IR::Apply->new($m,"infix:".$op,[ir($m->{hash}{left}),ir($m->{hash}{right})]);
    };
    $IRBuild::constructors{'scope_declarator:my'} = sub {
      my($m)=@_;
    my $vd = ir($m->{hash}{scoped});
IR::Decl->new($m,'my',undef,$vd->[0],$vd->[1]);
    };
    $IRBuild::constructors{'scope_declarator:has'} = sub {
      my($m)=@_;
    my $vd = ir($m->{hash}{scoped});
IR::Decl->new($m,'has',undef,$vd->[0],$vd->[1]);
    };
    $IRBuild::constructors{'scope_declarator:our'} = sub {
      my($m)=@_;
    my $vd = ir($m->{hash}{scoped});
IR::Decl->new($m,'our',undef,$vd->[0],$vd->[1]);
    };
    $IRBuild::constructors{'scoped'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe(1)."\n") if(@keys > 1);
die("Unexpectedly less than 1 field\n".
    $m->match_describe(1)."\n") if(@keys < 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'variable_decl'} = sub {
      my($m)=@_;
    [ir($m->{hash}{variable}),ir($m->{hash}{default_value})];
    };
    $IRBuild::constructors{'variable'} = sub {
      my($m)=@_;
    IR::Var->new($m,ir($m->{hash}{sigil}),ir($m->{hash}{twigil}),ir($m->{hash}{desigilname}));
    };
    $IRBuild::constructors{'sigil'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'twigil'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'circumfix'} = sub {
      my($m)=@_;
    my $s = ($m->match_string);
my $name = substr($s,0,1).' '.substr($s,-1,1);
IR::Apply->new($m,"circumfix:".$name,ir($m->{hash}{kludge_name}));
    };
    $IRBuild::constructors{'statement_control:for'} = sub {
      my($m)=@_;
    IR::For->new($m,ir($m->{hash}{expr}),ir($m->{hash}{block}));
    };
    $IRBuild::constructors{'statement_control:while'} = sub {
      my($m)=@_;
    IR::While->new($m,ir($m->{hash}{expr}),ir($m->{hash}{block}));
    };
    $IRBuild::constructors{'statement_control:if'} = sub {
      my($m)=@_;
    IR::If->new($m,ir($m->{hash}{if_expr}),ir($m->{hash}{if_block}),ir($m->{hash}{elsif}),ir($m->{hash}{else}));
    };
    $IRBuild::constructors{'elsif'} = sub {
      my($m)=@_;
    [ir($m->{hash}{elsif_expr}),ir($m->{hash}{elsif_block})];
    };
    $IRBuild::constructors{'if__else'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe(1)."\n") if(@keys > 1);
die("Unexpectedly less than 1 field\n".
    $m->match_describe(1)."\n") if(@keys < 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'pblock'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe(1)."\n") if(@keys > 1);
die("Unexpectedly less than 1 field\n".
    $m->match_describe(1)."\n") if(@keys < 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'block'} = sub {
      my($m)=@_;
    IR::Block->new($m,ir($m->{hash}{statementlist}));
    };
    $IRBuild::constructors{'routine_declarator:routine_def'} = sub {
      my($m)=@_;
    my $ident = "";
if(ir($m->{hash}{ident})) { $ident = ir($m->{hash}{ident})->[0] };
my $sig = IR::Sig->new($m,undef,[]);
if(ir($m->{hash}{multisig})) { $sig = ir($m->{hash}{multisig})->[0] };
IR::Sub->new($m,$ident,$sig,ir($m->{hash}{block}));
    };
    $IRBuild::constructors{'routine_declarator:method_def'} = sub {
      my($m)=@_;
    IR::Method->new($m,ir($m->{hash}{ident}),ir($m->{hash}{multisig})->[0],ir($m->{hash}{block}));
    };
    $IRBuild::constructors{'signature'} = sub {
      my($m)=@_;
    IR::Sig->new($m,undef,ir($m->{hash}{parsep}));
    };
    $IRBuild::constructors{'parameter'} = sub {
      my($m)=@_;
    IR::Lit_SigArgument->new($m,ir($m->{hash}{param_var}));
    };
    $IRBuild::constructors{'param_var'} = sub {
      my($m)=@_;
    IR::Var->new($m,ir($m->{hash}{sigil}),ir($m->{hash}{twigil}),ir($m->{hash}{ident}));
    };
    $IRBuild::constructors{'package_declarator:class'} = sub {
      my($m)=@_;
    local $blackboard::package_declarator = 'class';
ir($m->{hash}{package_def});
    };
    $IRBuild::constructors{'package_declarator:module'} = sub {
      my($m)=@_;
    local $blackboard::package_declarator = 'module';
ir($m->{hash}{package_def});
    };
    $IRBuild::constructors{'package_declarator:package'} = sub {
      my($m)=@_;
    local $blackboard::package_declarator = 'package';
ir($m->{hash}{package_def});
    };
    $IRBuild::constructors{'package_def'} = sub {
      my($m)=@_;
    IR::PackageDeclarator->new($m,$blackboard::package_declarator,ir($m->{hash}{module_name})->[0],ir($m->{hash}{traits}),ir($m->{hash}{block}));
    };
    $IRBuild::constructors{'fulltypename'} = sub {
      my($m)=@_;
    join("::",@{((ir($m->{hash}{typename})))});
    };
    $IRBuild::constructors{'typename'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'trait_verb:is'} = sub {
      my($m)=@_;
    IR::Trait->new($m,'is',ir($m->{hash}{ident}));
    };
    $IRBuild::constructors{'circumfix:pblock'} = sub {
      my($m)=@_;
    if(not ir($m->{hash}{lambda}) and not ir($m->{hash}{signature})) {
IR::Lit_Hash->new($m,ir($m->{hash}{block}->{hash}{statementlist}))
} else {
die "AST handler circumfix:pblock partially unimplemented";
}
;
    };
}
#line 2 emit_p5.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IR;
  sub emit_p5_for {
    my($this,$tree)=@_;
    if(not ref($tree)) {
      $tree;
    } else {
      my $ref = ref($tree);
      if($ref eq 'ARRAY') {
        [map{$this->emit_p5_for($_)} @$tree]
      }
      elsif($ref eq 'HASH') {
        my %h;
        for my $k (keys %$tree) {
          my $v = $tree->{$k};
          $h{$k} = $this->emit_p5_for($v);
        }
        \%h;
      }
      else {
        $tree->emit_p5
      }
    }
  }
}
{ package IR::All;
  sub emit_p5 {
    my $name = $_[0]->node_name;
    print STDERR "ERROR: emit_p5 is not defined for $name.\n";
    "***<$name>***";
  }
}
{ package IR::CompUnit; sub emit_p5 {
    my($n)=@_;
    local $whiteboard::in_package = [];
"\x23".'line 2 emitted_p5_'.int(rand(10000)).'
package main;
use Data::Dumper;
'.join(";\n",@{IR->emit_p5_for($n->{statements})})
  }
}
{ package IR::Val_Int; sub emit_p5 {
    my($n)=@_;
    IR->emit_p5_for($n->{text})
  }
}
{ package IR::Apply; sub emit_p5 {
    my($n)=@_;
    if(IR->emit_p5_for($n->{code}) =~ /^infix:(.+)$/) {
  my $op = $1;
  my($l,$r)=@{IR->emit_p5_for($n->{arguments})};
  if($op eq '~'){ "($l . $r)" }
  elsif($op eq ','){ "$l, $r" }
  elsif($op eq '=') {
    my $t = $n->{arguments}[0]{twigil};
    if($t && $t eq '.') {
$l.'('.$r.')'
    }
    else { "($l $op $r)" }
  }
  else { "($l $op $r)" }
}
elsif(IR->emit_p5_for($n->{code}) =~ /^circumfix:(.+)/) {
  my $op = $1;
  my($arg)=join(",",@{IR->emit_p5_for($n->{arguments})||[]});
  if(undef) {
  } else {
    $op =~ s/ /$arg/;
    $op  
  }
}
else {
  my $f = IR->emit_p5_for($n->{code});
  if($f =~ /^\$\w+$/) {
     $f.'->('.join(",",@{IR->emit_p5_for($n->{arguments})}).')';
  }elsif($f eq 'self') {
    '$self'
  }else{
     '::'.$f.'('.join(",",@{IR->emit_p5_for($n->{arguments})}).')';
  }
}
  }
}
{ package IR::Decl; sub emit_p5 {
    my($n)=@_;
    if(IR->emit_p5_for($n->{decl}) eq 'has') {
  my $default = IR->emit_p5_for($n->{default});
  if(defined $default) {
    $default = ", default => $default"
  } else {
    $default = ""
  }
  "has '".IR->emit_p5_for($n->{var}->{name})."' => (is => 'rw'$default);"
}
elsif(IR->emit_p5_for($n->{var}->{twigil}) eq '^') {
  my $name = IR->emit_p5_for($n->{var});
  $name =~ s/^(.)::/$1/;
  "{package main; use vars '".$name."'};".
  'local'.' '.IR->emit_p5_for($n->{var}).(IR->emit_p5_for($n->{default}) ? ' = '.IR->emit_p5_for($n->{default}) : '')
}
else {
  IR->emit_p5_for($n->{decl}).' '.IR->emit_p5_for($n->{var}).(IR->emit_p5_for($n->{default}) ? ' = '.IR->emit_p5_for($n->{default}) : '')
}
  }
}
{ package IR::Use; sub emit_p5 {
    my($n)=@_;
    ""
  }
}
{ package IR::Val_Buf; sub emit_p5 {
    my($n)=@_;
    local $Data::Dumper::Terse = 1;
my $s = Data::Dumper::Dumper(IR->emit_p5_for($n->{buf})); chomp($s);
$s;
  }
}
{ package IR::Val_Rx; sub emit_p5 {
    my($n)=@_;
    'qr/'.IR->emit_p5_for($n->{pat}).'/'
  }
}
{ package IR::Var; sub emit_p5 {
    my($n)=@_;
    my $s = IR->emit_p5_for($n->{sigil});
my $t = IR->emit_p5_for($n->{twigil})||'';
my $env = '';
$env = 'e' if $t eq '^';
my $pre = '';
$pre = 's_' if $s eq '$' && $env eq 'e';
$pre = 'a_' if $s eq '@';
$pre = 'h_' if $s eq '%';
my $name = $env.$pre.IR->emit_p5_for($n->{name});
if($t eq '.') {
  '$self->'.$name
}elsif($t eq '^') {
  $name =~ s/::/__/g;
  '$'.'::'.$name
}else{
  '$'.$name
}
  }
}
{ package IR::For; sub emit_p5 {
    my($n)=@_;
    'for('.IR->emit_p5_for($n->{expr})."->flatten){\n".IR->emit_p5_for($n->{body})."\n}"
  }
}
{ package IR::If; sub emit_p5 {
    my($n)=@_;
    ('if('.IR->emit_p5_for($n->{test}).") {\n".IR->emit_p5_for($n->{body})."\n}"
.join("",map{'elsif('.$_->[0].") {\n".$_->[1]."\n}"} @{IR->emit_p5_for($n->{elsif})})
.(IR->emit_p5_for($n->{else}) ?  "else {\n".IR->emit_p5_for($n->{else})->[0]."\n}" : ""))
  }
}
{ package IR::While; sub emit_p5 {
    my($n)=@_;
    'while('.IR->emit_p5_for($n->{test}).") {\n".IR->emit_p5_for($n->{body})."\n}"
  }
}
{ package IR::Block; sub emit_p5 {
    my($n)=@_;
    ''.join(";\n",@{IR->emit_p5_for($n->{statements})}).''
  }
}
{ package IR::Sub; sub emit_p5 {
    my($n)=@_;
    'sub '.IR->emit_p5_for($n->{name}).'{'.IR->emit_p5_for($n->{sig}).IR->emit_p5_for($n->{block}).'}'
  }
}
{ package IR::Method; sub emit_p5 {
    my($n)=@_;
    'sub '.IR->emit_p5_for($n->{name}).'{my $self=CORE::shift;'.IR->emit_p5_for($n->{sig}).IR->emit_p5_for($n->{block}).'}'
  }
}
{ package IR::Sig; sub emit_p5 {
    my($n)=@_;
    my @a = @{IR->emit_p5_for($n->{positional})};
if(!@a) { "" }
else {
  'my('.join(",",@{IR->emit_p5_for($n->{positional})}).')=@_;'."\n";
}
  }
}
{ package IR::Lit_SigArgument; sub emit_p5 {
    my($n)=@_;
    IR->emit_p5_for($n->{key})
  }
}
{ package IR::PackageDeclarator; sub emit_p5 {
    my($n)=@_;
    local $whiteboard::in_package = [@{(($whiteboard::in_package))},IR->emit_p5_for($n->{name})];
my $name = join('::',@{(($whiteboard::in_package))});
("\n{ package ".$name.";\n".
 "use Moose;\n".
 "use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';\n".
 join("\n",@{IR->emit_p5_for($n->{traits})||[]}).
 IR->emit_p5_for($n->{block}).
 "\n}\n");
  }
}
{ package IR::Trait; sub emit_p5 {
    my($n)=@_;
    if(IR->emit_p5_for($n->{verb}) eq 'is') {
  my $name = join('::',splice(@{(($whiteboard::in_package))},0,-1),IR->emit_p5_for($n->{expr}));
  "extends '".$name."';"
} else {
  print STDERR "ERROR: Emitting p5 for Trait verb ".IR->emit_p5_for($n->{verb})." has not been implemented.\n";
  "***Trait***"
}
  }
}
{ package IR::Call; sub emit_p5 {
    my($n)=@_;
    my $method = IR->emit_p5_for($n->{method});
if($method =~ 'postcircumfix:< >') {
  IR->emit_p5_for($n->{invocant}).'->'."{'".IR->emit_p5_for($n->{arguments})."'}";
}
elsif($method =~ 'postcircumfix:(.*)') {
  my $op = $1;
  my $arg = join(",",@{IR->emit_p5_for($n->{arguments})||[]});
  $op =~ s/ /$arg/;
  IR->emit_p5_for($n->{invocant}).'->'.$op;
} else {
  IR->emit_p5_for($n->{invocant}).'->'.IR->emit_p5_for($n->{method}).'('.join(",",@{IR->emit_p5_for($n->{arguments})||[]}).')'
}
  }
}
{ package IR::Lit_Hash; sub emit_p5 {
    my($n)=@_;
    '{'.join(",",@{IR->emit_p5_for($n->{hash})||[]}).'}'
  }
}
#line 2 prelude.pl
sub Program::prelude {
  #XXX only Main is prelude'ed.
  return "#line ".(__LINE__+1)." elf_a_src/prelude.pl\n".<<'END';
package main;
use Perl6::Say;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

our $a_ARGS = [@ARGV];

{package UNDEF;}
{package UNDEF; sub ref{'UNDEF'}}
{package UNIVERSAL; sub ref{ref($_[0]) || 'SCALAR'} }

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; `cat $file`;}
sub unslurp{my($text,$file)=@_; open(F,">$file") or die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{exit(@_)}
sub ::defined{defined($_[0])}
sub ::substr ($$$){substr($_[0],$_[1],$_[2])}

{ package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}
}

package main;
END
}
#line 2 main.pl
{ package Program;
  use YAML::Syck;

  sub new {
    my($cls)=@_;
    bless {},$cls;
  }
  sub print_usage_and_exit {
    my $usage = "
Usage: [-v] [-c|-x|-xe] [-o OUTPUT_FILE] [ P6_FILE | -e P6_CODE ]

default Run code.
 -c     Compile code.
 -x     Compile code, and include prelude, creating an executable.
 -xe    Compile code, and include prelude, and run it.

";
    print STDERR $usage;
    exit(2);
  }
  sub main {
    my($self,$argv)=@_;
    $self->print_usage_and_exit() if !@$argv;
    my($output_file,$dont_eval,$run_externally,$include_prelude,$verbose);
    my $p5_code = "";
    while(my $arg = shift(@$argv)) {
      if($arg eq '-v') {
        $verbose = 1;
      }
      elsif($arg eq '-c') {
        $dont_eval = 1;
      }
      elsif($arg eq '-x') {
        $dont_eval = 1;
        $include_prelude = 1;
      }
      elsif($arg eq '-xe') {
        $dont_eval = 1;
        $include_prelude = 1;
        $run_externally = 1;
      }
      elsif($arg eq '-o') {
        $output_file = shift(@$argv) || $self->print_usage_and_exit();
      }
      elsif($arg eq '-e') {
        my $p6_code = shift(@$argv) || $self->print_usage_and_exit();
        $p5_code .= $self->compile($p6_code,$verbose);
        $p5_code .= "\n;\n";
      }
      elsif(-f $arg) {
        my $p6_code = `cat $arg`;
        $p5_code .= $self->compile($p6_code,$verbose);
        $p5_code .= "\n;\n";
      }
      elsif($arg eq '--') {
        last;
      }
      else {
        $self->print_usage_and_exit();
      }
    }
    my $prelude = "";
    $prelude = $self->prelude if $include_prelude || !$dont_eval;
    $p5_code = $prelude."\n".$p5_code;
    $p5_code = "#!/usr/bin/perl -w\n".$p5_code;
    if(!$dont_eval) {
      eval($p5_code);
      if($@) {
        #XXX... provide $code.
        die $@;
      }
    }
    elsif($run_externally) {
      if(not $output_file) {
        use File::Temp qw/ tempfile /;
        my($fh,$fname) = tempfile();
        close $fh;
        $output_file = $fname;
      }
      open(F,">$output_file") or die $!;
      print F $p5_code; close F;
      exec("perl",$output_file,@ARGV);
    }
    else {
      if(not $output_file) {
        print $p5_code,"\n";
      } else {
        open(F,">$output_file") or die $!;
        print F $p5_code,"\n"; close F;
      }
    }
  }
  sub compile {
    my($self,$p6_code,$verbose)=@_;
    #my $yaml = $self->parse(undef,$p6_code);
    #print $yaml if $verbose;
    #my $tree = YAML::Syck::Load($yaml);
    my $dump5 = $self->parse(undef,$p6_code);
    print $dump5 if $verbose;
    my $tree = eval('package Fastdump;'.$dump5);
    if(!$tree) {
      die "Flawed dump: $@";
    }
    #print Data::Dumper::Dumper($tree);
    print $tree->match_describe(1),"\n" if $verbose;
    my $ir = IRBuild->make_ir_from_Match_tree($tree);
    print "\n",$ir->describe,"\n" if $verbose;
    my $p5 = IR->emit_p5_for($ir);
    print "\n",$p5,"\n\n" if $verbose;
    $p5;
  }
  sub parse {
    my($self,$p6_file,$p6_code)=@_;
    $p6_code ||= `cat $p6_file`;
    my $std_red_from_root = "misc/STD_red/STD_red_run";
    my $std_red_from_src = "../../../$std_red_from_root";
    my $std_red;
    if(-f $std_red_from_src) {
      $std_red = $std_red_from_src;
    } else {
      die "The environment variable PUGS_ROOT must be defined.\n"
          if !exists($ENV{PUGS_ROOT});
      $std_red = $ENV{PUGS_ROOT}."/".$std_red_from_root;
    }
    my $file = $p6_file;
    if(!$file) {
      use File::Temp qw/ tempfile /;
      my($fh,$fname) = tempfile();
      print $fh $p6_code;
      close($fh);
      $file = $fname;
    }
    my $cmd = "$std_red -q --format=p5a $file";
    my $out = `$cmd` or die "Parse failed. $!\n";
    $out;
  }
}
Program->new()->main(\@ARGV);

{ package Fastdump;
  sub match {my($r,$s,$f,$t,$h)=@_;Match->new_set($r,$s,$f,$t,$h)}
}
