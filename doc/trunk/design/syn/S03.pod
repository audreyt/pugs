=encoding utf8

=head1 TITLE

Synopsis 3: Summary of Perl 6 Operators

=head1 AUTHOR

Luke Palmer <luke@luqui.org>

=head1 VERSION

  Maintainer: Larry Wall <larry@wall.org>
  Date: 8 Mar 2004
  Last Modified: 11 Jun 2006
  Number: 3
  Version: 38

=head1 Changes to existing operators

Several operators have been given new names to increase clarity and better
Huffman-code the language, while others have changed precedence.

=over

=item * C<< -> >> becomes C<.>, like the rest of the world uses.

=item * The string concatenation C<.> becomes C<~>.  Think of it as
"stitching" the two ends of its arguments together.

=item * All postfix operators that do not start with a dot also have
an alternate form that does.  (The converse does not hold--just because
you can write C<x().foo> doesn't mean you can write C<x()foo>.)  In the
absence of a postfix interpretation, the dot form will call the corresponding
prefix operator instead.  So C<x().!> will call C<!x()> unless someone
defines a postfix C<!> operator.  In particular, you can say things like
C<$array.@> and C<$filename.-e.-r>, but you can't say C<$fh.=> because
there's a C<.=> operator already.

=item * Unary C<~> now imposes a string (C<Str>) context on its
argument, and C<+> imposes a numeric (C<Num>) context (as opposed
to being a no-op in Perl 5).  Along the same lines, C<?> imposes
a boolean (C<Bool>) context, and the C<[,]> list operator imposes
a function-arguments (C<Capture>) context on its arguments.
Unary sigils impose the container context implied by their sigil.
As with Perl 5, however, C<$$foo[bar]> parses as C<$($foo)[bar]>,
so you need C<$($foo[bar])> to mean the other way.

=item * Bitwise operators get a data type prefix: C<+>, C<~>, or C<?>.
For example, C<|> becomes either C<+|> or C<~|> or C<?|>, depending on
whether the operands are to be treated as numbers, strings, or boolean
values.  Left shift C< << > becomes C< +< >, and correspondingly with
right shift. Unary C<~> becomes either C<+^> or C<~^> or C<?^>, since a
bitwise NOT is like an exclusive-or against solid ones.  Note that C<?^>
is functionally identical to C<!>.  C<?|> differs from C<||> in that
C<?|> always returns a standard boolean value (either 1 or 0), whereas
C<||> return the actual value of the first of its arguments that is
true.  Bitwise string operators may only be applied to Buf types or
similar compact integer arrays, and treat the entire chunk of memory
as a single huge integer.

=item * C<x> splits into two operators: C<x> (which concatenates repetitions 
of a string to produce a single string), and C<xx> (which creates a list of 
repetitions of a list or scalar).  C<"foo" xx *> represents an arbitrary
number of copies, useful for initializing lists.  The left side of
an C<xx> is evaluated only once.  (To call a block repeatedly, use a C<map>
instead.)

=item * Trinary C<? :> becomes C<?? !!>.  It is a syntax error to use an
operator in the middle that binds looser in precedence, such as C<=>.

=item * C<qw{ ... }> gets a synonym: C< < ... > >, and an interpolating
variant, C<«...»>.
For those still living without the blessings of Unicode, that can also be
written: C<<< << ... >> >>>.

=item * The scalar comma C<,> now constructs a List object from its
operands.  You have to use a C<[-1]> subscript to get the last one.

=item * The backslash operator captures its arguments, and returns an
object representing those arguments.  You can I<dereference> this object
in several ways to retrieve different parts of the arguments; see the
definition of C<Capture> in S02 for details.

=item * The old scalar C<..> flipflop operator is now done with
C<ff> operator.  (C<..> now always produces a Range object
even in scalar context.)  The C<ff> operator may take a caret on
either end to exclude either the beginning or ending.  There is
also a corresponding C<fff> operator with Perl 5's C<...> semantics.
You may say

    /foo/ ff *

to indicate a flipflop that never flops once flipped.

=item * All comparison operators are unified at the same precedence level.
See Chained Comparisons below.

=item * The list assignment operator now parses on the right like
any other list operator, so you don't need parens on the right side of:

    @foo = 1,2,3;

You do still need them on the left for

    ($a,$b,$c) = 1,2,3;

since list assignment operators are of assignment precedence to their left.

=item * The scalar assignment operator still parses as it did before, so

    loop ($a = 1, $b = 2; ; $a++, $b++) {...}

still works fine.  The distinction between scalar and list
assignment is similar to the way Perl 5 does it, but has to be a
little different because we can no longer decide on the basis of
the sigil.  The following forms are defined as "simple lvalues",
and imply scalar assignment:

    $a		# simple scalar variable
    $(ANY)      # scalar dereference (including $$a)
    $::(ANY)    # symbolic scalar dereference
    ANY[SIMPLE]	# single simple subscript
    ANY{SIMPLE}	# single simple subscript
    ANY<x>	# single literal subscript

Where SIMPLE is (recursively) defined as one of the forms above,
plus the following forms:

    123		# single literal
    'x'		# single literal
    "$x"	# single literal
    qq/$x/	# single literal
    +TERM	# any single term coerced to numeric
    -TERM	# any single term coerced to numeric
    ~TERM	# any single term coerced to string
    ?TERM	# any single term coerced to boolean
    !TERM	# any single term coerced to boolean

We also include:

    OP SIMPLE	
    SIMPLE OP
    SIMPLE OP SIMPLE

where C<OP> is includes any standard scalar operators in the five
precedence levels autoincrement, exponentiation, symbolic unary,
multiplicative, and additive; but these are limited to standard
operators that are known to return numbers, strings, or booleans.
(Operators that imply list operations are excluded: C<@>, C<%>,
and C<xx>, for instance.  Hyper operators are also excluded, but
post-assigment forms such as C<SIMPLE += SIMPLE> is allowed.)

All other forms imply list assignment, and will evaluate both sides
of the assignment in list context (eventually).   However, this is
primarily a syntactic distinction, and no semantic or type information
is used, since it influences subsequent parsing.  In particular, even
if a function is known to return a scalar value from its declaration,
you must use C<+> or or C<~> to use it as a scalar within a subscript:

    @a[foo()] = bar();		# foo() and bar() called in list context
    @a[+foo()] = bar();		# foo() and bar() called in scalar context

(But note that the first form still works fine if C<foo()> and C<bar()>
are scalar functions that are not context sensitive.  The difference
in parsing is only an issue if C<bar()> is followed by a comma or
some such.)

=item * List operators are all parsed consistently.  As in Perl 5,
to the left they look like terms, while to the right they look like
operators that are looser than comma.  Unlike in Perl 5, the difference
between the list operator form and the function form is consistently
indicated via whitespace between the list operator and the first
argument.  If there is whitespace, it is always a list operator,
and the next token will be taken as the first term of the list.
If there is no whitespace, the parser is biased towards taking the
next token as an operator if at all possible.  If the next token
can be taken as either an infix or a postfix operator, it indicates
that the list operator has no arguments.  (Or more precisely, no
extra arguments that aren't supplied the operator, since C<.()>
is a postfix that supplies arguments to the preceding function.)

Examples:

    say foo($bar+1),$baz		say(foo($bar+1), $baz);
    say foo.($bar+1),$baz		say(foo($bar+1), $baz);
    say foo ($bar+1),$baz		say(foo($bar+1, $baz));
    say foo .($bar+1),$baz		say(foo($_.($bar+1), $baz));

    say foo[$bar+1],$baz		say((foo[$bar+1]), $baz);
    say foo.[$bar+1],$baz		say((foo[$bar+1]), $baz);
    say foo [$bar+1],$baz		say(foo([$bar+1], $baz));
    say foo .[$bar+1],$baz		say(foo($_.[$bar+1], $baz));

    say foo{$bar+1},$baz		say((foo{$bar+1}), $baz);
    say foo.{$bar+1},$baz		say((foo{$bar+1}), $baz);
    say foo {$bar+1},$baz		say(foo({$bar+1}, $baz));
    say foo .{$bar+1},$baz		say(foo($_.{$bar+1}, $baz));

    say foo<$bar+1>,$baz		say((foo<$bar+1>), $baz);
    say foo.<$bar+1>,$baz		say((foo<$bar+1>), $baz);
    say foo <$bar+1>,$baz		say(foo(<$bar+1>, $baz));
    say foo .<$bar+1>,$baz		say(foo($_.<$bar+1>, $baz));

Note that Perl 6 is making a consistent three-way distinction between
term vs postfix vs infix, and will interpret an overloaded character
like C<< < >> accordingly:

    any <a b c>				any('a','b','c')	# term
    any<a b c>				(any).{'a','b','c'}	# postfix
    any()<a b c>			(any).{'a','b','c'}	# postfix
    any() < $x				(any) < $x		# infix

This will seem unfamiliar and "undwimmy" to Perl 5 programmers, who
are used to a grammar that sloppily hardwires a few postfix operators
at the price of extensibility.  Perl 6 chooses instead to mandate a
whitespace dependency in order to gain a completely extensible class
of postfix operators.

=item * A list operator's arguments are also terminated by a closure
that is not followed by a comma or colon.  (And a semicolon is implied if
the closure is the final thing on a line.)

=back

=head1 New operators

=over

=item * Binary C<//> is just like C<||>, except that it tests its left
side for definedness instead of truth. There is a low-precedence form,
too: C<err>.

=item * Binary C<===> tests type and value correspondence: for two value types,
tests whether they are the same value (eg. C<1 === 1>); for two reference
types, checks whether they have the same identity value.  For reference
types that do not define an identity, the reference itself is used (eg. it
is not true that C<[1,2] === [1,2]>, but it is true that C<@a === @a>).

Any reference type may pretend to be a value type by defining a C<.id> method
which returns a built-in value, i.e. an immutable object or a native value,
as specified in S06.

Because Perl 6 uses a false C<.id> to signify a non-instantiated prototype,
all instances should arrange to return a C<.id> that boolifies to true.

A class may also overload C<< infix:<===> >> for more efficient comparison of
any two objects of that type, but it must return the same result as if
the two identity values had been generated and compared.

Two values are never equivalent unless they are of exactly the same type.  By
contrast, C<eq> always coerces to string, while C<==> always coerces to
numeric.  In fact, C<$a eq $b> really means "C<~$a === ~$b>" and C<$a == $b>
means "C<+$a === +$b>.

Note also that, while string hashes use C<eq> semantics by default,
object hashes use C<===> semantics.

=item * Binary C<< => >> is no longer just a "fancy comma."  It now
constructs a C<Pair> object that can, among other things, be used to
pass named arguments to functions.  It provides scalar context to both sides.
Its precedence is now equivalent to assignment, and it is right associative.

=item * C<^^> is the high-precedence version of C<xor>.

=item * C<=~> becomes the "smart match" operator C<~~>, with a whole new set
of semantics.  Anywhere you used C<=~> before you now use C<~~>, but C<~~> is
much more general now.  See S04 for details.  (To catch "brainos",
the Perl 6 parser defines an C<< infix:<=~> >> macro which always fails at
compile time with a message directing the user either to use C<~~> or C<~=> instead,
or to put a space between if they really wanted to assign a stringified value.)

=item * "Unary" C<.> calls its single argument (which must a postfix operator)
on C<$_>.  (It's not really a unary operator, so we put it in quotes.)

=item * The C<..> range operator has variants with C<^> on either
end to indicate exclusion of that endpoint from the range.  It always
produces a Range object.  Range objects are lazy iterators, and can
be interrogated for their current C<.min> and C<.max> values (which
change as they are iterated).  Ranges are not autoreversing: C<2..1>
is always a null range, as is C<1^..^2>.  To reverse a range use:

    2..1:by(-1)
    reverse 1..2

(The C<reverse> is preferred because it works for alphabetic ranges
as well.)

Because C<Range> objects are lazy, they do not automatically generate
a list.  So smart matching against a C<Range> object smartmatches the
endpoints in the domain of the object being matched, so fractional
numbers are C<not> truncated before comparison to integer ranges:

    1.5 ~~ 1^..^2  # true, equivalent to 1 < 1.5 < 2
    2.1 ~~ 1..2    # false, equivalent to 1 <= 2.1 <= 2

If a C<*> (see the "Whatever" type in S02) occurs on
the right side of a range, it is taken to mean "positive infinity"
in whatever space the range is operating.  A C<*> on the left means
"negative infinity" for types that support negative values.  If the
C<*> occurs on one side but not the other, the type is inferred from
the other argument.  A star on both sides will match any value that
supports the C<Ordered> role.

    0..*	# 0 .. +Inf
    'a'..*	# 'a' .. 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
    *..0	# -Inf .. 0
    *..*	# "-Inf .. +Inf", really Ordered
    1.2.3..*	# Any version higher than 1.2.3.

Note: infinite lists are constructed lazily.  And even though C<*..*>
can't be constructed at all, it's still useful as a selector object.

=item * The unary C<^> operator generates a range from C<0> up to
one less than its argument.  So C<^4> is short for C<0..^4> or C<0..3>.

    for ^4 { say $_ } # 0, 1, 2, 3

If applied to a list, it generates a multidimensional set of subscripts.

    for ^(3,3) { ... } # (0,0)(0,1)(0,2)(1,0)(1,1)(1,2)(2,0)(2,1)(2,2)

If applied to a type name, it indicates the metaclass instance instead,
so C<^Moose> is short for C<Moose.meta>.  It still kinda means "what
is this thing's domain" in an abstract sort of way.

=item * The C<...> prefix operator is the
"yada, yada, yada" operator, which is used as the body in function
prototypes.  It complains bitterly (by calling C<fail>) if it is
ever executed.  Variant C<???> calls C<warn>, and C<!!!> calls C<die>.
The argument is optional, but if provided, is passed onto the C<warn>,
C<fail>, or C<die>.  Otherwise the system will make up a message for
you based on the context.  We can't be responsible for what it might
say.

=item * In addition to the ordinary C<.> method invocation, there are
variants C<.*>, C<.?>, and C<.+> to control how multiple related methods
of the same name are handled.  The C<.=> operator does inplace modification
of the object on the left.  The C<.^> operator calls a class metamethod;
C<foo.^bar> is short for C<foo.meta.bar>.

=item * Unary C<=> reads lines from a filehandle or filename, or
iterates an iterator, or in general causes a scalar to explode its guts
when it would otherwise not.  How it does that is context senstive.
For instance, C<=$iterator> is scalar/list sensitive and will
produce one value in scalar context but many values in list context.
(Use C<@$iterator> to force a fetch of all the values even in scalar
context, and C<$$iterator> to force a fetch of a single value even
in list context.)  On the other hand, C<=$capture> interpolates all
parts of the capture that makes sense in the current list context,
depending on what controls that list context.

=back

=head1 Hyper operators

The Unicode characters C<»> (C<\x[BB]>) and C<«> (C<\x[AB]>) and
their ASCII digraphs C<<< >> >>> and C<<< << >>> are used to denote
"list operations", which operate on each element of two lists (or
arrays) and return a list (or array) of the results.  Spaces are not
allowed on the "pointy" end of each "hyper", but are allowed on the
blunt end (except for postfix operators, which must still follow postfix
spacing rules, but do allow for an additional dot before the "hyper").

For example:

     (1,1,2,3,5) »+« (1,2,3,5,8);  # (2,3,5,8,13)

If either argument is insufficiently dimensioned, Perl "upgrades" it:

     (3,8,2,9,3,8) >>-<< 1;          # (2,7,1,8,2,7)

In fact, this is the I<only> form that will work for an unordered type
such as a Bag:

     Bag(3,8,2,9,3,8) >>-<< 1;       # Bag(2,7,1,8,2,7) ~~ Bag(1,2,2,7,7,8)

When using a unary operator, only put the "hyper" on the side of the
single operand:

     @negatives = -« @positives;

     @positions»++;            # Increment all positions

     @positions.»++;           # Same thing, dot form
     @positions».++;           # Same thing, dot form
     @positions.».++;          # Same thing, dot form
     @positions\  .»\  .++;    # Same thing, long dot form

     @objects.».run();
     ("f","oo","bar").>>.chars;   # (1,2,3)

Note that method calls are really postfix operators, not infix, so you
shouldn't put a C<«> after the dot.

Hyper operators are defined recursively on arrays, so:

    -« [[1, 2], 3]               #    [-«[1, 2], -«3]
                                 # == [[-1, -2], -3]
    [[1, 2], 3] »+« [4, [5, 6]]  #    [[1,2] »+« 4, 3 »+« [5, 6]]
                                 # == [[5, 6], [8, 9]]

More generally, hyper operators work recursively for any object
matching the C<Each> role even if the object itself doesn't support
the operator in question:

    Bag(3,8,[2,Seq(9,3)],8) >>-<< 1;         # Bag(2,7,[1,Seq(8,2)],7)
    Seq(3,8,[2,Seq(9,3)],8) >>-<< (1,1,2,1); # Seq(2,7,[0,Seq(7,1)],7)

In particular, tree node types with C<Each> semantics enable visitation:

    $tree.».foo;	# short for $tree.foo, $tree.each: { .».foo }

If not all nodes support the operation, you need a form of it that
specifies the call is optional:

    $tree.».?foo;	# short for $tree.?foo, $tree.each: { .».?foo }
    $tree.».*foo;	# short for $tree.*foo, $tree.each: { .».*foo }

You are not allowed to define your own hyper operators, because they
are supposed to have consistent semantics derivable entirely from
the modified scalar operator.  If you're looking for a mathematical
vector product, this isn't where you'll find it.  A hyperoperator
is one of the ways that you can promise to the optimizer that your
code is parallelizable.  (The tree visitation above is allowed to
have side effects, but it is erroneous for the meaning of those side
effects to depend on the order of visitation.  [Conjecture: we could
allow dependencies that assume top-down visitation and only leaves
sibling calls unordered.])

=head1 Reduction operators

The other metaoperator in Perl 6 is the reduction operator.  Any
infix operator (except for non-associating operators and assignment
operators) can be surrounded by square brackets in term position to
create a list operator that reduces using that operation:

    [+] 1, 2, 3;      # 1 + 2 + 3 = 6
    my @a = (5,6);
    [*] @a;           # 5 * 6 = 30

As with the all metaoperators, space is not allowed inside.  The whole
thing parses as a single token.

A reduction operator really is a list operator, and is invoked as one.
Hence, you can implement a reduction operator in one of two ways.  Either
you can write an explicit list operator:

    proto prefix:<[+]> (*@args) {
        my $accum = 0;
        while (@args) {
            $accum += @args.shift();
        }
        return $accum;
    }

or you can let the system autogenerate one for you based on the
corresponding infix operator, probably by currying:

    # (examples, actual system may define prefix:[**] instead)
    &prefix:<[*]> ::= &reduce.assuming(&infix:<*>, 1);
    &prefix:<[**]> ::= &reducerev.assuming(&infix:<**>);

As a special form of name, the non-prefix notation, as in

    proto [foo] (*@args) {
        ...
    }

or

    &[foo] ::= ...

defines both the C<[foo]> reduce operator and the C<foo> infix operator.
Where appropriate, use of the infix form may be optimized like this:

    # Original          # Optimized
    $a foo $b           # [foo] $a, $b
    $a foo $b foo $c    # [foo] $a, $b, $c

If the reduction operator is defined separately from the infix operator,
it must associate the same way as the operator used:

    [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
    [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144

For list-associating operators (like C<< < >>), all arguments are taken
together, just as if you had written it out explicitly:

    [<] 1, 3, 5;      # 1 < 3 < 5

If fewer than two arguments are given, a dispatch is still attempted
with whatever arguments are given, and it is up to the receiver of that
dispatch to deal with fewer than two arguments.  Note that the proto
list operator definition is the most general, so you are allowed to define
different ways to handle the one argument case depending on type:

    multi prefix:<[foo]> (Int $x) { 42 }
    multi prefix:<[foo]> (Str $x) { fail "Can't foo a single Str" }

However, the zero argument case must of necessity be handled by the
proto version, since there is no type information to dispatch on.
Operators that wish to specify an identity value should do so by
specifying the proto listop.  Among the builtin operators, C<[+]()>
returns 0 and C<[*]()> returns 1, for instance.

By default, if there is one argument, the built-in reduce operators
return that one argument.  However, this default doesn't make sense
for operators like C<< < >> that don't return the same type as they
take, so these kinds of operators overload the single-argument case
to return something more meaningful.  All the comparison operators
return a boolean for either 1 or 0 arguments.  Negated operators
return C<Bool::False>, and all the rest return C<Bool::True>.

You can also make a reduce operator of the comma operator.  This has
the effect of dereferencing its arguments into another argument list
as if they'd been placed there directly.

    @args = \@foo,1,2,3;
    push [,] @args;	# same as push @foo,1,2,3

See S06 for more.

You may also reduce using the semicolon second-dimension separator:

    [[;] 1,2,3]   # equivalent to [1;2;3]

Builtin reduce operators return the following identity operations:

    [**]()      # 1     (arguably nonsensical)
    [*]()       # 1
    [/]()       # fail  (reduce is nonsensical)
    [%]()       # fail  (reduce is nonsensical)
    [x]()       # fail  (reduce is nonsensical)
    [xx]()      # fail  (reduce is nonsensical)
    [+&]()      # +^0   (-1 on 2's complement machine)
    [+<]()      # fail  (reduce is nonsensical)
    [+>]()      # fail  (reduce is nonsensical)
    [~&]()      # fail  (sensical but 1's length indeterminate)
    [~<]()      # fail  (reduce is nonsensical)
    [~>]()      # fail  (reduce is nonsensical)
    [+]()       # 0
    [-]()       # 0
    [~]()       # ''
    [+|]()      # 0
    [+^]()      # 0
    [~|]()      # ''    (length indeterminate but 0's default)
    [~^]()      # ''    (length indeterminate but 0's default)
    [&]()       # all()
    [|]()       # any()
    [^]()       # one()
    [!=]()      # Bool::False   (also for 1 arg)
    [==]()      # Bool::True    (also for 1 arg)
    [<]()       # Bool::True    (also for 1 arg)
    [<=]()      # Bool::True    (also for 1 arg)
    [>]()       # Bool::True    (also for 1 arg)
    [>=]()      # Bool::True    (also for 1 arg)
    [~~]()      # Bool::True    (also for 1 arg)
    [!~]()      # Bool::False   (also for 1 arg)
    [eq]()      # Bool::True    (also for 1 arg)
    [ne]()      # Bool::False   (also for 1 arg)
    [lt]()      # Bool::True    (also for 1 arg)
    [le]()      # Bool::True    (also for 1 arg)
    [gt]()      # Bool::True    (also for 1 arg)
    [ge]()      # Bool::True    (also for 1 arg)
    [=:=]()     # Bool::True    (also for 1 arg)
    [===]()     # Bool::True    (also for 1 arg)
    [&&]()      # Bool::True
    [||]()      # Bool::False
    [^^]()      # Bool::False
    [//]()      # undef
    [=]()       # undef    (same for all assignment operators)
    [,]()       # ()
    [¥]()       # []

User-defined operators may define their own identity values, but
there is no explicit identity property.  The value is implicit in the
behavior of the 0-arg reduce, so mathematical code wishing to find
the identity value for an operation can call C<prefix:{"[$opname]"}()>
to discover it.

To call some other non-infix function as a reduce operator, you may
define an alias in infix form.  The infix form will parse the right
argument as a scalar even if the aliased function would have parsed it
as a list:

    &infix:<dehash> ::= postcircumfix:<{ }>;
    $x = [dehash] $a,'foo','bar';  # $a<foo><bar>, not $a<foo bar>

Alternately, just define your own C<< prefix:<[dehash]> >> routine.

Note that, because a reduce is a list operator, the argument list is
evaluated in list context.  Therefore the following would be incorrect:

    $x = [dehash] %a,'foo','bar';

You'd instead have to say one of:

    $x = [dehash] \%a,'foo','bar';
    $x = [dehash] %a<foo>,'bar';

On the plus side, this works without a star:

    @args = (\%a,'foo','bar');
    $x = [dehash] @args;

A reduce operator returns only a scalar result regardless of context.
(Even C<[,]> returns a single Capture object which is then spliced
into the outer argument list.)  To return all intermediate results,
backslash the operator:

    say [\+] 1..*  #  (1, 3, 6, 10, 15, ...)

The visual picture of a triangle is not accidental.  To produce a triangular
list of lists, you can use a "triangular comma":

    [\,] 1..5
    [1],
    [1,2],
    [1,2,3],
    [1,2,3,4],
    [1,2,3,4,5]

If there is ambiguity between a triangular reduce and an infix operator
beginning with backslash, the infix operator is chosen, and an extra backslash
indicates the corresponding triangular reduce.  As a consequence, defining an
infix operator beginning with backslash, C<< infix:<\x> >> say, will make it
impossible to write certain triangular reduction operators, since C<[\x]> would
mean the normal reduction of C<< infix:<\x> >> operator, not the triangular
reduction of C<< infix:<x> >>.  This is deemed to be an insignificant problem.

=head1 Junctive operators

C<|>, C<&>, and C<^> are no longer bitwise operators (see L</Operator
Renaming>) but now serve a much higher cause: they are now the
junction constructors.

A junction is a single value that is equivalent to multiple values. They
thread through operations, returning another junction representing the
result:

     (1|2|3) + 4;                            # 5|6|7
     (1|2) + (3&4);                          # (4|5) & (5|6)

Note how when two junctions are applied through an operator, the result
is a junction representing the operator applied to each combination of
values.

Junctions come with the functional variants C<any>, C<all>, C<one>, and C<none>.

This opens doors for constructions like:

     unless $roll == any(1..6) { print "Invalid roll" }

     if $roll == 1|2|3 { print "Low roll" }

Junctions work through subscripting:

    print if @foo[any(1,2,3)]

Junctions are specifically unordered.  So if you say

    for all(@foo) {...}

it indicates to the compiler that there is no coupling between loop
iterations and they can be run in any order or even in parallel.

=head1 Chained comparisons

Perl 6 supports the natural extension to the comparison operators,
allowing multiple operands.

    if 1 < $a < 100 { say "Good, you picked a number *between* 1 and 100." }

    if 3 < $roll <= 6              { print "High roll" }

    if 1 <= $roll1 == $roll2 <= 6  { print "Doubles!" }

Note: any operator beginning with C<< < >> must have whitespace
in front of it, or it will be interpreted as a hash subscript instead.

=head1 Binding

A new form of assignment is present in Perl 6, called "binding," used in
place of typeglob assignment.  It is performed with the C<:=> operator.
Instead of replacing the value in a container like normal assignment, it
replaces the container itself.  For instance:

    my $x = 'Just Another';
    my $y := $x;
    $y = 'Perl Hacker';

After this, both C<$x> and C<$y> contain the string "Perl Hacker," since
they are really just two different names for the same variable.

There is another variant, spelled C<::=>, that does the same thing at
compile time.

There is also an identity test, C<=:=>, which tests whether two names
are bound to the same underlying variable.  C<$x =:= $y> would return
true in the above example.

The binding fails if the type of the variable being bound is sufficiently
inconsistent with the type of the current declaration.

=head1 Declarators

The list of variable declarators has expanded from C<my> and C<our>
to include:

    my $foo		# ordinary lexically scoped variable
    our $foo		# lexically scoped alias to package variable
    has $foo		# object attribute
    env $foo		# environmental lexical
    state $foo		# persistent lexical (cloned with closures)
    constant $foo	# lexically scoped compile-time constant

Variable declarators such as C<my> now take a C<Signature> as their
argument.  The parentheses around the signature may be omitted for a
simple declaration that declares a single variable, along with its
associated type and traits.  Parentheses must always be used when
declaring multiple parameters:

    my $a;		# okay
    my ($b, $c);	# okay
    my $b, $c;		# wrong: "Use of undeclared variable: $c"

The syntax for a C<Signature> when one isn't expected is:

    :(Dog $a, *@c)

The colon (and sometimes the parens) may be omitted within declarators
where a signature is expected, for instance in the formal list of a loop
block:

    for @dogpound -> Dog $fido { ... }

If a C<Signature> is assigned to (whether declared or colon form), the
signature is converted to a list of lvalue variables and the ordinary
rules of assignment apply, except that the evaluation of the right
side and the assignment happens at time determined by the declarator.
(With C<my> this is always when an ordinary assignment would happen.)
If the signature is too complicated to convert to an assignment,
a compile-time error occurs.  Assignment to a signature makes the
same scalar/list distinction as ordinary assignment, so

    my $a = foo();	# foo in scalar context
    my ($a) = foo();	# foo in list context

If a C<Signature> is bound to an argument list, then the binding of the
arguments proceeds as if the C<Signature> were the formal parameters for
a function, except that, unlike in a function call, the parameters
are bound C<rw> by default rather than C<readonly>.  See Binding below.

Note that C<temp> and C<let> are I<not> variable declarators, because
their effects only take place at runtime.  Therefore, they take an ordinary
lvalue object as their argument.  See S04 for more details.

There are a number of other declarators that are not variable
declarators.  These include both type declarators:

    package Foo
    module Foo
    class Foo
    role Foo
    subset Foo

and code declarators:

    sub foo
    method foo
    submethod foo
    multi foo
    proto foo
    regex foo
    rule foo
    token foo

These all have their uses and are explained in subsequent Synopses.

=head1 Argument List Interpolating

Perl 5 forced interpolation of a functions argument list by use of
the C<&> prefix.  That option is no longer available in Perl 6, so
instead the C<[,]> reduction operator serves as an
interpolator, by casting its operands to C<Capture> objects
and inserting them into the current argument list.

It can be used to interpolate an C<Array> or C<Hash> into the current
call, as positional and named arguments respectively.

Note that those arguments still must comply with the subroutine's
signature, but the presence of C<[,]> defers that test until run time for
that argument (and for any subsequent arguments):

    my @args = (scalar @foo, @bar);
    push [,] @args;

is equivalent to:

    push @foo, @bar;

as is this:

    my $args = \(@foo, @bar);    # construct a Capture object
    push [,] @$args;

In list context, a Scalar holding an Array object does not flatten.  Hence

    $bar = @bar;
    push @foo, $bar;

merely pushes a single C<Array> object onto C<@foo>.  You can
explicitly flatten it in either of these ways:

    push @foo, @$bar;
    push @foo, $bar[];

Those two forms work because the slurpy array in C<push>'s signature
flattens the C<Array> object into a list argument.

Note that those two forms also allow you to specify list context on
assignment:

    @$bar = (1,2,3);
    $bar[] = (1,2,3);

The last is particularly useful at the end of a long name naming an
array attribute:

    $foo.bar.baz.bletch.whatever.attr[] = 1,2,3;

The empty C<[]> and C<.[]> postfix operators are interpreted as
zero-dimensional slices returning the entire array, not null slices
returning no elements.  Likewise for C<{}> and C<.{}> on hashes,
not to mention the C<< <> >>, C<< .<> >>, C<«»>, and C<.«»>
constant and interpolating slice subscripting forms.

The C<[,]> operator interpolates lazily for C<Array> and C<Range> objects.
To get an immediate interpolation like Perl 5 does, add the C<eager> list
operator:

    func([,] 1..Inf);         # works fine
    func([,] eager 1..Inf);   # never terminates

To interpolate a function's return value, you must say:

    push [,] func()

Within the argument list of a C<[,]>, function return values are
automatically exploded into their various parts, as if you'd said:

    \$capture := func();
    push [,] $$capture: @$capture, %$capture;

or some such.  The C<[,]> then handles the various zones appropriately
depending on the context.  An invocant only makes sense as the first
argument to the outer function call.  An invocant inserted anywhere
else just becomes a positional argument at the front of its list,
as if its colon changed back to a comma.

If you already have a capture variable, you can interpolated all of its
bits at once using the C<< prefix:<=> >> operator.  The above is equivalent to

    \$capture := func();
    push [,] =$capture;

=head1 Piping operators

The new operators C<< ==> >> and C<< <== >> are akin to UNIX pipes, but
work with functions that accept and return lists.  For example,

     @result = map { floor($^x / 2) },
                 grep { /^ \d+ $/ },
                   @data;

Can also now be written:

     @data ==> grep { /^ \d+ $/ }
           ==> map { floor($^x / 2) }
           ==> @result;

or:

     @result <== map { floor($^x / 2) }
             <== grep { /^ \d+ $/ }
             <== @data;

Either form more clearly indicates the flow of data.  See S06 for 
more of the (less-than-obvious) details on these two operators.

=head1 Invocant marker

An appended C<:> marks the invocant when using the indirect-object
syntax for Perl 6 method calls.  The following two statements are
equivalent:

    $hacker.feed('Pizza and cola');
    feed $hacker: 'Pizza and cola';

A colon may also be used on an ordinary method call to indicate that
it should be parsed as a list operator:

    $hacker.feed: 'Pizza and cola';

This colon is a separate token.  A colon prefixing an adverb is not
a separate token.  Therefore, under the longest-token rule,

    $hacker.feed:xxx('Pizza and cola');

is tokenized as an adverb applying to the method:

    $hacker.feed :xxx('Pizza and cola');

not as an xxx sub in the argument list of .feed:

    $hacker.feed: xxx('Pizza and cola');  # wrong

If you want both meanings of colon, you have to put it twice:

    $hacker.feed: :xxx('Pizza and cola'), 1,2,3;

(For similar reasons it's best to put whitespace after the colon of a label.)

=head1 C<zip>

In order to support parallel iteration over multiple arrays, Perl 6 has
a C<zip> function that builds C<Seq> objects from the elements of two or more
arrays.

    for zip(@names; @codes) -> [$name, $zip] {
        print "Name: $name;   Zip code: $zip\n";
    }

C<zip> has an infix synonym, the Unicode operator C<¥>, and its the ASCII
equivalent C<Y>.

To read arrays in parallel like C<zip> but just sequence the values
rather than generating tuples, use C<each> instead of C<zip>.

    for each(@names; @codes) -> $name, $zip {
        print "Name: $name;   Zip code: $zip\n";
    }

The C<each> function reads to the end of the longest list, not counting
lists that are known to be infinite such as C<0..Inf>.  Missing values
are replaced with C<undef>.  In contrast, use C<roundrobin> if you just
wish to skip missing entries:

    for roundrobin(@queue1; @queue2; @queue3) -> $next {
        ...
    }

To read arrays serially rather than in parallel, use C<cat(@x;@y)>.

=head1 Minimal whitespace DWIMmery

Whitespace is no longer allowed before the opening bracket of an array
or hash accessor.  That is:

    %monsters{'cookie'} = Monster.new;  # Valid Perl 6
    %people  {'john'}   = Person.new;   # Not valid Perl 6

One of the several useful side-effects of this restriction is that
parentheses are no longer required around the condition of control
constructs:

    if $value eq $target {
        print "Bullseye!";
    }
    while 0 < $i { $i++ }

It is, however, still possible to align accessors by explicitly using the
I<long dot> syntax:

     %monsters.{'cookie'} = Monster.new;
     %people\ .{'john'}   = Person.new;
     %cats\   .{'fluffy'} = Cat.new;

=head1 Precedence

Perl 6 has 22 precedence levels (which is fewer than Perl 5):

    terms               42 "eek" $x /abc/ (1+2) a(1) :by(2) .meth listop
    method postfix      . .+ .? .* .() .[] .{} .<> .«» .:: .=
    autoincrement       ++ --
    exponentiation      **
    symbolic unary      ! + - ~ ? $ @ % & +^ ~^ ?^ \ ^ =
    multiplicative      * / % x xx +& +< +> ~& ~< ~>
    additive            + - ~ +| +^ ~| ~^
    junctive and (all)  &
    junctive or (any)   | ^
    named unary         rand sleep abs etc. -e -r -w -x etc.
    nonchaining binary  but does cmp <=> .. ^.. ..^ ^..^ ff ^ff ff^ ^ff^ fff ^fff etc.
    chaining binary     != == < <= > >= ~~ !~ eq ne lt le gt ge =:= ===
    tight and           &&
    tight or            || ^^ //
    ternary             ?? !!
    assignment          = := ::= += -= **= xx= .= etc. (and also =>)
    loose unary         true not
    list ops            , print push any all etc. and ()= rightward
    list infix          ¥ <== ==>
    loose and           and
    loose or            or xor err
    expr terminator     ; {} as control block, statement modifiers

Comma is the only listop that is allowed to occur where an operator is
expected.  All other listops function as a term within the list to the left.
