package Perl6in5::Grammar::tester;

use warnings;
use strict;

use base 'Exporter';
our @EXPORT = qw ( make_parser );

#use Perl6in5::Compiler::Trace; # set env var TRACE for trace output

# isa Perl6in5::Grammar someday (to inherit some of the common features below)

use Perl6in5::Grammar;
use Perl6in5::Compiler::Parser ':all';

use Data::Dumper;
$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Quotekeys = 0;
#$Data::Dumper::Deparse = 1;

no warnings qw{ reserved closure recursion };

sub make_parser {
    
    my $input = shift;

    # <sigh> these "predeclaration" need to be autogenerated someday, somehow
    my ($base, $factor, $program, $term, $expr,
        $identifier, $bareInt, $stmt, 
    );

    my $Stmt         = parser { $stmt      ->(@_) };
    sub stmt () { $Stmt };
    my $Expr         = parser { $expr      ->(@_) };
    sub expr () { $Expr };
    my $Base               = parser { $base            ->(@_) };
    sub base () { $Base };
    my $Factor             = parser { $factor          ->(@_) };
    sub factor () { $Factor };
    my $Program            = parser { $program         ->(@_) };
    sub program () { $Program };
    my $Term               = parser { $term            ->(@_) };
    sub term () { $Term };
    my $BareInt               = parser { $bareInt            ->(@_) };
    sub bareInt () { $BareInt };
    my $Identifier               = parser { $identifier            ->(@_) };
    sub identifier () { $Identifier };

    # these hash keys are coderef (addresses)
    %N = (
        $Term             => 'Term',
        $Factor           => 'Factor',
        $Base             => 'Base',
        $Expr             => 'Expr',
        $Program          => 'Program',
        $Stmt       => 'Stmt',
        $BareInt          => 'BareInt',
        $Identifier => 'Identifier'
    );
    
    # right recursion
    rule program {
            star( -( stmt ) )
    };
    
    # terminal
    rule bareInt {
            match( qr|^(\d+)| )
    };
    
    # terminal
    rule identifier {
            '$' . match( qr|^([A-Za-z_]\w*)| )
    };
    
    # leading terminals then expression.
    rule stmt {
            ( hit( "say" )++ | identifier - '=' ) - expr - ';'
    };
    
    # all exprs are terms. ow() is "optional wrap"
    # row() is "nested optional wrap"
    rule expr {
            term - star( ( '+' | '-' ) - term )
    };
    
    # all terms are factors
    rule term {
            factor - star( ( '*' | '/' ) - factor )
    };
    
    # all factors are bases
    rule factor {
            base - opt( hit( '**' ) - factor )
    };
    
    # all bases are either bareInts or identifiers or wrapped expr.
    # This rule could have been called "BareTerminal"
    rule base {
            bareInt | identifier | w( '()', expr )
    };
    
    sub {
        my $r = (program->($input,eoi));
        unless ($r->{success}) {
            my $msg;
            if (ceoi($r)) {
                $msg = "incomplete statement near the end of input";
            } else {
                $msg = "syntax error (or degenerate/incomplete grammar) at line ".($r->{line}+1)." col ".$r->{col}." near ".(sprintf '%.50s', Dumper(left($r))).($r->{expected}?"\nExpected: ".Dumper($r->{expected}).".":'');
            }
            print STDERR $msg."\n".Dumper($r);
            return 255;
        } else {
            print "parse successful in $stat{rulecalls} rule executions.\n:".Dumper($r)."\n";
            return 0;
        }
    }
}

1;