This is intended to be a table that can be a guidance on what to work
on. Basically, in YAP6, we have types that must implement a standard
API. Here follows the list of types versus the methods.


Type / Method  Anything?   NEW   DESTR   STRNG   NUMBR  BOOLN  SCALAR  LIST  HASH  WHICH  CUSTOM
false          0           0     0       0       0      0      0       0     0     0      N/A
undef          0           0     0       0       0      0      0       0     0     0      N/A
string         0           0     0       0       0      0      0       0     0     0      See below.
num            0           0     0       0       0      0      0       0     0     0      See below.
int            1           0     1       0       0      1      0       0     0     1      See below.
bytes          1           0     1       0       0      1      0       0     0     1      See below.
bool           1           0     0       0       0      0      0       0     0     1      N/A
Scalar         1           0     1       0       0      0      0       0     0     1      Ok.
List           1           0     1       0       0      0      0       0     0     1      Needs some changes.
Pair           1           0     1       0       0      0      0       0     0     1      Ok.
Hash           1           0     1       0       0      0      0       0     0     1      Incomplete.


If you want to help, just take a look at one of the 1 and look how to
implement it in some of the zeroes, always creating a test,
please. When you implement it, just mark it as 1 or if you're not
sure, just put a question mark and explain below.


----

Notes for each type

=========================================
undef
=========================================

Undef must implement the coercion for the other types so that the
array and hash auto-vivification may work.

=========================================
false
=========================================

This is a constant value. When in boolean context, this object means
false. Everything else means true. When implementing the BOOLN method,
the types simply have to return false or themselves.

=========================================
string
=========================================

== Should it be implemented as low-level?

COMPARE: Maybe we should have a compare method that receives another
string and returns -1, 0 or 1 depending on the result.

CONCAT: A method that would return a new string that would concatenate
the current string and one given as parameter.

SUBSTR: This method would return a sub string of this string.

=========================================
num
=========================================

Even if the specs tells about more native types than that, yap6 will
probably only have the "Num" type. This type is probably able to do
anything needed. Any optimization can get back to C level.

== Which other precision types should be implemented?

bit: is this really necessary? C doesn't have it.

uint: this probably makes sense.

complex: is this two doubles?

float: does it make sense to have float and double? 

buf: I'm not sure what this is. Does YAP6__CORE__bytes provide the
needed features?

== Should it be implemented as low-level?

INTEGER: return this number with int precision instead of the current
one.

DOUBLE: return this number with double precision instead of the
current one.

BIGNUM: return this number with bignum precision instead of the
current one.

COMPARE: Maybe we should have a compare method that receives another
string and returns -1, 0 or 1 depending on the result.

SUM: return the result of the sum of this number with the given number
adjusting precision accordingly?

MUL: return the result of the multiplication of this number wit the
given number adjusting precision accordingly.

SUB: return the result of the subtraction of this number and the given
number adjusting precision accordingly.

DIV: return the result of the division of this number and the given
number adjusting precision accordingly.

POW: return the result of this number in the power of the given number
adjusting precision accordingly.

=========================================
int
=========================================

Does it makes sense to have a int object type? The advantage is to
force the int precision in all operations, avoiding yet another method
call to have it in int precision. On the other hand, this can be just
a different dispatcher for the same data type.

=========================================
bytes
=========================================

Once this is the return type of WHICH, a COMPARE method seem very
appropriated.

=========================================
List
=========================================

the current implementation must be changed to make the proxying
recursive. This may be made simply by moving the code from the STORE
method in the proxy scalar to the list STORE.

=========================================
Pair
=========================================

This is a considerably simple type. Any comments?

=========================================
Hash
=========================================

This is for now absolutely incomplete. A hashtable library would be
very helpfull.
