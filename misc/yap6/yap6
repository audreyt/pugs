#!/usr/local/bin/perl

# yap6/yap6
# This is intended to be (eventually) a hand-coded replacement for
# STD.pm->cheat->gimme5->

use warnings;
use strict;
# Parser.pm overloads some Perl operators for grammar notation convenience
use Parser ':all';
use Lexer ':all';

my $handle_lex_whitespace = sub { "" };

# pipe your source code to this program; it will evaluate it.
my $input = allinput(\*STDIN);

# This generates a lexer.  It will eventually contain all the character
# categories in STD.pm, ie. it will produce a stream of tokens, one for
# each character, other than \w, which of course are lumped successively.
# Someday this file will be automatically generated from STD.pm, probably
# by some version of this program.
my $lexer = iterator_to_stream(make_lexer($input,

# These are the patterns to do the initial lexing.  Each's first item is
# a category used by the "l()" (lookfor) function, which is a technique of
# defining literals in the grammar rules.  These are the defaults from
# MJD's "Higher Order Perl", but they'll be modified greatly.

[ 'TERMINATOR'      ,qr/;\n*|\n+/         ,                            ],
[ 'INT'             ,qr/\d+/              ,                            ],
[ 'PRINT'           ,qr/\bprint\b/        ,                            ],
[ 'IDENTIFIER'      ,qr|[A-Za-z_]\w*|     ,                            ],
[ 'OP'              ,qr#\*\*|[-=+*/()]#   ,                            ],
[ 'WHITESPACE'      ,qr/\s+/              ,$handle_lex_whitespace      ],

)); 

# This is our current excuse for a symbol table for our (only) variable scope.
my %VAR;

# These are globally accessible "shortcuts" to the actual parser coderefs.
my ($base, $expression, $factor, $program, $statement, $term);
my ($Base, $Expression, $Factor, $Program, $Statement, $Term);

$Base               = parser { $base            ->(@_) };
$Expression         = parser { $expression      ->(@_) };
$Factor             = parser { $factor          ->(@_) };
$Program            = parser { $program         ->(@_) };
$Statement          = parser { $statement       ->(@_) };
$Term               = parser { $term            ->(@_) };

# Currently these handlers do a synchronous evaluation of
# simple variable assignment, variable printing, and
# Please Excuse My Dear Aunt Sally arithmetic.
# comprising a one-step interpreter. Soon, instead they
# will pass around and generate an enhanced AST.
# On an evaluation run of a given "visible-code instruction set",
# they can be defined to implement the runtime, given a decent
# object/metaobject model.  Of course, they may return coderefs
# to subroutines in other packages, or another coderef
# generator.

my $handle_infix_addition = sub { my $term = $_[1]; sub { $_[0] + $term } };
my $handle_print_statement = sub { say $_[1] };
my $handle_assignment_statement = sub { $VAR{$_[0]} = $_[2] };
my $handle_infix_subtraction = sub { my $term = $_[1]; sub { $_[0] - $term } }; 
my $handle_infix_multiplication = sub { my $factor = $_[1];
                                        sub {$_[0] * $factor}};
my $handle_infix_division = sub { my $factor = $_[1];
                                  warn "failed to divide by 0!" unless $factor;
                                  $factor ||= 1; #silly, I know; this is only a toy interpreter.
                                  sub {$_[0] / $factor}};
my $handle_infix_exponentiation_factor = sub { $_[1] };
my $handle_empty_nothing = sub { 1 };
my $handle_infix_exponentiation_operation = sub { $_[0] ** $_[1] };
my $handle_variable_lookup = sub { $VAR{$_[0]} };
my $handle_base_value = sub { $_[1] };
my $handle_cascade = sub { my ($first, $rest) = @_;
                             for my $f (@$rest) { 
                                  $first = $f->($first); 
                             } $first};


# commalist(p, sep) = p star(sep p) option(sep)
sub commalist {
  my ($p, $separator, $sepstr) = @_;

  if (defined $separator) {
    $sepstr ||= $N{$separator};
  } else {
    $separator ||= lookfor('COMMA');
    $sepstr ||= ", ";
  }

  my $parser = T(concatenate($p,
                             star(T(concatenate($separator, $p),
                                    sub { $_[1] }
                                   )),
                             option($separator)),
                 sub { [$_[0], @{$_[1]}] }
                );


  $N{$parser} = "$N{$p}$sepstr $N{$p}$sepstr ...";
  return $parser;
}

sub termilist {
  my ($pr) = shift;
  commalist($pr, lookfor('TERMINATOR'), "; ");
}

sub labeledblock {
  my ($label, $contents) = @_;
  my $t;
  my $p = concatenate(concatenate(concatenate($label, 
                                              lookfor('LBRACE'),
                                             ),
                                  $t = star($contents),
                                 ),
                      lookfor('RBRACE'),
                     );
  $N{$p} = "$N{$label} { $N{$t} }";
  T($p, sub { [$_[0], @{$_[2]}] });
}



# Each grammar rule defines the creation of a hierarchy of
# parser objects.  concatenate(), signified by infix "-",
# looks for successive match successes.  alternate(), signified
# by infix "|" ), finds the first successful match of
# the rest of the input.  Yes, it backtracks.
# Soon, alternate will find all the
# successful matches, and choose the one that eats the most
# characters, comprising a longest-token-matcher.  If >one
# parse-tree candidates eat the same size input, there is
# either (too much) ambiguity in the input, or a problem with
# the grammar (that it allows too much ambiguity).

$N{\&End_of_Input} = 'EOI';
$N{\&nothing} = '(nothing)';
$N{$Expression} = 'expression';
$N{$Term} = 'term';
$N{$Factor} = 'factor';
$N{$Statement} = 'statement';
$N{$Base} = 'base';

$program = star($Statement) - $End_of_Input;

$statement = l('PRINT') - $Expression - l('TERMINATOR')
             >> $handle_print_statement
           | l('IDENTIFIER') - l('OP', '=') - $Expression - l('TERMINATOR')
             >> $handle_assignment_statement;

$expression = $Term - star(l('OP', '+') - $Term >>  $handle_infix_addition
                         | l('OP', '-') - $Term >> $handle_infix_subtraction) 
              >> $handle_cascade;

$term = $Factor - star(l('OP', '*') - $Factor >> $handle_infix_multiplication
                     | l('OP', '/') - $Factor >> $handle_infix_division)
        >> $handle_cascade;
          
$factor = $Base - ( l('OP', '**') - $Factor >> $handle_infix_exponentiation_factor
                  | $nothing >> $handle_empty_nothing )
        >> $handle_infix_exponentiation_operation;

$base = l('INT')
      | (l('IDENTIFIER') > $handle_variable_lookup)
      | l('OP', '(') - $Expression - l('OP', ')')
      >> $handle_base_value;

$program->($lexer);


# COPYRIGHT NOTICE:
# The contents of this file are Copyright (c) 2008, Matthew Wilson
# and any other contributors whose commits are recorded by the
# "pugscode" subversion source control repository.  The contributors'
# names/handles of are listed in the "pugsroot/AUTHORS" file).
# See licenses/Artistic2.txt for the 'Artistic License 2.0',
# under which this code is distributed and which may be found
# at http://www.opensource.org/licenses/artistic-license-2.0.php
# or http://www.perlfoundation.org/artistic_license_2_0

# ORIGIN:
# The code in this file originates directly
#       from Higher-Order Perl by Mark Dominus,
#       published by Morgan Kaufmann Publishers,
#       Copyright 2005 by Elsevier Inc
# Because of the origin, this file is also subject to the license
# agreement at http://hop.perl.plover.com/LICENSE.txt