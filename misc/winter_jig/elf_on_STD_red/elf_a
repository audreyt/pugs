#!/usr/bin/perl
# This file was mechanically written.  Your changes to it will be overwritten.
#line 3 head.pl
use strict;
use warnings;
#line 2 Match.pm
# This code was originally taken from yet_another_regex_engine/Regexp_ModuleA.pm,
# r20138.
{ package Match;
  sub new {
    my($cls)=@_;
    my $h = {
      from    => undef,
      to      => undef,
      result  => undef,
      bool => 1,
      str  => "",
      array   => [],
      hash    => {},
      };
    my $o = \$h;
    bless $o,$cls;
  }
  sub from { shift->{from} }
  sub to { shift->{from} }

  sub match_string { shift->{str} }
  sub match_array { shift->{array}||[] }
  sub match_hash { shift->{hash} }
  sub match_boolean { shift->{bool} }
  sub match_value { undef }
  sub match_describe {
    my($o,$verbosity)=@_;
    $verbosity ||= 0;
    my $vp = $verbosity;
    my $os = $o->match_string;
    if($verbosity > 1) {
      $os = $o->match__indent_except_top($os) if $os =~ /\n/;
    } else {
      $os =~ s/\n/\\n/g;
      $os =~ s/\t/\\t/g;
      if(length($os) > 60) {
        $os = substr($os,0,30).' ... '.substr($os,-30);
      }
    }
    my $s = $o->match__describe_name_as($verbosity);
    $s .= "<".($o->match_boolean?"1":"0").",\"$os\",[";
    for my $v (@{$o->match_array}) {
      my $vs = "";
      if(ref($v) eq 'ARRAY') {
        $vs = "[\n".$o->match__indent(join(",\n",map{
          $_->match_describe($vp)
          }@$v))."\n]";
      } else {
        $vs = $v->match_describe($vp);
      }
      $s .= "\n".$o->match__indent($vs).",";
    }
    $s .= "\n " if @{$o->match_array};
    $s .= "],{";
    for my $k (keys(%{$o->match_hash})) {
      my $v = $o->match_hash->{$k};
      my $vs = "";
      if(ref($v) eq 'ARRAY') {
        $vs = "[\n".$o->match__indent(join(",\n",map{
          $_->match_describe($vp)
          }@$v))."\n]";
      } elsif(!ref($v)) {
        $vs = $v;
      } else {
        $vs = $v->match_describe($vp);
      }
      $s .= "\n  $k => " .$o->match__indent_except_top($vs).",";
    }
    $s .= "\n " if %{$o->match_hash};
    $s .= "},";
    my($from,$to)=($o->from,$o->to);
    $from = "" if !defined $from;
    $to   = "" if !defined $to;
    $s .= "$from,$to";
    my $val = $o->match_value;
    $s .= defined $val ? ",$val" : "";
    $s .= ">";
    return $s;
  }
  sub match__indent {my($o,$s)=@_; $s =~ s/^(?!\Z)/  /mg; $s}
  sub match__indent_except_top {my($o,$s)=@_; $s =~ s/^(?<!\A)(?!\Z)/  /mg; $s}
  sub match__describe_name_as {
    my($o,$verbosity)=@_;
    return "" if not $verbosity;
    my $s = "";
    $s .= $o->{rule} if defined $o->{rule};
    $s = overload::StrVal($o).'{'.$s.'}' if $verbosity > 1;
    $s;
  }
}
#line 2 ir_nodes.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IR::All;
  use Data::Dumper;
  sub describe_anything {
    my($this,$x)=@_;
    my $ref = ref($x);
    if($ref) {
      if(UNIVERSAL::can($x,'describe')) {
        $x->describe

      } elsif($ref eq 'ARRAY') {
        '['.join(",",map{$this->describe_anything($_)} @$x).']'
      } else {
        die "bug";
      }
    } else {
      local $Data::Dumper::Terse = 1;
      my $s = Dumper($x); $s =~ s/\n$//; $s;
    }
  }
}
{ package IR::CompUnit;
  @IR::CompUnit::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$statements)=@_;
    my %h;
    @h{'match','statements'}=($match,$statements);
    bless \%h,$cls;
  }
  sub node_name { 'CompUnit' }
  sub match { shift->{match} }
  sub field_names { qw{ statements } }
  sub field_values { my($self)=@_; @$self{'statements'} }
  sub describe {
    my($self)=@_;
    "CompUnit(".join(",",map{$self->describe_anything($_)}@$self{'statements'}).")"
  }
}
{ package IR::Val_Int;
  @IR::Val_Int::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$text)=@_;
    my %h;
    @h{'match','text'}=($match,$text);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Int' }
  sub match { shift->{match} }
  sub field_names { qw{ text } }
  sub field_values { my($self)=@_; @$self{'text'} }
  sub describe {
    my($self)=@_;
    "Val_Int(".join(",",map{$self->describe_anything($_)}@$self{'text'}).")"
  }
}
{ package IR::PackageDeclarator;
  @IR::PackageDeclarator::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$kind,$name,$block)=@_;
    my %h;
    @h{'match','kind','name','block'}=($match,$kind,$name,$block);
    bless \%h,$cls;
  }
  sub node_name { 'PackageDeclarator' }
  sub match { shift->{match} }
  sub field_names { qw{ kind name block } }
  sub field_values { my($self)=@_; @$self{'kind','name','block'} }
  sub describe {
    my($self)=@_;
    "PackageDeclarator(".join(",",map{$self->describe_anything($_)}@$self{'kind','name','block'}).")"
  }
}
{ package IR::Block;
  @IR::Block::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$statements)=@_;
    my %h;
    @h{'match','statements'}=($match,$statements);
    bless \%h,$cls;
  }
  sub node_name { 'Block' }
  sub match { shift->{match} }
  sub field_names { qw{ statements } }
  sub field_values { my($self)=@_; @$self{'statements'} }
  sub describe {
    my($self)=@_;
    "Block(".join(",",map{$self->describe_anything($_)}@$self{'statements'}).")"
  }
}
{ package IR::Quote;
  @IR::Quote::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$concat)=@_;
    my %h;
    @h{'match','concat'}=($match,$concat);
    bless \%h,$cls;
  }
  sub node_name { 'Quote' }
  sub match { shift->{match} }
  sub field_names { qw{ concat } }
  sub field_values { my($self)=@_; @$self{'concat'} }
  sub describe {
    my($self)=@_;
    "Quote(".join(",",map{$self->describe_anything($_)}@$self{'concat'}).")"
  }
}
{ package IR::Val_Bit;
  @IR::Val_Bit::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$bit)=@_;
    my %h;
    @h{'match','bit'}=($match,$bit);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Bit' }
  sub match { shift->{match} }
  sub field_names { qw{ bit } }
  sub field_values { my($self)=@_; @$self{'bit'} }
  sub describe {
    my($self)=@_;
    "Val_Bit(".join(",",map{$self->describe_anything($_)}@$self{'bit'}).")"
  }
}
{ package IR::Val_Num;
  @IR::Val_Num::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$num)=@_;
    my %h;
    @h{'match','num'}=($match,$num);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Num' }
  sub match { shift->{match} }
  sub field_names { qw{ num } }
  sub field_values { my($self)=@_; @$self{'num'} }
  sub describe {
    my($self)=@_;
    "Val_Num(".join(",",map{$self->describe_anything($_)}@$self{'num'}).")"
  }
}
{ package IR::Val_Buf;
  @IR::Val_Buf::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$buf)=@_;
    my %h;
    @h{'match','buf'}=($match,$buf);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Buf' }
  sub match { shift->{match} }
  sub field_names { qw{ buf } }
  sub field_values { my($self)=@_; @$self{'buf'} }
  sub describe {
    my($self)=@_;
    "Val_Buf(".join(",",map{$self->describe_anything($_)}@$self{'buf'}).")"
  }
}
{ package IR::Val_Char;
  @IR::Val_Char::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$char)=@_;
    my %h;
    @h{'match','char'}=($match,$char);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Char' }
  sub match { shift->{match} }
  sub field_names { qw{ char } }
  sub field_values { my($self)=@_; @$self{'char'} }
  sub describe {
    my($self)=@_;
    "Val_Char(".join(",",map{$self->describe_anything($_)}@$self{'char'}).")"
  }
}
{ package IR::Val_Undef;
  @IR::Val_Undef::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Undef' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Val_Undef()
  }
}
{ package IR::Val_Object;
  @IR::Val_Object::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$clazz,$fields)=@_;
    my %h;
    @h{'match','clazz','fields'}=($match,$clazz,$fields);
    bless \%h,$cls;
  }
  sub node_name { 'Val_Object' }
  sub match { shift->{match} }
  sub field_names { qw{ clazz fields } }
  sub field_values { my($self)=@_; @$self{'clazz','fields'} }
  sub describe {
    my($self)=@_;
    "Val_Object(".join(",",map{$self->describe_anything($_)}@$self{'clazz','fields'}).")"
  }
}
{ package IR::Lit_Seq;
  @IR::Lit_Seq::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$seq)=@_;
    my %h;
    @h{'match','seq'}=($match,$seq);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Seq' }
  sub match { shift->{match} }
  sub field_names { qw{ seq } }
  sub field_values { my($self)=@_; @$self{'seq'} }
  sub describe {
    my($self)=@_;
    "Lit_Seq(".join(",",map{$self->describe_anything($_)}@$self{'seq'}).")"
  }
}
{ package IR::Lit_Array;
  @IR::Lit_Array::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$array)=@_;
    my %h;
    @h{'match','array'}=($match,$array);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Array' }
  sub match { shift->{match} }
  sub field_names { qw{ array } }
  sub field_values { my($self)=@_; @$self{'array'} }
  sub describe {
    my($self)=@_;
    "Lit_Array(".join(",",map{$self->describe_anything($_)}@$self{'array'}).")"
  }
}
{ package IR::Lit_Hash;
  @IR::Lit_Hash::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$hash)=@_;
    my %h;
    @h{'match','hash'}=($match,$hash);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Hash' }
  sub match { shift->{match} }
  sub field_names { qw{ hash } }
  sub field_values { my($self)=@_; @$self{'hash'} }
  sub describe {
    my($self)=@_;
    "Lit_Hash(".join(",",map{$self->describe_anything($_)}@$self{'hash'}).")"
  }
}
{ package IR::Lit_Pair;
  @IR::Lit_Pair::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value)=@_;
    my %h;
    @h{'match','key','value'}=($match,$key,$value);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Pair' }
  sub match { shift->{match} }
  sub field_names { qw{ key value } }
  sub field_values { my($self)=@_; @$self{'key','value'} }
  sub describe {
    my($self)=@_;
    "Lit_Pair(".join(",",map{$self->describe_anything($_)}@$self{'key','value'}).")"
  }
}
{ package IR::Lit_SigArgument;
  @IR::Lit_SigArgument::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy)=@_;
    my %h;
    @h{'match','key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'}=($match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_SigArgument' }
  sub match { shift->{match} }
  sub field_names { qw{ key value type has_default is_named_only is_optional is_slurpy is_multidimensional is_rw is_copy } }
  sub field_values { my($self)=@_; @$self{'key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'} }
  sub describe {
    my($self)=@_;
    "Lit_SigArgument(".join(",",map{$self->describe_anything($_)}@$self{'key','value','type','has_default','is_named_only','is_optional','is_slurpy','is_multidimensional','is_rw','is_copy'}).")"
  }
}
{ package IR::Lit_NamedArgument;
  @IR::Lit_NamedArgument::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$key,$value)=@_;
    my %h;
    @h{'match','key','value'}=($match,$key,$value);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_NamedArgument' }
  sub match { shift->{match} }
  sub field_names { qw{ key value } }
  sub field_values { my($self)=@_; @$self{'key','value'} }
  sub describe {
    my($self)=@_;
    "Lit_NamedArgument(".join(",",map{$self->describe_anything($_)}@$self{'key','value'}).")"
  }
}
{ package IR::Lit_Code;
  @IR::Lit_Code::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$pad,$state,$sig,$body,$catch)=@_;
    my %h;
    @h{'match','pad','state','sig','body','catch'}=($match,$pad,$state,$sig,$body,$catch);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Code' }
  sub match { shift->{match} }
  sub field_names { qw{ pad state sig body catch } }
  sub field_values { my($self)=@_; @$self{'pad','state','sig','body','catch'} }
  sub describe {
    my($self)=@_;
    "Lit_Code(".join(",",map{$self->describe_anything($_)}@$self{'pad','state','sig','body','catch'}).")"
  }
}
{ package IR::Lit_Object;
  @IR::Lit_Object::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$clazz,$fields)=@_;
    my %h;
    @h{'match','clazz','fields'}=($match,$clazz,$fields);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Object' }
  sub match { shift->{match} }
  sub field_names { qw{ clazz fields } }
  sub field_values { my($self)=@_; @$self{'clazz','fields'} }
  sub describe {
    my($self)=@_;
    "Lit_Object(".join(",",map{$self->describe_anything($_)}@$self{'clazz','fields'}).")"
  }
}
{ package IR::Var;
  @IR::Var::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$sigil,$twigil,$name,$namespace)=@_;
    my %h;
    @h{'match','sigil','twigil','name','namespace'}=($match,$sigil,$twigil,$name,$namespace);
    bless \%h,$cls;
  }
  sub node_name { 'Var' }
  sub match { shift->{match} }
  sub field_names { qw{ sigil twigil name namespace } }
  sub field_values { my($self)=@_; @$self{'sigil','twigil','name','namespace'} }
  sub describe {
    my($self)=@_;
    "Var(".join(",",map{$self->describe_anything($_)}@$self{'sigil','twigil','name','namespace'}).")"
  }
}
{ package IR::Bind;
  @IR::Bind::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$parameters,$arguments)=@_;
    my %h;
    @h{'match','parameters','arguments'}=($match,$parameters,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Bind' }
  sub match { shift->{match} }
  sub field_names { qw{ parameters arguments } }
  sub field_values { my($self)=@_; @$self{'parameters','arguments'} }
  sub describe {
    my($self)=@_;
    "Bind(".join(",",map{$self->describe_anything($_)}@$self{'parameters','arguments'}).")"
  }
}
{ package IR::Assign;
  @IR::Assign::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$parameters,$arguments)=@_;
    my %h;
    @h{'match','parameters','arguments'}=($match,$parameters,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Assign' }
  sub match { shift->{match} }
  sub field_names { qw{ parameters arguments } }
  sub field_values { my($self)=@_; @$self{'parameters','arguments'} }
  sub describe {
    my($self)=@_;
    "Assign(".join(",",map{$self->describe_anything($_)}@$self{'parameters','arguments'}).")"
  }
}
{ package IR::Proto;
  @IR::Proto::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name)=@_;
    my %h;
    @h{'match','name'}=($match,$name);
    bless \%h,$cls;
  }
  sub node_name { 'Proto' }
  sub match { shift->{match} }
  sub field_names { qw{ name } }
  sub field_values { my($self)=@_; @$self{'name'} }
  sub describe {
    my($self)=@_;
    "Proto(".join(",",map{$self->describe_anything($_)}@$self{'name'}).")"
  }
}
{ package IR::Call;
  @IR::Call::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$hyper,$method,$arguments)=@_;
    my %h;
    @h{'match','invocant','hyper','method','arguments'}=($match,$invocant,$hyper,$method,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Call' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant hyper method arguments } }
  sub field_values { my($self)=@_; @$self{'invocant','hyper','method','arguments'} }
  sub describe {
    my($self)=@_;
    "Call(".join(",",map{$self->describe_anything($_)}@$self{'invocant','hyper','method','arguments'}).")"
  }
}
{ package IR::Apply;
  @IR::Apply::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$code,$arguments)=@_;
    my %h;
    @h{'match','code','arguments'}=($match,$code,$arguments);
    bless \%h,$cls;
  }
  sub node_name { 'Apply' }
  sub match { shift->{match} }
  sub field_names { qw{ code arguments } }
  sub field_values { my($self)=@_; @$self{'code','arguments'} }
  sub describe {
    my($self)=@_;
    "Apply(".join(",",map{$self->describe_anything($_)}@$self{'code','arguments'}).")"
  }
}
{ package IR::Return;
  @IR::Return::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$result)=@_;
    my %h;
    @h{'match','result'}=($match,$result);
    bless \%h,$cls;
  }
  sub node_name { 'Return' }
  sub match { shift->{match} }
  sub field_names { qw{ result } }
  sub field_values { my($self)=@_; @$self{'result'} }
  sub describe {
    my($self)=@_;
    "Return(".join(",",map{$self->describe_anything($_)}@$self{'result'}).")"
  }
}
{ package IR::If;
  @IR::If::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$cond,$body,$otherwise)=@_;
    my %h;
    @h{'match','cond','body','otherwise'}=($match,$cond,$body,$otherwise);
    bless \%h,$cls;
  }
  sub node_name { 'If' }
  sub match { shift->{match} }
  sub field_names { qw{ cond body otherwise } }
  sub field_values { my($self)=@_; @$self{'cond','body','otherwise'} }
  sub describe {
    my($self)=@_;
    "If(".join(",",map{$self->describe_anything($_)}@$self{'cond','body','otherwise'}).")"
  }
}
{ package IR::While;
  @IR::While::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$cond,$body)=@_;
    my %h;
    @h{'match','cond','body'}=($match,$cond,$body);
    bless \%h,$cls;
  }
  sub node_name { 'While' }
  sub match { shift->{match} }
  sub field_names { qw{ cond body } }
  sub field_values { my($self)=@_; @$self{'cond','body'} }
  sub describe {
    my($self)=@_;
    "While(".join(",",map{$self->describe_anything($_)}@$self{'cond','body'}).")"
  }
}
{ package IR::Decl;
  @IR::Decl::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$decl,$type,$var)=@_;
    my %h;
    @h{'match','decl','type','var'}=($match,$decl,$type,$var);
    bless \%h,$cls;
  }
  sub node_name { 'Decl' }
  sub match { shift->{match} }
  sub field_names { qw{ decl type var } }
  sub field_values { my($self)=@_; @$self{'decl','type','var'} }
  sub describe {
    my($self)=@_;
    "Decl(".join(",",map{$self->describe_anything($_)}@$self{'decl','type','var'}).")"
  }
}
{ package IR::Sig;
  @IR::Sig::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$positional)=@_;
    my %h;
    @h{'match','invocant','positional'}=($match,$invocant,$positional);
    bless \%h,$cls;
  }
  sub node_name { 'Sig' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant positional } }
  sub field_values { my($self)=@_; @$self{'invocant','positional'} }
  sub describe {
    my($self)=@_;
    "Sig(".join(",",map{$self->describe_anything($_)}@$self{'invocant','positional'}).")"
  }
}
{ package IR::Lit_Capture;
  @IR::Lit_Capture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$invocant,$array,$hash)=@_;
    my %h;
    @h{'match','invocant','array','hash'}=($match,$invocant,$array,$hash);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Capture' }
  sub match { shift->{match} }
  sub field_names { qw{ invocant array hash } }
  sub field_values { my($self)=@_; @$self{'invocant','array','hash'} }
  sub describe {
    my($self)=@_;
    "Lit_Capture(".join(",",map{$self->describe_anything($_)}@$self{'invocant','array','hash'}).")"
  }
}
{ package IR::Lit_Subset;
  @IR::Lit_Subset::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$base_class,$block)=@_;
    my %h;
    @h{'match','name','base_class','block'}=($match,$name,$base_class,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Lit_Subset' }
  sub match { shift->{match} }
  sub field_names { qw{ name base_class block } }
  sub field_values { my($self)=@_; @$self{'name','base_class','block'} }
  sub describe {
    my($self)=@_;
    "Lit_Subset(".join(",",map{$self->describe_anything($_)}@$self{'name','base_class','block'}).")"
  }
}
{ package IR::Method;
  @IR::Method::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Method' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Method(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Sub;
  @IR::Sub::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Sub' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Sub(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Macro;
  @IR::Macro::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Macro' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Macro(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::Coro;
  @IR::Coro::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$sig,$block)=@_;
    my %h;
    @h{'match','name','sig','block'}=($match,$name,$sig,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Coro' }
  sub match { shift->{match} }
  sub field_names { qw{ name sig block } }
  sub field_values { my($self)=@_; @$self{'name','sig','block'} }
  sub describe {
    my($self)=@_;
    "Coro(".join(",",map{$self->describe_anything($_)}@$self{'name','sig','block'}).")"
  }
}
{ package IR::P5Token;
  @IR::P5Token::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$regex)=@_;
    my %h;
    @h{'match','regex'}=($match,$regex);
    bless \%h,$cls;
  }
  sub node_name { 'P5Token' }
  sub match { shift->{match} }
  sub field_names { qw{ regex } }
  sub field_values { my($self)=@_; @$self{'regex'} }
  sub describe {
    my($self)=@_;
    "P5Token(".join(",",map{$self->describe_anything($_)}@$self{'regex'}).")"
  }
}
{ package IR::Token;
  @IR::Token::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$name,$regex,$sym)=@_;
    my %h;
    @h{'match','name','regex','sym'}=($match,$name,$regex,$sym);
    bless \%h,$cls;
  }
  sub node_name { 'Token' }
  sub match { shift->{match} }
  sub field_names { qw{ name regex sym } }
  sub field_values { my($self)=@_; @$self{'name','regex','sym'} }
  sub describe {
    my($self)=@_;
    "Token(".join(",",map{$self->describe_anything($_)}@$self{'name','regex','sym'}).")"
  }
}
{ package IR::Do;
  @IR::Do::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$block)=@_;
    my %h;
    @h{'match','block'}=($match,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Do' }
  sub match { shift->{match} }
  sub field_names { qw{ block } }
  sub field_values { my($self)=@_; @$self{'block'} }
  sub describe {
    my($self)=@_;
    "Do(".join(",",map{$self->describe_anything($_)}@$self{'block'}).")"
  }
}
{ package IR::Begin;
  @IR::Begin::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$block)=@_;
    my %h;
    @h{'match','block'}=($match,$block);
    bless \%h,$cls;
  }
  sub node_name { 'Begin' }
  sub match { shift->{match} }
  sub field_names { qw{ block } }
  sub field_values { my($self)=@_; @$self{'block'} }
  sub describe {
    my($self)=@_;
    "Begin(".join(",",map{$self->describe_anything($_)}@$self{'block'}).")"
  }
}
{ package IR::Use;
  @IR::Use::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$mod,$perl5)=@_;
    my %h;
    @h{'match','mod','perl5'}=($match,$mod,$perl5);
    bless \%h,$cls;
  }
  sub node_name { 'Use' }
  sub match { shift->{match} }
  sub field_names { qw{ mod perl5 } }
  sub field_values { my($self)=@_; @$self{'mod','perl5'} }
  sub describe {
    my($self)=@_;
    "Use(".join(",",map{$self->describe_anything($_)}@$self{'mod','perl5'}).")"
  }
}
{ package IR::Rule;
  @IR::Rule::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Rule' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Rule()
  }
}
{ package IR::Rule_Quantifier;
  @IR::Rule_Quantifier::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$term,$quant,$greedy,$ws1,$ws2,$ws3)=@_;
    my %h;
    @h{'match','term','quant','greedy','ws1','ws2','ws3'}=($match,$term,$quant,$greedy,$ws1,$ws2,$ws3);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Quantifier' }
  sub match { shift->{match} }
  sub field_names { qw{ term quant greedy ws1 ws2 ws3 } }
  sub field_values { my($self)=@_; @$self{'term','quant','greedy','ws1','ws2','ws3'} }
  sub describe {
    my($self)=@_;
    "Rule_Quantifier(".join(",",map{$self->describe_anything($_)}@$self{'term','quant','greedy','ws1','ws2','ws3'}).")"
  }
}
{ package IR::Rule_Or;
  @IR::Rule_Or::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$terms)=@_;
    my %h;
    @h{'match','terms'}=($match,$terms);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Or' }
  sub match { shift->{match} }
  sub field_names { qw{ terms } }
  sub field_values { my($self)=@_; @$self{'terms'} }
  sub describe {
    my($self)=@_;
    "Rule_Or(".join(",",map{$self->describe_anything($_)}@$self{'terms'}).")"
  }
}
{ package IR::Rule_Concat;
  @IR::Rule_Concat::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$concat)=@_;
    my %h;
    @h{'match','concat'}=($match,$concat);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Concat' }
  sub match { shift->{match} }
  sub field_names { qw{ concat } }
  sub field_values { my($self)=@_; @$self{'concat'} }
  sub describe {
    my($self)=@_;
    "Rule_Concat(".join(",",map{$self->describe_anything($_)}@$self{'concat'}).")"
  }
}
{ package IR::Rule_Subrule;
  @IR::Rule_Subrule::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$metasyntax,$ident,$capture_to_array)=@_;
    my %h;
    @h{'match','metasyntax','ident','capture_to_array'}=($match,$metasyntax,$ident,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Subrule' }
  sub match { shift->{match} }
  sub field_names { qw{ metasyntax ident capture_to_array } }
  sub field_values { my($self)=@_; @$self{'metasyntax','ident','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Subrule(".join(",",map{$self->describe_anything($_)}@$self{'metasyntax','ident','capture_to_array'}).")"
  }
}
{ package IR::Rule_SubruleNoCapture;
  @IR::Rule_SubruleNoCapture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$metasyntax)=@_;
    my %h;
    @h{'match','metasyntax'}=($match,$metasyntax);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_SubruleNoCapture' }
  sub match { shift->{match} }
  sub field_names { qw{ metasyntax } }
  sub field_values { my($self)=@_; @$self{'metasyntax'} }
  sub describe {
    my($self)=@_;
    "Rule_SubruleNoCapture(".join(",",map{$self->describe_anything($_)}@$self{'metasyntax'}).")"
  }
}
{ package IR::Rule_Var;
  @IR::Rule_Var::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$sigil,$twigil,$name)=@_;
    my %h;
    @h{'match','sigil','twigil','name'}=($match,$sigil,$twigil,$name);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Var' }
  sub match { shift->{match} }
  sub field_names { qw{ sigil twigil name } }
  sub field_values { my($self)=@_; @$self{'sigil','twigil','name'} }
  sub describe {
    my($self)=@_;
    "Rule_Var(".join(",",map{$self->describe_anything($_)}@$self{'sigil','twigil','name'}).")"
  }
}
{ package IR::Rule_Constant;
  @IR::Rule_Constant::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$constant)=@_;
    my %h;
    @h{'match','constant'}=($match,$constant);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Constant' }
  sub match { shift->{match} }
  sub field_names { qw{ constant } }
  sub field_values { my($self)=@_; @$self{'constant'} }
  sub describe {
    my($self)=@_;
    "Rule_Constant(".join(",",map{$self->describe_anything($_)}@$self{'constant'}).")"
  }
}
{ package IR::Rule_Dot;
  @IR::Rule_Dot::ISA = qw( IR::All );
  sub new {
    my($cls,$match)=@_;
    my %h;
    $h{'match'}=($match);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Dot' }
  sub match { shift->{match} }
  sub field_names { return () }
  sub field_values { my($self)=@_; return () }
  sub describe {
    my($self)=@_;
    Rule_Dot()
  }
}
{ package IR::Rule_SpecialChar;
  @IR::Rule_SpecialChar::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$char)=@_;
    my %h;
    @h{'match','char'}=($match,$char);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_SpecialChar' }
  sub match { shift->{match} }
  sub field_names { qw{ char } }
  sub field_values { my($self)=@_; @$self{'char'} }
  sub describe {
    my($self)=@_;
    "Rule_SpecialChar(".join(",",map{$self->describe_anything($_)}@$self{'char'}).")"
  }
}
{ package IR::Rule_Block;
  @IR::Rule_Block::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$closure)=@_;
    my %h;
    @h{'match','closure'}=($match,$closure);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Block' }
  sub match { shift->{match} }
  sub field_names { qw{ closure } }
  sub field_values { my($self)=@_; @$self{'closure'} }
  sub describe {
    my($self)=@_;
    "Rule_Block(".join(",",map{$self->describe_anything($_)}@$self{'closure'}).")"
  }
}
{ package IR::Rule_InterpolateVar;
  @IR::Rule_InterpolateVar::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$var)=@_;
    my %h;
    @h{'match','var'}=($match,$var);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_InterpolateVar' }
  sub match { shift->{match} }
  sub field_names { qw{ var } }
  sub field_values { my($self)=@_; @$self{'var'} }
  sub describe {
    my($self)=@_;
    "Rule_InterpolateVar(".join(",",map{$self->describe_anything($_)}@$self{'var'}).")"
  }
}
{ package IR::Rule_NamedCapture;
  @IR::Rule_NamedCapture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$ident,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','ident','capture_to_array'}=($match,$rule,$ident,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_NamedCapture' }
  sub match { shift->{match} }
  sub field_names { qw{ rule ident capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','ident','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_NamedCapture(".join(",",map{$self->describe_anything($_)}@$self{'rule','ident','capture_to_array'}).")"
  }
}
{ package IR::Rule_Before;
  @IR::Rule_Before::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$assertion_modifier,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','assertion_modifier','capture_to_array'}=($match,$rule,$assertion_modifier,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Before' }
  sub match { shift->{match} }
  sub field_names { qw{ rule assertion_modifier capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','assertion_modifier','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Before(".join(",",map{$self->describe_anything($_)}@$self{'rule','assertion_modifier','capture_to_array'}).")"
  }
}
{ package IR::Rule_After;
  @IR::Rule_After::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$assertion_modifier,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','assertion_modifier','capture_to_array'}=($match,$rule,$assertion_modifier,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_After' }
  sub match { shift->{match} }
  sub field_names { qw{ rule assertion_modifier capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','assertion_modifier','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_After(".join(",",map{$self->describe_anything($_)}@$self{'rule','assertion_modifier','capture_to_array'}).")"
  }
}
{ package IR::Rule_NegateCharClass;
  @IR::Rule_NegateCharClass::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$chars)=@_;
    my %h;
    @h{'match','chars'}=($match,$chars);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_NegateCharClass' }
  sub match { shift->{match} }
  sub field_names { qw{ chars } }
  sub field_values { my($self)=@_; @$self{'chars'} }
  sub describe {
    my($self)=@_;
    "Rule_NegateCharClass(".join(",",map{$self->describe_anything($_)}@$self{'chars'}).")"
  }
}
{ package IR::Rule_CharClass;
  @IR::Rule_CharClass::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$chars)=@_;
    my %h;
    @h{'match','chars'}=($match,$chars);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_CharClass' }
  sub match { shift->{match} }
  sub field_names { qw{ chars } }
  sub field_values { my($self)=@_; @$self{'chars'} }
  sub describe {
    my($self)=@_;
    "Rule_CharClass(".join(",",map{$self->describe_anything($_)}@$self{'chars'}).")"
  }
}
{ package IR::Rule_Capture;
  @IR::Rule_Capture::ISA = qw( IR::All );
  sub new {
    my($cls,$match,$rule,$position,$capture_to_array)=@_;
    my %h;
    @h{'match','rule','position','capture_to_array'}=($match,$rule,$position,$capture_to_array);
    bless \%h,$cls;
  }
  sub node_name { 'Rule_Capture' }
  sub match { shift->{match} }
  sub field_names { qw{ rule position capture_to_array } }
  sub field_values { my($self)=@_; @$self{'rule','position','capture_to_array'} }
  sub describe {
    my($self)=@_;
    "Rule_Capture(".join(",",map{$self->describe_anything($_)}@$self{'rule','position','capture_to_array'}).")"
  }
}
#line 2 ir_build.pl
{ package IRBuild;
  sub make_ir_from_Match_tree {
    my($this,$tree)=@_;
    if(not ref($tree)) {
      $tree;
    } else {
      my $ref = ref($tree);
      if($ref eq 'Match') {
        my $m = $tree;
        my $rule = $m->{rule};
        if(not $rule) {die "Bug.  Found an unlabeled Match:\n$m->match_describe";}
        my $constructor = $IRBuild::constructors{$rule};
        if($constructor) {
          #print STDERR "Calling constructor for $rule with @{[$m->match_describe]}.\n";
          $constructor->($m);
        } else {
          die "Unknown rule: $rule\nDon't know how to build an IR from it.\n";
        }
      }
      elsif($ref eq 'ARRAY') {
        [map{$this->make_ir_from_Match_tree($_)} @$tree]
      }
      elsif($ref eq 'HASH') {
        my %h;
        for my $k (keys %$tree) {
          my $v = $tree->{$k};
          $h{$k} = $this->make_ir_from_Match_tree($v);
        }
        \%h;
      }
      else {
        die "bug? $ref $tree";
      }
    }
  }
  sub ir {
    my($tree)=@_;
    IRBuild->make_ir_from_Match_tree($tree);
  }
}
#line 2 ast_handlers.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IRBuild;
    $IRBuild::constructors{'comp_unit'} = sub {
      my($m)=@_;
    IR::CompUnit->new($m,ir($m->{hash}{statementlist}));
    };
    $IRBuild::constructors{'statement'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe."\n") if(@keys > 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'expect_term'} = sub {
      my($m)=@_;
    ir($m->{hash}{noun});
    };
    $IRBuild::constructors{'integer'} = sub {
      my($m)=@_;
    IR::Val_Int->new($m,($m->match_string));
    };
    $IRBuild::constructors{'subcall'} = sub {
      my($m)=@_;
    IR::Apply->new($m,ir($m->{hash}{subshortname}),ir($m->{hash}{semilist}));
    };
    $IRBuild::constructors{'name'} = sub {
      my($m)=@_;
    ir($m->{hash}{ident});
    };
    $IRBuild::constructors{'statement_control:use'} = sub {
      my($m)=@_;
    IR::Use->new($m,ir($m->{hash}{module_name}));
    };
    $IRBuild::constructors{'module_name:depreciated'} = sub {
      my($m)=@_;
    ($m->match_string);
    };
    $IRBuild::constructors{'term:listop'} = sub {
      my($m)=@_;
    IR::Apply->new($m,ir($m->{hash}{ident}),[ir($m->{hash}{arglist})]);
    };
    $IRBuild::constructors{'quote:q'} = sub {
      my($m)=@_;
    IR::Val_Buf->new($m,ir($m->{hash}{text}));
    };
    $IRBuild::constructors{'quote:qq'} = sub {
      my($m)=@_;
    IR::Val_Buf->new($m,ir($m->{hash}{text}));
    };
    $IRBuild::constructors{'infix'} = sub {
      my($m)=@_;
    IR::Apply->new($m,"infix:".($m->match_string),[ir($m->{hash}{left}),ir($m->{hash}{right})]);
    };
    $IRBuild::constructors{'statement_control:if'} = sub {
      my($m)=@_;
    IR::If->new($m,[ir($m->{hash}{if_expr}),ir($m->{hash}{if_block}),@{ir($m->{hash}{elsif})}],ir($m->{hash}{else}));
    };
    $IRBuild::constructors{'if__else'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe."\n") if(@keys > 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'pblock'} = sub {
      my($m)=@_;
      my @keys = map{$_ eq "match" ? () : ($_)} keys %{$m->{hash}};
die("Unexpectedly more than 1 field - dont know which to choose\n".
    $m->match_describe."\n") if(@keys > 1);
my $one = ir($m->{hash}{$keys[0]});
$one;
    };
    $IRBuild::constructors{'block'} = sub {
      my($m)=@_;
    IR::Block->new($m,ir($m->{hash}{statementlist}))
;
    };
}
#line 2 emit_p5.pl
# Warning: This file is mechanically written.  Your changes will be overwritten.
{ package IR;
  sub emit_p5_for {
    my($this,$tree)=@_;
    if(not ref($tree)) {
      $tree;
    } else {
      my $ref = ref($tree);
      if($ref eq 'ARRAY') {
        [map{$this->emit_p5_for($_)} @$tree]
      }
      elsif($ref eq 'HASH') {
        my %h;
        for my $k (keys %$tree) {
          my $v = $tree->{$k};
          $h{$k} = $this->emit_p5_for($v);
        }
        \%h;
      }
      else {
        $tree->emit_p5
      }
    }
  }
}
{ package IR::All;
  sub emit_p5 {
    my $name = $_[0]->node_name;
    print STDERR "ERROR: emit_p5 is not defined for $name.\n";
    "***<$name>***";
  }
}
{ package IR::CompUnit; sub emit_p5 {
    my($n)=@_;
    'package Main;
use Perl6::Say;
'.join(";\n",@{IR->emit_p5_for($n->{statements})})
  }
}
{ package IR::Val_Int; sub emit_p5 {
    my($n)=@_;
    IR->emit_p5_for($n->{text})
  }
}
{ package IR::Apply; sub emit_p5 {
    my($n)=@_;
    if(IR->emit_p5_for($n->{code}) =~ /^infix:(.+)$/) {
  my($l,$r)=@{IR->emit_p5_for($n->{arguments})};
  my $op = $1;
  if($op eq '~'){ "($l . $r)" }
  else { "($l $op $r)" }
}
else {
  IR->emit_p5_for($n->{code}).'('.join(",",@{IR->emit_p5_for($n->{arguments})}).')'
}
  }
}
{ package IR::Use; sub emit_p5 {
    my($n)=@_;
    ""
  }
}
{ package IR::Val_Buf; sub emit_p5 {
    my($n)=@_;
    "'".IR->emit_p5_for($n->{buf})."'"
  }
}
{ package IR::If; sub emit_p5 {
    my($n)=@_;
    'if('.IR->emit_p5_for($n->{cond}).")\n".IR->emit_p5_for($n->{body}).IR->emit_p5_for($n->{otherwise})
  }
}
{ package IR::Block; sub emit_p5 {
    my($n)=@_;
    '{'.join(";\n",IR->emit_p5_for($n->{statements})).'}'

  }
}
#line 2 main.pl
{ package Program;
  use YAML::Syck;

  sub new {
    my($cls)=@_;
    bless {},$cls;
  }
  sub print_usage_and_exit {
    my $usage = "
Usage: [-v] [-c] [-o OUTPUT_FILE] [ P6_FILE | -e P6_CODE ]

";
    print STDERR $usage;
    exit(2);
  }
  sub main {
    my($self,$argv)=@_;
    $self->print_usage_and_exit() if !@$argv;
    my($p6_code,$output_file,$compile,$verbose);
    while(my $arg = shift(@$argv)) {
      if($arg eq '-v') {
        $verbose = 1;
      }
      elsif($arg eq '-c') {
        $compile = 1;
      }
      elsif($arg eq '-o') {
        $output_file = shift(@$argv) || $self->print_usage_and_exit();
      }
      elsif($arg eq '-e') {
        $p6_code = shift(@$argv) || $self->print_usage_and_exit();
      }
      elsif(-f $arg) {
        $p6_code = `cat $arg`;
      }
      else {
        $self->print_usage_and_exit();
      }
    }
    my $yaml = $self->parse(undef,$p6_code);
    print $yaml if $verbose;
    my $tree = YAML::Syck::Load($yaml);
    if(!$tree) {
      exit(1);
    }
    print $tree->match_describe(1),"\n" if $verbose;
    my $ir = IRBuild->make_ir_from_Match_tree($tree);
    print "\n",$ir->describe,"\n" if $verbose;
    my $p5 = IR->emit_p5_for($ir);
    print "\n",$p5,"\n\n" if $verbose;
    if($compile) {
      if(not $output_file) {
        print $p5,"\n";
      } else {
        open(F,">$output_file") or die $!;
        print F $p5,"\n"; close F;
      }
    } else {
      my $code = $p5;
      eval($code);
      if($@) {
        #XXX... provide $code.
        die $@;
      }
    }
  }
  sub parse {
    my($self,$p6_file,$p6_code)=@_;
    $p6_code ||= `cat $p6_file`;
    my $std_red_from_root = "misc/STD_red/STD_red_run";
    my $std_red_from_src = "../../../$std_red_from_root";
    my $std_red;
    if(-f $std_red_from_src) {
      $std_red = $std_red_from_src;
    } else {
      die "The environment variable PUGS_ROOT must be defined.\n"
          if !exists($ENV{PUGS_ROOT});
      $std_red = $ENV{PUGS_ROOT}."/".$std_red_from_root;
    }
    my $file = $p6_file;
    if(!$file) {
      use File::Temp qw/ tempfile /;
      my($fh,$fname) = tempfile();
      print $fh $p6_code;
      close($fh);
      $file = $fname;
    }
    my $cmd = "$std_red -q --yaml $file";
    my $yaml = `$cmd` or die "Parse failed. $!\n";
    $yaml;
  }
}
Program->new()->main(\@ARGV);
