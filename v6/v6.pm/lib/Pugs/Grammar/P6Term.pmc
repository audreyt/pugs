# Generated by v6 0.014 (Module::Compile 0.17) - do not edit!
################((( 32-bit Checksum Validator III )))################
#line 1
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); if (unpack('%32N*',
$F=readline(*F)) != 0xCB5F12AA) { use Filter::Util::Call; my $f = $F;
filter_add(sub { filter_del(); 1 while &filter_read; $_ = $f; 1; })}}
#line 1
package main;
use Config;
use lib split( /\Q$Config{path_sep}/, $ENV{PERL6LIB} || '' );
use Scalar::Util;
use Pugs::Runtime::Perl6;
use Pugs::Runtime::Perl6Prelude;
use strict;
no strict 'refs';
no warnings( 'void', 'uninitialized' );
$::_V6_COMPILER_OS      = 'MSWin32';
$::_V6_COMPILER_NAME    = 'v6.pm';
$::_V6_COMPILER_VERSION = '0.014';
my %_V6_PAD;
our %_V6_STATE;

# use v6-alpha
package Pugs::Grammar::Term;
use Pugs::Compiler::Rule;
use Moose;
use base 'Pugs::Grammar::Base';
no strict 'refs';
use Exporter 'import';
push our @ISA, 'Exporter';
our @EXPORT;
bool->import();    # True, False
use base 'Pugs::Grammar::BaseCategory';
*ident = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '!' )
          ? do { $pos += 1; 1 }
          : 0
        );
        }
        || do {
        $pos = $pos1;
        do {
          my $pos1 = $pos;
          do {
            (
              do {
                (
                  (
                    ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '?' )
                    ? do { $pos += 1; 1 }
                    : 0
                  )
                    || 1
                );
                }
                && (
                do {
                  (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '*' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                      || 1
                  );
                }
                && (
                  do {
                    (
                      (
                        ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ':' )
                        ? do { $pos += 1; 1 }
                        : 0
                      )
                        || 1
                    );
                  }
                  && do {
                    (
                      (
                        do {
                          my $pos1 = $pos;
                          do {
                            (
                              ( length($s) >= $pos && substr( $s, $pos, 2 ) eq '::' )
                              ? do { $pos += 2; 1 }
                              : 0
                            );
                            }
                            || do {
                            $pos = $pos1;
                            1    # null

                            }
                          }
                          && (
                          do {
                            my $pos1 = $pos;
                            do {
                              (
                                ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                ? do { $pos += 1; 1 }
                                : 0
                              );
                              }
                              || do {
                              $pos = $pos1;
                              do {
                                my $match = $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                                my $bool = ( !$match != 1 );
                                $pos = $match->to if $bool;
                                $match;
                                }
                              }
                          }
                          && do {
                            while (
                              do {
                                my $pos1 = $pos;
                                do {
                                  (
                                    ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                    ? do { $pos += 1; 1 }
                                    : 0
                                  );
                                  }
                                  || do {
                                  $pos = $pos1;
                                  do {
                                    my $match = $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                                    my $bool = ( !$match != 1 );
                                    $pos = $match->to if $bool;
                                    $match;
                                    }
                                  }
                              }
                              )
                            {
                            }
                            1;
                          }
                          )
                      )
                        && do {
                        while (
                          (
                            do {
                              my $pos1 = $pos;
                              do {
                                (
                                  ( length($s) >= $pos && substr( $s, $pos, 2 ) eq '::' )
                                  ? do { $pos += 2; 1 }
                                  : 0
                                );
                                }
                                || do {
                                $pos = $pos1;
                                1    # null

                                }
                            }
                            && (
                              do {
                                my $pos1 = $pos;
                                do {
                                  (
                                    ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                    ? do { $pos += 1; 1 }
                                    : 0
                                  );
                                  }
                                  || do {
                                  $pos = $pos1;
                                  do {
                                    my $match = $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                                    my $bool = ( !$match != 1 );
                                    $pos = $match->to if $bool;
                                    $match;
                                    }
                                  }
                              }
                              && do {
                                while (
                                  do {
                                    my $pos1 = $pos;
                                    do {
                                      (
                                        ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                        ? do { $pos += 1; 1 }
                                        : 0
                                      );
                                      }
                                      || do {
                                      $pos = $pos1;
                                      do {
                                        my $match = $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                                        my $bool = ( !$match != 1 );
                                        $pos = $match->to if $bool;
                                        $match;
                                        }
                                      }
                                  }
                                  )
                                {
                                }
                                1;
                              }
                            )
                          )
                          )
                        {
                        }
                        1;
                        }
                    );
                  }
                )
                )
            );
            }
            || do {
            $pos = $pos1;
            do {
              my $pos1 = $pos;
              do {
                do {
                  my $pos1 = $pos;
                  do {
                    my $pos  = $pos1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0
                      unless do {
                      my $pos1 = $pos;
                      do {
                        (
                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '<' )
                          ? do { $pos += 1; 1 }
                          : 0
                        );
                        }
                        || do {
                        $pos = $pos1;
                        do {
                          my $pos1 = $pos;
                          do {
                            (
                              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '[' )
                              ? do { $pos += 1; 1 }
                              : 0
                            );
                            }
                            || do {
                            $pos = $pos1;
                            (
                              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '{' )
                              ? do { $pos += 1; 1 }
                              : 0
                            );
                            }
                          }
                        }
                      };
                    $bool;
                  };
                  }
                }
                || do {
                $pos = $pos1;
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '/' )
                  ? do { $pos += 1; 1 }
                  : 0
                );
                }
              }
            }
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ident
Data::Bind->sub_signature( \&ident, );
*bare_ident = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      (
        (
          do {
            my $pos1 = $pos;
            do {
              (
                ( length($s) >= $pos && substr( $s, $pos, 2 ) eq '::' )
                ? do { $pos += 2; 1 }
                : 0
              );
              }
              || do {
              $pos = $pos1;
              1    # null

              }
            }
            && (
            do {
              my $pos1 = $pos;
              do {
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                  ? do { $pos += 1; 1 }
                  : 0
                );
                }
                || do {
                $pos = $pos1;
                do {
                  my $match = $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                  }
                }
            }
            && do {
              while (
                do {
                  my $pos1 = $pos;
                  do {
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                      ? do { $pos += 1; 1 }
                      : 0
                    );
                    }
                    || do {
                    $pos = $pos1;
                    do {
                      my $match = $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                      }
                    }
                }
                )
              {
              }
              1;
            }
            )
        )
          && do {
          while (
            (
              do {
                my $pos1 = $pos;
                do {
                  (
                    ( length($s) >= $pos && substr( $s, $pos, 2 ) eq '::' )
                    ? do { $pos += 2; 1 }
                    : 0
                  );
                  }
                  || do {
                  $pos = $pos1;
                  1    # null

                  }
              }
              && (
                do {
                  my $pos1 = $pos;
                  do {
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                      ? do { $pos += 1; 1 }
                      : 0
                    );
                    }
                    || do {
                    $pos = $pos1;
                    do {
                      my $match = $grammar->alpha( $s, { p => $pos, args => {} }, undef );
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                      }
                    }
                }
                && do {
                  while (
                    do {
                      my $pos1 = $pos;
                      do {
                        (
                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                          ? do { $pos += 1; 1 }
                          : 0
                        );
                        }
                        || do {
                        $pos = $pos1;
                        do {
                          my $match = $grammar->alnum( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                          }
                        }
                    }
                    )
                  {
                  }
                  1;
                }
              )
            )
            )
          {
          }
          1;
          }
      );
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for bare_ident
Data::Bind->sub_signature( \&bare_ident, );
*parenthesis = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
            }
            && (
            do {
              my $match = Pugs::Grammar::Expression->parse( $s, { p => $pos, args => { 'allow_semicolon', 1 } }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Expression.parse'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
              }
              && (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ')' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return (
                        {
                          'op1' => {
                            'op' => "("    # hash
                          },
                          'op2' => {
                            'op' => ")"    # hash
                          },
                          'fixity' => "circumfix",
                          'exp1'   => $::_V6_MATCH_->{'Pugs::Grammar::Expression.parse'}->()    # hash
                        }
                      );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            )
        );
        }
        || do {
        $pos = $pos1;
        do {
          my $pos1 = $pos;
          do {
            (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
                }
                && (
                do {
                  my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
                  if ($match) {
                    $named{'Pugs::Grammar::Perl6.block'} = $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                && (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                  }
                  && (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ')' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'op1' => {
                                'op' => "("    # hash
                              },
                              'op2' => {
                                'op' => ")"    # hash
                              },
                              'fixity' => "circumfix",
                              'exp1'   => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->()    # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                )
                )
            );
            }
            || do {
            $pos = $pos1;
            (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
                }
                && (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ')' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return (
                        {
                          'op1' => {
                            'op' => "("    # hash
                          },
                          'op2' => {
                            'op' => ")"    # hash
                          },
                          'fixity' => "circumfix"    # hash
                        }
                      );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
                )
            );
            }
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for parenthesis
Data::Bind->sub_signature( \&parenthesis, );
*brackets = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            my $match = Pugs::Grammar::Infix->parse( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'Pugs::Grammar::Infix.parse'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
            }
            && (
            (
              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ']' )
              ? do { $pos += 1; 1 }
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'op'     => $::_V6_MATCH_->{'Pugs::Grammar::Infix.parse'}->(),
                      'reduce' => 1                                                    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            )
        );
        }
        || do {
        $pos = $pos1;
        do {
          my $pos1 = $pos;
          do {
            (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
                }
                && (
                do {
                  my $match = Pugs::Grammar::Expression->parse( $s, { p => $pos, args => {} }, undef );
                  if ($match) {
                    $named{'Pugs::Grammar::Expression.parse'} = $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                && (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                  }
                  && (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ']' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'op1' => {
                                'op' => "["    # hash
                              },
                              'op2' => {
                                'op' => "]"    # hash
                              },
                              'fixity' => "circumfix",
                              'exp1'   => $::_V6_MATCH_->{'Pugs::Grammar::Expression.parse'}->()    # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                )
                )
            );
            }
            || do {
            $pos = $pos1;
            do {
              my $pos1 = $pos;
              do {
                (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                    }
                    && (
                    do {
                      my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        $named{'Pugs::Grammar::Perl6.block'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && (
                      do {
                        (
                          do {
                            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                            my $bool = ( !$match != 1 );
                            $pos = $match->to if $bool;
                            $match;
                            }
                            || 1
                        );
                      }
                      && (
                        (
                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ']' )
                          ? do { $pos += 1; 1 }
                          : 0
                        )
                        && do {
                          $::_V6_MATCH_ = $m;
                          local $::_V6_SUCCEED = 1;
                          $m->data->{capture} = \(
                            sub {
                              return (
                                {
                                  'op1' => {
                                    'op' => "["    # hash
                                  },
                                  'op2' => {
                                    'op' => "]"    # hash
                                  },
                                  'fixity' => "circumfix",
                                  'exp1'   => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->()    # hash
                                }
                              );
                              }
                              ->()
                          );
                          $bool = $::_V6_SUCCEED;
                          $::_V6_MATCH_ = $m if $bool;
                          return $m if $bool;
                        }
                      )
                    )
                    )
                );
                }
                || do {
                $pos = $pos1;
                (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                    }
                    && (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ']' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'op1' => {
                                'op' => "["    # hash
                              },
                              'op2' => {
                                'op' => "]"    # hash
                              },
                              'fixity' => "circumfix"    # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                    )
                );
                }
              }
            }
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for brackets
Data::Bind->sub_signature( \&brackets, );
*cpan_bareword = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $hash = do {
        my $bool = 1;
        my $from = $pos;
        my @match;
        my %named;
        $bool = 0
          unless (
          do {
            my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'ident'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            (
              (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '-' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                  && do {
                  my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
                  if ($match) {
                    push @{ $named{'ident'} }, $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                  }
              )
                && do {
                while (
                  (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '-' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                    && do {
                      my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        push @{ $named{'ident'} }, $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                  )
                  )
                {
                }
                1;
                }
            );
          }
          );
        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
      };
      my $bool = ${ $hash->{'bool'} };
      $match[0] = Pugs::Runtime::Match->new($hash);
      $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for cpan_bareword
Data::Bind->sub_signature( \&cpan_bareword, );
*perl5source = do {

  package Pugs::Runtime::Regex;
  my $matcher = concat(
    positional(
      0, 0,
      non_greedy_star(
        sub {
          my $param = { %{ $_[7] || {} }, args => {} };
          $_[3] = $_[4]->any( $_[0], $param, $_[3], );
        }
      )
    ),
    concat(
      alternation(
        [
          constant(q!;!),
          sub {
            my $param = { %{ $_[7] || {} }, args => {} };
            $_[3] = $_[4]->ws( $_[0], $param, $_[3], );
            }
        ]
      ),
      concat(
        constant(q!u!),
        concat(
          constant(q!s!),
          concat(
            constant(q!e!),
            concat(
              sub {
                my $param = { %{ $_[7] || {} }, args => {} };
                $_[3] = $_[4]->ws( $_[0], $param, $_[3], );
              },
              concat(
                constant(q!v!),
                concat(
                  constant(q!6!),
                  concat(
                    non_greedy_star(
                      positional(
                        1, 1,
                        sub {
                          my $param = { %{ $_[7] || {} }, args => {} };
                          $_[3] = $_[4]->any( $_[0], $param, $_[3], );
                        }
                      )
                    ),
                    concat(
                      constant(q!;!),
                      sub {
                        $_[3] = Pugs::Runtime::Match->new(
                          {
                            bool    => \1,
                            str     => \( $_[0] ),
                            from    => \( $_[7]{p} || 0 ),
                            to      => \( $_[7]{p} || 0 ),
                            match   => [],
                            named   => {},
                            capture => sub {
                              return (
                                {
                                  'perl5source' => $::_V6_MATCH_->[0]->()    # hash
                                }
                              );
                            },
                            abort => 1,
                          }
                        );
                      }
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  );
  sub {
    my $tree;
    if ( defined $_[3]{p} ) {
      $matcher->( $_[1], $_[2], $tree, $tree, $_[0], $_[3]{p}, $_[1], $_[3] );
    }
    else {
      for my $pos ( 0 .. length( $_[1] ) - 1 ) {
        my $param = { %{ $_[3] }, p => $pos };
        $matcher->( $_[1], $_[2], $tree, $tree, $_[0], $pos, $_[1], $param );
        last if $tree;
      }
      $tree = Pugs::Grammar::RegexBase->no_match(@_)
        unless defined $tree;
    }
    my $cap = $tree->data->{capture};
    if ( ref $cap eq 'CODE' ) {
      $::_V6_MATCH_ = $tree;
      $tree->data->{capture} = \( $cap->($tree) );
    }
    return $tree;
    }
};    ## Signature for perl5source
Data::Bind->sub_signature( \&perl5source, );
@::_V6_GRAMMAR::term{qw($)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'scalar' => '$' . $::_V6_MATCH_->()    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            }
        );
        }
        || do {
        $pos = $pos1;
        (
          do {
            my $hash = do {
              my $bool = 1;
              my $from = $pos;
              my @match;
              my %named;
              $bool = 0
                unless do {
                (
                  (
                    ( substr( $s, $pos ) =~ m/^\d/s )
                    ? do { $pos += length $&; 1 }
                    : 0
                  )
                    && do {
                    while (
                      (
                        ( substr( $s, $pos ) =~ m/^\d/s )
                        ? do { $pos += length $&; 1 }
                        : 0
                      )
                      )
                    {
                    }
                    1;
                    }
                );
                };
              { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            };
            my $bool = ${ $hash->{'bool'} };
            $match[0] = Pugs::Runtime::Match->new($hash);
            $bool;
            }
            && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'scalar' => '$' . $::_V6_MATCH_->()    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            }
        );
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw($.)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'scalar' => '$.' . $::_V6_MATCH_->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw($/)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      $::_V6_MATCH_ = $m;
      local $::_V6_SUCCEED = 1;
      $m->data->{capture} = \(
        sub {
          return (
            {
              'scalar' => '$/'    # hash
            }
          );
          }
          ->()
      );
      $bool = $::_V6_SUCCEED;
      $::_V6_MATCH_ = $m if $bool;
      return $m if $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw!$()!} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      $::_V6_MATCH_ = $m;
      local $::_V6_SUCCEED = 1;
      $m->data->{capture} = \(
        sub {
          return (
            {
              'op1' => 'call',
              'sub' => {
                'scalar' => '$/'    # hash
                }    # hash
            }
          );
          }
          ->()
      );
      $bool = $::_V6_SUCCEED;
      $::_V6_MATCH_ = $m if $bool;
      return $m if $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
$::_V6_GRAMMAR::term{'$<'} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $hash = do {
          my $bool = 1;
          my $from = $pos;
          my @match;
          my %named;
          $bool = 0
            unless do {
            my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            };
          { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
        };
        my $bool = ${ $hash->{'bool'} };
        $match[0] = Pugs::Runtime::Match->new($hash);
        $bool;
      }
      && (
        (
          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '>' )
          ? do { $pos += 1; 1 }
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'scalar' => {
                    'match_variable' => $::_V6_MATCH_->[0]->()    # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(@)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          (
            ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ';' )
            ? do { $pos += 1; 1 }
            : 0
          )
            && (
            do {
              my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'die' => "not implemented"    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            )
        );
        }
        || do {
        $pos = $pos1;
        (
          do {
            my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'array' => "\@" . $::_V6_MATCH_->()    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
            }
        );
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(%)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'hash' => "\%" . $::_V6_MATCH_->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw!%(!} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->parenthesis( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.parenthesis'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'exp1'   => $::_V6_MATCH_->{'Pugs::Grammar::Term.parenthesis'}->(),
                'fixity' => 'prefix',
                'op1'    => {
                  'op' => 'hash'    # hash
                  }    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(&)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'code' => "\&" . $::_V6_MATCH_->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw!(!} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->parenthesis( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.parenthesis'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return ( $::_V6_MATCH_->{'Pugs::Grammar::Term.parenthesis'}->() );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw([)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->brackets( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.brackets'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return ( $::_V6_MATCH_->{'Pugs::Grammar::Term.brackets'}->() );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw({)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
            }
            && (
            (
              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '}' )
              ? do { $pos += 1; 1 }
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'bare_block' => {
                        'statements' => []    # hash
                        }    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
            )
        );
        }
        || do {
        $pos = $pos1;
        (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
            }
            && (
            do {
              my $match = Pugs::Grammar::Perl6->statements( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.statements'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
              }
              && (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '}' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return (
                        {
                          'bare_block' => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.statements'}->()    # hash
                        }
                      );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            )
        );
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
$::_V6_GRAMMAR::term{'->'} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
            }
            && (
            do {
              my $match = Pugs::Grammar::Perl6->signature_no_invocant( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.signature_no_invocant'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
              }
              && (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '{' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                && (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                  }
                  && (
                    do {
                      my $match = Pugs::Grammar::Perl6->statements( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        $named{'Pugs::Grammar::Perl6.statements'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && (
                      do {
                        (
                          do {
                            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                            my $bool = ( !$match != 1 );
                            $pos = $match->to if $bool;
                            $match;
                            }
                            || 1
                        );
                      }
                      && (
                        (
                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '}' )
                          ? do { $pos += 1; 1 }
                          : 0
                        )
                        && do {
                          $::_V6_MATCH_ = $m;
                          local $::_V6_SUCCEED = 1;
                          $m->data->{capture} = \(
                            sub {
                              return (
                                {
                                  'pointy_block' => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.statements'}->(),
                                  'signature'    => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.signature_no_invocant'}->()    # hash
                                }
                              );
                              }
                              ->()
                          );
                          $bool = $::_V6_SUCCEED;
                          $::_V6_MATCH_ = $m if $bool;
                          return $m if $bool;
                        }
                      )
                    )
                  )
                )
              )
            )
            )
        );
        }
        || do {
        $pos = $pos1;
        (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
            }
            && (
            (
              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '{' )
              ? do { $pos += 1; 1 }
              : 0
            )
            && (
              do {
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                    }
                    || 1
                );
              }
              && (
                do {
                  my $match = Pugs::Grammar::Perl6->statements( $s, { p => $pos, args => {} }, undef );
                  if ($match) {
                    $named{'Pugs::Grammar::Perl6.statements'} = $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                && (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                  }
                  && (
                    (
                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '}' )
                      ? do { $pos += 1; 1 }
                      : 0
                    )
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'pointy_block' => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.statements'}->(),
                              'signature'    => undef                                                     # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                )
              )
            )
            )
        );
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(.)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->ident( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'dot_bareword' => $::_V6_MATCH_->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(...)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      $::_V6_MATCH_ = $m;
      local $::_V6_SUCCEED = 1;
      $m->data->{capture} = \(
        sub {
          return (
            {
              'term' => "yada"    # hash
            }
          );
          }
          ->()
      );
      $bool = $::_V6_SUCCEED;
      $::_V6_MATCH_ = $m if $bool;
      return $m if $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(self)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      $::_V6_MATCH_ = $m;
      local $::_V6_SUCCEED = 1;
      $m->data->{capture} = \(
        sub {
          return (
            {
              'term' => "self"    # hash
            }
          );
          }
          ->()
      );
      $bool = $::_V6_SUCCEED;
      $::_V6_MATCH_ = $m if $bool;
      return $m if $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(undef)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      $::_V6_MATCH_ = $m;
      local $::_V6_SUCCEED = 1;
      $m->data->{capture} = \(
        sub {
          return (
            {
              'term' => "undef"    # hash
            }
          );
          }
          ->()
      );
      $bool = $::_V6_SUCCEED;
      $::_V6_MATCH_ = $m if $bool;
      return $m if $bool;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(my)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Term->parse( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Term.parse'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
          }
          && (
            do {
              my $match = Pugs::Grammar::Perl6->attribute( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.attribute'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'exp1'                => $::_V6_MATCH_->{'Pugs::Grammar::Term.parse'}->(),
                      'attribute'           => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.attribute'}->(),
                      'variable_declarator' => "my"                                                     # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(our)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Term->parse( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Term.parse'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
          }
          && (
            do {
              my $match = Pugs::Grammar::Perl6->attribute( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.attribute'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'exp1'                => $::_V6_MATCH_->{'Pugs::Grammar::Term.parse'}->(),
                      'attribute'           => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.attribute'}->(),
                      'variable_declarator' => "our"                                                    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(has)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Term->parse( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Term.parse'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
          }
          && (
            do {
              my $match = Pugs::Grammar::Perl6->attribute( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.attribute'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'exp1'                => $::_V6_MATCH_->{'Pugs::Grammar::Term.parse'}->(),
                      'attribute'           => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.attribute'}->(),
                      'variable_declarator' => "has"                                                    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(state)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Term->parse( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Term.parse'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
          }
          && (
            do {
              my $match = Pugs::Grammar::Perl6->attribute( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.attribute'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'exp1'                => $::_V6_MATCH_->{'Pugs::Grammar::Term.parse'}->(),
                      'attribute'           => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.attribute'}->(),
                      'variable_declarator' => "state"                                                  # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(constant)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Term->parse( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Term.parse'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
                }
                || 1
            );
          }
          && (
            do {
              my $match = Pugs::Grammar::Perl6->attribute( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                $named{'Pugs::Grammar::Perl6.attribute'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'exp1'                => $::_V6_MATCH_->{'Pugs::Grammar::Term.parse'}->(),
                      'attribute'           => $::_V6_MATCH_->{'Pugs::Grammar::Perl6.attribute'}->(),
                      'variable_declarator' => "constant"                                               # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(s)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->substitution( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.substitution'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'substitution' => $::_V6_MATCH_->{'Pugs::Grammar::Term.substitution'}->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(rx)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->rx( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.rx'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'rx' => $::_V6_MATCH_->{'Pugs::Grammar::Term.rx'}->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(m)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->rx( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.rx'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'rx' => $::_V6_MATCH_->{'Pugs::Grammar::Term.rx'}->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(/)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->rx_body( $s, { p => $pos, args => { 'open', '/' } }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.rx_body'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'rx' => $::_V6_MATCH_->{'Pugs::Grammar::Term.rx_body'}->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(perl5:)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Grammar::Term->bare_ident( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'Pugs::Grammar::Term.bare_ident'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'bareword' => $::_V6_MATCH_->{'Pugs::Grammar::Term.bare_ident'}->(),
                'lang'     => 'perl5'                                                  # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(use)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            && (
            (
              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq 'v' )
              ? do { $pos += 1; 1 }
              : 0
            )
            && (
              (
                ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '5' )
                ? do { $pos += 1; 1 }
                : 0
              )
              && (
                do {
                  (
                    do {
                      my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                      }
                      || 1
                  );
                }
                && (
                  (
                    ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ';' )
                    ? do { $pos += 1; 1 }
                    : 0
                  )
                  && (
                    do {
                      my $match = $grammar->perl5source( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        $named{'perl5source'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return ( $::_V6_MATCH_->{ perl5source() }->() );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                )
              )
            )
            )
        );
        }
        || do {
        $pos = $pos1;
        do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'bareword' => 'use'    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(do)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
        my $bool = ( !$match != 1 );
        $pos = $match->to if $bool;
        $match;
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->statement( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'exp1'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'statement' => 'do',
                  'exp1'      => $::_V6_MATCH_->{ exp1() }->()    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(:)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            my $hash = do {
              my $bool = 1;
              my $from = $pos;
              my @match;
              my %named;
              $bool = 0
                unless do {
                (
                  do {
                    my $pos1 = $pos;
                    do {
                      (
                        ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                        ? do { $pos += 1; 1 }
                        : 0
                      );
                      }
                      || do {
                      $pos = $pos1;
                      (
                        ( substr( $s, $pos ) =~ m/^\w/s )
                        ? do { $pos += length $&; 1 }
                        : 0
                      );
                      }
                    }
                    && do {
                    while (
                      do {
                        my $pos1 = $pos;
                        do {
                          (
                            ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                            ? do { $pos += 1; 1 }
                            : 0
                          );
                          }
                          || do {
                          $pos = $pos1;
                          (
                            ( substr( $s, $pos ) =~ m/^\w/s )
                            ? do { $pos += length $&; 1 }
                            : 0
                          );
                          }
                      }
                      )
                    {
                    }
                    1;
                    }
                );
                };
              { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            };
            my $bool = ${ $hash->{'bool'} };
            $match[0] = Pugs::Runtime::Match->new($hash);
            $bool;
            }
            && (
            (
              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '<' )
              ? do { $pos += 1; 1 }
              : 0
            )
            && (
              do {
                my $match = Pugs::Grammar::Quote->angle_quoted( $s, { p => $pos, args => {} }, undef );
                if ($match) {
                  $named{'Pugs::Grammar::Quote.angle_quoted'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return (
                      {
                        'pair' => {
                          'key' => {
                            'single_quoted' => $::_V6_MATCH_->[0]->()    # hash
                          },
                          'value' => {
                            'single_quoted' => $::_V6_MATCH_->{'Pugs::Grammar::Quote.angle_quoted'}->()    # hash
                            }    # hash
                          }    # hash
                      }
                    );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
            )
        );
        }
        || do {
        $pos = $pos1;
        do {
          my $pos1 = $pos;
          do {
            (
              do {
                my $hash = do {
                  my $bool = 1;
                  my $from = $pos;
                  my @match;
                  my %named;
                  $bool = 0
                    unless do {
                    (
                      do {
                        my $pos1 = $pos;
                        do {
                          (
                            ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                            ? do { $pos += 1; 1 }
                            : 0
                          );
                          }
                          || do {
                          $pos = $pos1;
                          (
                            ( substr( $s, $pos ) =~ m/^\w/s )
                            ? do { $pos += length $&; 1 }
                            : 0
                          );
                          }
                        }
                        && do {
                        while (
                          do {
                            my $pos1 = $pos;
                            do {
                              (
                                ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                ? do { $pos += 1; 1 }
                                : 0
                              );
                              }
                              || do {
                              $pos = $pos1;
                              (
                                ( substr( $s, $pos ) =~ m/^\w/s )
                                ? do { $pos += length $&; 1 }
                                : 0
                              );
                              }
                          }
                          )
                        {
                        }
                        1;
                        }
                    );
                    };
                  { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                };
                my $bool = ${ $hash->{'bool'} };
                $match[0] = Pugs::Runtime::Match->new($hash);
                $bool;
                }
                && (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '(' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                && (
                  do {
                    (
                      do {
                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                        }
                        || 1
                    );
                  }
                  && (
                    do {
                      my $match = Pugs::Grammar::Expression->parse( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        $named{'Pugs::Grammar::Expression.parse'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && (
                      do {
                        (
                          do {
                            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                            my $bool = ( !$match != 1 );
                            $pos = $match->to if $bool;
                            $match;
                            }
                            || 1
                        );
                      }
                      && (
                        (
                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq ')' )
                          ? do { $pos += 1; 1 }
                          : 0
                        )
                        && do {
                          $::_V6_MATCH_ = $m;
                          local $::_V6_SUCCEED = 1;
                          $m->data->{capture} = \(
                            sub {
                              return (
                                {
                                  'pair' => {
                                    'key' => {
                                      'single_quoted' => $::_V6_MATCH_->[0]->()    # hash
                                    },
                                    'value' => $::_V6_MATCH_->{'Pugs::Grammar::Expression.parse'}->()    # hash
                                    }    # hash
                                }
                              );
                              }
                              ->()
                          );
                          $bool = $::_V6_SUCCEED;
                          $::_V6_MATCH_ = $m if $bool;
                          return $m if $bool;
                        }
                      )
                    )
                  )
                )
                )
            );
            }
            || do {
            $pos = $pos1;
            do {
              my $pos1 = $pos;
              do {
                (
                  (
                    ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '$' )
                    ? do { $pos += 1; 1 }
                    : 0
                  )
                    && (
                    do {
                      my $hash = do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0
                          unless do {
                          (
                            do {
                              my $hash = do {
                                my $bool = 1;
                                my $from = $pos;
                                my @match;
                                my %named;
                                $bool = 0
                                  unless do {
                                  my $pos1 = $pos;
                                  do {
                                    (
                                      ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                      ? do { $pos += 1; 1 }
                                      : 0
                                    );
                                    }
                                    || do {
                                    $pos = $pos1;
                                    (
                                      ( substr( $s, $pos ) =~ m/^\w/s )
                                      ? do { $pos += length $&; 1 }
                                      : 0
                                    );
                                    }
                                  };
                                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                              };
                              my $bool = ${ $hash->{'bool'} };
                              if ($bool) {
                                push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                              }
                              $bool;
                              }
                              && do {
                              while (
                                do {
                                  my $hash = do {
                                    my $bool = 1;
                                    my $from = $pos;
                                    my @match;
                                    my %named;
                                    $bool = 0
                                      unless do {
                                      my $pos1 = $pos;
                                      do {
                                        (
                                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                          ? do { $pos += 1; 1 }
                                          : 0
                                        );
                                        }
                                        || do {
                                        $pos = $pos1;
                                        (
                                          ( substr( $s, $pos ) =~ m/^\w/s )
                                          ? do { $pos += length $&; 1 }
                                          : 0
                                        );
                                        }
                                      };
                                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                                  };
                                  my $bool = ${ $hash->{'bool'} };
                                  if ($bool) {
                                    push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                                  }
                                  $bool;
                                }
                                )
                              {
                              }
                              1;
                              }
                          );
                          };
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                      };
                      my $bool = ${ $hash->{'bool'} };
                      $match[0] = Pugs::Runtime::Match->new($hash);
                      $bool;
                    }
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'pair' => {
                                'key' => {
                                  'single_quoted' => $::_V6_MATCH_->[0]->()    # hash
                                },
                                'value' => {
                                  'scalar' => '$' . $::_V6_MATCH_->[0]->()     # hash
                                  }    # hash
                                }    # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                    )
                );
                }
                || do {
                $pos = $pos1;
                do {
                  my $pos1 = $pos;
                  do {
                    (
                      do {
                        my $hash = do {
                          my $bool = 1;
                          my $from = $pos;
                          my @match;
                          my %named;
                          $bool = 0
                            unless do {
                            (
                              do {
                                my $hash = do {
                                  my $bool = 1;
                                  my $from = $pos;
                                  my @match;
                                  my %named;
                                  $bool = 0
                                    unless do {
                                    my $pos1 = $pos;
                                    do {
                                      (
                                        ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                        ? do { $pos += 1; 1 }
                                        : 0
                                      );
                                      }
                                      || do {
                                      $pos = $pos1;
                                      (
                                        ( substr( $s, $pos ) =~ m/^\w/s )
                                        ? do { $pos += length $&; 1 }
                                        : 0
                                      );
                                      }
                                    };
                                  { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                                };
                                my $bool = ${ $hash->{'bool'} };
                                if ($bool) {
                                  push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                                }
                                $bool;
                                }
                                && do {
                                while (
                                  do {
                                    my $hash = do {
                                      my $bool = 1;
                                      my $from = $pos;
                                      my @match;
                                      my %named;
                                      $bool = 0
                                        unless do {
                                        my $pos1 = $pos;
                                        do {
                                          (
                                            ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                            ? do { $pos += 1; 1 }
                                            : 0
                                          );
                                          }
                                          || do {
                                          $pos = $pos1;
                                          (
                                            ( substr( $s, $pos ) =~ m/^\w/s )
                                            ? do { $pos += length $&; 1 }
                                            : 0
                                          );
                                          }
                                        };
                                      { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                                    };
                                    my $bool = ${ $hash->{'bool'} };
                                    if ($bool) {
                                      push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                                    }
                                    $bool;
                                  }
                                  )
                                {
                                }
                                1;
                                }
                            );
                            };
                          { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                        };
                        my $bool = ${ $hash->{'bool'} };
                        $match[0] = Pugs::Runtime::Match->new($hash);
                        $bool;
                        }
                        && do {
                        $::_V6_MATCH_ = $m;
                        local $::_V6_SUCCEED = 1;
                        $m->data->{capture} = \(
                          sub {
                            return (
                              {
                                'pair' => {
                                  'key' => {
                                    'single_quoted' => $::_V6_MATCH_->[0]->()    # hash
                                  },
                                  'value' => {
                                    'num' => 1                                   # hash
                                    }    # hash
                                  }    # hash
                              }
                            );
                            }
                            ->()
                        );
                        $bool = $::_V6_SUCCEED;
                        $::_V6_MATCH_ = $m if $bool;
                        return $m if $bool;
                        }
                    );
                    }
                    || do {
                    $pos = $pos1;
                    (
                      (
                        ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '!' )
                        ? do { $pos += 1; 1 }
                        : 0
                      )
                        && (
                        do {
                          my $hash = do {
                            my $bool = 1;
                            my $from = $pos;
                            my @match;
                            my %named;
                            $bool = 0
                              unless do {
                              (
                                do {
                                  my $hash = do {
                                    my $bool = 1;
                                    my $from = $pos;
                                    my @match;
                                    my %named;
                                    $bool = 0
                                      unless do {
                                      my $pos1 = $pos;
                                      do {
                                        (
                                          ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                          ? do { $pos += 1; 1 }
                                          : 0
                                        );
                                        }
                                        || do {
                                        $pos = $pos1;
                                        (
                                          ( substr( $s, $pos ) =~ m/^\w/s )
                                          ? do { $pos += length $&; 1 }
                                          : 0
                                        );
                                        }
                                      };
                                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                                  };
                                  my $bool = ${ $hash->{'bool'} };
                                  if ($bool) {
                                    push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                                  }
                                  $bool;
                                  }
                                  && do {
                                  while (
                                    do {
                                      my $hash = do {
                                        my $bool = 1;
                                        my $from = $pos;
                                        my @match;
                                        my %named;
                                        $bool = 0
                                          unless do {
                                          my $pos1 = $pos;
                                          do {
                                            (
                                              ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '_' )
                                              ? do { $pos += 1; 1 }
                                              : 0
                                            );
                                            }
                                            || do {
                                            $pos = $pos1;
                                            (
                                              ( substr( $s, $pos ) =~ m/^\w/s )
                                              ? do { $pos += length $&; 1 }
                                              : 0
                                            );
                                            }
                                          };
                                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                                      };
                                      my $bool = ${ $hash->{'bool'} };
                                      if ($bool) {
                                        push @{ $match[0] }, Pugs::Runtime::Match->new($hash);
                                      }
                                      $bool;
                                    }
                                    )
                                  {
                                  }
                                  1;
                                  }
                              );
                              };
                            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                          };
                          my $bool = ${ $hash->{'bool'} };
                          $match[0] = Pugs::Runtime::Match->new($hash);
                          $bool;
                        }
                        && do {
                          $::_V6_MATCH_ = $m;
                          local $::_V6_SUCCEED = 1;
                          $m->data->{capture} = \(
                            sub {
                              return (
                                {
                                  'pair' => {
                                    'key' => {
                                      'single_quoted' => $::_V6_MATCH_->[0]->()    # hash
                                    },
                                    'value' => {
                                      'num' => 0                                   # hash
                                      }    # hash
                                    }    # hash
                                }
                              );
                              }
                              ->()
                          );
                          $bool = $::_V6_SUCCEED;
                          $::_V6_MATCH_ = $m if $bool;
                          return $m if $bool;
                        }
                        )
                    );
                    }
                  }
                }
              }
            }
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
$::_V6_GRAMMAR::term{''} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      my $pos1 = $pos;
      do {
        (
          do {
            (
              (
                ( substr( $s, $pos ) =~ m/^\d/s )
                ? do { $pos += length $&; 1 }
                : 0
              )
                && do {
                while (
                  (
                    ( substr( $s, $pos ) =~ m/^\d/s )
                    ? do { $pos += length $&; 1 }
                    : 0
                  )
                  )
                {
                }
                1;
                }
            );
            }
            && do {
            my $pos1 = $pos;
            do {
              (
                (
                  ( length($s) >= $pos && substr( $s, $pos, 1 ) eq '.' )
                  ? do { $pos += 1; 1 }
                  : 0
                )
                  && (
                  do {
                    (
                      (
                        ( substr( $s, $pos ) =~ m/^\d/s )
                        ? do { $pos += length $&; 1 }
                        : 0
                      )
                        && do {
                        while (
                          (
                            ( substr( $s, $pos ) =~ m/^\d/s )
                            ? do { $pos += length $&; 1 }
                            : 0
                          )
                          )
                        {
                        }
                        1;
                        }
                    );
                  }
                  && (
                    do {
                      (
                        (
                          (
                            ( substr( $s, $pos ) =~ m/^[Ee]/s )
                            ? do { $pos += length $&; 1 }
                            : 0
                          )
                            && (
                            do {
                              (
                                (
                                  ( substr( $s, $pos ) =~ m/^[+-]/s )
                                  ? do { $pos += length $&; 1 }
                                  : 0
                                )
                                  || 1
                              );
                            }
                            && do {
                              (
                                (
                                  ( substr( $s, $pos ) =~ m/^\d/s )
                                  ? do { $pos += length $&; 1 }
                                  : 0
                                )
                                  && do {
                                  while (
                                    (
                                      ( substr( $s, $pos ) =~ m/^\d/s )
                                      ? do { $pos += length $&; 1 }
                                      : 0
                                    )
                                    )
                                  {
                                  }
                                  1;
                                  }
                              );
                            }
                            )
                        )
                          || 1
                      );
                    }
                    && do {
                      $::_V6_MATCH_ = $m;
                      local $::_V6_SUCCEED = 1;
                      $m->data->{capture} = \(
                        sub {
                          return (
                            {
                              'num' => $::_V6_MATCH_->()    # hash
                            }
                          );
                          }
                          ->()
                      );
                      $bool = $::_V6_SUCCEED;
                      $::_V6_MATCH_ = $m if $bool;
                      return $m if $bool;
                    }
                  )
                  )
              );
              }
              || do {
              $pos = $pos1;
              do {
                my $pos1 = $pos;
                do {
                  (
                    (
                      ( substr( $s, $pos ) =~ m/^[Ee]/s )
                      ? do { $pos += length $&; 1 }
                      : 0
                    )
                      && (
                      do {
                        (
                          (
                            ( substr( $s, $pos ) =~ m/^[+-]/s )
                            ? do { $pos += length $&; 1 }
                            : 0
                          )
                            || 1
                        );
                      }
                      && (
                        do {
                          (
                            (
                              ( substr( $s, $pos ) =~ m/^\d/s )
                              ? do { $pos += length $&; 1 }
                              : 0
                            )
                              && do {
                              while (
                                (
                                  ( substr( $s, $pos ) =~ m/^\d/s )
                                  ? do { $pos += length $&; 1 }
                                  : 0
                                )
                                )
                              {
                              }
                              1;
                              }
                          );
                        }
                        && do {
                          $::_V6_MATCH_ = $m;
                          local $::_V6_SUCCEED = 1;
                          $m->data->{capture} = \(
                            sub {
                              return (
                                {
                                  'num' => $::_V6_MATCH_->()    # hash
                                }
                              );
                              }
                              ->()
                          );
                          $bool = $::_V6_SUCCEED;
                          $::_V6_MATCH_ = $m if $bool;
                          return $m if $bool;
                        }
                      )
                      )
                  );
                  }
                  || do {
                  $pos = $pos1;
                  do {
                    $::_V6_MATCH_ = $m;
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \(
                      sub {
                        return (
                          {
                            'int' => $::_V6_MATCH_->()    # hash
                          }
                        );
                        }
                        ->()
                    );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool;
                    return $m if $bool;
                    }
                  }
                }
              }
            }
        );
        }
        || do {
        $pos = $pos1;
        do {
          my $pos1 = $pos;
          do {
            (
              do {
                my $match = Pugs::Grammar::Perl6->sub_decl( $s, { p => $pos, args => {} }, undef );
                if ($match) {
                  $named{'Pugs::Grammar::Perl6.sub_decl'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
                }
                && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.sub_decl'}->() );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
                }
            );
            }
            || do {
            $pos = $pos1;
            do {
              my $pos1 = $pos;
              do {
                (
                  do {
                    my $match = Pugs::Grammar::Perl6->class_decl( $s, { p => $pos, args => {} }, undef );
                    if ($match) {
                      $named{'Pugs::Grammar::Perl6.class_decl'} = $match;
                      $pos = $match->to;
                      1;
                    }
                    else { 0 }
                    }
                    && do {
                    $::_V6_MATCH_ = $m;
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \(
                      sub {
                        return ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.class_decl'}->() );
                        }
                        ->()
                    );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool;
                    return $m if $bool;
                    }
                );
                }
                || do {
                $pos = $pos1;
                do {
                  my $pos1 = $pos;
                  do {
                    (
                      do {
                        my $match = Pugs::Grammar::Term->cpan_bareword( $s, { p => $pos, args => {} }, undef );
                        if ($match) {
                          $named{'Pugs::Grammar::Term.cpan_bareword'} = $match;
                          $pos = $match->to;
                          1;
                        }
                        else { 0 }
                        }
                        && do {
                        $::_V6_MATCH_ = $m;
                        local $::_V6_SUCCEED = 1;
                        $m->data->{capture} = \(
                          sub {
                            return (
                              {
                                'cpan_bareword' => $::_V6_MATCH_->{'Pugs::Grammar::Term.cpan_bareword'}->()    # hash
                              }
                            );
                            }
                            ->()
                        );
                        $bool = $::_V6_SUCCEED;
                        $::_V6_MATCH_ = $m if $bool;
                        return $m if $bool;
                        }
                    );
                    }
                    || do {
                    $pos = $pos1;
                    (
                      do {
                        my $match = Pugs::Grammar::Term->bare_ident( $s, { p => $pos, args => {} }, undef );
                        if ($match) {
                          $named{'Pugs::Grammar::Term.bare_ident'} = $match;
                          $pos = $match->to;
                          1;
                        }
                        else { 0 }
                        }
                        && do {
                        $::_V6_MATCH_ = $m;
                        local $::_V6_SUCCEED = 1;
                        $m->data->{capture} = \(
                          sub {
                            return (
                              {
                                'bareword' => $::_V6_MATCH_->{'Pugs::Grammar::Term.bare_ident'}->()    # hash
                              }
                            );
                            }
                            ->()
                        );
                        $bool = $::_V6_SUCCEED;
                        $::_V6_MATCH_ = $m if $bool;
                        return $m if $bool;
                        }
                    );
                    }
                  }
                }
              }
            }
          }
        }
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(BEGIN)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'BEGIN',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(CHECK)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'CHECK',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(INIT)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'INIT',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(START)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'START',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(FIRST)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'FIRST',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
@::_V6_GRAMMAR::term{qw(ENTER)} = sub {

  my $s       = $_[0] || '';
  my $grammar = $_[1] || __PACKAGE__;

  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
            }
            || 1
        );
      }
      && (
        do {
          my $match = Pugs::Grammar::Perl6->block( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'Pugs::Grammar::Perl6.block'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'trait' => 'ENTER',
                  %{ ( $::_V6_MATCH_->{'Pugs::Grammar::Perl6.block'}->() ) }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};
*parse = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s = $_[1] || '';
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = do {
          our $I1505;
          our $I1505_sizes;
          unless ($I1505) {
            my $hash = \%::_V6_GRAMMAR::term;
            my %sizes = map { length($_) => 1 } keys %$hash;
            $I1505_sizes = [ sort { $b <=> $a } keys %sizes ];
            $I1505 = $hash;
          }
          my $match = 0;
          my $key;
          for (@$I1505_sizes) {
            $key = (
              $pos <= length($s)
              ? substr( $s, $pos, $_ )
              : ''
            );
            if ( exists $I1505->{$key} ) {
              $match = Pugs::Emitter::Rule::Perl5::Ratchet::preprocess_hash( $I1505, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => {} }, undef );
              last if $match;
            }
          }
          if ($match) {
            $pos = $match->to;

            #print "match: $key at $pos = ", Dumper( $match->data );
            $bool = 1;
          }
          else { $bool = 0 }
          $match;
        };
        if ($match) {
          $named{'::_V6_GRAMMAR::term'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return ( $::_V6_MATCH_->{'::_V6_GRAMMAR::term'}->() );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for parse
Data::Bind->sub_signature( \&parse, );

1;
