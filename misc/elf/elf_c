#!/usr/bin/perl -w
package main;
use Perl6::Say;
use autobox; use autobox::Core; use autobox UNDEF => "UNDEF";
use Moose::Autobox;
{package AssertCurrentModuleVersions;
 use Moose 0.40;
 use Moose::Autobox 0.06;
 use autobox 2.23;
 use autobox::Core 0.4;
}

our $a_ARGS = [@ARGV];

{package UNDEF;}
{package UNDEF; sub ref{"UNDEF"}}
{package UNIVERSAL; sub ref{CORE::ref($_[0]) || "SCALAR"} }

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; `cat $file`;}
sub unslurp{
  my($text,$file)=@_; open(F,">$file") or CORE::die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{CORE::system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{CORE::exit(@_)}
sub ::defined{CORE::defined($_[0])}
sub ::substr ($$$){CORE::substr($_[0],$_[1],$_[2])}
sub ::not ($){CORE::not $_[0]}
sub ::exec{CORE::exec(@_)}


# because the p5->p6 massage of ast_handlers isnt massaging join.
sub ::join{CORE::join(CORE::shift,@_)}
# end

{ package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}
}

{ package ARRAY;
# absent from autobox::Core
sub splice { my $a = CORE::shift; [CORE::splice(@{$a},$_[0],$_[1])] }
sub copy { my $a = CORE::shift; [@$a] }
# buggy in autobox::Core
BEGIN{my $x = *ARRAY::unshift; undef &$x;}
sub unshift (\@;@) { my $a = CORE::shift; CORE::unshift(@$a, @_); $a; }
}

sub parser_name{
  my $f = $0;
  $f =~ s/[^\/]+$//;
  $f."../STD_red/STD_red_run"
}

our $a_INC = ["."];
sub ::require {
  my($module)=@_;
  my $file = find_required_module($module);
  $file || CORE::die "Cant locate $module in ( ".CORE::join(" ",@$a_INC)." ).\n";
  eval_file($file);
};
sub ::find_required_module {
  my($module)=@_;
  my @names = ($module,$module.".pm",$module.".p6");
  for my $dir (@$a_INC) {
    for my $name (@names) {
      my $file = $dir."/".$name;
      if(-f $file) {
        return $file;
      }
    }
  }
  return undef;
}

our $compiler0;
our $compiler1;
sub ::eval_file {
  my($file)=@_;
  $compiler0->eval_file($file);
}
sub ::eval_perl6 {
  my($code)=@_;
  $compiler0->eval_perl6($code);
}

package main;

package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;
;
;
;
;
;

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package Match;
use Moose;
has 'rule' => (is => 'rw');;
has 'str' => (is => 'rw');;
has 'from' => (is => 'rw');;
has 'to' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub make{my $self=CORE::shift;my($r,$s,$f,$t,$h)=@_;
my $init = {'rule', $r, 'str', $s, 'from', $f, 'to', $t, 'hash', $h};
$self->new($init)};
sub match_describe{my $self=CORE::shift;my $s = ((((((($self->rule . '<') . $self->from) . ',') . $self->to) . ',\'') . $self->str) . '\',{');
for($self->hash->keys()->flatten){
my $k = $_;
my $v = $self->hash->{$k};
my $vs = 'undef';
if(::defined($v)) {
($vs = $v->match_describe())
};
($s = ((((($s . '
  ') . $k) . ' => ') . $self->indent_except_top($vs)) . ','))
};
if($self->hash->keys()->elems()) {
($s = ($s . '
'))
};
($s = ($s . '}>'))};
sub indent{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?!\Z))/, '  ')};
sub indent_except_top{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?<!\A)(?!\Z))/, '  ')};
sub match_string{my $self=CORE::shift;$self->str}; __PACKAGE__->meta->make_immutable();

}
;

{ package ARRAY;
use Moose;
sub match_describe{my $self=CORE::shift;((('[
' . Match->indent($self->map(sub {my($e)=@_;
$e->match_describe()})->join(',
'))) . '
]'))}; __PACKAGE__->meta->make_immutable();

}
;

{ package SCALAR;
use Moose;
sub match_describe{my $self=CORE::shift;(('\'' . $self) . '\'')}; __PACKAGE__->meta->make_immutable();

}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package ARRAY;
use Moose;
sub ir0_describe{my $self=CORE::shift;(('[' . $self->map(sub {my($e)=@_;
$e->ir0_describe()})->join(',')) . ']')}; __PACKAGE__->meta->make_immutable();

}
;

{ package SCALAR;
use Moose;
sub ir0_describe{my $self=CORE::shift;($self . '')}; __PACKAGE__->meta->make_immutable();

}
;

{ package UNDEF;
use Moose;
sub ir0_describe{my $self=CORE::shift;'undef'}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0;
use Moose;

{ package IR0::Base;
use Moose;
; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Base;
use Moose;
extends 'IR0::Base';; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Base;
use Moose;
extends 'IR0::Base';; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Base;
use Moose;
extends 'IR0::Base';; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::CompUnit;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'statements' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
$self->new('match', $match, 'statements', $statements)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__CompUnit($self)};
sub node_name{my $self=CORE::shift;'CompUnit'};
sub field_names{my $self=CORE::shift;['statements']};
sub field_values{my $self=CORE::shift;[$self->statements]};
sub ir0_describe{my $self=CORE::shift;(('CompUnit(' . $self->statements->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Int;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'text' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$text)=@_;
$self->new('match', $match, 'text', $text)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Int($self)};
sub node_name{my $self=CORE::shift;'Val_Int'};
sub field_names{my $self=CORE::shift;['text']};
sub field_values{my $self=CORE::shift;[$self->text]};
sub ir0_describe{my $self=CORE::shift;(('Val_Int(' . $self->text->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::PackageDeclarator;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'kind' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'traits' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$kind,$name,$traits,$block)=@_;
$self->new('match', $match, 'kind', $kind, 'name', $name, 'traits', $traits, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__PackageDeclarator($self)};
sub node_name{my $self=CORE::shift;'PackageDeclarator'};
sub field_names{my $self=CORE::shift;['kind', 'name', 'traits', 'block']};
sub field_values{my $self=CORE::shift;[$self->kind, $self->name, $self->traits, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((((('PackageDeclarator(' . $self->kind->ir0_describe()) . ',') . $self->name->ir0_describe()) . ',') . $self->traits->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Trait;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'verb' => (is => 'rw');;
has 'expr' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$verb,$expr)=@_;
$self->new('match', $match, 'verb', $verb, 'expr', $expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Trait($self)};
sub node_name{my $self=CORE::shift;'Trait'};
sub field_names{my $self=CORE::shift;['verb', 'expr']};
sub field_values{my $self=CORE::shift;[$self->verb, $self->expr]};
sub ir0_describe{my $self=CORE::shift;(((('Trait(' . $self->verb->ir0_describe()) . ',') . $self->expr->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Block;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'statements' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
$self->new('match', $match, 'statements', $statements)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Block($self)};
sub node_name{my $self=CORE::shift;'Block'};
sub field_names{my $self=CORE::shift;['statements']};
sub field_values{my $self=CORE::shift;[$self->statements]};
sub ir0_describe{my $self=CORE::shift;(('Block(' . $self->statements->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Quote;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'concat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$concat)=@_;
$self->new('match', $match, 'concat', $concat)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Quote($self)};
sub node_name{my $self=CORE::shift;'Quote'};
sub field_names{my $self=CORE::shift;['concat']};
sub field_values{my $self=CORE::shift;[$self->concat]};
sub ir0_describe{my $self=CORE::shift;(('Quote(' . $self->concat->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Bit;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'bit' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$bit)=@_;
$self->new('match', $match, 'bit', $bit)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Bit($self)};
sub node_name{my $self=CORE::shift;'Val_Bit'};
sub field_names{my $self=CORE::shift;['bit']};
sub field_values{my $self=CORE::shift;[$self->bit]};
sub ir0_describe{my $self=CORE::shift;(('Val_Bit(' . $self->bit->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Num;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'num' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$num)=@_;
$self->new('match', $match, 'num', $num)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Num($self)};
sub node_name{my $self=CORE::shift;'Val_Num'};
sub field_names{my $self=CORE::shift;['num']};
sub field_values{my $self=CORE::shift;[$self->num]};
sub ir0_describe{my $self=CORE::shift;(('Val_Num(' . $self->num->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Buf;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'buf' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$buf)=@_;
$self->new('match', $match, 'buf', $buf)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Buf($self)};
sub node_name{my $self=CORE::shift;'Val_Buf'};
sub field_names{my $self=CORE::shift;['buf']};
sub field_values{my $self=CORE::shift;[$self->buf]};
sub ir0_describe{my $self=CORE::shift;(('Val_Buf(' . $self->buf->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Char;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'char' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$char)=@_;
$self->new('match', $match, 'char', $char)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Char($self)};
sub node_name{my $self=CORE::shift;'Val_Char'};
sub field_names{my $self=CORE::shift;['char']};
sub field_values{my $self=CORE::shift;[$self->char]};
sub ir0_describe{my $self=CORE::shift;(('Val_Char(' . $self->char->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Undef;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Undef($self)};
sub node_name{my $self=CORE::shift;'Val_Undef'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Val_Undef(' . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Object;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'clazz' => (is => 'rw');;
has 'fields' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$clazz,$fields)=@_;
$self->new('match', $match, 'clazz', $clazz, 'fields', $fields)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Object($self)};
sub node_name{my $self=CORE::shift;'Val_Object'};
sub field_names{my $self=CORE::shift;['clazz', 'fields']};
sub field_values{my $self=CORE::shift;[$self->clazz, $self->fields]};
sub ir0_describe{my $self=CORE::shift;(((('Val_Object(' . $self->clazz->ir0_describe()) . ',') . $self->fields->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Val_Rx;
use Moose;
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'pat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$pat)=@_;
$self->new('match', $match, 'pat', $pat)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Val_Rx($self)};
sub node_name{my $self=CORE::shift;'Val_Rx'};
sub field_names{my $self=CORE::shift;['pat']};
sub field_values{my $self=CORE::shift;[$self->pat]};
sub ir0_describe{my $self=CORE::shift;(('Val_Rx(' . $self->pat->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Seq;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'seq' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$seq)=@_;
$self->new('match', $match, 'seq', $seq)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Seq($self)};
sub node_name{my $self=CORE::shift;'Lit_Seq'};
sub field_names{my $self=CORE::shift;['seq']};
sub field_values{my $self=CORE::shift;[$self->seq]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Seq(' . $self->seq->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Array;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$array)=@_;
$self->new('match', $match, 'array', $array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Array($self)};
sub node_name{my $self=CORE::shift;'Lit_Array'};
sub field_names{my $self=CORE::shift;['array']};
sub field_values{my $self=CORE::shift;[$self->array]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Array(' . $self->array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Hash;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$hash)=@_;
$self->new('match', $match, 'hash', $hash)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Hash($self)};
sub node_name{my $self=CORE::shift;'Lit_Hash'};
sub field_names{my $self=CORE::shift;['hash']};
sub field_values{my $self=CORE::shift;[$self->hash]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Hash(' . $self->hash->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Pair;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
$self->new('match', $match, 'key', $key, 'value', $value)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Pair($self)};
sub node_name{my $self=CORE::shift;'Lit_Pair'};
sub field_names{my $self=CORE::shift;['key', 'value']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_Pair(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_SigArgument;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
has 'type' => (is => 'rw');;
has 'has_default' => (is => 'rw');;
has 'is_named_only' => (is => 'rw');;
has 'is_optional' => (is => 'rw');;
has 'is_slurpy' => (is => 'rw');;
has 'is_multidimensional' => (is => 'rw');;
has 'is_rw' => (is => 'rw');;
has 'is_copy' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy)=@_;
$self->new('match', $match, 'key', $key, 'value', $value, 'type', $type, 'has_default', $has_default, 'is_named_only', $is_named_only, 'is_optional', $is_optional, 'is_slurpy', $is_slurpy, 'is_multidimensional', $is_multidimensional, 'is_rw', $is_rw, 'is_copy', $is_copy)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_SigArgument($self)};
sub node_name{my $self=CORE::shift;'Lit_SigArgument'};
sub field_names{my $self=CORE::shift;['key', 'value', 'type', 'has_default', 'is_named_only', 'is_optional', 'is_slurpy', 'is_multidimensional', 'is_rw', 'is_copy']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value, $self->type, $self->has_default, $self->is_named_only, $self->is_optional, $self->is_slurpy, $self->is_multidimensional, $self->is_rw, $self->is_copy]};
sub ir0_describe{my $self=CORE::shift;(((((((((((((((((((('Lit_SigArgument(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ',') . $self->type->ir0_describe()) . ',') . $self->has_default->ir0_describe()) . ',') . $self->is_named_only->ir0_describe()) . ',') . $self->is_optional->ir0_describe()) . ',') . $self->is_slurpy->ir0_describe()) . ',') . $self->is_multidimensional->ir0_describe()) . ',') . $self->is_rw->ir0_describe()) . ',') . $self->is_copy->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_NamedArgument;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
$self->new('match', $match, 'key', $key, 'value', $value)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_NamedArgument($self)};
sub node_name{my $self=CORE::shift;'Lit_NamedArgument'};
sub field_names{my $self=CORE::shift;['key', 'value']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_NamedArgument(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Code;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'pad' => (is => 'rw');;
has 'state' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'body' => (is => 'rw');;
has 'catch' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$pad,$state,$sig,$body,$catch)=@_;
$self->new('match', $match, 'pad', $pad, 'state', $state, 'sig', $sig, 'body', $body, 'catch', $catch)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Code($self)};
sub node_name{my $self=CORE::shift;'Lit_Code'};
sub field_names{my $self=CORE::shift;['pad', 'state', 'sig', 'body', 'catch']};
sub field_values{my $self=CORE::shift;[$self->pad, $self->state, $self->sig, $self->body, $self->catch]};
sub ir0_describe{my $self=CORE::shift;(((((((((('Lit_Code(' . $self->pad->ir0_describe()) . ',') . $self->state->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->body->ir0_describe()) . ',') . $self->catch->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Object;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'clazz' => (is => 'rw');;
has 'fields' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$clazz,$fields)=@_;
$self->new('match', $match, 'clazz', $clazz, 'fields', $fields)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Object($self)};
sub node_name{my $self=CORE::shift;'Lit_Object'};
sub field_names{my $self=CORE::shift;['clazz', 'fields']};
sub field_values{my $self=CORE::shift;[$self->clazz, $self->fields]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_Object(' . $self->clazz->ir0_describe()) . ',') . $self->fields->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Var;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'sigil' => (is => 'rw');;
has 'twigil' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'namespace' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name,$namespace)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name, 'namespace', $namespace)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Var($self)};
sub node_name{my $self=CORE::shift;'Var'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name', 'namespace']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name, $self->namespace]};
sub ir0_describe{my $self=CORE::shift;(((((((('Var(' . $self->sigil->ir0_describe()) . ',') . $self->twigil->ir0_describe()) . ',') . $self->name->ir0_describe()) . ',') . $self->namespace->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Bind;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'parameters' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$parameters,$arguments)=@_;
$self->new('match', $match, 'parameters', $parameters, 'arguments', $arguments)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Bind($self)};
sub node_name{my $self=CORE::shift;'Bind'};
sub field_names{my $self=CORE::shift;['parameters', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->parameters, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Bind(' . $self->parameters->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Assign;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'parameters' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$parameters,$arguments)=@_;
$self->new('match', $match, 'parameters', $parameters, 'arguments', $arguments)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Assign($self)};
sub node_name{my $self=CORE::shift;'Assign'};
sub field_names{my $self=CORE::shift;['parameters', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->parameters, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Assign(' . $self->parameters->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Proto;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name)=@_;
$self->new('match', $match, 'name', $name)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Proto($self)};
sub node_name{my $self=CORE::shift;'Proto'};
sub field_names{my $self=CORE::shift;['name']};
sub field_values{my $self=CORE::shift;[$self->name]};
sub ir0_describe{my $self=CORE::shift;(('Proto(' . $self->name->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Call;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'hyper' => (is => 'rw');;
has 'method' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$hyper,$method,$arguments)=@_;
$self->new('match', $match, 'invocant', $invocant, 'hyper', $hyper, 'method', $method, 'arguments', $arguments)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Call($self)};
sub node_name{my $self=CORE::shift;'Call'};
sub field_names{my $self=CORE::shift;['invocant', 'hyper', 'method', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->hyper, $self->method, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((((((('Call(' . $self->invocant->ir0_describe()) . ',') . $self->hyper->ir0_describe()) . ',') . $self->method->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Apply;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'code' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$code,$arguments)=@_;
$self->new('match', $match, 'code', $code, 'arguments', $arguments)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Apply($self)};
sub node_name{my $self=CORE::shift;'Apply'};
sub field_names{my $self=CORE::shift;['code', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->code, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Apply(' . $self->code->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Return;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'result' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$result)=@_;
$self->new('match', $match, 'result', $result)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Return($self)};
sub node_name{my $self=CORE::shift;'Return'};
sub field_names{my $self=CORE::shift;['result']};
sub field_values{my $self=CORE::shift;[$self->result]};
sub ir0_describe{my $self=CORE::shift;(('Return(' . $self->result->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::If;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'test' => (is => 'rw');;
has 'body' => (is => 'rw');;
has 'elsif' => (is => 'rw');;
has 'else' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$test,$body,$elsif,$else)=@_;
$self->new('match', $match, 'test', $test, 'body', $body, 'elsif', $elsif, 'else', $else)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__If($self)};
sub node_name{my $self=CORE::shift;'If'};
sub field_names{my $self=CORE::shift;['test', 'body', 'elsif', 'else']};
sub field_values{my $self=CORE::shift;[$self->test, $self->body, $self->elsif, $self->else]};
sub ir0_describe{my $self=CORE::shift;(((((((('If(' . $self->test->ir0_describe()) . ',') . $self->body->ir0_describe()) . ',') . $self->elsif->ir0_describe()) . ',') . $self->else->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::While;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'test' => (is => 'rw');;
has 'body' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$test,$body)=@_;
$self->new('match', $match, 'test', $test, 'body', $body)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__While($self)};
sub node_name{my $self=CORE::shift;'While'};
sub field_names{my $self=CORE::shift;['test', 'body']};
sub field_values{my $self=CORE::shift;[$self->test, $self->body]};
sub ir0_describe{my $self=CORE::shift;(((('While(' . $self->test->ir0_describe()) . ',') . $self->body->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::For;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'expr' => (is => 'rw');;
has 'body' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$expr,$body)=@_;
$self->new('match', $match, 'expr', $expr, 'body', $body)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__For($self)};
sub node_name{my $self=CORE::shift;'For'};
sub field_names{my $self=CORE::shift;['expr', 'body']};
sub field_values{my $self=CORE::shift;[$self->expr, $self->body]};
sub ir0_describe{my $self=CORE::shift;(((('For(' . $self->expr->ir0_describe()) . ',') . $self->body->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Decl;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'decl' => (is => 'rw');;
has 'type' => (is => 'rw');;
has 'var' => (is => 'rw');;
has 'default' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$decl,$type,$var,$default)=@_;
$self->new('match', $match, 'decl', $decl, 'type', $type, 'var', $var, 'default', $default)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Decl($self)};
sub node_name{my $self=CORE::shift;'Decl'};
sub field_names{my $self=CORE::shift;['decl', 'type', 'var', 'default']};
sub field_values{my $self=CORE::shift;[$self->decl, $self->type, $self->var, $self->default]};
sub ir0_describe{my $self=CORE::shift;(((((((('Decl(' . $self->decl->ir0_describe()) . ',') . $self->type->ir0_describe()) . ',') . $self->var->ir0_describe()) . ',') . $self->default->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Sig;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'positional' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$positional)=@_;
$self->new('match', $match, 'invocant', $invocant, 'positional', $positional)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Sig($self)};
sub node_name{my $self=CORE::shift;'Sig'};
sub field_names{my $self=CORE::shift;['invocant', 'positional']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->positional]};
sub ir0_describe{my $self=CORE::shift;(((('Sig(' . $self->invocant->ir0_describe()) . ',') . $self->positional->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Capture;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'array' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$array,$hash)=@_;
$self->new('match', $match, 'invocant', $invocant, 'array', $array, 'hash', $hash)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Capture($self)};
sub node_name{my $self=CORE::shift;'Lit_Capture'};
sub field_names{my $self=CORE::shift;['invocant', 'array', 'hash']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->array, $self->hash]};
sub ir0_describe{my $self=CORE::shift;(((((('Lit_Capture(' . $self->invocant->ir0_describe()) . ',') . $self->array->ir0_describe()) . ',') . $self->hash->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Lit_Subset;
use Moose;
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'base_class' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$base_class,$block)=@_;
$self->new('match', $match, 'name', $name, 'base_class', $base_class, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Lit_Subset($self)};
sub node_name{my $self=CORE::shift;'Lit_Subset'};
sub field_names{my $self=CORE::shift;['name', 'base_class', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->base_class, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Lit_Subset(' . $self->name->ir0_describe()) . ',') . $self->base_class->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Method;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Method($self)};
sub node_name{my $self=CORE::shift;'Method'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Method(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Sub;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Sub($self)};
sub node_name{my $self=CORE::shift;'Sub'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Sub(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Macro;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Macro($self)};
sub node_name{my $self=CORE::shift;'Macro'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Macro(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Coro;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Coro($self)};
sub node_name{my $self=CORE::shift;'Coro'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Coro(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::P5Token;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'regex' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$regex)=@_;
$self->new('match', $match, 'regex', $regex)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__P5Token($self)};
sub node_name{my $self=CORE::shift;'P5Token'};
sub field_names{my $self=CORE::shift;['regex']};
sub field_values{my $self=CORE::shift;[$self->regex]};
sub ir0_describe{my $self=CORE::shift;(('P5Token(' . $self->regex->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Token;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'regex' => (is => 'rw');;
has 'sym' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$regex,$sym)=@_;
$self->new('match', $match, 'name', $name, 'regex', $regex, 'sym', $sym)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Token($self)};
sub node_name{my $self=CORE::shift;'Token'};
sub field_names{my $self=CORE::shift;['name', 'regex', 'sym']};
sub field_values{my $self=CORE::shift;[$self->name, $self->regex, $self->sym]};
sub ir0_describe{my $self=CORE::shift;(((((('Token(' . $self->name->ir0_describe()) . ',') . $self->regex->ir0_describe()) . ',') . $self->sym->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Do;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$block)=@_;
$self->new('match', $match, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Do($self)};
sub node_name{my $self=CORE::shift;'Do'};
sub field_names{my $self=CORE::shift;['block']};
sub field_values{my $self=CORE::shift;[$self->block]};
sub ir0_describe{my $self=CORE::shift;(('Do(' . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Begin;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$block)=@_;
$self->new('match', $match, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Begin($self)};
sub node_name{my $self=CORE::shift;'Begin'};
sub field_names{my $self=CORE::shift;['block']};
sub field_values{my $self=CORE::shift;[$self->block]};
sub ir0_describe{my $self=CORE::shift;(('Begin(' . $self->block->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Use;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'mod' => (is => 'rw');;
has 'perl5' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$mod,$perl5)=@_;
$self->new('match', $match, 'mod', $mod, 'perl5', $perl5)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Use($self)};
sub node_name{my $self=CORE::shift;'Use'};
sub field_names{my $self=CORE::shift;['mod', 'perl5']};
sub field_values{my $self=CORE::shift;[$self->mod, $self->perl5]};
sub ir0_describe{my $self=CORE::shift;(((('Use(' . $self->mod->ir0_describe()) . ',') . $self->perl5->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule;
use Moose;
extends 'IR0::Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule($self)};
sub node_name{my $self=CORE::shift;'Rule'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Rule(' . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Quantifier;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'term' => (is => 'rw');;
has 'quant' => (is => 'rw');;
has 'greedy' => (is => 'rw');;
has 'ws1' => (is => 'rw');;
has 'ws2' => (is => 'rw');;
has 'ws3' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$term,$quant,$greedy,$ws1,$ws2,$ws3)=@_;
$self->new('match', $match, 'term', $term, 'quant', $quant, 'greedy', $greedy, 'ws1', $ws1, 'ws2', $ws2, 'ws3', $ws3)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Quantifier($self)};
sub node_name{my $self=CORE::shift;'Rule_Quantifier'};
sub field_names{my $self=CORE::shift;['term', 'quant', 'greedy', 'ws1', 'ws2', 'ws3']};
sub field_values{my $self=CORE::shift;[$self->term, $self->quant, $self->greedy, $self->ws1, $self->ws2, $self->ws3]};
sub ir0_describe{my $self=CORE::shift;(((((((((((('Rule_Quantifier(' . $self->term->ir0_describe()) . ',') . $self->quant->ir0_describe()) . ',') . $self->greedy->ir0_describe()) . ',') . $self->ws1->ir0_describe()) . ',') . $self->ws2->ir0_describe()) . ',') . $self->ws3->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Or;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'terms' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$terms)=@_;
$self->new('match', $match, 'terms', $terms)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Or($self)};
sub node_name{my $self=CORE::shift;'Rule_Or'};
sub field_names{my $self=CORE::shift;['terms']};
sub field_values{my $self=CORE::shift;[$self->terms]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Or(' . $self->terms->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Concat;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'concat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$concat)=@_;
$self->new('match', $match, 'concat', $concat)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Concat($self)};
sub node_name{my $self=CORE::shift;'Rule_Concat'};
sub field_names{my $self=CORE::shift;['concat']};
sub field_values{my $self=CORE::shift;[$self->concat]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Concat(' . $self->concat->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Subrule;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'metasyntax' => (is => 'rw');;
has 'ident' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$metasyntax,$ident,$capture_to_array)=@_;
$self->new('match', $match, 'metasyntax', $metasyntax, 'ident', $ident, 'capture_to_array', $capture_to_array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Subrule($self)};
sub node_name{my $self=CORE::shift;'Rule_Subrule'};
sub field_names{my $self=CORE::shift;['metasyntax', 'ident', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->metasyntax, $self->ident, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Subrule(' . $self->metasyntax->ir0_describe()) . ',') . $self->ident->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_SubruleNoCapture;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'metasyntax' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$metasyntax)=@_;
$self->new('match', $match, 'metasyntax', $metasyntax)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_SubruleNoCapture($self)};
sub node_name{my $self=CORE::shift;'Rule_SubruleNoCapture'};
sub field_names{my $self=CORE::shift;['metasyntax']};
sub field_values{my $self=CORE::shift;[$self->metasyntax]};
sub ir0_describe{my $self=CORE::shift;(('Rule_SubruleNoCapture(' . $self->metasyntax->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Var;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'sigil' => (is => 'rw');;
has 'twigil' => (is => 'rw');;
has 'name' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Var($self)};
sub node_name{my $self=CORE::shift;'Rule_Var'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Var(' . $self->sigil->ir0_describe()) . ',') . $self->twigil->ir0_describe()) . ',') . $self->name->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Constant;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'constant' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$constant)=@_;
$self->new('match', $match, 'constant', $constant)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Constant($self)};
sub node_name{my $self=CORE::shift;'Rule_Constant'};
sub field_names{my $self=CORE::shift;['constant']};
sub field_values{my $self=CORE::shift;[$self->constant]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Constant(' . $self->constant->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Dot;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Dot($self)};
sub node_name{my $self=CORE::shift;'Rule_Dot'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Rule_Dot(' . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_SpecialChar;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'char' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$char)=@_;
$self->new('match', $match, 'char', $char)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_SpecialChar($self)};
sub node_name{my $self=CORE::shift;'Rule_SpecialChar'};
sub field_names{my $self=CORE::shift;['char']};
sub field_values{my $self=CORE::shift;[$self->char]};
sub ir0_describe{my $self=CORE::shift;(('Rule_SpecialChar(' . $self->char->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Block;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'closure' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$closure)=@_;
$self->new('match', $match, 'closure', $closure)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Block($self)};
sub node_name{my $self=CORE::shift;'Rule_Block'};
sub field_names{my $self=CORE::shift;['closure']};
sub field_values{my $self=CORE::shift;[$self->closure]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Block(' . $self->closure->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_InterpolateVar;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'var' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$var)=@_;
$self->new('match', $match, 'var', $var)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_InterpolateVar($self)};
sub node_name{my $self=CORE::shift;'Rule_InterpolateVar'};
sub field_names{my $self=CORE::shift;['var']};
sub field_values{my $self=CORE::shift;[$self->var]};
sub ir0_describe{my $self=CORE::shift;(('Rule_InterpolateVar(' . $self->var->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_NamedCapture;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'ident' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$ident,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'ident', $ident, 'capture_to_array', $capture_to_array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_NamedCapture($self)};
sub node_name{my $self=CORE::shift;'Rule_NamedCapture'};
sub field_names{my $self=CORE::shift;['rule', 'ident', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->ident, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_NamedCapture(' . $self->rule->ir0_describe()) . ',') . $self->ident->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Before;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'assertion_modifier' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$assertion_modifier,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'assertion_modifier', $assertion_modifier, 'capture_to_array', $capture_to_array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Before($self)};
sub node_name{my $self=CORE::shift;'Rule_Before'};
sub field_names{my $self=CORE::shift;['rule', 'assertion_modifier', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->assertion_modifier, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Before(' . $self->rule->ir0_describe()) . ',') . $self->assertion_modifier->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_After;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'assertion_modifier' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$assertion_modifier,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'assertion_modifier', $assertion_modifier, 'capture_to_array', $capture_to_array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_After($self)};
sub node_name{my $self=CORE::shift;'Rule_After'};
sub field_names{my $self=CORE::shift;['rule', 'assertion_modifier', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->assertion_modifier, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_After(' . $self->rule->ir0_describe()) . ',') . $self->assertion_modifier->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_NegateCharClass;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'chars' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$chars)=@_;
$self->new('match', $match, 'chars', $chars)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_NegateCharClass($self)};
sub node_name{my $self=CORE::shift;'Rule_NegateCharClass'};
sub field_names{my $self=CORE::shift;['chars']};
sub field_values{my $self=CORE::shift;[$self->chars]};
sub ir0_describe{my $self=CORE::shift;(('Rule_NegateCharClass(' . $self->chars->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_CharClass;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'chars' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$chars)=@_;
$self->new('match', $match, 'chars', $chars)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_CharClass($self)};
sub node_name{my $self=CORE::shift;'Rule_CharClass'};
sub field_names{my $self=CORE::shift;['chars']};
sub field_values{my $self=CORE::shift;[$self->chars]};
sub ir0_describe{my $self=CORE::shift;(('Rule_CharClass(' . $self->chars->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
;

{ package IR0::Rule_Capture;
use Moose;
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'position' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$position,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'position', $position, 'capture_to_array', $capture_to_array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rule_Capture($self)};
sub node_name{my $self=CORE::shift;'Rule_Capture'};
sub field_names{my $self=CORE::shift;['rule', 'position', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->position, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Capture(' . $self->rule->ir0_describe()) . ',') . $self->position->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}; __PACKAGE__->meta->make_immutable();

}
; __PACKAGE__->meta->make_immutable();

}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package IRBuild;
use Moose;
has 'constructors' => (is => 'rw');;
($main::irbuilder = IRBuild->new());
sub add_constructor{my $self=CORE::shift;my($k,$constructor)=@_;
if($self->constructors) {

}else {
my $h = {};
$self->constructors($h)
};
($self->constructors->{$k} = $constructor)};
sub make_ir_from_Match_tree{my $self=CORE::shift;my($m)=@_;
my $rule = $m->rule();
my $constructor = $self->constructors->{$rule};
if(($constructor)) {
$constructor->($m)
}else {
::die('Unknown rule: $rule
It needs to be added to ast_handlers.
')
}}; __PACKAGE__->meta->make_immutable();

}
;

{ package Match;
use Moose;
sub make_ir_from_Match_tree{my $self=CORE::shift;$main::irbuilder->make_ir_from_Match_tree($self)}; __PACKAGE__->meta->make_immutable();

}
;

{ package ARRAY;
use Moose;
sub make_ir_from_Match_tree{my $self=CORE::shift;$self->map(sub {my($e)=@_;
$e->make_ir_from_Match_tree()})}; __PACKAGE__->meta->make_immutable();

}
;

{ package SCALAR;
use Moose;
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}; __PACKAGE__->meta->make_immutable();

}
;

{ package UNDEF;
use Moose;
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}; __PACKAGE__->meta->make_immutable();

}
;
sub irbuild_ir{my($x)=@_;
$x->make_ir_from_Match_tree()}
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package IRBuild;
use Moose;
$main::irbuilder->add_constructor('comp_unit', sub {my($m)=@_;
IR0::CompUnit->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('statement', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('expect_term', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__expect_term_base'};local $::es_blackboard__expect_term_base = ::irbuild_ir($m->{'hash'}->{'noun'});
my $post = ($m->{'hash'}->{'post'} || []);
for(($post)->flatten){
($::es_blackboard__expect_term_base = ::irbuild_ir($_))
};
$::es_blackboard__expect_term_base});
$main::irbuilder->add_constructor('post', sub {my($m)=@_;
(::irbuild_ir($m->{'hash'}->{'dotty'}) or ::irbuild_ir($m->{'hash'}->{'postop'}))});
$main::irbuilder->add_constructor('dotty:methodop', sub {my($m)=@_;
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), ::irbuild_ir($m->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'semilist'}))});
$main::irbuilder->add_constructor('dotty:postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), $ident, ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), $ident, ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('term:expect_term', sub {my($m)=@_;
::irbuild_ir($m->{'hash'}->{'noun'})});
$main::irbuilder->add_constructor('term', sub {my($m)=@_;
if(((($m->match_string()) eq 'self'))) {
IR0::Apply->newp($m, 'self', [])
}else {
::die('AST term partially unimplemented.
')
}});
$main::irbuilder->add_constructor('integer', sub {my($m)=@_;
IR0::Val_Int->newp($m, ($m->match_string()))});
$main::irbuilder->add_constructor('subcall', sub {my($m)=@_;
my $t = ::irbuild_ir($m->{'hash'}->{'subshortname'}->{'hash'}->{'twigil'});
if((($t && ($t eq '~')))) {
IR0::Call->newp($m, IR0::Apply->newp($m, 'self', []), ::undef(), ::irbuild_ir($m->{'hash'}->{'subshortname'}->{'hash'}->{'desigilname'}->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'semilist'}))
}else {
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'subshortname'}), ::irbuild_ir($m->{'hash'}->{'semilist'}))
}});
$main::irbuilder->add_constructor('name', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('statement_control:use', sub {my($m)=@_;
IR0::Use->newp($m, ::irbuild_ir($m->{'hash'}->{'module_name'}))});
$main::irbuilder->add_constructor('module_name:depreciated', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('module_name:normal', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('term:listop', sub {my($m)=@_;
my $not_really_an_arglist = ::irbuild_ir($m->{'hash'}->{'arglist'});
if((::irbuild_ir($m->{'hash'}->{'arglist'}))) {
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), [$not_really_an_arglist])
}else {
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), [])
}});
$main::irbuilder->add_constructor('quote:q', sub {my($m)=@_;
IR0::Val_Buf->newp($m, ::irbuild_ir($m->{'hash'}->{'text'}))});
$main::irbuilder->add_constructor('quote:qq', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
$s->re_gsub(qr/(?<!\\)\\n/, '
');
$s->re_gsub(qr/(?<!\\)\\t/, '	');
IR0::Val_Buf->newp($m, $s)});
$main::irbuilder->add_constructor('quote:regex', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
IR0::Val_Rx->newp($m, $s)});
$main::irbuilder->add_constructor('infix', sub {my($m)=@_;
my $op = ($m->match_string());
if((($op eq 'str'))) {
($op = '=')
};
IR0::Apply->newp($m, ('infix:' . $op), [::irbuild_ir($m->{'hash'}->{'left'}), ::irbuild_ir($m->{'hash'}->{'right'})])});
$main::irbuilder->add_constructor('scope_declarator:my', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'my', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:has', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'has', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:our', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'our', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scoped', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('variable_decl', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'variable'}), ::irbuild_ir($m->{'hash'}->{'default_value'})]});
$main::irbuilder->add_constructor('variable', sub {my($m)=@_;
IR0::Var->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'desigilname'}))});
$main::irbuilder->add_constructor('sigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('twigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('circumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
IR0::Apply->newp($m, ('circumfix:' . $name), ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('statement_control:for', sub {my($m)=@_;
IR0::For->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:while', sub {my($m)=@_;
IR0::While->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:if', sub {my($m)=@_;
IR0::If->newp($m, ::irbuild_ir($m->{'hash'}->{'if_expr'}), ::irbuild_ir($m->{'hash'}->{'if_block'}), ::irbuild_ir($m->{'hash'}->{'elsif'}), ::irbuild_ir($m->{'hash'}->{'else'}))});
$main::irbuilder->add_constructor('elsif', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'elsif_expr'}), ::irbuild_ir($m->{'hash'}->{'elsif_block'})]});
$main::irbuilder->add_constructor('if__else', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('pblock', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('block', sub {my($m)=@_;
IR0::Block->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('routine_declarator:routine_def', sub {my($m)=@_;
my $ident = '';
if((::irbuild_ir($m->{'hash'}->{'ident'}))) {
($ident = ::irbuild_ir($m->{'hash'}->{'ident'})->[0])
};
my $sig = IR0::Sig->newp($m, ::undef(), []);
if((::irbuild_ir($m->{'hash'}->{'multisig'}))) {
($sig = ::irbuild_ir($m->{'hash'}->{'multisig'})->[0])
};
IR0::Sub->newp($m, $ident, $sig, ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('routine_declarator:method_def', sub {my($m)=@_;
IR0::Method->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'multisig'})->[0], ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('signature', sub {my($m)=@_;
IR0::Sig->newp($m, ::undef(), ::irbuild_ir($m->{'hash'}->{'parsep'}))});
$main::irbuilder->add_constructor('parameter', sub {my($m)=@_;
IR0::Lit_SigArgument->newp($m, ::irbuild_ir($m->{'hash'}->{'param_var'}))});
$main::irbuilder->add_constructor('param_var', sub {my($m)=@_;
IR0::Var->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('package_declarator:class', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'class';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:module', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'module';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:package', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'package';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_def', sub {my($m)=@_;
IR0::PackageDeclarator->newp($m, $::es_blackboard__package_declarator, ::irbuild_ir($m->{'hash'}->{'module_name'})->[0], ::irbuild_ir($m->{'hash'}->{'traits'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('fulltypename', sub {my($m)=@_;
::join('::', ::irbuild_ir($m->{'hash'}->{'typename'})->flatten())});
$main::irbuilder->add_constructor('typename', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('trait_verb:is', sub {my($m)=@_;
IR0::Trait->newp($m, 'is', ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('circumfix:pblock', sub {my($m)=@_;
if((::not((::irbuild_ir($m->{'hash'}->{'lambda'}) and ::not(::irbuild_ir($m->{'hash'}->{'signature'})))))) {
IR0::Lit_Hash->newp($m, ::irbuild_ir($m->{'hash'}->{'block'}->{'hash'}->{'statementlist'}))
}else {
::die('AST handler circumfix:pblock partially unimplemented')
}}); __PACKAGE__->meta->make_immutable();

}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package SimpleEmit5;
use Moose;
has 'compiler' => (is => 'rw');;
sub prelude{my $self=CORE::shift;my($n)=@_;
'#!/usr/bin/perl -w
package main;
use Perl6::Say;
use autobox; use autobox::Core; use autobox UNDEF => "UNDEF";
use Moose::Autobox;
{package AssertCurrentModuleVersions;
 use Moose 0.40;
 use Moose::Autobox 0.06;
 use autobox 2.23;
 use autobox::Core 0.4;
}

our $a_ARGS = [@ARGV];

{package UNDEF;}
{package UNDEF; sub ref{"UNDEF"}}
{package UNIVERSAL; sub ref{CORE::ref($_[0]) || "SCALAR"} }

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; `cat $file`;}
sub unslurp{
  my($text,$file)=@_; open(F,">$file") or CORE::die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{CORE::system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{CORE::exit(@_)}
sub ::defined{CORE::defined($_[0])}
sub ::substr ($$$){CORE::substr($_[0],$_[1],$_[2])}
sub ::not ($){CORE::not $_[0]}
sub ::exec{CORE::exec(@_)}


# because the p5->p6 massage of ast_handlers isnt massaging join.
sub ::join{CORE::join(CORE::shift,@_)}
# end

{ package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}
}

{ package ARRAY;
# absent from autobox::Core
sub splice { my $a = CORE::shift; [CORE::splice(@{$a},$_[0],$_[1])] }
sub copy { my $a = CORE::shift; [@$a] }
# buggy in autobox::Core
BEGIN{my $x = *ARRAY::unshift; undef &$x;}
sub unshift (\\@;@) { my $a = CORE::shift; CORE::unshift(@$a, @_); $a; }
}

sub parser_name{
  my $f = $0;
  $f =~ s/[^\\/]+$//;
  $f."../STD_red/STD_red_run"
}

our $a_INC = ["."];
sub ::require {
  my($module)=@_;
  my $file = find_required_module($module);
  $file || CORE::die "Cant locate $module in ( ".CORE::join(" ",@$a_INC)." ).\\n";
  eval_file($file);
};
sub ::find_required_module {
  my($module)=@_;
  my @names = ($module,$module.".pm",$module.".p6");
  for my $dir (@$a_INC) {
    for my $name (@names) {
      my $file = $dir."/".$name;
      if(-f $file) {
        return $file;
      }
    }
  }
  return undef;
}

our $compiler0;
our $compiler1;
sub ::eval_file {
  my($file)=@_;
  $compiler0->eval_file($file);
}
sub ::eval_perl6 {
  my($code)=@_;
  $compiler0->eval_perl6($code);
}

package main;
'};
sub e{my $self=CORE::shift;my($x)=@_;
my $ref = $x->ref();
if(($ref eq 'UNDEF')) {
$x
}elsif(($ref eq 'SCALAR')) {
$x
}elsif(($ref eq 'ARRAY')) {
$x->map(sub {my($ae)=@_;
$self->e($ae)})
}else {
$x->callback($self)
}};
sub cb__CompUnit{my $self=CORE::shift;my($n)=@_;
{package main; use vars '$1es_whiteboard__in_package'};local $::es_whiteboard__in_package = [];
((('package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
' . 'use Data::Dumper;
') . $self->e($n->{'statements'})->join(';
')))};
sub cb__Val_Int{my $self=CORE::shift;my($n)=@_;
$self->e($n->{'text'})};
sub cb__Apply{my $self=CORE::shift;my($n)=@_;
if(($n->{'code'} =~ qr/^infix:(.+)$/)) {
my $op = $1;
my $a = $self->e($n->{'arguments'});
my $l = $a->[0];
my $r = $a->[1];
if((($op eq '~'))) {
(((('(' . $l) . ' . ') . $r) . ')')
}elsif((($op eq ','))) {
(($l . ', ') . $r)
}elsif((($op eq '='))) {
my $t = $self->e($n->{'arguments'}->[0]->{'twigil'});
if((($t && ($t eq '.')))) {
((($l . '(') . $r) . ')')
}else {
(((((('(' . $l) . ' ') . $op) . ' ') . $r) . ')')
}
}else {
(((((('(' . $l) . ' ') . $op) . ' ') . $r) . ')')
}
}elsif((($self->e($n->{'code'}) =~ qr/^circumfix:(.+)/))) {
my $op = $1;
my $arg = $self->e(($n->{'arguments'} || []))->join(',');
$op->re_gsub(' ', $arg)
}else {
my $f = $self->e($n->{'code'});
if((($f =~ qr/^\$\w+$/))) {
((($f . '->(') . $self->e($n->{'arguments'})->join(',')) . ')')
}elsif((($f eq 'self'))) {
'$self'
}elsif((($f eq 'last'))) {
'last'
}elsif((($f =~ qr/^\w/))) {
(((('::' . $f) . '(') . $self->e($n->{'arguments'})->join(',')) . ')')
}else {
((($f . '(') . $self->e($n->{'arguments'})->join(',')) . ')')
}
}};
sub cb__Decl{my $self=CORE::shift;my($n)=@_;
if((($n->{'decl'} eq 'has'))) {
my $default = $self->e($n->{'default'});
if((::defined($default))) {
($default = (', default => ' . $default))
}else {
($default = '')
};
(((('has \'' . $self->e($n->{'var'}->{'name'})) . '\' => (is => \'rw\'') . $default) . ');')
}else {
my $default = '';
if($n->{'default'}) {
($default = (' = ' . $self->e($n->{'default'})))
};
if((($n->{'var'}->{'twigil'} eq '^'))) {
my $name = $self->e($n->{'var'});
$name->re_gsub('^(.)::', '$1');
((((((('{package main; use vars \'' . $name) . '\'};') . 'local') . ' ') . $self->e($n->{'var'})) . $default))
}else {
((($n->{'decl'} . ' ') . $self->e($n->{'var'})) . $default)
}
}};
sub cb__Use{my $self=CORE::shift;my($n)=@_;
my $module = $n->{'mod'};
if($self->compiler->hook_for_use($module)) {
''
}else {
'***Unimplemented use()***'
}};
sub cb__Val_Buf{my $self=CORE::shift;my($n)=@_;
my $s = ::eval_perl5('sub{local $Data::Dumper::Terse = 1; Data::Dumper::Dumper($_[0])}')->($n->{'buf'});
$s->chomp();
$s};
sub cb__Val_Rx{my $self=CORE::shift;my($n)=@_;
(('qr/' . $n->{'pat'}) . '/')};
sub cb__Var{my $self=CORE::shift;my($n)=@_;
my $s = $n->{'sigil'};
my $t = ($n->{'twigil'} || '');
my $env = '';
my $pre = '';
if(($t eq '^')) {
($env = 'e')
};
if((($s eq '$') && ($env eq 'e'))) {
($pre = 's_')
};
if(($s eq '@')) {
($pre = 'a_')
};
if(($s eq '%')) {
($pre = 'h_')
};
my $name = (($env . $pre) . $self->e($n->{'name'}));
if((($t eq '.'))) {
('$self->' . $name)
}elsif((($t eq '^'))) {
$name->re_gsub('::', '__');
(('$' . '::') . $name)
}else {
('$' . $name)
}};
sub cb__For{my $self=CORE::shift;my($n)=@_;
(((('for(' . $self->e($n->{'expr'})) . '->flatten){
') . $self->e($n->{'body'})) . '
}')};
sub cb__If{my $self=CORE::shift;my($n)=@_;
my $els = '';
if($n->{'else'}) {
($els = (('else {
' . $self->e($n->{'else'})->[0]) . '
}'))
};
((((((('if(' . $self->e($n->{'test'})) . ') {
') . $self->e($n->{'body'})) . '
}') . $self->e($n->{'elsif'})->map(sub {my($e)=@_;
(((('elsif(' . $e->[0]) . ') {
') . $e->[1]) . '
}')})->join('')) . $els))};
sub cb__While{my $self=CORE::shift;my($n)=@_;
(((('while(' . $self->e($n->{'test'})) . ') {
') . $self->e($n->{'body'})) . '
}')};
sub cb__Block{my $self=CORE::shift;my($n)=@_;
(('' . $self->e($n->{'statements'})->join(';
')) . '')};
sub cb__Sub{my $self=CORE::shift;my($n)=@_;
((((('sub ' . $self->e($n->{'name'})) . '{') . $self->e($n->{'sig'})) . $self->e($n->{'block'})) . '}')};
sub cb__Method{my $self=CORE::shift;my($n)=@_;
((((('sub ' . $self->e($n->{'name'})) . '{my $self=CORE::shift;') . $self->e($n->{'sig'})) . $self->e($n->{'block'})) . '}')};
sub cb__Sig{my $self=CORE::shift;my($n)=@_;
if((($n->{'positional'}->elems() == 0))) {
''
}else {
((('my(' . $self->e($n->{'positional'})->join(',')) . ')=@_;') . '
')
}};
sub cb__Lit_SigArgument{my $self=CORE::shift;my($n)=@_;
$self->e($n->{'key'})};
sub cb__PackageDeclarator{my $self=CORE::shift;my($n)=@_;
{package main; use vars '$1es_whiteboard__in_package'};local $::es_whiteboard__in_package = [$::es_whiteboard__in_package->flatten(), $n->{'name'}];
my $name = $::es_whiteboard__in_package->join('::');
(((((((('
{ package ' . $name) . ';
') . 'use Moose;
') . $self->e(($n->{'traits'} || []))->join('
')) . $self->e($n->{'block'})) . '; __PACKAGE__->meta->make_immutable();
') . '
}
'))};
sub cb__Trait{my $self=CORE::shift;my($n)=@_;
if((($n->{'verb'} eq 'is'))) {
my $name = (($::es_whiteboard__in_package->splice(0, (0 - 1))->join('::') . '::') . $self->e($n->{'expr'}));
(('extends \'' . $name) . '\';')
}else {
::say((('ERROR: Emitting p5 for Trait verb ' . $n->{'verb'}) . ' has not been implemented.
'));
'***Trait***'
}};
sub cb__Call{my $self=CORE::shift;my($n)=@_;
my $method = $self->e($n->{'method'});
if((($method =~ 'postcircumfix:< >'))) {
(((($self->e($n->{'invocant'}) . '->') . '{\'') . $n->{'arguments'}) . '\'}')
}elsif((($method =~ 'postcircumfix:(.*)'))) {
my $op = $1;
my $arg = $self->e(($n->{'arguments'} || []))->join(',');
$op->re_gsub(' ', $arg);
(($self->e($n->{'invocant'}) . '->') . $op)
}else {
((((($self->e($n->{'invocant'}) . '->') . $self->e($n->{'method'})) . '(') . $self->e(($n->{'arguments'} || []))->join(',')) . ')')
}};
sub cb__Lit_Hash{my $self=CORE::shift;my($n)=@_;
(('{' . $self->e(($n->{'hash'} || []))->join(',')) . '}')}; __PACKAGE__->meta->make_immutable();

}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use Data::Dumper;

{ package Program;
use Moose;
sub print_usage_and_die{my $self=CORE::shift;::say('
Usage: [-v] [-c|-x|-xe] [-o OUTPUT_FILE] [-I dir] [ P6_FILE | -e P6_CODE ]+

default Run code.
 -c     Compile code.
 -x     Compile code, and include prelude, creating an executable.
 -xe    Compile code, and include prelude, and run it.

');
::exit(2)};
sub main{my $self=CORE::shift;my($args)=@_;
if(($args->elems() == 0)) {
$self->print_usage_and_die()
};
my $output_file;
my $dont_eval;
my $run_externally;
my $include_prelude = 1;
my $verbose;
my $sources = [];
while($args->elems()) {
my $arg = $args->shift();
if(($arg eq '-v')) {
($verbose = 1)
}elsif(($arg eq '-c')) {
($dont_eval = 1);
($include_prelude = 0)
}elsif(($arg eq '-x')) {
($dont_eval = 1)
}elsif(($arg eq '-xe')) {
($dont_eval = 1);
($run_externally = 1)
}elsif(($arg eq '-o')) {
($output_file = ($args->shift() || $self->print_usage_and_die()))
}elsif(($arg eq '-e')) {
my $p6_code = ($args->shift() || $self->print_usage_and_die());
$sources->push(CompilerSource->new('filename', '-e', 'code', $p6_code))
}elsif(::file_exists($arg)) {
$sources->push(CompilerSource->new('filename', $arg))
}elsif(($arg eq '-I')) {
my $dir = ($args->shift() || $self->print_usage_and_die());
$a_INC->push($dir)
}elsif(($arg eq '--')) {
last
}else {
$self->print_usage_and_die()
}
};
if((::not($dont_eval))) {
$compiler0->eval_sources($sources, $verbose)
}elsif(($run_externally)) {
if((::not($output_file))) {
($output_file = 'deleteme_exe')
};
my $p5_code = $compiler1->compile_sources($sources, $verbose, $include_prelude);
::unslurp($p5_code, $output_file);
::exec('perl', $output_file, $args)
}else {
my $p5_code = $compiler1->compile_sources($sources, $verbose, $include_prelude);
if((::not($output_file))) {
::say($p5_code)
}else {
::unslurp($p5_code, $output_file)
}
}}; __PACKAGE__->meta->make_immutable();

}
;

{ package CompilerSource;
use Moose;
has 'filename' => (is => 'rw');;
has 'code' => (is => 'rw');;
has 'module' => (is => 'rw');; __PACKAGE__->meta->make_immutable();

}
;

{ package Compiler;
use Moose;
sub eval_perl6{my $self=CORE::shift;my($code)=@_;
my $compiler = Compiler->new('is_compiler_for_runtime', 1);
$compiler->eval_sources([CompilerSource->new('code', $code)], 0)};
sub eval_file{my $self=CORE::shift;my($file)=@_;
$self->eval_perl6(::slurp($file))};
has 'is_compiler_for_runtime' => (is => 'rw');;
has 'verbose' => (is => 'rw');;
has 'is_eval' => (is => 'rw');;
sub eval_sources{my $self=CORE::shift;my($sources,$verbose)=@_;
$self->verbose($verbose);
$self->is_eval(1);
my $p5_code = $self->do_tasks($sources);
::eval_perl5($p5_code)};
sub compile_sources{my $self=CORE::shift;my($sources,$verbose,$include_prelude)=@_;
$self->verbose($verbose);
$self->is_eval(0);
my $p5_code = $self->do_tasks($sources);
if($include_prelude) {
($p5_code = (($self->prelude() . '
') . $p5_code))
};
$p5_code};
has 'todo' => (is => 'rw');;
sub do_tasks{my $self=CORE::shift;my($tasks)=@_;
my $p5_code = '';
$self->todo($tasks->copy());
while($self->todo->elems()) {
my $task = $self->todo->shift();
my $p6_code = $task->code();
if(::not(::defined($p6_code))) {
($p6_code = ::slurp($task->filename()))
};
my $p5 = $self->compile($p6_code);
($p5_code = (($p5_code . $p5) . '
;
'))
};
$p5_code};
sub compile{my $self=CORE::shift;my($p6_code)=@_;
::unslurp($p6_code, 'deleteme.p6');
my $parser = ::parser_name();
my $cmd = ($parser . ' -q --format=p5a deleteme.p6 > deleteme.dump');
((::system($cmd) == 0) or ::die('Parse failed.
'));
my $dump5 = ::slurp('deleteme.dump');
my $tree = ::eval_perl5(('package Fastdump;' . $dump5));
if($self->verbose) {
::say($tree->match_describe())
};
my $ir = $tree->make_ir_from_Match_tree();
if($self->verbose) {
::say($ir->ir0_describe())
};
my $p5 = $ir->callback(SimpleEmit5->new('compiler', $self));
if($self->verbose) {
::say($p5)
};
$p5};
sub prelude{my $self=CORE::shift;SimpleEmit5->prelude()};
sub hook_for_use{my $self=CORE::shift;my($module)=@_;
if($self->is_eval) {
::require($module)
}else {
my $filename = (::find_required_module($module) || ::die((((('Didnt find ' . $module) . ' in ( ') . $a_INC->join(' ')) . ' ).
')));
$self->todo->push(CompilerSource->new('filename', $filename))
};
1}; __PACKAGE__->meta->make_immutable();

}
;

{ package Fastdump;
use Moose;
sub match{my($r,$s,$f,$t,$h)=@_;
Match->make($r, $s, $f, $t, $h)}; __PACKAGE__->meta->make_immutable();

}
;
if(::not($compiler0)) {
($compiler0 = Compiler->new('is_compiler_for_runtime', 1))
};
($compiler1 = Compiler->new());
Program->new()->main($a_ARGS)
;
