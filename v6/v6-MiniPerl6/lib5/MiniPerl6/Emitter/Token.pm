# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package Rul; sub new { shift; bless { @_ }, "Rul" } sub constant { my $str = $_[0]; my $len = Main::chars($str, ); do { if (($str eq '\\')) { $str = '\\\\' } else {  } }; do { if (($str eq '\'')) { $str = '\\\'' } else {  } }; do { if ($len) { ('( ( \'' . ($str . ('\' eq substr( $str, $MATCH.to, ' . ($len . (')) ' . ('  ?? (1 + $MATCH.to( ' . ($len . (' + $MATCH.to ))' . ('  !! (0) ' . ')'))))))))) } else { return('1') } } };
package Rul::Quantifier; sub new { shift; bless { @_ }, "Rul::Quantifier" } sub term { @_ == 1 ? ( $_[0]->{term} ) : ( $_[0]->{term} = $_[1] ) }; sub quant { @_ == 1 ? ( $_[0]->{quant} ) : ( $_[0]->{quant} = $_[1] ) }; sub greedy { @_ == 1 ? ( $_[0]->{greedy} ) : ( $_[0]->{greedy} = $_[1] ) }; sub ws1 { @_ == 1 ? ( $_[0]->{ws1} ) : ( $_[0]->{ws1} = $_[1] ) }; sub ws2 { @_ == 1 ? ( $_[0]->{ws2} ) : ( $_[0]->{ws2} = $_[1] ) }; sub ws3 { @_ == 1 ? ( $_[0]->{ws3} ) : ( $_[0]->{ws3} = $_[1] ) }; sub emit { my $self = $_[0]; $_[0]->{term}->emit() };
package Rul::Or; sub new { shift; bless { @_ }, "Rul::Or" } sub or { @_ == 1 ? ( $_[0]->{or} ) : ( $_[0]->{or} = $_[1] ) }; sub emit { my $self = $_[0]; ('do { ' . ('my $pos1 := $MATCH.to(); do{ ' . (Main::join([ map { $_->emit() } @{ $_[0]->{or} } ], '} || do { $MATCH.to( $pos1 ); ') . '} }'))) };
package Rul::Concat; sub new { shift; bless { @_ }, "Rul::Concat" } sub concat { @_ == 1 ? ( $_[0]->{concat} ) : ( $_[0]->{concat} = $_[1] ) }; sub emit { my $self = $_[0]; ('(' . (Main::join([ map { $_->emit() } @{ $_[0]->{concat} } ], ' && ') . ')')) };
package Rul::Subrule; sub new { shift; bless { @_ }, "Rul::Subrule" } sub metasyntax { @_ == 1 ? ( $_[0]->{metasyntax} ) : ( $_[0]->{metasyntax} = $_[1] ) }; sub emit { my $self = $_[0]; my $meth = ((1 + index($_[0]->{metasyntax}, '.')) ? $_[0]->{metasyntax} : ('$grammar.' . $_[0]->{metasyntax})); ('do { ' . ('my $m2 := ' . ($meth . ('($str, $MATCH.to); ' . ('if $m2 { $MATCH.to( $m2.to ); $MATCH{\'' . ($_[0]->{metasyntax} . ('\'} := $m2; 1 } else { 0 } ' . '}'))))))) };
package Rul::SubruleNoCapture; sub new { shift; bless { @_ }, "Rul::SubruleNoCapture" } sub metasyntax { @_ == 1 ? ( $_[0]->{metasyntax} ) : ( $_[0]->{metasyntax} = $_[1] ) }; sub emit { my $self = $_[0]; my $meth = ((1 + index($_[0]->{metasyntax}, '.')) ? $_[0]->{metasyntax} : ('$grammar.' . $_[0]->{metasyntax})); ('do { ' . ('my $m2 := ' . ($meth . ('($str, $MATCH.to); ' . ('if $m2 { $MATCH.to( $m2.to ); 1 } else { 0 } ' . '}'))))) };
package Rul::Var; sub new { shift; bless { @_ }, "Rul::Var" } sub sigil { @_ == 1 ? ( $_[0]->{sigil} ) : ( $_[0]->{sigil} = $_[1] ) }; sub twigil { @_ == 1 ? ( $_[0]->{twigil} ) : ( $_[0]->{twigil} = $_[1] ) }; sub name { @_ == 1 ? ( $_[0]->{name} ) : ( $_[0]->{name} = $_[1] ) }; sub emit { my $self = $_[0]; my $table = { '$' => '$','@' => '$List_','%' => '$Hash_','&' => '$Code_', }; ($table->{$_[0]->{sigil}} . $_[0]->{name}) };
package Rul::Constant; sub new { shift; bless { @_ }, "Rul::Constant" } sub constant { @_ == 1 ? ( $_[0]->{constant} ) : ( $_[0]->{constant} = $_[1] ) }; sub emit { my $self = $_[0]; my $str = $_[0]->{constant}; Rul::constant($str) };
package Rul::Dot; sub new { shift; bless { @_ }, "Rul::Dot" } sub emit { my $self = $_[0]; ('( (\'\' ne substr( $str, $MATCH.to, 1 )) ' . ('  ?? (1 + $MATCH.to( 1 + $MATCH.to ))' . ('  !! (0) ' . ')'))) };
package Rul::SpecialChar; sub new { shift; bless { @_ }, "Rul::SpecialChar" } sub char { @_ == 1 ? ( $_[0]->{char} ) : ( $_[0]->{char} = $_[1] ) }; sub emit { my $self = $_[0]; my $char = $_[0]->{char}; do { if (($char eq 'n')) { my $rul = Rul::SubruleNoCapture->new( 'metasyntax' => 'newline', );$rul = $rul->emit();return($rul) } else {  } }; do { if (($char eq 'N')) { my $rul = Rul::SubruleNoCapture->new( 'metasyntax' => 'not_newline', );$rul = $rul->emit();return($rul) } else {  } }; do { if (($char eq 'd')) { my $rul = Rul::SubruleNoCapture->new( 'metasyntax' => 'digit', );$rul = $rul->emit();return($rul) } else {  } }; do { if (($char eq 's')) { my $rul = Rul::SubruleNoCapture->new( 'metasyntax' => 'space', );$rul = $rul->emit();return($rul) } else {  } }; return(Rul::constant($char)) };
package Rul::Block; sub new { shift; bless { @_ }, "Rul::Block" } sub closure { @_ == 1 ? ( $_[0]->{closure} ) : ( $_[0]->{closure} = $_[1] ) }; sub emit { my $self = $_[0]; ('do { ' . ('my $ret := ( sub {' . ('do {' . ($_[0]->{closure} . ('}; ' . ('\'974^213\' } ).();' . ('if $ret ne \'974^213\' {' . ('$MATCH.capture( $ret ); ' . ('return $MATCH;' . ('};' . ('1' . '}'))))))))))) };
package Rul::InterpolateVar; sub new { shift; bless { @_ }, "Rul::InterpolateVar" } sub var { @_ == 1 ? ( $_[0]->{var} ) : ( $_[0]->{var} = $_[1] ) }; sub emit { my $self = $_[0]; Main::say(('# TODO: interpolate var ' . ($_[0]->{var}->emit() . ''))); die() };
package Rul::NamedCapture; sub new { shift; bless { @_ }, "Rul::NamedCapture" } sub rule { @_ == 1 ? ( $_[0]->{rule} ) : ( $_[0]->{rule} = $_[1] ) }; sub ident { @_ == 1 ? ( $_[0]->{ident} ) : ( $_[0]->{ident} = $_[1] ) }; sub emit { my $self = $_[0]; Main::say(('# TODO: named capture ' . ($_[0]->{ident} . (' := ' . ($_[0]->{rule}->emit() . ''))))); die() };
package Rul::Before; sub new { shift; bless { @_ }, "Rul::Before" } sub rule { @_ == 1 ? ( $_[0]->{rule} ) : ( $_[0]->{rule} = $_[1] ) }; sub emit { my $self = $_[0]; ('do { ' . ('my $tmp := $MATCH; ' . ('$MATCH := ::MiniPerl6::Perl5::Match( \'str\' => $str, \'from\' => $tmp.to, \'to\' => $tmp.to ); ' . ('$MATCH.bool( ' . ($_[0]->{rule}->emit() . ('); ' . ('$tmp.bool( ?$MATCH ); ' . ('$MATCH := $tmp; ' . '}')))))))) };
package Rul::NotBefore; sub new { shift; bless { @_ }, "Rul::NotBefore" } sub rule { @_ == 1 ? ( $_[0]->{rule} ) : ( $_[0]->{rule} = $_[1] ) }; sub emit { my $self = $_[0]; ('do { ' . ('my $tmp := $MATCH; ' . ('$MATCH := ::MiniPerl6::Perl5::Match( \'str\' => $str, \'from\' => $tmp.to, \'to\' => $tmp.to ); ' . ('$MATCH.bool( ' . ($_[0]->{rule}->emit() . ('); ' . ('$tmp.bool( !$MATCH ); ' . ('$MATCH := $tmp; ' . '}')))))))) };
package Rul::NegateCharClass; sub new { shift; bless { @_ }, "Rul::NegateCharClass" } sub chars { @_ == 1 ? ( $_[0]->{chars} ) : ( $_[0]->{chars} = $_[1] ) }; sub emit { my $self = $_[0]; Main::say('TODO NegateCharClass'); die() };
package Rul::CharClass; sub new { shift; bless { @_ }, "Rul::CharClass" } sub chars { @_ == 1 ? ( $_[0]->{chars} ) : ( $_[0]->{chars} = $_[1] ) }; sub emit { my $self = $_[0]; Main::say('TODO CharClass'); die() }
;
1;
