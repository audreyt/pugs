Index: src/UTF8.hs
===================================================================
--- src/UTF8.hs	(revision 18880)
+++ src/UTF8.hs	(working copy)
@@ -105,8 +105,8 @@
 #if defined(__GLASGOW_HASKELL__)
         -- * Low level construction
         -- | For constructors from foreign language types see /Data.ByteString/
-        packAddress,            -- :: Addr# -> ByteString
-        unsafePackAddress,      -- :: Int -> Addr# -> ByteString
+--WV: deprecated        packAddress,            -- :: Addr# -> ByteString
+        unsafePackAddress,      -- :: Int -> Addr# -> ByteString -- WV: now IO ByteString
 #endif

         -- simple list-using functions
@@ -186,16 +186,21 @@
                        ,getContents, putStr, putStrLn
                        ,readFile, {-mmapFile,-} writeFile
                        ,hGetContents, hGet, hPut
-                       ,copy, copyCString, copyCStringLen
+                       --,copy, copyCString, copyCStringLen
+                       ,copy, packCString, packCStringLen
                        ,singleton
                        )

-import Data.ByteString.Base
-                       ( ByteString(..), unsafeUseAsCString, unsafeUseAsCStringLen, unsafeCreate, memcpy
+import Data.ByteString.Internal
+                       ( ByteString(..), unsafeCreate, memcpy
+			)
+import Data.ByteString.Unsafe
+                       (  unsafeUseAsCString, unsafeUseAsCStringLen
+                        ,unsafePackAddress
                        )
 import Data.ByteString.Char8
                        (getLine, hGetLine, hGetNonBlocking
-                       ,packAddress, unsafePackAddress
+--                       ,packAddress, unsafePackAddress
                        ,useAsCStringLen, useAsCString
                        )

@@ -219,6 +224,14 @@
 #define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
 #define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined

+-- WV
+copyCString str = do
+                        nstr <-  (packCString str)
+                        return $ copy nstr
+copyCStringLen str = do
+                        nstr <-  (packCStringLen str)
+                        return $ copy nstr
+
 newline, space :: Word8
 newline = 0x0A
 space   = 0x20
Index: src/Pugs/Prim.hs
===================================================================
--- src/Pugs/Prim.hs	(revision 18880)
+++ src/Pugs/Prim.hs	(working copy)
@@ -553,7 +553,8 @@
         { threadId      = tid
         , threadLock    = lock
         }
-    return undef
+--    return undef
+
 op1 "listen" = \v -> do
     port    <- fromVal v
     socket  <- guardIO $ listenOn (PortNumber $ fromInteger port)
Index: src/Pugs/AST/Internals/Instances.hs
===================================================================
--- src/Pugs/AST/Internals/Instances.hs	(revision 18880)
+++ src/Pugs/AST/Internals/Instances.hs	(working copy)
@@ -112,9 +112,22 @@
         return (Map.fromList [ (cast k, v) | (k, v) <- list ])
 instance Typeable a => YAML (IVar a) where
     asYAML x = asYAML (MkRef x)
+
+instance YAML VMultiCode where
+    fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
+	"MkMultiCode" -> do
+	    let ESeq [aa, ab, ac, ad, ae] = e
+	    liftM5 MkMultiCode (fromYAML aa) (fromYAML ab) (fromYAML ac) (fromYAML ad) (fromYAML ae)
+	_ -> fail $ "unhandled tag: " ++ show t ++ ", expecting " ++ show ["MkMultiCode"] ++ " in node " ++ show e
+    fromYAML e = fail $ "no tag found: expecting " ++ show ["MkMultiCode"] ++ " in node " ++ show e
+    asYAML (MkMultiCode aa ab ac ad ae) = asYAMLseq "MkMultiCode"
+	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae]
+
+fromTypeableVMC :: forall a . (Typeable a) => a -> Maybe VMultiCode
+fromTypeableVMC = fromTypeable
 instance YAML VRef where
     asYAML (MkRef (ICode cv))
-        | Just mc <- fromTypeable cv = do
+        | Just mc <- fromTypeableVMC cv = do
             mcC <- asYAML (mc :: VMultiCode)
             return $ mkTagNode (tagHs "VMultiCode") $ ESeq [mcC]
         | otherwise = do
@@ -715,7 +728,7 @@
     fromYAML e = fail $ "no tag found: expecting " ++ show ["MkCompUnit"] ++ " in node " ++ show e
     asYAML (MkCompUnit aa ab ac ad) = asYAMLseq "MkCompUnit"
 	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad]
-
+{-
 instance YAML VMultiCode where
     fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
 	"MkMultiCode" -> do
@@ -725,7 +738,7 @@
     fromYAML e = fail $ "no tag found: expecting " ++ show ["MkMultiCode"] ++ " in node " ++ show e
     asYAML (MkMultiCode aa ab ac ad ae) = asYAMLseq "MkMultiCode"
 	   [asYAML aa, asYAML ab, asYAML ac, asYAML ad, asYAML ae]
-
+-}
 instance YAML VJunc where
     fromYAML MkNode{n_tag=Just t, n_elem=e} | 't':'a':'g':':':'h':'s':':':tag <- unpackBuf t = case tag of
 	"MkJunc" -> do
Index: src/Pugs/AST/Internals.hs
===================================================================
--- src/Pugs/AST/Internals.hs	(revision 18880)
+++ src/Pugs/AST/Internals.hs	(working copy)
@@ -2085,7 +2085,7 @@
     asYAML x = asYAML (MkRef x)
 instance YAML VRef where
     asYAML (MkRef (ICode cv))
-        | Just mc <- fromTypeable cv = do
+        | Just mc :: VMultiCode <- fromTypeable cv = do
             mcC <- asYAML (mc :: VMultiCode)
             return $ mkTagNode (tagHs "VMultiCode") $ ESeq [mcC]
         | otherwise = do
Index: src/Pugs/AST/Pad.hs
===================================================================
--- src/Pugs/AST/Pad.hs	(revision 18880)
+++ src/Pugs/AST/Pad.hs	(working copy)
@@ -75,12 +75,15 @@
 adjustPad :: (PadEntry -> PadEntry) -> Var -> Pad -> Pad
 adjustPad f v (MkPad p) = MkPad (Map.adjust f v p)

+fromTypeableVMC :: forall a . (Typeable a) => a -> Maybe VMultiCode
+fromTypeableVMC = fromTypeable
+
 mergePadEntry :: PadEntry -> PadEntry -> PadEntry
 mergePadEntry
     PEConstant{ pe_proto = MkRef (ICode newCV), pe_flags = flags }
     PEConstant{ pe_proto = MkRef (ICode oldCV) }
-    | Just newMC <- fromTypeable newCV
-    , Just oldMC <- fromTypeable oldCV
+    | Just newMC <- fromTypeableVMC newCV
+    , Just oldMC <- fromTypeableVMC oldCV
     = PEConstant
         { pe_type  = mc_type newMC -- XXX - Select a narrower type?
         , pe_proto = MkRef . ICode $! MkMultiCode
Index: src/Pugs/Monads.hs
===================================================================
--- src/Pugs/Monads.hs	(revision 18880)
+++ src/Pugs/Monads.hs	(working copy)
@@ -249,9 +249,12 @@
             }
 recloseCode vcode = return vcode

+fromTypeableVC :: forall a . (Typeable a) => a -> Maybe VCode
+fromTypeableVC = fromTypeable
+
 recloseRef :: VRef -> STM VRef
 recloseRef (MkRef (ICode cv))
-    | Just vcode <- fromTypeable cv = do
+    | Just vcode <- fromTypeableVC cv = do
         vcode'   <- recloseCode vcode
         return . MkRef . ICode $ vcode'
 recloseRef ref = return ref
Index: src/Pugs/AST.hs
===================================================================
--- src/Pugs/AST.hs	(revision 18880)
+++ src/Pugs/AST.hs	(working copy)
@@ -45,6 +45,10 @@
 import Pugs.Meta ()
 import Pugs.Class (Boxable(..), ResponderInterface(..), Invocant(..), AnyResponder(..), MethodInvocation(..), ivDispatch)

+
+fromTypeableVMC :: forall a . (Typeable a) => a -> Maybe VMultiCode
+fromTypeableVMC = fromTypeable
+
 instance Value (Val.Val) where
     fromVV = return
     fromSV = return . mkVal
@@ -195,7 +199,7 @@
                 }
             merge _ old = case old of
                 PEConstant{ pe_proto = MkRef (ICode oldCV) }
-                    | Just mc <- fromTypeable oldCV -> protoEntry
+                    | Just mc <- fromTypeableVMC oldCV -> protoEntry
                         { pe_proto = MkRef . ICode $ protoCode
                             { mc_assoc      = code_assoc c `mappend` code_assoc mc
                             , mc_variants   = Set.insert var (mc_variants mc)
@@ -473,9 +477,13 @@
 __ITEM__ :: Call
 __ITEM__ = cast "ITEM"

+
+fromTypeableVC :: forall a . (Typeable a) => a -> Maybe VCode
+fromTypeableVC = fromTypeable
+
 readCodesFromRef :: VRef -> Eval [VCode]
 readCodesFromRef (MkRef (ICode c))
-    | Just mc <- fromTypeable c = do
+    | Just mc <- fromTypeableVMC c = do
         let names@(pivot:_) = Set.elems (mc_variants mc)
         rvs <- fmap concat . forM names $ \var -> do
             ref  <- fromVal =<< readVar var
@@ -486,7 +494,7 @@
             if not (defined cvGlobal) then return rvs else do
                 rvsGlobal <- readCodesFromRef =<< fromVal cvGlobal
                 return (rvsGlobal ++ rvs)
-    | Just cv <- fromTypeable c = return [cv]
+    | Just cv <- fromTypeableVC c = return [cv]
 readCodesFromRef ref = do
     code <- fromVal =<< readRef ref
     readCodesFromRef (MkRef (ICode (code :: VCode)))
Index: src/Pugs/Eval.hs
===================================================================
--- src/Pugs/Eval.hs	(revision 18880)
+++ src/Pugs/Eval.hs	(working copy)
@@ -14,7 +14,7 @@
 thereby evaluating the program.

 The AST is represented as a hierarchy of nested 'Exp' expressions
-(see "Pugs.AST").  Some understanding of 'Exp' and "Pugs.AST" in will help in
+(see "Pugs.AST").  Some understanding of 'Exp' and "Pugs.AST" will help in
 understanding this module.
 -}

@@ -184,7 +184,7 @@
 evalRef :: VRef -> Eval Val
 evalRef ref = do
     if refType ref == (mkType "Thunk") then forceRef ref else do
-    val <- catchT $ \esc -> do
+    val <- catchT $ \(esc :: Val -> Eval ()) -> do
         MkEnv{ envContext = cxt, envLValue = lv } <- ask
         let typ = typeOfCxt cxt
             isCollectionRef = isaType "List" (refType ref)
@@ -207,7 +207,7 @@
             isUndefinedVal VUndef   = True
             isUndefinedVal VType{}  = True
             isUndefinedVal _        = False
-            -- Here we ensutre "my Hash $x" can only vivify into Hash no matter how it's asked.
+            -- Here we ensure "my Hash $x" can only vivify into Hash no matter how it's asked.
             typ' = case val of
                 VType t -> t
                 _       -> typ
@@ -1483,11 +1483,11 @@
                 (True, False)   -> do
                     --- not scalarRef! -- use the new "transparent IType" thing!
                     case showType (typeOfSigilVar var) of
-                        "Hash"  -> ($ v) . fix $ \redo x -> case x of
+                        "Hash"  -> ($ v) . fix $ \(redo::Val->Eval Val) x -> case x of
                             VRef (MkRef (IHash h)) -> return (VRef $ hashRef h)
                             VRef ref@(MkRef IScalar{}) -> redo =<< readRef ref
                             _ -> fmap (VRef . hashRef) (fromVal v :: Eval VHash)
-                        "Array" -> ($ v) . fix $ \redo x -> case x of
+                        "Array" -> ($ v) . fix $ \(redo::Val->Eval Val) x -> case x of
                             VRef (MkRef (IArray a)) -> return (VRef $ arrayRef a)
                             VRef ref@(MkRef IScalar{}) -> redo =<< readRef ref
                             _ -> fmap (VRef . arrayRef) (fromVal v :: Eval VArray)
Index: src/Pugs/Compile.hs
===================================================================
--- src/Pugs/Compile.hs	(revision 18880)
+++ src/Pugs/Compile.hs	(working copy)
@@ -73,12 +73,13 @@
         return $ concat entries'
         where
         entries = sortBy padSort [ (cast var, readPadEntry ref) | (var, ref) <- padToList pad ]
+        canCompile :: ([Char],Eval VRef) -> Eval [PIL_Decl] -- WV
         canCompile (name@('&':_), sym) = do
-            ref <- sym
+            ref <- sym
             case ref of
-                MkRef ICode{} -> do
-                    codes <- readCodesFromRef ref
-                    fmap concat $ forM codes (doCode name)
+                MkRef ICode{} -> do
+                    codes <- readCodesFromRef (ref :: VRef)
+                    fmap concat $ forM codes (doCode (name :: String))
                 MkRef (IScalar sv) | scalar_iType sv == mkType "Scalar::Const"
                     -> doCode name =<< fromVal =<< scalar_fetch sv
                 _ -> return []
Index: Makefile.PL
===================================================================
--- Makefile.PL	(revision 18880)
+++ Makefile.PL	(working copy)
@@ -250,7 +250,7 @@
     # set up install path for third-party modules
     mkdir File::Spec->catdir('third-party', 'installed');

-    compile_hs($ghc, 'Setup', $setup);
+    compile_hs($ghc,'Setup', $setup);
     compile_hs($ghc, File::Spec->catfile('util', 'ghc-pkg-wrapper'), $ghc_pkg_wrapper);
     compile_hs($ghc, File::Spec->catfile('util', 'runcompiler'), $ghc_wrapper);

@@ -967,6 +967,7 @@
         close TMP;
         system(
             $ghc, @_,
+#	    "-L/usr/local/lib/", "-lreadline",
             "--make", "-v0",
             -o => "$temp.exe",
             "$temp.hs"
Index: misc/runpugs/bin/perl_repl.pl
===================================================================
--- misc/runpugs/bin/perl_repl.pl	(revision 18880)
+++ misc/runpugs/bin/perl_repl.pl	(working copy)
@@ -14,4 +14,4 @@

 my $repl = new Repl {subref=>$subref,prompt=>$prompt,motd=>$motd};

-$repl->run();
+$repl->run("\n");
Index: SLAVES
===================================================================
--- SLAVES	(revision 18880)
+++ SLAVES	(working copy)
@@ -10,9 +10,13 @@
 autosmoke on feather                    agentzh
 evalbot                                 diakopter
 irc logs                                moritz, <moritz at faui2k3 dot org>
-run.pugscode.org                        andara
+run.pugscode.org                        andara, <andara at feather dot perl6 dot nl>
 smartlinks                              agentzh
 svnbot6                                 diakopter
 devbot6                                 diakopter
+<<<<<<< .mine
 specbot6                                diakopter
+=======
+specbot6                                diakopter
 exp_evalbot                             moritz
+>>>>>>> .r17615
Index: util/build_pugs.pl
===================================================================
--- util/build_pugs.pl	(revision 18880)
+++ util/build_pugs.pl	(working copy)
@@ -490,7 +490,7 @@

     $push_pkgs->('Pugs'); #"-$version";

-    @_ = ('--make', @pkgs, qw(-optl-Lthird-party/installed -o ), "$out.new", qw( src/Main.hs ), @libs);
+    @_ = ('-L/usr/local/lib/','-lreadline','--make', @pkgs, qw(-optl-Lthird-party/installed -o ), "$out.new", qw( src/Main.hs ), @libs);
     #@_ = (@pkgs, qw(-idist/build -Ldist/build -idist/build/src -Ldist/build/src -o pugs src/Main.hs), @libs);
     print "*** Building: ", join(' ', $ghc, @_), $/;
     system $ghc, @_;
