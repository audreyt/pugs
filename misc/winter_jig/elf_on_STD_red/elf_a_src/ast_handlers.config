comp_unit
CompUnit.new($m<statementlist>)

statement
*1*

expect_term
local $blackboard::expect_term_base = $m<noun>;
for my $post (@{$m->{hash}{post}||[]}) {
  $blackboard::expect_term_base = ir($post)
}
$blackboard::expect_term_base

post
*1*

dotty:methodop
Call.new($blackboard::expect_term_base,undef,$m<ident>,$m<semilist>)

dotty:postcircumfix
my $s = *text*;
my $name = substr($s,0,1).' '.substr($s,-1,1); # XXX :(
my $ident = "postcircumfix:".$name;
Call.new($blackboard::expect_term_base,undef,$ident,$m<kludge_name>)


term:expect_term
$m<noun>

integer
Val_Int.new(*text*)

subcall
Apply.new($m<subshortname>,$m<semilist>)

name
$m<ident>

statement_control:use
Use.new($m<module_name>)

module_name:depreciated
*text*

module_name:normal
*text*

term:listop
Apply.new($m<ident>,[$m<arglist>])

quote:q
Val_Buf.new($m<text>)

quote:qq
Val_Buf.new($m<text>)

infix
Apply.new("infix:".*text*,[$m<left>,$m<right>])

scope_declarator:my
my $vd = $m<scoped>;
Decl.new('my',undef,$vd->[0],$vd->[1])

scoped
*1*

variable_decl
[$m<variable>,$m<default_value>]

variable
Var.new($m<sigil>,$m<twigil>,$m<desigilname>)

sigil
*text*

twigil
*text*

circumfix
my $s = *text*;
my $name = substr($s,0,1).' '.substr($s,-1,1); # XXX :(
Apply.new("circumfix:".$name,$m<kludge_name>)

statement_control:if
If.new($m<if_expr>,$m<if_block>,$m<elsif>,$m<else>)

elsif
[$m<elsif_expr>,$m<elsif_block>]

if__else
*1*

pblock
*1*

block
Block.new($m<statementlist>)

routine_declarator:routine_def
my $ident = $m<ident> ? $m<ident>->[0] : "";
my $sig = $m<multisig> ? $m<multisig>->[0] : Sig.new(undef,[]);
Sub.new($ident,$sig,$m<block>)

routine_declarator:method_def
Method.new($m<ident>,$m<multisig>->[0],$m<block>)

signature
Sig.new(undef,$m<parsep>)

parameter
Lit_SigArgument.new($m<param_var>)

param_var
Var.new($m<sigil>,$m<twigil>,$m<ident>)

package_declarator:class
PackageDeclarator.new('class',$m<package_def><module_name>->[0],$m<package_def><block>)

fulltypename
join("::",@{$m<typename>})

typename
$m<name>
