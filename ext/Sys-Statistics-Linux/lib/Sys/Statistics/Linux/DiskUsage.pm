=begin pod

=head1 NAME

Sys::Statistics::Linux::DiskUsage - Collect linux disk usage.

=head1 SYNOPSIS

   use Sys::Statistics::Linux::DiskUsage;

   my $lxs   = Sys::Statistics::Linux::DiskUsage.new;
   my %stats = $lxs.get;

=head1 DESCRIPTION

Sys::Statistics::Linux::DiskUsage gathers the disk usage with the command C<df>.

For more informations read the documentation of the front-end module L<Sys::Statistics::Linux>.

=head1 DISK USAGE INFORMATIONS

Generated by F</bin/df -kP>.

   total       -  The total size of the disk.
   usage       -  The used disk space in kilobytes.
   free        -  The free disk space in kilobytes.
   usageper    -  The used disk space in percent.
   mountpoint  -  The moint point of the disk.

=head1 METHODS

=head2 new()

Call C<new()> to create a new object.

   my $lxs = new Sys::Statistics::Linux::DiskUsage;

=head2 get()

Call C<get()> to get the statistics. C<get()> returns the statistics as a hash.

   my %stats = $lxs.get;

=head1 EXAMPLES

    my $lxs = Sys::Statistics::Linux::DiskUsage.new;
    my $header = 0;

     while ( 1 ) {
        sleep(1);
        my %stats = $lxs.get;
        my $time  = localtime();

        if $header == 0 {
            $header = 20;
            print  ' ' x 20;
            printf "%-20s%16s%16s%16s%16s%20s\n", <disk total usage free usageper mountpoint>;
        }

        for %stats.keys.sort -> $disk {
            my %cstat := %stats{$disk};
            printf "%04d-%02d-%02d %02d:%02d:%02d %-20s%16s%16s%16s%16s%20s\n",
                   $time.<year month day hour min sec>, $disk,
                   %cstat<total usage free usageper mountpoint>;
        }

        $header--;
    }

=head1 EXPORTS

No exports.

=head1 SEE ALSO

B<df(1)>

=head1 REPORTING BUGS

Please report all bugs to <jschulz.cpan(at)bloonix.de>.

=head1 AUTHOR

Jonny Schulz <jschulz.cpan(at)bloonix.de>.

=head1 COPYRIGHT

Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.

This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=end pod

#package Sys::Statistics::Linux::DiskUsage;
#our $VERSION = '0.04';

class Sys::Statistics::Linux::DiskUsage-0.001;

use v6-alpha;

#use strict;
#use warnings;
#use Carp qw(croak);

sub croak (*@m) { die @m } # waiting for Carp::croak

#sub new {
#   my $class = shift;
#   my %self = (
#      cmd => {
#         df => '/bin/df -kP',
#      }
#   );
#   return bless \%self, $class;
#}

has Hash $.cmd = {};

submethod BUILD () {
    $.cmd<df> = '/bin/df -kP';
}

#sub get {
#   my $self  = shift;
#   my $class = ref $self;
#   my $cmd   = $self->{cmd};
#   my (%disk_usage, $disk_name);
#
#   open my $fh, "$cmd->{df}|" or croak "$class: unable to execute '$cmd->{df}' ($!)";
#
#   # filter the header
#   {my $null = <$fh>;}
#
#   while (my $line = <$fh>) {
#      next unless $line =~ /^(.+?)\s+(.+)$/ && !$disk_name;
#      @{$disk_usage{$1}}{qw(
#         total
#         usage
#         free
#         usageper
#         mountpoint
#      )} = (split /\s+/, $2)[0..4];
#      $disk_usage{$1}{usageper} =~ s/%//;
#   }
#
#   close($fh);
#   return \%disk_usage;
#}

method get () {
    my $cmd = self.cmd<df>;
    my %disk_usage;

    my $diskfh = Pipe::open($cmd, :r) or croak("unable to execute $cmd: $!");

    # filter the header
    {$diskfh.readline};

    for =$diskfh -> $line {
        next unless $line ~~ /(.+?)\s+(.+)$/;
        my %d := %disk_usage{$0};
        %d<total usage free usageper mountpoint> = (~$1).comb;
        %d<usageper> ~~ s/%//;
    }

    $diskfh.close;
    return %disk_usage;
}

1;
