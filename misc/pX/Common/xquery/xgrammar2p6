#!/usr/bin/perl
use strict;

use XML::Parser;
use Term::ANSIColor qw(:constants);
use Attribute::Handlers;
use Data::Dumper;
my $parser = new XML::Parser();
my %context = (choice=>0,atomify=>0);
my %atomic = ();
$parser->setHandlers(
	Char=>sub {
		my ($expat,$string) = @_;	
		return if $string =~ /^\s*$/;
		return if $context{description};
		print quotemeta($string);
	},
	Start=>sub {
		my ($expat,$element,%attrs) = @_;	
		$element =~ s/^g://;
		my $sub = $main::{$element};
		unless (defined $sub) {
			die "no $element";
			return;
		}
		if ($context{choice}>0) {
			print "|" unless $context{first_choice};
			$context{first_choice} = 0 if $context{first_choice};
		}
		if ($context{atomify}>0 and !$atomic{$element}) {
			print "[";
		}
		no strict 'refs';

		&{$sub};
	},
	End=>sub {
		my ($expat,$element,%attrs) = @_;	
		$element =~ s/^g://;
		my $sub = $main::{$element."_"};
		unless (defined $sub) {
			warn "no ${element}_";
			return;
		}

		no strict 'refs';
		&{$sub};

		if ($context{atomify}>0 and !$atomic{$element}) {
			print "]";
		}
	},
	Comment=>sub {}
);
$parser->parsefile(shift);

sub closed :ATTR {
	no strict 'refs';
	my ($package,$symbol) = @_;
	my $name = *{$symbol}{NAME} . "_";
	*{$name} = sub {};
}
sub atom :ATTR {
	no strict 'refs';
	my ($package,$symbol) = @_;
	my $name = *{$symbol}{NAME};
	$atomic{$name} = 1;
}

sub token {
	my ($expat,$name,%attr) = @_;
	print "rule $attr{name} {"
}
sub token_  {
	my ($expat,$name,%attr) = @_;
	print "}\n"
}
sub production {
	my ($expat,$name,%attr) = @_;
	print "rule $attr{name} {"
}
sub production_  {
	my ($expat,$name,%attr) = @_;
	print "}\n"
}
sub ignore {
	warn "ignoring: @_\n";
	for (@_) {
		$main::{$_} = sub {};
		$main::{$_ . "_"} = sub {};
	}
}


## atoms
sub ref :closed :atom {
	my ($expat,$name,%attr) = @_;
	print "<$attr{name}>";
} 
sub string :atom {
}
sub string_ {
}

### control flow
sub choice {
	$context{choice}++;
	$context{first_choice} = 1;
}
sub choice_ {
	$context{choice}--;
}
sub sequence :atom {
	$context{choice}--;
}
sub sequence_  {
	$context{choice}++;
}
sub quantifier {
	my %tmp = @_;
	while (my ($name,$symbol) = each %tmp) {
		$main::{$name} = sub {
			$context{atomify}++
		};
		$main::{$name."_"} = sub {
			print $symbol;
			$context{atomify}--;
		};
	}
}
INIT { quantifier(qw(
zeroOrMore *
oneOrMore  +
optional   ?
))} 

sub optionalSkip :atom :closed {print " <S>* "}
sub requiredSkip :atom :closed {print " <S>+ "}

# XXX skip
INIT { ignore qw(skip) }
# XXX character classes
INIT { ignore qw(complement char charRange charClass charCodeRange charCode) }

## things I don't understand and/or don't know how to translate 
sub description {
	$context{description}++;
}
sub description_ {
	$context{description}--;
}


INIT { ignore qw(exposition-production primary transition-default state start language grammar tref transition state-list ) }

# XXX OpTable

INIT {ignore qw(binary exprProduction prefix postfix level)}
=for later
}

### charackter classes
sub close_bracket {
	warn "\t\tclosing bracket:$_[0]";
	print "]" if $context{open_bracket};
}
sub open_bracket {
	print "[" unless $context{open_bracket};
	$context{open_bracket}++;
}
sub charRange {
	my ($expat,$name,%attr) = @_;
	close_bracket();
	print "[$attr{minChar}..$attr{maxChar}]";
}
sub charClass {
	$context{charClass}++;
	print "<"
}
sub charClass_ {
	close_bracket();
	$context{charClass}--;
	print ">"
}
sub char {
	if ($context{charClass}) {
		open_bracket;
	} else {
		print "<'";
	}
}
sub char_ {
	print "'>" unless $context{charClass};
}
### XXX: complete those

sub charCode {}
sub charCode_ {}
sub charCodeRange {}
sub charCodeRange_ {}

sub char {}
sub char_ {}
