
class EmitSM0P {

  method new_emitter($ignore,$compiler,$ignore2,$filename) {
    self.new('compiler',$compiler,'filename',$filename);
  };

  has $.SEQ = 1;
  has $.compiler;
  has $.filename;

  method tidy($source) {
      $source;
  }

  method prelude_lexical () {
      "# prelude lexical\n"
  }

  method prelude ($n) { "# prelude\n" }

  method e($x,$arg) {
    my $ref = $x.WHAT;
    if $ref eq 'Undef' { $x }
    elsif $ref eq 'Str' || $ref eq 'Int' || $ref eq 'Num' { $x }
    elsif $ref eq 'Array' { $x.map(sub($ae){$.e($ae,self.genid)}) }
    else {$x.callback(self,$arg)}
  }

  method genid () {
      # i'm not lazy to fix methods to be lvalues
      self.SEQ = self.SEQ + 1;
      return 'id'~self.SEQ;
  }
  method cb__CompUnit ($n) {
      "# this is autogenerated sm0p code\n" ~ ";\n" ~ $.e($n.statements).join(';');
  }
  method capturize($arguments,$id) {
    my $positionals = $arguments.keys.map(sub($k) {'`pos_'~$id~"_"~$k}).join(',');
    "SMOP__SLIME__Capturize.new(`i_" ~ $id ~ ",(" ~ $positionals ~ "),(),1)";
  }
  method cb__Call ($n,$ret) {
      my $id = self.genid;
      my $positionals = "";
      my $arguments = $n.capture.arguments;
      if ($arguments.elems == 1 && $arguments[0].isa("IRx1::Apply") && $arguments[0].function eq "infix:,") {
          $arguments = $arguments[0].capture.arguments;
      }
      for $arguments.keys -> $i {
          $positionals = $positionals ~ $.e($arguments[$i],"pos_"~$id~"_"~$i);
      }
      #"# method call " ~ $id ~ "\n" ~
      $.e($n.invocant,'i_'~$id) ~
      'ic_'~$id~': $SMOP__SLIME__CurrentFrame.copy(`i_' ~ $id ~ ");\n" ~
      'id_'~$id~': q:identifier['~$n.method.re_gsub(rx:P5/\]/,"\\]") ~"];\n" ~
      $positionals ~
      '$SMOP__SLIME__CurrentFrame.move_responder(`ic_' ~ $id ~ ",3);\n" ~
      '$SMOP__SLIME__CurrentFrame.move_identifier(`id_' ~ $id ~ ",2);\n" ~
      '$SMOP__SLIME__CurrentFrame.move_capturize('~self.capturize($arguments,$id)~");\n" ~
      $ret ~ ": ;\n"
  }
  method cb__Apply ($n,$ret) {
      my $id = self.genid;
      if ($n.function eq 'return') {
          my $arguments = $n.capture.arguments;
          my $positionals = "";
          for $arguments.keys -> $i {
              $positionals = $positionals ~ $.e($arguments[$i],"pos_"~$id~"_"~$i);
          }
          'i_' ~ $id ~ ': $continuation;' ~ "\n" ~ 
          $positionals ~
          '$SMOP__SLIME__CurrentFrame.move_capturize('~self.capturize($arguments,$id)~");\n" ~
          $ret ~ ': $continuation.$SMOP__ID__setr();' ~ "\n"
      }
  }

  method cb__Buf ($n,$label) {
      $label ~ ": " ~ '"' ~ $n.buf.re_gsub(/\n/,"\\n") ~ '"' ~ ";\n"; #TODO: quote \ and "
  }
  method cb__NumInt ($n,$label) {
      $label ~ ": " ~ $n.text ~ ";\n";
  }
  method cb__SubDecl ($n,$label) {
      $label ~ ": " ~ "q:sm0p {\n"~ $.e($n.block.statements).join(';') ~ "};\n"
  }
  method cb__Var ($n,$label) {
      if $n.sigil eq '$' and $n.twigil ne '*' {
          $label ~ ': $' ~ $n.name ~ ";\n";
      } else {
          $label ~ ': $SMOP__S1P__RootNamespace.q:identifier[postcircumfix:{ }]("' ~ $n.sigil ~ ($n.twigil || '') ~ $n.name ~ '")' ~ ";\n";
      }
  }

}
