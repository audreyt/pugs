### comp_unit 
make (IRx1::CompUnit->new(statements=>$_->{statementlist}->item))
### statementlist 
 make ([map { ref $_->item ? $_->item : '#' . $_->item } @{$_->{statement}}])
### statement control
make ($_->{statement_control}->item) 
### statement expr
            make (EXPR($_->{EXPR}))
        
### statement_control:use 
make(IRx1::Use->new(module_name=>$_->{module_name}->item))
### noun 

        for my $key (keys %{$_}) {
            next if $key =~ /^_|^sigil$/;
            make ($_->{$key}->item);
        }
    
### arglist 

        if ($_->{EXPR}{infix} && $_->{EXPR}{infix}->item eq ',') {
            make (IRx1::Capture->new(arguments=>[map {$_->{noun}{''}} @{$_->{EXPR}{list}}]));
        } else {
            make (IRx1::Capture->new(arguments=>[EXPR($_->{EXPR})]));
        }

### scope_declarator:my 

        my $vd = $_->{scoped}{declarator}{variable_declarator};
        if ($vd) {
            make (IRx1::VarDecl->new(var=>$vd->{variable}->item,scope=>'my',default_expr=>EXPR($vd->{EXPR}[0])));
        }

### variable 
make (IRx1::Var->new(sigil=>$_->{sigil}[0]->item,name=>$_->{desigilname}->item))
### value 
 make (quote($_->{quote})) if $_->{quote};
### term:name listop args
make (IRx1::Apply->new(function=>$_->{longname}->item,capture=>$_->{arglist}->item));
