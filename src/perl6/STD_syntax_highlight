#!/usr/local/bin/perl

use STD;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
use strict;
use warnings;
use English;
use Getopt::Long;
use File::Slurp;

my $nocolor = 0;
my $horizontal = 0;
my $yaml = 0;
my $mark_arrays;
my $clean_html = 0;
GetOptions(
    "nocolor"=>\$nocolor,
    "horizontal"=>\$horizontal,
    "yaml"=>\$yaml,
    "mark-arrays"=>\$mark_arrays,
    "clean-html"=>\$clean_html);
unless ($#ARGV <= 0) {
    die "USAGE: [--nocolor --horizontal --mark-arrays --clean-html] filename [rule]\n";
}
if ($nocolor) {
    $DumpMatch::NOCOLOR = 1;
}
my $file = shift;
my $what = shift // 'comp_unit';

my $r = STD->parsefile($file,$what);

=item highlight_match
=cut
sub highlight_match {
    my $name = shift;
    my $r = shift;
    my $opt = shift || {};
    my $events = [];
    traverse_match($r,$name,0,$events,$opt);
    highlight_perl6(${$r->{_orig}},$events,$opt);
}

# CSS color table
my %css_classes = (
    "comp_unit"             => "blue",
    "scope_declarator"	    => "red",
    "routine_declarator"	=> "red",
    "regex_declarator"      => "red",
    "statement_control"     => 'red',
    "block"                 => "black",
    "regex_block"           => "black",
    "noun"                  => "black",
    "sigil" 			    => "darkgreen",
    "variable"  		    => "green",
    "assertion"             => "green",
    "quote" 			    => "orange",	
    "number"                => "orange",
    "infix"                 => "grey",
);

=item highlight_perl6
=cut
sub highlight_perl6 {
    my ($orig,$events,$opt) = @_;
    my $str = "";
    my $at = 0;
    my $indent=0;
    my $css = "";
    foreach my $css_class ( sort keys %css_classes ) {
       my $css_color = $css_classes{$css_class};
       $css .= (" " x 4) . ".$css_class { color: $css_color; }\n";
    }

    # slurp libraries and javascript to inline them
    my ($JQUERY_JS,$JS) = ("jquery-1.2.6.pack.js", "STD_syntax_highlight.js");
    my $jquery_js = qq{<script type="text/javascript" src="$JQUERY_JS"></script>};
    my $js = qq{<script type="text/javascript" src="$JS"></script>};
    if(!$clean_html) {
        $jquery_js = read_file($JQUERY_JS) 
            or die "Error while slurping file: $OS_ERROR\n";    
        $js = read_file($JS) 
            or die "Error while slurping file: $OS_ERROR\n";    
        $jquery_js = qq{<script type="text/javascript">\n$jquery_js\n</script>};
        $js = qq{<script type="text/javascript">\n$js\n</script>};
    }

    $str .= <<HTML;
<html>
<head>
    <title>$PROGRAM_NAME $file</title>
    <style type="text/css">
$css
    #parseTreeOutput { 
        position:absolute; 
        right: 10px; 
        top: 10px; 
        width: 40%; 
        font-family: Verdana;
        color: black; 
        background-color: white; 
    }   
    </style>    
    $jquery_js
    $js
</head>
<body>
	<div id="parseTreeOutput"></div>
    <pre>
HTML
 																	
    for (sort {$a->[0] <=> $b->[0] or $a->[4] <=> $b->[4]} @{$events}) {
        my $text = substr($orig,$at,$_->[0]-$at);
        $str .= escape_html($text);
        $at = $_->[0];
    
        if ($_->[1] eq 'from') {
                $str .= '<span class="'.$_->[2].'">';
        } elsif ($_->[1] eq 'to') {
                $str .=  '</span>';
        }
    }
    
    $str .= <<HTML;
    </pre>
</body>
</html>
HTML

    $str;
}

=item escape_html
=cut
sub escape_html {
    my $str = shift;
    my %esc = (
        '<'     => '&lt;',
        '>'     => '&gt;',
        '"'     => '&quot;',
        '&'     => '&amp;'
    );
    my $re = join '|', map quotemeta, keys %esc;
    $str =~ s/($re)/$esc{$1}/g;
    return $str;
}

print highlight_match($what=>$r,{}),"\n";

