#!/usr/bin/perl
# This file was mechanically written.  Your changes to it will be overwritten.
#line 3 head.pl
use strict;
use warnings;
#line 1 Match.pm
# This code was originally taken from yet_another_regex_engine/Regexp_ModuleA.pm,
# r20138.
{ package Match;
  sub new {
    my($cls)=@_;
    my $h = {
      from    => undef,
      to      => undef,
      result  => undef,
      bool => 1,
      str  => "",
      array   => [],
      hash    => {},
      };
    my $o = \$h;
    bless $o,$cls;
  }
  sub from { shift->{from} }
  sub to { shift->{from} }

  sub match_string { shift->{str} }
  sub match_array { shift->{array}||[] }
  sub match_hash { shift->{hash} }
  sub match_boolean { shift->{bool} }
  sub match_value { undef }
  sub match_describe {
    my($o,$verbosity)=@_;
    my $vp = $verbosity;
    my $os = $o->match_string;
    if($verbosity > 1) {
      $os = $o->match__indent_except_top($os) if $os =~ /\n/;
    } else {
      $os =~ s/\n/\\n/g;
      $os =~ s/\t/\\t/g;
      if(length($os) > 60) {
        $os = substr($os,0,30).' ... '.substr($os,-30);
      }
    }
    my $s = $o->match__describe_name_as($verbosity);
    $s .= "<".($o->match_boolean?"1":"0").",\"$os\",[";
    for my $v (@{$o->match_array}) {
      my $vs = "";
      if(ref($v) eq 'ARRAY') {
        $vs = "[\n".$o->match__indent(join(",\n",map{
          $_->match_describe($vp)
          }@$v))."\n]";
      } else {
        $vs = $v->match_describe($vp);
      }
      $s .= "\n".$o->match__indent($vs).",";
    }
    $s .= "\n " if @{$o->match_array};
    $s .= "],{";
    for my $k (keys(%{$o->match_hash})) {
      my $v = $o->match_hash->{$k};
      my $vs = "";
      if(ref($v) eq 'ARRAY') {
        $vs = "[\n".$o->match__indent(join(",\n",map{
          $_->match_describe($vp)
          }@$v))."\n]";
      } elsif(!ref($v)) {
        $vs = $v;
      } else {
        $vs = $v->match_describe($vp);
      }
      $s .= "\n  $k => " .$o->match__indent_except_top($vs).",";
    }
    $s .= "\n " if %{$o->match_hash};
    $s .= "},";
    my($from,$to)=($o->from,$o->to);
    $from = "" if !defined $from;
    $to   = "" if !defined $to;
    $s .= "$from,$to";
    my $val = $o->match_value;
    $s .= defined $val ? ",$val" : "";
    $s .= ">";
    return $s;
  }
  sub match__indent {my($o,$s)=@_; $s =~ s/^(?!\Z)/  /mg; $s}
  sub match__indent_except_top {my($o,$s)=@_; $s =~ s/^(?<!\A)(?!\Z)/  /mg; $s}
  sub match__describe_name_as {
    my($o,$verbosity)=@_;
    return "" if not $verbosity;
    my $s = "";
    $s .= $o->{rule} if defined $o->{rule};
    $s = overload::StrVal($o).'{'.$s.'}' if $verbosity > 1;
    $s;
  }
}
#line 1 main.pl
{ package Program;
  use YAML::Syck;

  sub new {
    my($cls)=@_;
    bless {},$cls;
  }
  sub print_usage_and_exit {
    my $usage = "
Usage: [-c] [-o OUTPUT_FILE] [ P6_FILE | -e P6_CODE ]

";
    print STDERR $usage;
    exit(2);
  }
  sub main {
    my($self,$argv)=@_;
    $self->print_usage_and_exit() if !@$argv;
    my($p6_code,$output_file,$compile);
    while(my $arg = shift(@$argv)) {
      if($arg eq '-c') {
        $compile = 1;
      }
      elsif($arg eq '-o') {
        $output_file = shift(@$argv) || $self->print_usage_and_exit();
      }
      elsif($arg eq '-e') {
        $p6_code = shift(@$argv) || $self->print_usage_and_exit();
      }
      elsif(-f $arg) {
        $p6_code = `cat $arg`;
      }
      else {
        $self->print_usage_and_exit();
      }
    }
    my $yaml = $self->parse(undef,$p6_code);
    print $yaml;
    my $tree = YAML::Syck::Load($yaml);
    if(!$tree) {
      exit(1);
    }
    print $tree->match_describe(1),"\n";
  }
  sub parse {
    my($self,$p6_file,$p6_code)=@_;
    $p6_code ||= `cat $p6_file`;
    my $std_red_from_root = "misc/STD_red/STD_red_run";
    my $std_red_from_src = "../../../$std_red_from_root";
    my $std_red;
    if(-f $std_red_from_src) {
      $std_red = $std_red_from_src;
    } else {
      die "The environment variable PUGS_ROOT must be defined.\n"
          if !exists($ENV{PUGS_ROOT});
      $std_red = $ENV{PUGS_ROOT}."/".$std_red_from_root;
    }
    my $file = $p6_file;
    if(!$file) {
      use File::Temp qw/ tempfile /;
      my($fh,$fname) = tempfile();
      print $fh $p6_code;
      close($fh);
      $file = $fname;
    }
    my $cmd = "$std_red -q --yaml $file";
    my $yaml = `$cmd` or die "Parse failed. $!\n";
    $yaml;
  }
}
Program->new()->main(\@ARGV);
