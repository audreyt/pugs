======================
 Tree Transformations
======================

Match expressions
=================

Conditions on nodes, access to other nodes. Two kind of accessors:
node accessors (return node lists), scalar accessors (return other
types)

\?????

root().children()[name = 'stuff'].attributes()[value = 'boo'].name

Rule finding
============

Each rule has a name, a matching expression, and a priority.

No two rules can have the same name-match-prio.

Given a node and a name, the rule to use is the one with that
name, whose matching expression matches the node, and with the highest
priority.

Processing Model
================

Context: node, node list, position, variables?

Run the code. You can select nodes by matching. You can call *named*
transformations on node lists.

The "matching" here is different than the matching while selecting
rules. The matching expression for rules evals to a boolean. The
matching here evals to a node list.

Ideas from Ruoso
================

- OUTER like caller
- remove "current node list" - not really useful, and prevents
  in-place transforms
- ignore surface syntax, just ship it
- kill priority, esplicitly call sub-rules in order?
  ::

     rule Main matches {*} {
       SubRule1(_) || SubRule2(_)
     }
     rule SubRule1 matches {foo} { # do something }
     rule SubRule2 matches {bar} { # do something }

