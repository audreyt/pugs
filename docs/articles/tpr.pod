=head1 TITLE

Run Perl 6 Today!

=head1 BLURB

For a while, you could have thought Perl 6 was vaporware. It isn't. You
can install Pugs and run Perl 6 programs in five minutes.

(This isn't a module; It's an article to appear in the December 2005
issue of I<The Perl Review>.)

=head1 BODY

Perl 6 is an incredibly fun language to play with. It isn't finished
yet, and in fact for a while it looked like it would take forever to
arrive. But thanks to the Pugs project, you can try it out right now
and start hacking Perl 6 straight away.

=head2 First things first

[[ This section could be placed in a sidebar. If so, the previous
paragraph should point to it. ]]

If you're on *nix, one of these commands should get you up to speed:

  apt-get install pugs pugs-doc pugs-modules  # Debian
  pkg_add pugs                                # FreeBSD
  emerge pugs                                 # Gentoo
 
On Windows, you can fetch the PxPerl binary distribution from this site:

  http://www.pxperl.com/?pxperl

If your OS isn't one of the above, or if you want to build pugs yourself,
you'll need the latest GHC compiler from L<http://haskell.org/ghc/>,
and then install L<Perl6::Pugs> via CPAN, like a standard Perl 5
module. Compiling pugs takes a lot of memory, so try this on a strong
machine.

=head2 What's in the box?

You get B<pugs>, the experimental compiler for Perl 6. Along with it come
plenty of short example programs, some modules, and documentation. B<pugs>
can run programs from files and via the B<-e> switch, just like B<perl>,
but it also has an interactive mode which is great for quick things. In
Perl 5, you'd probably run C<perl -de 42> for this; here, just run it with
no parameters. You'll get a welcome banner and a prompt.

[[ The screenshot is optional :-) ]]

  $ pugs
     ______
   /\   __ \
   \ \  \/\ \ __  __  ______  ______     (P)erl6
    \ \   __//\ \/\ \/\  __ \/\  ___\    (U)ser's
     \ \  \/ \ \ \_\ \ \ \/\ \ \___  \   (G)olfing
      \ \__\  \ \____/\ \____ \/\_____\  (S)ystem
       \/__/   \/___/  \/___/\ \/____/
                         /\____/               Version: 6.2.10
                         \/___/    Copyright 2005 by Autrijus Tang
  --------------------------------------------------------------------
   Web: http://pugscode.org/           Email: perl6-compiler@perl.org
  
  Welcome to Pugs -- Perl6 User's Golfing System
  Type :h for help.
  
  Loading Prelude... done.
  pugs>
 
We are now ready to run our canonical first Perl 6 program:

  pugs> say "Hello, world!"
  Hello, world!
  bool::true
  pugs>

The C<say> builtin works just like C<print>, but puts a newline at the
end. You'll find there are many small improvements of this sort. Since
we are in an interactive environment, we also got the result of the
whole expression we'd evaluated; in this case the print was successful,
so it returned a true boolean value. You can also run this program from
the command line. Would it be Perl if you couldn't?

  $ pugs -e 'say "Hello, world!"'
  Hello, world!
  $

If you like OOP, you'd be pleased to see that this works as well:

  "Hello, world!".say;

[[ Not sure the following bit isn't too much of a digression at this
point. I'd like to make the point about lists being candidates for method
invocation but maybe arrange this to come later. ]]

As does this:

  "Hello, world!".split("").join("").say;

Everything can be used like an object in Perl 6. In the last example,
the string is getting the C<split> method invoked on it; the result,
a list, responds to the C<join> method and returns a string, which is
printed by C<say>. Of course, you could spell this in longhand the same
way as you could in Perl 5:

  my $original   = "Hello, world!";
  my @characters = split //, $original;
  my $rejoined   = join "", @characters;
  print $rejoined, "\n";

[[ (EM) this seems overstating it to me... the real P5 equivalent would be:

  print join("",split //,"Hello, world!"),"\n";

]]

[[ (GY) sure. This section needs work; I was steering this towards the
point below that this isn't "just" a chain of builins, it's a chain of
builins dispatched as methods. Leaving for now until I word it better. ]]

  # This code is valid Perl 5 and Perl 6. You will often
  # find Perl 5 code works as is, or with little modification,
  # in Perl 6.)

But aggregates can be treated like objects too, so C<@characters.join("")>
works in Perl 6 where C<< @characters->join("") >> didn't in Perl 5. (Yes,
C<< -> >> is uniformly a dot now.)

[[ End digression. ]]

=head2 Who's this new dog?

[[ XXX: WRITEME ]]

=head2 A Catalog of Cool

Perl 6 offers many cleanups and rationalizations over Perl 5, as well as
some shiny new features. If you've been programming Perl 5 for a while
you may have gotten used to some quirks of the language, so much that
you don't see what the fuss is about and why you'd like to switch. I'll
list just a few things, and limit myself to what Pugs already supports.

=over 4

=item Function signatures

Up until now, subs in Perl didn't have much by way of formal parameter
specification. Sure, this made them very flexible (take a C<@_>
and do whatever you like with it), but it also meant that for fairly
straightforward things like argument validation or default values you
had to write code yourself, or rely on on an external module.

Take the following (Perl 5) code:

  sub make_car {
      my $model = shift || die "no model";
      my $color = shift || "black";
      my $doors = shift || 4;
  
      # ...

Expressing parameters is flexible, yes, but it's also tedious. Even
where there are no default values there can be trouble: for example, if
you decide you don't like multiple calls to C<shift> and consistently
code in this style:

  sub my_func {
      my($foo, $bar, $baz) = @_;
      # ...

Beginners (and insufficiently caffenated late-night hackers) can easily
make either of the following disastrous mistakes:

      my ($foo, $bar, $baz);         # oops, forgot " = @_"

      my ($foo, $bar, $baz) = shift; # oops, used shift() rather than "@_"

      my $single_arg = @_;           # oops, will usually be 1

The Perl 6 compiler has syntax to save you from all this. Here's how
you spell out the car example:

  sub make_car ($model, $color? = "black", Int $doors? = 4) { ... }

This single line does more than the four Perl 5 lines did. First, it
specifies that the function receives three parameters, one of which is
mandatory. The C<?> in C<$black?> and C<$doors?> means they are optional;
in both cases default values are supplied. (You don't have to give one:
the default default is undef.) The C<Int> mark on the last parameter
means calling the function with a non-integer will raise an error. As
you can see, this is an optional feature: you don't have to declare
types everywhere.

How is this make_car used? These are obvious:

[[ (EM) Maybe source code examples should adhere to PBP ?? ]]

  make_car("VW Beetle", "green", 2);
  make_car("Ford Model T");              # black, 4-doored
  make_car();                            # error: model not supplied
  make_car("Fiat", "Red", 3, "sunroof"); # error: too many args

But there's more. Ever used a library that has functions with many
parameters? It can get kind of hard to keep track of their order. This
is why many complex libraries use hashes for named args, but coding up
validation for that is once again tedious. Perl 6 lets I<any> function
be called with named args automatically:

  make_car(doors => 2, model => "VW Beetle")

  $widget.add_accelerator(signal => "clicked",
                          group  => $accel_group,
                          key    => GDK_n,
                          mods   => GDK_MOD1_MASK,
                          flags  => GTK_ACCEL_VISIBLE);

You've probably seen Perl 5 functions that go out of their way to accept
either positional args, or a hash or hashref with named args. There's no
need to do that any more. If you have a function you'll be calling many
times with a changing set of arguments, you can keep them in a hash and
use the "splat" operator to flatten it:

  sub make_many_cars($howmany) {
      my @cars;
      for 1 .. $howmany {         # the parens can be omitted here in Perl 6
          my %car_prefs = get_user_prefs();
          push @cars, make_car(*%car_prefs);
      }
      return @cars;
  }

=item Lightweight closure syntax

Every block potentially acts like a closure in Perl 6, and the syntax
is at once simplified (you don't need to say C<sub> to declare anonymous
pieces of code) and extended to include formal parameters.

  my $beeper = { say "beep!" };   # $beeper is a coderef. No need for "sub".
  $beeper();                      # says "beep!". No p5ish "->" here.

  my $square = -> $x { $x * $x }; # use "->" to introduce args
  my @squares = map $square, 1 .. 10;

Control structures typically take closures, so you can, as in the example
below, iterate with C<for> with more than one element every time. C<zip>
is a function that takes a few lists and returns interleaves their
elements:

  for zip @Xs, @Ys -> $x, $y {
      push @differences, $x - $y;
  }

Of course, this kind of thing is usually better expressed with map,
which can also take more than one element at a time.

  # Infix "¥" means the same thing as "zip"; this is a visual analogy.
  # See the sidebar on Unicode operators for details.
  @differences = map -> $x, $y { $x - $y }, @Xs ¥ @Ys;

There's even a feature for the extremely lazy: formal parameters with
no predeclaration. Variables mentioned in a closure that have the C<^>
secondary sigil (caller "twigil" in Perl 6 speak) are all inferred as
parameters to the block.

  @differences = map { $^x - $^y }, @Xs ¥ @Ys;

How does this compare with Perl 5? If C<@Xs> and C<@Ys> can be assumed to be
the same length, then this isn't too bad, though the explicit subscripting
does make it less elegant:

  @differences = map { $Xs[$_] - $Ys[$_] } 0 .. $#Xs;

If we want to allow for lists of different length, though, we need a
solution that's much more involved:

  sub map2 (&@) {
      my ($code, @list) = @_;
      my @output;
      
      while (@list) {
          my($x, $y) = splice @list, 0, 2;
          push @output, $code->($x, $y);
      }
      
      return @output;
  }
  
  sub zip2 (\@\@) {
      my($Xs, $Ys) = @_;
      my @output;
      for my $i (0 .. max(scalar(@$Xs), scalar(@$Ys))) {
          push @output,
              ($i < scalar(@$Xs) ? $Xs->[$i] : undef),
              ($i < scalar(@$Ys) ? $Ys->[$i] : undef);
      }
      return @output;
  }

  sub max { $_[0] > $_[1] ? $_[0] : $_[1] }

  my @differences = map2 { $_[0] - $_[1] } zip2(@Xs, @Ys);

This took care of throwing undef instead of missing values from the
shorter list, while taking care not to grow the original. It even uses
some fancy prototypes to avoid gratitious syntax (the C<sub> keyword
and reference-taking backslashes). It is much longer than the Perl 6
version, but also less efficient (two temporary copies of the whole data
are created in memory). Since we used prototypes, the utility functions
need to be declared above the actual code (or stowed in a module, of
course). But the strongest point against this is how it isn't extensible;
if you wanted to take the differences of I<three> lists, element by
element, you'd need to write more support code. In Perl 6, you just say

  @differences = map { $^x - $^y - $^z }, @Xs ¥ @Ys ¥ @Zs;

=item Many (but systematically arranged) operators

If non-ASCII operators and parameters that don't need to be declared
haven't blown your mind yet, good. The two-list difference operation
from the last section could also be written like this:[1]

  @differences = @Xs »-« @Ys;

C<< »« >> are "hyperoperators" that take a regular operator and "lift" it to
work on lists. You can still use them when you don't have I<two> lists:

  @halves = @original »/« 2;      # 2 is upgraded to "(2, 2, 2, ...)"

Relatedly, there's a way to "reduce" long expressions such as sums or
products with the C<[]> metaoperator:

  my $sum  = [+] (1, 2, 3, 4);    # 1 + 2 + 3 + 4
  my $prod = [*] (1, 2, 3, 4);    # 1 * 2 * 3 * 4

If these sound a little too abstract, rest assured that they do become
quite handy after you get used to them. Let's introduce two nice and
less funky operators. The first is a new syntax for quoting words,
similar to Perl 5's C<qw>:

  my @suspects = <Hockney McManus Fenster Keaton Verbal>;

Like Perl 5, C<< <...> >> does single-quoting. If you want interpolation,
you can use the C<< «...» >> variant.

The second convenient new operator is C<//>, the "and-if-not-defined" operator.
You'd typically use it like this:

  my $output_file = lookup("output_file") // $DEFAULT_FILENAME;

In Perl 5, you might use C<||> but risk the gotcha of the config value being
set to a file called "C<0>". You'd have to spell this the long way:

  my $output_file = defined lookup("output_file") ?
                            lookup("output_file") : $DEFAULT_FILENAME;

This becomes especially annoying when you want to check in more than
one place (for example, what if you can also get the output file from an
environment variable?). Which brings me to the point of the digression,
which was to suggest that if you had a function to C<interrogate>
a suspect, you could talk to them one by one until you had an answer:

  my $answer = [//] map &interrogate, <Hockney McManus Fenster Keaton Verbal>;

It's important to note that unlike Perl 5, map is I<lazy>, which means
it only "eats up" one element of input as an element of output is
required. In this case, Verbal may not feel the heat at all if (say)
McManus talks.[2]

=item Junctions

=item Cleaned-up OOP

=back

=head2 SIDEBAR: Confused by Unicode?

Perl 6 defines a few operators that aren't ASCII, though they all have
ASCII fallbacks. Here's the current (short) core list:

  Op      Fallback    Meaning
  «...»   <<...>>     Interpolating word quotes
  ¥       Y or &zip   Zip lists together

Since it's easy to add new operators, expect mathematical modules to say things like 
⌈$PI⌉ to mean 4.

[[ Those are Unicode LEFT CEILING and RIGHT CEILING, U+2308 and
U+2309. They look just like square brackets with the lower serifs
sawn off. Sorry about the pain it must be to include this, it's worth
mentioning since this kind of thing is definitely going to show up in
Perl 6 code. ]]

The file C<docs/quickref/unicode> in the pugs distribution explains how
to type Unicode in popular editors.

[[ examples/ ]]

[[ annotated webliography ]]

=head1 FOOTNOTES

[1] Yes, C<<< @Xs »-« @Ys »-« @Zs >>> also works.

[2] C<//> is scheduled for inclusion in perl 5.10. For those interested,
patches are available for existing version all the way back to 5.6.

=head1 AUTHOR INFORMATION

This article was written by Gaal Yahas E<lt>L<gaal@forum2.org>E<gt>
with the help and inspiration of #perl6. It is distributed
under the Creative Commons Attribution-ShareAlike 2.0 license
L<http://creativecommons.org/licenses/by-sa/2.0/>.

Thanks to Eric Hodges and Elizabeth Mattijsen for material suggestions.

=cut
