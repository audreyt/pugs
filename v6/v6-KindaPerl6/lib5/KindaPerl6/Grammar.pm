# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package KindaPerl6::Grammar; sub new { shift; bless { @_ }, "KindaPerl6::Grammar" } use KindaPerl6::Grammar::Regex; use KindaPerl6::Grammar::Mapping; use KindaPerl6::Grammar::Control; my  $Class_name; sub get_class_name { my $List__ = \@_; do { [] }; $Class_name }; sub ident_digit { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { do { my  $pos1 = $MATCH->to(); (do { (do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->word($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || (do { $MATCH->to($pos1); (('_' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } })) } && do { my  $m2 = $grammar->ident_digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } } }); return($MATCH) }; sub ident { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->word($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); (('_' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }) } && do { my  $m2 = $grammar->ident_digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } }); return($MATCH) }; sub full_ident { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) }; sub to_line_end { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->not_newline($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub pod_begin { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->newline($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('=end' eq substr($str, $MATCH->to(), 4)) ? (1 + $MATCH->to((4 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })) } || do { $MATCH->to($pos1); ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $m2 = $grammar->pod_begin($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })) }) }); return($MATCH) }; sub pod_other { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->newline($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('=cut' eq substr($str, $MATCH->to(), 4)) ? (1 + $MATCH->to((4 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })) } || do { $MATCH->to($pos1); ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })) }) }); return($MATCH) }; sub ws { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { ((('#' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->to_line_end($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->newline($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { ((('=begin' eq substr($str, $MATCH->to(), 6)) ? (1 + $MATCH->to((6 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->pod_begin($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); ((('=kwid' eq substr($str, $MATCH->to(), 5)) ? (1 + $MATCH->to((5 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); ((('=pod' eq substr($str, $MATCH->to(), 4)) ? (1 + $MATCH->to((4 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); ((('=for' eq substr($str, $MATCH->to(), 4)) ? (1 + $MATCH->to((4 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || (do { $MATCH->to($pos1); ((('=head1' eq substr($str, $MATCH->to(), 6)) ? (1 + $MATCH->to((6 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->pod_other($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }))))) }) } || do { $MATCH->to($pos1); do { my  $m2 = $grammar->space($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } })) } && do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) }; sub opt_ws { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub opt_ws2 { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub opt_ws3 { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub parse { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->comp_unit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'comp_unit'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->parse($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parse'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'comp_unit'}}, @{${$MATCH->{'parse'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'comp_unit'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub unit_type { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('class' eq substr($str, $MATCH->to(), 5)) ? (1 + $MATCH->to((5 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('grammar' eq substr($str, $MATCH->to(), 7)) ? (1 + $MATCH->to((7 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('role' eq substr($str, $MATCH->to(), 4)) ? (1 + $MATCH->to((4 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('module' eq substr($str, $MATCH->to(), 6)) ? (1 + $MATCH->to((6 + $MATCH->to()))) : 0) }))) }); return($MATCH) }; sub trait_auxiliary { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('i' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || (do { $MATCH->to($pos1); ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))) } || do { $MATCH->to($pos1); ((('m' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('a' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))) })) }); return($MATCH) }; sub class_trait { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->trait_auxiliary($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'trait_auxiliary'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'trait_auxiliary'}}, ${$MATCH->{'full_ident'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub class_traits { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->class_trait($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'class_trait'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->class_traits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'class_traits'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'class_trait'}}, @{${$MATCH->{'class_traits'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'class_trait'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub comp_unit { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && (do { my  $pos1 = $MATCH->to(); (do { ((('use' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('v6-' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })))))) } || do { $MATCH->to($pos1); 1 }) } && do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->unit_type($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'unit_type'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->class_traits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'class_traits'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { $Class_name = ("" . $MATCH->{'full_ident'}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad($Class_name) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(CompUnit->new( 'unit_type' => ${$MATCH->{'unit_type'}},'name' => ${$MATCH->{'full_ident'}},'traits' => ${$MATCH->{'class_traits'}},'attributes' => {  },'methods' => {  },'body' => Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => Sig->new( 'invocant' => (undef),'positional' => [],'named' => {  }, ),'body' => ${$MATCH->{'exp_stmts'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))))))))))) } }))) } || do { $MATCH->to($pos1); do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->exp_stmts2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts2'} = $m2;1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { $Class_name = 'Main'; COMPILER::add_pad($Class_name) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(CompUnit->new( 'unit_type' => 'module','name' => 'Main','traits' => [],'attributes' => {  },'methods' => {  },'body' => Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => Sig->new( 'invocant' => (undef),'positional' => [],'named' => {  }, ),'body' => ${$MATCH->{'exp_stmts2'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) } } }) }); return($MATCH) }; sub infix_op { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('-' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('*' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('/' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('q' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || (do { $MATCH->to($pos1); ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) } || (do { $MATCH->to($pos1); (('==' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('!=' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('&&' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('||' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('~~' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('~' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }))))))))))) }); return($MATCH) }; sub hyper_op { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('>>' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub prefix_op { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $pos1 = $MATCH->to(); (do { (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('@' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('%' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('?' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('!' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('++' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('--' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('+' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('-' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('~' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }))))))))) } && do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }) }); $tmp->bool(($MATCH ? 1 : 0)); $MATCH = $tmp; ($MATCH ? 1 : 0) }) } }); return($MATCH) }; sub declarator { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('my' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('state' eq substr($str, $MATCH->to(), 5)) ? (1 + $MATCH->to((5 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('has' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('our' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) }))) }); return($MATCH) }; sub exp2 { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'exp'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } }); return($MATCH) }; sub exp_stmts2 { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'exp_stmts'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } }); return($MATCH) }; sub exp { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->term_meth($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term_meth'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('??' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('!!' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp2'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Apply->new( 'code' => Var->new( 'sigil' => '&','twigil' => '','name' => 'ternary:<?? !!>', ),'arguments' => [${$MATCH->{'term_meth'}}, ${$MATCH->{'exp'}}, ${$MATCH->{'exp2'}}], )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax error in ternary operation') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) })) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->infix_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'infix_op'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Apply->new( 'code' => Var->new( 'sigil' => '&','twigil' => '','name' => ('infix:<' . ($MATCH->{'infix_op'} . '>')), ),'arguments' => [${$MATCH->{'term_meth'}}, ${$MATCH->{'exp'}}], )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('::=' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $bind = Bind->new( 'parameters' => ${$MATCH->{'term_meth'}},'arguments' => ${$MATCH->{'exp'}}, ); COMPILER::begin_block($bind); return($bind) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((':=' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Bind->new( 'parameters' => ${$MATCH->{'term_meth'}},'arguments' => ${$MATCH->{'exp'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('=' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Assign->new( 'parameters' => ${$MATCH->{'term_meth'}},'arguments' => ${$MATCH->{'exp'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'term_meth'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }))))) }) } }); return($MATCH) }; sub opt_ident { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'ident'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); (1 && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('postcircumfix:<( )>') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) }) }); return($MATCH) }; sub term_meth { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); do { ((('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->hyper_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'hyper_op'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))) } || (do { $MATCH->to($pos1); (((':' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Call->new( 'invocant' => Proto->new( 'name' => ("" . $MATCH->{'full_ident'}), ),'method' => ${$MATCH->{'ident'}},'arguments' => (undef),'hyper' => ${$MATCH->{'hyper_op'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } })) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Call->new( 'invocant' => Proto->new( 'name' => ("" . $MATCH->{'full_ident'}), ),'method' => ${$MATCH->{'ident'}},'arguments' => ${$MATCH->{'exp_seq'}},'hyper' => ${$MATCH->{'hyper_op'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } }) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->term($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { ((('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->hyper_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'hyper_op'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_ident'} = $m2;1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))) } || (do { $MATCH->to($pos1); (((':' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Call->new( 'invocant' => ${$MATCH->{'term'}},'method' => ${$MATCH->{'opt_ident'}},'arguments' => (undef),'hyper' => ${$MATCH->{'hyper_op'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } })) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Call->new( 'invocant' => ${$MATCH->{'term'}},'method' => ${$MATCH->{'opt_ident'}},'arguments' => ${$MATCH->{'exp_seq'}},'hyper' => ${$MATCH->{'hyper_op'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Index->new( 'obj' => ${$MATCH->{'term'}},'index' => ${$MATCH->{'exp'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || (do { $MATCH->to($pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Lookup->new( 'obj' => ${$MATCH->{'term'}},'index' => ${$MATCH->{'exp'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'term'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }))) }) }) }); return($MATCH) }; sub sub_or_method_name { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { ((('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) }; sub opt_type { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $pos1 = $MATCH->to(); (do { (('::' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); 1 }) } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'full_ident'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) } || do { $MATCH->to($pos1); (1 && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) }) }); return($MATCH) }; sub use_from_perl5 { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (((':from<perl5>' eq substr($str, $MATCH->to(), 12)) ? (1 + $MATCH->to((12 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(1) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(0) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub term { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'var'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->prefix_op($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'prefix_op'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Apply->new( 'code' => Var->new( 'sigil' => '&','twigil' => '','name' => ('prefix:<' . ($MATCH->{'prefix_op'} . '>')), ),'arguments' => [${$MATCH->{'exp'}}], )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) } || (do { $MATCH->to($pos1); ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'exp'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || (do { $MATCH->to($pos1); ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_mapping($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_mapping'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Lit::Hash->new( 'hash' => ${$MATCH->{'exp_mapping'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || (do { $MATCH->to($pos1); ((('[' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((']' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Lit::Array->new( 'array' => ${$MATCH->{'exp_seq'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || (do { $MATCH->to($pos1); ((('$' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('<' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->sub_or_method_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sub_or_method_name'} = $m2;1 } else { 0 } } } && ((('>' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Lookup->new( 'obj' => Var->new( 'sigil' => '$','twigil' => '','name' => '/', ),'index' => Val::Buf->new( 'buf' => ${$MATCH->{'sub_or_method_name'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->block1($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'block1'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Do->new( 'block' => ${$MATCH->{'block1'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->use_from_perl5($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'use_from_perl5'} = $m2;1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { ((('-' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Use->new( 'mod' => ${$MATCH->{'full_ident'}},'perl5' => ${$MATCH->{'use_from_perl5'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->val($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->lit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'lit'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->token($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'token'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'token'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->method($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'method'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->subset($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'subset'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { do { if ((${$MATCH->{'subset'}}->name() ne '')) { my  $bind = Bind->new( 'parameters' => Decl->new( 'decl' => 'our','var' => Var->new( 'name' => ${$MATCH->{'subset'}}->name(),'twigil' => '','sigil' => '::', ),'type' => '', ),'arguments' => Subset->new( 'name' => '','base_class' => ${$MATCH->{'subset'}}->base_class(),'block' => ${$MATCH->{'subset'}}->block(), ), );COMPILER::begin_block($bind);return($bind) } else {  } }; return(${$MATCH->{'subset'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->sub($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sub'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { do { if ((${$MATCH->{'sub'}}->name() ne '')) { my  $bind = Bind->new( 'parameters' => Decl->new( 'decl' => 'our','var' => Var->new( 'name' => ${$MATCH->{'sub'}}->name(),'twigil' => '','sigil' => '&', ),'type' => '', ),'arguments' => Sub->new( 'name' => '','block' => ${$MATCH->{'sub'}}->block(), ), );COMPILER::begin_block($bind);return($bind) } else {  } }; return(${$MATCH->{'sub'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->declarator($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'declarator'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->sub($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sub'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { do { if ((${$MATCH->{'sub'}}->name() ne '')) { do { if ((${$MATCH->{'declarator'}} eq 'my')) { $List_COMPILER::PAD->[0]->add_lexicals([Decl->new( 'decl' => ${$MATCH->{'declarator'}},'var' => Var->new( 'name' => ${$MATCH->{'sub'}}->name(),'twigil' => '','sigil' => '&', ),'type' => '', )]);my  $bind = Bind->new( 'parameters' => Var->new( 'name' => ${$MATCH->{'sub'}}->name(),'twigil' => '','sigil' => '&', ),'arguments' => Sub->new( 'name' => '','block' => ${$MATCH->{'sub'}}->block(), ), );COMPILER::begin_block($bind);return($bind) } else {  } };my  $bind = Bind->new( 'parameters' => Decl->new( 'decl' => ${$MATCH->{'declarator'}},'var' => Var->new( 'name' => ${$MATCH->{'sub'}}->name(),'twigil' => '','sigil' => '&', ),'type' => '', ),'arguments' => Sub->new( 'name' => '','block' => ${$MATCH->{'sub'}}->block(), ), );COMPILER::begin_block($bind);return($bind) } else {  } }; Main::print('Error: subroutines with declarators should have a name'); die('Error: subroutines with declarators should have a name') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->declarator($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'declarator'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_type($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_type'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->undeclared_var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'undeclared_var'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { do { if ((${$MATCH->{'declarator'}} eq 'my')) { $List_COMPILER::PAD->[0]->add_lexicals([Decl->new( 'decl' => ${$MATCH->{'declarator'}},'type' => ${$MATCH->{'opt_type'}},'var' => ${$MATCH->{'undeclared_var'}}, )]);return(${$MATCH->{'undeclared_var'}}) } else {  } }; do { if ((${$MATCH->{'declarator'}} eq 'our')) { $List_COMPILER::PAD->[0]->add_lexicals([Decl->new( 'decl' => ${$MATCH->{'declarator'}},'type' => ${$MATCH->{'opt_type'}},'var' => ${$MATCH->{'undeclared_var'}}, )]);return(${$MATCH->{'undeclared_var'}}) } else {  } }; return(Decl->new( 'decl' => ${$MATCH->{'declarator'}},'type' => ${$MATCH->{'opt_type'}},'var' => ${$MATCH->{'undeclared_var'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->begin_block($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'begin_block'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'begin_block'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->check_block($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'check_block'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'check_block'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); ((('i' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { die('not implemented') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || (do { $MATCH->to($pos1); ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { die('not implemented') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->control($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'control'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'control'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->apply($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'apply'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'apply'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) }))))))))))))))))))))) }); return($MATCH) }; sub sigil { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (('$' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('%' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('@' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('&' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }))) }); return($MATCH) }; sub twigil { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $pos1 = $MATCH->to(); (do { (('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('!' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || (do { $MATCH->to($pos1); (('^' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('*' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) }))) } } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub var_name { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } } || (do { $MATCH->to($pos1); (('/' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digit'} = $m2;1 } else { 0 } } } })) }); return($MATCH) }; sub undeclared_var { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->twigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'twigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->var_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var_name'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Var->new( 'sigil' => ("" . $MATCH->{'sigil'}),'twigil' => ("" . $MATCH->{'twigil'}),'name' => ("" . $MATCH->{'var_name'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub var { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->twigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'twigil'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->var_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var_name'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(COMPILER::get_var(("" . $MATCH->{'sigil'}), ("" . $MATCH->{'twigil'}), ("" . $MATCH->{'var_name'}))) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub val { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->val_undef($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_undef'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val_undef'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->val_int($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_int'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val_int'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->val_bit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_bit'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val_bit'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || (do { $MATCH->to($pos1); (do { my  $m2 = $grammar->val_num($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_num'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val_num'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->val_buf($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'val_buf'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'val_buf'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) })))) }); return($MATCH) }; sub val_bit { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('T' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('r' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Bit->new( 'bit' => 1, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || do { $MATCH->to($pos1); ((('F' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('a' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('l' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Bit->new( 'bit' => 0, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))) }) }); return($MATCH) }; sub val_undef { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('f' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('w' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Undef->new(  )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } }); return($MATCH) }; sub val_num { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('TODO: val_num') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub double_quoted { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'} = $m2;1 } else { 0 } } })) } || (do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('"' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'} = $m2;1 } else { 0 } } })) } || do { $MATCH->to($pos1); 1 })) }); return($MATCH) }; sub single_quoted { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('\\' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'} = $m2;1 } else { 0 } } })) } || (do { $MATCH->to($pos1); (do { my  $tmp = $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $tmp->to(),'to' => $tmp->to(),'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } }); $tmp->bool(($MATCH ? 0 : 1)); $MATCH = $tmp; ($MATCH ? 1 : 0) } && ((('' ne substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'} = $m2;1 } else { 0 } } })) } || do { $MATCH->to($pos1); 1 })) }); return($MATCH) }; sub digits { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digits'} = $m2;1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }) } }); return($MATCH) }; sub val_buf { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->double_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'double_quoted'} = $m2;1 } else { 0 } } } && ((('"' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Buf->new( 'buf' => ("" . $MATCH->{'double_quoted'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } || do { $MATCH->to($pos1); ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->single_quoted($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'single_quoted'} = $m2;1 } else { 0 } } } && ((('\'' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Buf->new( 'buf' => ("" . $MATCH->{'single_quoted'}), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) }) }); return($MATCH) }; sub val_int { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digits'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Val::Int->new( 'int' => ("" . $MATCH), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } }); return($MATCH) }; sub exp_stmts { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'exp'}}, @{${$MATCH->{'exp_stmts'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'exp'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub exp_seq { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'exp'}}, @{${$MATCH->{'exp_seq'}}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((',' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([${$MATCH->{'exp'}}]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) }) }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return([]) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub lit { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->lit_object($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'lit_object'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'lit_object'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } }); return($MATCH) }; sub lit_seq { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('TODO: lit_seq') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub lit_array { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('TODO: lit_array') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub lit_hash { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('TODO: lit_hash') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub lit_code { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('X' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return('TODO - Lit::Code') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub lit_object { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('::' eq substr($str, $MATCH->to(), 2)) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_mapping($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_mapping'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Lit::Object->new( 'class' => ${$MATCH->{'full_ident'}},'fields' => ${$MATCH->{'exp_mapping'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error parsing Constructor'); die() }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }))) } }); return($MATCH) }; sub call { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->exp($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp'} = $m2;1 } else { 0 } } } && ((('.' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Call->new( 'invocant' => ${$MATCH->{'exp'}},'method' => ${$MATCH->{'ident'}},'arguments' => ${$MATCH->{'exp_seq'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))))) } }); return($MATCH) }; sub apply { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && do { my  $pos1 = $MATCH->to(); (do { (do { my  $pos1 = $MATCH->to(); (do { ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))))) } || do { $MATCH->to($pos1); (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })) }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Apply->new( 'code' => COMPILER::get_var('&', '', ${$MATCH->{'full_ident'}}),'arguments' => ${$MATCH->{'exp_seq'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Apply->new( 'code' => COMPILER::get_var('&', '', ${$MATCH->{'full_ident'}}),'arguments' => [], )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }) } }); return($MATCH) }; sub opt_name { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } } || do { $MATCH->to($pos1); 1 }) }); return($MATCH) }; sub invocant { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->var($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'var'} = $m2;1 } else { 0 } } } && (((':' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'var'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Var->new( 'sigil' => '$','twigil' => '','name' => 'self', )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub sig { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->invocant($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'invocant'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_seq($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_seq'} = $m2;1 } else { 0 } } } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Sig->new( 'invocant' => ${$MATCH->{'invocant'}},'positional' => ${$MATCH->{'exp_seq'}},'named' => {  }, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))) } }); return($MATCH) }; sub method_sig { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); (do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('(' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'sig'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((')' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(${$MATCH->{'sig'}}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Sig->new( 'invocant' => Var->new( 'sigil' => '$','twigil' => '','name' => 'self', ),'positional' => [],'named' => {  }, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) }); return($MATCH) }; sub base_class { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } } }); return($MATCH) }; sub subset { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('b' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('f' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->base_class($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'base_class'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('w' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('h' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('r' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad() }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error in subset \'', get_class_name(), '.', ${$MATCH->{'name'}}, '\' near pos=', $MATCH->to()); die('error in Block') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(Subset->new( 'name' => ${$MATCH->{'full_ident'}},'base_class' => ${$MATCH->{'base_class'}},'block' => Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => (undef),'body' => ${$MATCH->{'exp_stmts'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))))))))))))))))))))))) } }); return($MATCH) }; sub method { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('m' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('h' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('d' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->method_sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method_sig'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad() }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error in method \'', get_class_name(), '.', ${$MATCH->{'name'}}, '\' near pos=', $MATCH->to()); die('error in Block') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(Method->new( 'name' => ${$MATCH->{'opt_name'}},'block' => Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => ${$MATCH->{'method_sig'}},'body' => ${$MATCH->{'exp_stmts'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))))))))))))) } }); return($MATCH) }; sub sub { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('s' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('u' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('b' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->method_sig($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'method_sig'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad() }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error in sub \'', ${$MATCH->{'name'}}, '\''); die('error in Block') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(Sub->new( 'name' => ${$MATCH->{'opt_name'}},'block' => Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => ${$MATCH->{'method_sig'}},'body' => ${$MATCH->{'exp_stmts'}}, ), )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))))))))))) } }); return($MATCH) }; sub begin_block { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('B' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('E' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('G' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('I' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('N' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { COMPILER::add_pad() }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error in BEGIN near pos=', $MATCH->to()); die('error in Block') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $env = $List_COMPILER::PAD->[0]; COMPILER::drop_pad(); return(COMPILER::begin_block(Lit::Code->new( 'pad' => $env,'state' => {  },'sig' => Sig->new( 'invocant' => (undef),'positional' => [],'named' => {  }, ),'body' => ${$MATCH->{'exp_stmts'}}, ))) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 })))))))))))) } }); return($MATCH) }; sub check_block { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('C' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('H' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('E' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('C' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('K' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { Main::say('*** Syntax Error in CHECK block'); die('error in Block') }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(COMPILER::check_block(${$MATCH->{'exp_stmts'}})) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))))))) } }); return($MATCH) }; sub token { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { ((('t' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('o' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('k' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('e' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && ((('n' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_name($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'opt_name'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = KindaPerl6::Grammar::Regex->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'KindaPerl6::Grammar::Regex.rule'} = $m2;1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { return(Token->new( 'name' => ("" . $MATCH->{'opt_name'}),'regex' => ${$MATCH->{'KindaPerl6::Grammar::Regex.rule'}}, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))))))) } }); return($MATCH) }
;
1;
