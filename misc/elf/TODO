Things you can do to help...

*** Update ../STD_red/PROBLEMS.
It's fallen out of sync with what actually parses.

*** Fix or document test failues.
Go through the run-tests results.
For each "ran but test failed", look at why.
If it's a missing or defective bit of prelude, either
 mention it below, or
 fix the prelude.
If it's an emitter problem, mention it below.

If it's a parser problem or failure ("X"), 
determine why the parse failed, and add a one-liner which
replicates it to ../STD_red/PROBLEMS.

*** Flesh out the prelude.
Go through S29 etc, adding p6 implementations to one of the preludes.
If it doesn't compile as spec'ed, comment it out so it serves as a todo.


TODO

* remove the following distastefull deviations
  - re_gsub

* replace cruft like  $.var.sigil eq '$' in Emit with methods in/added-to Analysis.  eg, is_scalar. (http://irclog.perlgeek.de/perl6/2008-05-24#i_309702)

* my($x,$y)...

* Lists!

BIG PICTURE

Very big picture:
() Move to p6, and a full bootstrap.
   Switch the front-end to p6, and as much as possible of the runtime.
() Get additional backends working.  javascript, ruby, python, scheme, common lisp.
() Pass more tests.
() Move towards full spec conformance.

Now:
() Absorb Class::Multimethods inline, and begin mutating it.
() Move from ruby STD_red to a p6 STD_gray.
() Implement regex, modeled on the p5 yet_another_regex_engine.
() Refactor Emit so the emitted code is generated by separate methods,
   like emit_block_start() and emit_block() and emit_call(), rather than
   directly by the IR node handlers.  This is to simplify swapping in other
   backends.
() Refactor Emit to use multimethods, making everything simpler.
   Caveat: requires an acceptably fast multimethod runtime.  At least on p5.
() Flesh out the prelude.
() Flesh out the unboxed prelude classes.
() Sketch try p6 oo designs for p5, and other backend languages.
  () Switch to a true p6 oo model.
  () Start several backends, to stay honest and motivate emitter refactoring.
() Flesh out the IR analysis.
