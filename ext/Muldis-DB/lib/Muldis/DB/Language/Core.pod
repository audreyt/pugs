=pod

=encoding utf8

=head1 NAME

Muldis::DB::Language::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::DB::Language::Core version 0.1.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::DB::Language>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

A significant subset of the Muldis D core entities are specific to being or
implementing the Muldis D system catalog / meta-model, and aren't used
elsewhere by the system; these are documented in the
L<Muldis::DB::Language::Catalog> document; all the other core entities are
described in the current C<Core> document.  TODO: EDIT THIS PARAGRAPH.

This current C<Core> document features the boolean, order, integer, bit
string, and character string types and operators, plus the tuple and
relation type constructors (and quasi- variants) and operators, plus the
type system minimal and maximal types, and the polymorphic operators that
all types, or some types including core types, have defined over them.

Extensions are in these other documents: L<Muldis::DB::Language::Ext::Num>,
L<Muldis::DB::Language::Ext::Temporal>,
L<Muldis::DB::Language::Ext::Spatial>.

=head1 TYPE SUMMARY

Following are all the data types and data type factories described in this
document, arranged in a type graph according to their proper sub|supertype
relationships:

    sys.type.Universal

        sys.type.Empty

        sys.type.Scalar
            sys.type.Ordinal

                # The following are all regular ordinal scalar types.

                sys.type.Bool
                    sys.type.Bool.False
                    sys.type.Bool.True
                sys.type.Order
                    sys.type.Order.Increase
                    sys.type.Order.Same
                    sys.type.Order.Decrease
                sys.type.Int
                    sys.type.UInt
                        sys.type.PInt
                sys.type.Blob
                    sys.type.NEBlob
                sys.type.Text
                    sys.type.NEText

        # The following are all nonscalar type factories.

        sys.type.Tuple
            sys.type.Database

        sys.type.Relation
            sys.type.Set
                sys.type.Maybe
            sys.type.Seq
            sys.type.Bag

        # The following are all quasi-nonscalar type factories.

        sys.type.QuasiTuple

        sys.type.QuasiRelation
            sys.type.QuasiSet
                sys.type.QuasiMaybe
            sys.type.QuasiSeq
            sys.type.QuasiBag

Note that C<sys.type.Empty> is a proper subtype of all of the other types
in this graph, but every other type has only one immediate supertype shown,
and hence the graph of them is a simple hierarchy.

=head1 SYSTEM-DEFINED CORE MAXIMAL AND MINIMAL DATA TYPES

These core data types are special and are the only Muldis D types that are
neither scalar nor nonscalar nor quasi-nonscalar types.  They are all
system-defined and it is impossible for users to define more types of this
nature.

=over

=item C<sys.type.Universal>

The C<Universal> type is the maximal type of the entire Muldis D type
system, and contains every value that can possibly exist.  Every other type
is implicitly a proper subtype of C<Universal>, and C<Universal> is
implicitly a union type over all other types.  Its default value is
C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Empty>

The C<Empty> type is the minimal type of the entire Muldis D type system,
and is the only type that contains exactly zero values.  Every other type
is implicitly a proper supertype of C<Empty> and C<Empty> is implicitly an
intersection type over all other types.  It has no default value.  The
cardinality of this type is zero.

=back

Note that there also exists a pseudo-type named C<sys.type.Any> which
represents a generic context that isn't the same as a context that would be
defined using C<sys.type.Universal>; an example is definitions of some
polymorphic operators.

=head1 SYSTEM-DEFINED CORE SCALAR DATA TYPES

These core scalar data types are the most fundamental Muldis D types.  Each
one has zero possreps, and hence has no named components that can be
referenced.  Concrete Muldis D provides a specific syntax per type to
select a value of one of these types, which does not look like a routine
invocation, but rather like a scalar literal in a typical programming
language; details of that syntax are not given here, but in
L<Muldis::DB::Language::Grammar>.  Abstract Muldis D as hosted in another
language will essentially use literals of corresponding host language
types, whatever they use for eg booleans and integers and character
strings, but tagged with extra meta-data if the host language is more
weakly typed or lacks one-to-one type correspondence.

=over

=item C<sys.type.Scalar>

The C<Scalar> type is the maximal type of all Muldis D scalar types, and
contains every scalar value that can possibly exist.  Every other scalar
type is implicitly a proper subtype of C<Scalar>, and C<Scalar> is
implicitly a union type over all other scalar types.  Its default value is
C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Ordinal>

The C<Ordinal> type is a proper subtype of C<Scalar> that is a proper
supertype of all scalar types that are considered ordinal.  Any scalar
types which consider themselves ordinal, which happens to include every
system-defined core scalar root type, will explicitly declare themselves as
subtypes of C<Ordinal> in their type definitions; the definition of
C<Ordinal> does not specify what other types it is a union over.  Its
default value is C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Bool>

A C<Bool> is an enumeration consisting of the 2 values C<Bool.False> and
C<Bool.True>.  It represents a truth value, and is the result type of any
C<equal> or C<not_equal> routine; it is the only essential scalar data type
of a B<D> language.  Its default value is C<Bool.False>.  The cardinality
of this type is 2.

=item C<sys.type.Order>

A C<Order> is an enumeration consisting of the 3 values C<Order.Increase>,
C<Order.Same>, C<Order.Decrease>.  It is the result type of any C<compare>
routine that is used on 2 values of a C<sys.type.Ordinal> subtype.  Its
default value is C<Order.Same>.  The cardinality of this type is 3.

=item C<sys.type.Int>

An C<Int> is a single integral number of any magnitude.  Its default value
is zero.  The cardinality of this type is infinity; to define a
most-generalized finite C<Int> subtype, you must specify the 2 integer
end-points of the inclusive range that all its values are in.

=item C<sys.type.UInt>

A C<UInt> (unsigned integer) is a proper subtype of C<Int> where all member
values are non-negative / greater than or equal to zero.

=item C<sys.type.PInt>

A C<PInt> (positive integer) is a proper subtype of C<UInt> where all
member values are positive / greater than or equal to one.  Its default
value is one.

=item C<sys.type.Blob>

A C<Blob> is an undifferentiated string of bits.  Its default value is the
empty string.  The cardinality of this type is infinity; to define a
most-generalized finite C<Blob> subtype, you must specify a maximum length
in characters that the subtype's strings are.

=item C<sys.type.NEBlob>

A C<NEBlob> (non-empty blob) is a proper subtype of C<Blob> where its
length in bits must be at least 1; it can be any C<Blob> except for the
empty string.  Its default value is a single zero bit.

=item C<sys.type.Text>

A C<Text> is a string of characters.  Its default value is the empty
string.  Note that there is only one system-defined character repertoire
for C<Text> types, which is the newest Unicode repertoire (5.0.0).  The
cardinality of this type is infinity; to define a most-generalized finite
C<Text> subtype, you must specify a maximum length in characters (that is,
eg, in NFC graphemes) that the subtype's strings are.

=item C<sys.type.NEText>

A C<NEText> (non-empty text) is a proper subtype of C<Text> where its
length in characters must be more than zero; it can be any C<Text> except
for the empty string.  Its default value is a single "space" character.

=back

=head1 SYSTEM-DEFINED CORE NONSCALAR PARAMETERIZED DATA TYPES

These are only called nonscalar data types in a loose sense, because by
themselves they are incomplete type definitions.  Actual nonscalar data
type definitions are derived from these by supplying the balance of the
type definitions, such as what their attributes are and/or what their
attribute types are.  Associated with these incomplete type definitions are
a set of system-defined routines that can be applied to values of any
actual nonscalar types derived from them; such are called I<generic
nonscalar operators>.  In the Muldis D type system, these incomplete
nonscalar types are defined as union types over all actual types derived
from them, and are proper supertypes of said.

Some actual nonscalar data types are system-defined, for use in defining
the Muldis D system catalog / meta-model (see
L<Muldis::DB::Language::Catalog> for more details), but all other actual
nonscalar data types are user-defined.  Users can also define their own
incomplete nonscalar data types that are tuple or relation types.

=over

=item C<sys.type.Tuple>

The C<Tuple> type is the maximal type of all Muldis D tuple (nonscalar)
types, and contains every tuple value that could possibly exist.  A
C<Tuple> is an unordered heterogeneous collection of 0..N named attributes
(the count of attributes being its I<degree>), where all attribute names
are mutually distinct, and each attribute may be of distinct types; the
mapping of a tuple's attribute names and their declared data types is
called the tuple's I<heading>.  Its default value is the sole value of the
sole tuple data type that has zero attributes.  The cardinality of this
type is equal to the product of the number of permutations drawable from
the values of each of its attributes' declared data types; for a C<Tuple>
subtype to be finite, all of its attribute types must be.

=item C<sys.type.Database>

A C<Database> is a proper subtype of C<Tuple> where all of its attributes
are of relation types; it is otherwise the same.

=item C<sys.type.Relation>

The C<Relation> type is the maximal type of all Muldis D relation
(nonscalar) types, and contains every relation value that could possibly
exist.  A C<Relation> is analogous to a set of 0..N tuples where all tuples
have the same heading (the degrees match and all attribute names and
corresponding declared data types match), but that a C<Relation> data type
still has its own corresponding heading (attribute names and declared data
types) even when it consists of zero tuples.  Its default value is the
zero-tuple value of the sole relation data type that has zero attributes.
Matters of its cardinality are generally the same as for C<Tuple>.  A
relation data type can also have (unique) keys each defined over a subset
of its attributes, which constrain its set of values relative to there
being no explicit keys, but having the keys won't turn an infinite relation
type into a finite one.

=item C<sys.type.Set>

A C<Set> is a proper subtype of C<Relation> that has 1 attribute, and its
name is C<value>; it can be of any declared type.  A C<Set> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is not significant, and that duplicate
values are not significant.  Its default value has zero tuples.

=item C<sys.type.Maybe>

A C<Maybe> is a proper subtype of C<Set> that may have at most one element;
that is, it is a unary C<Relation> with a nullary key.  Operators that work
specifically with C<Maybe> subtypes can provide a syntactic shorthand for
working with sparse data; so Muldis D has something which is conceptually
close to SQL's nullable types without actually having 3-valued logic; it
would probably be convenient for code that round-trips SQL by way of
Muldis D to use the C<Maybe> type.  Its default value has zero tuples.

=item C<sys.type.Seq>

An C<Seq> is a proper subtype of C<Relation> that has 2 attributes,
and their names are C<index> and C<value>, where C<index> is a unary key
and its declared type is an C<UInt> subtype (C<value> can be non-unique and
of any declared type).  A Seq is considered dense, and all C<index>
values in one are numbered consecutively from 0 to 1 less than the count of
tuples, like array indices in typical programming languages.  A C<Seq>
subtype is normally used by any system-defined N-ary operators where the
order of their argument elements or result is significant (and duplicate
values are significant); specifically, C<index> defines an explicit
ordering for C<values>.  Its default value has zero tuples.

=item C<sys.type.Bag>

A C<Bag> is a proper subtype of C<Relation> that has 2 attributes, and
their names are C<value> and C<count>, where C<value> is a unary key (that
can have any declared type) and C<count> is a C<PInt> subtype.  A C<Bag>
subtype is normally used by any system-defined N-ary operators where the
order of their argument elements or result is not significant, but that
duplicate values are significant; specifically, C<count> defines an
explicit count of occurrences for C<values>.  Its default value has zero
tuples.

=back

=head1 SYSTEM-DEFINED CORE QUASI-NONSCALAR PARAMETERIZED DATA TYPES

These quasi-nonscalar incomplete data type definitions correspond to their
similarly-named (differing only by the C<Quasi>) nonscalar data types, and
their use is intended to be limited to the few situations where the
corresponding nonscalar data types can't be used.  It should be noted in
particular that there is no "QuasiDatabase" type, since all normal data or
catalog databases should be composed of normal relations only; but all of
the other nonscalar incomplete types have counterparts here.

=over

=item C<sys.type.QuasiTuple>

A C<QuasiTuple> is like a C<Tuple> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.type.QuasiRelation>

A C<QuasiRelation> is like a C<Relation> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.type.QuasiSet>

A C<QuasiSet> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Set> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.type.QuasiMaybe>

A C<QuasiMaybe> is a proper subtype of C<QuasiRelation> in the
corresponding manner to C<Maybe> being a proper subtype of C<Relation>.
Its cardinality is infinite.

=item C<sys.type.QuasiSeq>

A C<QuasiSeq> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Seq> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.type.QuasiBag>

A C<QuasiBag> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Bag> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=back

=head1 SYSTEM-DEFINED GENERIC UNIVERSAL FUNCTIONS

These functions are applicable to values of any data type at all.

=over

=item C<sys.rtn.Any.equal (RO: Any $v1, Any $v2)>

This function results in C<Bool.True> iff its 2 arguments are exactly the
same value, and C<Bool.False> otherwise.  This function's arguments must be
of compatible declared types; in this case, 2 declared types are compatible
iff at least one of the following is true: 1. they are both subtypes of a
common scalar root type; 2. they are both subtypes of a common
non-incomplete tuple or relation type, that is they essentially have the
same headings; 3. at least one type is a generic (eg-C<Universal>) or
incomplete (eg-C<Seq>) type, and it is a supertype of the other.  This
function is commutative.

=item C<sys.rtn.Any.not_equal (RO: Any $v1, Any $v2)>

This function is exactly the same as C<sys.rtn.equal> except that it
results in the opposite boolean value when given the same arguments.

=back

=head1 SYSTEM-DEFINED GENERIC UNIVERSAL UPDATE OPERATORS

These update operators are applicable to values of any data type at all.

=over

=item C<sys.rtn.Any.assign (UPD: Any $target ; RO: Any $v)>

This update operator will update the variable supplied as its C<$target>
argument so that it holds the value supplied as its C<$v> argument.  This
update operator's arguments must be of compatible declared types; in this
case, C<$v> must be a subtype of C<$target>.

=back

=head1 SYSTEM-DEFINED CORE SCALAR FUNCTIONS

These functions are applicable to just one or more specific system-defined
core scalar data type.

=head2 Functions for sys.rtn.Bool

These functions select values of the C<Bool> enumeration.

=over

=item C<sys.rtn.Bool.False of Bool ()>

This selector function results in the C<Bool.False> value.

=item C<sys.rtn.Bool.True of Bool ()>

This selector function results in the C<Bool.True> value.

=back

These functions implement commonly used boolean operations.

=over

=item C<sys.rtn.Bool.not of Bool (RO: Bool $v)>

This function results in the logical I<not> of its argument.

=item C<sys.rtn.Bool.and of Bool (RO: Set{Bool} $v)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical I<and> (which is both
commutative and associative) on them until just one is left, which is the
function's result.  If C<$v> has zero values, then C<and> returns
C<Bool.True>, which is the identity value for logical I<and>.

=item C<sys.rtn.Bool.or of Bool (RO: Set{Bool} $v)>

This function is a reduction operator that recursively takes each pair of
its N input element values and does a logical inclusive-or (which is both
commutative and associative) on them until just one is left, which is the
function's result.  If C<$v> has zero values, then C<and> returns
C<Bool.False>, which is the identity value for logical inclusive-or.

=item C<sys.rtn.Bool.xor (RO: Bool $v1, Bool $v2)>

This function results in the logical exclusive-or of its 2 arguments.  This
function is commutative.

=back

=head2 Functions for sys.rtn.Order

These functions select values of the C<Order> enumeration.

=over

=item C<sys.rtn.Order.Increase of Order ()>

This selector function results in the C<Order.Increase> value.

=item C<sys.rtn.Order.Same of Order ()>

This selector function results in the C<Order.Same> value.

=item C<sys.rtn.Order.Decrease of Order ()>

This selector function results in the C<Order.Decrease> value.

=back

=head2 Functions for sys.rtn.Int

These functions implement commonly used integer operations.

=over

=item C<sys.rtn.Int.sum of Int (RO: Bag{Int} $addends)>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<$addends> has zero values,
then C<sum> returns the integer zero, which is the identity value for
addition.

=item C<sys.rtn.Int.difference of Int (RO: Int $minuend, Int $subtrahend)>

This function results in the difference when its C<$subtrahend> argument is
subtracted from its C<$minuend> argument.

=item C<sys.rtn.Int.product of Int (RO: Bag{Int} $factors)>

This function results in the product of the N element values of its
argument; it is a reduction operator that recursively takes each pair of
input values and multiplies (which is both commutative and associative)
them together until just one is left, which is the result.  If C<$factors>
has zero values, then C<product> returns the integer 1, which is the
identity value for multiplication.

=item C<sys.rtn.Int.quotient of Int (RO: Int $dividend, Int $divisor)>

This function results in the quotient when its C<$dividend> argument is
divided by its C<$divisor> argument using integer division.  This function
throws an exception if C<$divisor> is zero.

=item C<sys.rtn.Int.remainder of Int (RO: Int $dividend, Int $divisor)>

This function results in the remainder when its C<$dividend> argument is
divided by its C<$divisor> argument using integer division.  This function
throws an exception if C<$divisor> is zero.

=item C<sys.rtn.Int.abs of Int (RO: Int $v)>

This function results in the absolute value of its argument.

=item C<sys.rtn.Int.power of Int (RO: Int $radix, PInt $exponent)>

This function results in its C<$radix> argument taken to the power of its
(positive integer) C<$exponent> argument.

=back

These functions convert between C<Int> values and canonically formatted
representations of integers as character strings.

=over

=item C<sys.rtn.Int.Int_from_Text.2 of Int (RO: Text $text)>

This selector function results in the C<Int> value that its argument maps
to when the whole character string is evaluated as a base-2 integer.

=item C<sys.rtn.Int.Text_from_Int.2 of Text (RO: Int $int)>

This selector function results in the C<Text> value where its argument is
formatted as a base-2 integer.

=item C<sys.rtn.Int.Int_from_Text.8 of Int (RO: Text $text)>

Same as C<Int.Int_from_Text.2> but for base-8.

=item C<sys.rtn.Int.Text_from_Int.8 of Text (RO: Int $int)>

Same as C<Int.Text_from_Int.2> but for base-8.

=item C<sys.rtn.Int.Int_from_Text.10 of Int (RO: Text $text)>

Same as C<Int.Int_from_Text.2> but for base-10.

=item C<sys.rtn.Int.Text_from_Int.10 of Text (RO: Int $int)>

Same as C<Int.Text_from_Int.2> but for base-10.

=item C<sys.rtn.Int.Int_from_Text.16 of Int (RO: Text $text)>

Same as C<Int.Int_from_Text.2> but for base-16.

=item C<sys.rtn.Int.Text_from_Int.16 of Text (RO: Int $int)>

Same as C<Int.Text_from_Int.2> but for base-16.

=back

=head2 Functions for sys.rtn.Blob

These functions implement commonly used binary string operations.

=over

=back

These functions convert between C<Blob> values and canonically formatted
representations of binary strings as character strings.

=over

=item C<sys.rtn.Blob.Blob_from_Text.2 of Blob (RO: Text $text)>

This selector function results in the C<Blob> value that its argument maps
to when each input character is a [0-1] and represents a bit.

=item C<sys.rtn.Blob.Text_from_Blob.2 of Text (RO: Blob $blob)>

This selector function results in the C<Text> value where its argument is
encoded using a [0-1] character for each bit.

=item C<sys.rtn.Blob.Blob_from_Text.16 of Blob (RO: Text $text)>

This selector function results in the C<Blob> value that its argument maps
to when each input character is a [0-9A-Fa-f] and represents a hex digit.

=item C<sys.rtn.Blob.Text_from_Blob.16uc of Text (RO: Blob $blob)>

This selector function results in the C<Text> value where its argument is
encoded using a [0-9A-F] character for each bit.

=item C<sys.rtn.Blob.Text_from_Blob.16lc of Text (RO: Blob $blob)>

This selector function results in the C<Text> value where its argument is
encoded using a [0-9a-f] character for each bit.

=back

=head2 Functions for sys.rtn.Text

These functions implement commonly used character string operations.

=over

=back

=head1 SYSTEM-DEFINED CORE SCALAR UPDATE OPERATORS

These update operators are applicable to just one or more specific
system-defined core scalar data type.

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE SCALAR SYSTEM SERVICES

These system services are applicable to just one or more specific
system-defined core scalar data type.

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE GENERIC NONSCALAR FUNCTIONS

These functions are applicable to mainly nonscalar types, but are generic
in that they typically work with any nonscalar types.

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE GENERIC NONSCALAR UPDATE OPERATORS

These update operators are applicable to mainly nonscalar types, but are
generic in that they typically work with any nonscalar types.

=head1 SYSTEM-DEFINED CORE GENERIC QUASI-NONSCALAR FUNCTIONS

I<This documentation is pending.>

=head1 SYSTEM-DEFINED CORE GENERIC QUASI-NONSCALAR UPDATE OPERATORS

I<This documentation is pending.>

=head1 SEE ALSO

Go to L<Muldis::DB> for the majority of distribution-internal references,
and L<Muldis::DB::SeeAlso> for the majority of distribution-external
references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the Muldis::DB framework.

Muldis::DB is Copyright © 2002-2007, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Muldis::DB> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::DB> apply to this file too.

=cut
