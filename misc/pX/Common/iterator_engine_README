pX/Common/iterator_engine_p6regex.pl - fglock

Experimental implementation of:
- a parser engine (iterator_engine.pl)
- a Perl6 'rule' parser and perl5 emitter (iterator_engine_p6rule.pl)
- a 'mini-Perl6' (it only works on 'grammar' sections) parser and perl5 emitter 
  (iterator_engine_p6grammar.pl)
- a Perl6 'grammar' grammar (iterator_engine_p6rule_grammar.p6)

Some existing Perl6 'grammar' grammars:
  ../../Grammars/rx_grammar.pm
  http://svn.perl.org/parrot/trunk/compilers/pge/P6Rule.grammar

Plan:
- improve p6rule_grammar.p6 such that it can parse itself
- more tests, try to reuse pugs tests
- revisit XXX notes
- put together a Perl6 grammar that we can compile
- use putter's Match.pm
- make grammars inherit from Grammar; make grammars inheritable
- write an emitter that generates perl5 regexes (or dies)
- bind special variables $0, ...
- see also the 'not implemented' list below

Namespaces:
  Grammar - the base grammar - defines <ws>, <digit> 
  RuleGrammar - the pattern matching grammar
  Perl6Grammar - the Perl6 grammar

About the Rules:

implemented:

 . ? * + *? +? 
 \char <ws> <word> literal
 $variable @variable
 <'literal'>
 [] 
 {} (with perl5 code)
 () (but doesn't capture yet)
 <subrule>
 |

implemented but untested:
 <other::rule>

not implemented:
 $1
 <"literal">
 ^ ^^ $ $$
 <!term>
 <unicode-class> <+unicode-class> <+unicode-class+unicode-class>
 <?var> <@var> <&var> <%var>
 {n..m} 
 : :: :::   (commit)
 :=         (alias)
 <(closure-assertion)> <{code-returns-rule}>
 <<character-class>> <[character-class]>
 :flag :flag() :flag[]
 lookahead lookbehind
 #comment\n
 \x0a \0123 ...
 <?ws>  -- optional whitespace ???

not sure if specified:
 &
 'literal' "literal"
 <!n,m>  -- <!{n..m}> ???

