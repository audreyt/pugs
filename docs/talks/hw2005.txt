
                  Pugs: Bootstrapping Perl 6 with Haskell
                                Autrijus Tang
                            Haskell Workshop 2005
                  (Applications, Practice, and Experience)

== Abstract ==

Perl is a general-purpose language, known for its vast number of freely
available extension libraries.  The Perl 6 project was started in 2000
to create a more robust runtime environment, and improve the language's
support for multi-paradigmic programming.  However, attempts at producing a
concrete implementation failed to materialise in the first 4 years.

This paper presents Pugs, a working implementation of Perl 6, written in
Haskell.  We review the challenges posed by Perl 6's unusual execution model,
and how Pugs tackles them with features introduced in GHC 6.4, such as
Template Haskell, Software Transactional Memory, and GADTs.

Moreover, we demonstrate how Pugs uses Haskell's FFI to embed Perl 5, Parrot
and Haskell within Perl 6 programs, and how it mediates the execution context
between these runtime environments.

Finally, we discuss Parrot, a register-based virtual machine designated as
Perl 6's primary runtime.  We show how Pugs can evolve from an interpreter
to a compiler targeting Parrot, with a design based on metacomputational
monads.

== Categories and Subject Descriptors ==

D.3.m [Programming Languages]: Miscellaneous

== General Terms ==

Design, Languages

== Keywords ==

Perl, Haskell

---------------------------------------------------------------------------

1. Introduction

The Perl language, developed by Larry Wall in the mid-1980s, is an attempt to
synthesise the capabilities of the Unix toolset (C, shell, grep, sed, awk,
etc.), and present them in a way that maximises ease of use, efficiency and
completeness.

During the mid-1990s, Wall developed Perl 5, incoporating features from
contemporary languages (Scheme, C++, Python, etc.), such as modules, closures,
object-oriented programming and bytecode compilation. 

The Perl 6 project was started in 2000, with a focus on improved cross-language
interoperation and support for multiple programming paradigms.  The design
process continued well into 2005, producing the language specification in
installments.

However, the Perl 6 implementation, originally planned to proceed in parallel
with the design process, failed to materialise; this has seriously impeded the
development and adoption of Perl 6.

This paper presents Pugs, a project started in 2005 to implement Perl 6,
using Haskell as the host language.  Haskell proved to be a capable choice for
this task: we released the first working interpreter within the first week, and
by the third week we had a unit testing framework written in Perl 6.

The rest of this paper will proceed as follows.  In section 2, we give a more
detailed look at the Perl 6 project, to put the Pugs project into perspective.
We then present Perl 6's execution model in section 3, along with Pugs's
interpreter core that implements this model. 

Because Pugs is targeting GHC 6.4 instead of Haskell 98, it takes full
advantage of modern Haskell features GHC provides.  In section 4, we review
Pugs's use of GADT, STM, as well as subcontinuations built on higher-rank
polymorphism.  In section 5, we demonstrate how Pugs uses FFI and hs-plugins to
dynamically load Perl 5, Haskell and Parrot modules at runtime.

Although the naïve tree-reduction interpreter served well for prototyping Perl
6, it is not efficient enough for production uses.  In section 6, we discuss
our ongoing work in adapting Pugs into a compiler, targeting the
register-based Parrot virtual machine.

---------------------------------------------------------------------------

2. Overview of the Perl 6 Project

Previous versions of Perl were designed and implemented by Wall alone.
However, Perl 6's development is driven by Perl community's varied and often
conflicting needs.  As such, we will start with a brief overview of the Perl
community, and how Perl 6 has come to be.

2.1. Historical Background

Following the release of Perl 5 in 1994, a community of volunteers known as the
"Perl 5 porters" was formed to take charge of the ongoing development of
Perl 5.  For each major revision, the porters appoint a "pumpking" (release
manager) to take charge of the design and arbitrate patches submitted by other
porters.

In 1995, Jarkko Hietaniemi and Andreas König established the Comprehensive Perl
Archive Network (CPAN), an infrastructure for sharing freely reusable
libraries, programs and documentation.  Perl itself comes with a built-in client
side utility for automatic downloading, testing and installation of CPAN
modules.  As of 2005, CPAN has more than 8000 modules, supported by a toolchain
that covers smoke testing, issue tracking, cross-referencing, rating and
discussion forums.

Driven by hundreds of Perl 5 porters and thousands of CPAN authors, Perl 5's
development put a strong emphasis on backward compatibility.  Developers
avoid adding new built-in functions, as they might clash with user-defined
functions of the same name.  Conversely, deprecated features are almost never
fully retracted, while new incompatible features are consistently rejected.
For example, one cannot rewrite the reference-counting garbage collector,
because existing programs may rely on its object destruction semantics.

In 2000, many developers feel that Perl 5 development is stuck.  Some have
described the C-based runtime as a tower of Jenga, where new features are
constrained to re-use existing semantics, making it ever more fragile.

In response to this situation, Perl developers started the Perl 6 project to
rewrite Perl from scratch, dropping language-level backward compatibility for
the first time.  To use existing Perl 5 programs, one would need to embed a
Perl 5 runtime inside Perl 6's runtime, or recompile them into Perl 6.

2.2. Execution Model

The Perl 6 project started with a "requirement analysis" phase; during this
two-month period, 26 working groups produced 361 RFCs submissions as initial
input to the design team, calling for improved functional, object-oriented,
concurrency-based, data-driven and logic programming support in the base
language.  In order to support all of them, the design of Perl 6 focused on
its metaprogramming capabilities.

Unlike most languages, Perl 5 has no static grammar: its parser is tightly
coupled with the evaluator, so compile-time computation can affect how the
parser handles the rest of the program.  This allows for a limited form of
macros known as "source filters", where a Perl module can transform the
importing program's source code before its parsing.

Many CPAN modules use source filters to implement Perl dialects and embedded
domain-specific languages.  However, as the transformation happens on the
source string level instead of the AST level, multiple filters cannot reliably
work together.

Perl 6 proposes an unusual execution model to address this problem:

2.3. Language Interoperability

...comparison with clr/jvm...

---------------------------------------------------------------------------

3. Pugs the Interpreter

...how pugs started...

3.1. The Eval Monad

...basic types, CALLER::, OUTER::, coro, delayed evaluation...

3.2. Compile-time Evaluation

...BEGIN, rebindable rules, macros...

3.3. Introspection

...OO metamodel, profiling, reified AST...

---------------------------------------------------------------------------

4. Experimental Features 

...GHC's peculiarities that helped Pugs development...

4.1. "Tied" Variables with GADT

...ITypes/IVar, VRef, VOpaque...

4.2. Composable Concurrency

...SIO, liftSTM/liftIO, atomic{}...

4.3. Reified Subcontinuations

...CC_2CPST, Zipper, resumable runEvalIO...

---------------------------------------------------------------------------

5. Embedded Languages

...migration issues...

5.1. Perl 5

...callconv, context passing, XS stack handling...

5.2. Haskell

...hs-plugins, externalizeHaskell, class Value...

5.3. Parrot

...PIR overview, compreg, cross-lang interop...

---------------------------------------------------------------------------

6. Compiling Perl 6

...mixed notion of compile/runtime...

6.1. Metacomputational Compilation

...partial evaluation, Static/Dynam monads...

6.2. Targeting Parrot

...optimization, unboxing, helper PMCs...

6.3. Other Backends

...generating haskell with TH, ANF/SSA...

---------------------------------------------------------------------------

7. Conclusion and Future Work

...porting Pugs to perl 6, compiling Haskell to PIR...

---------------------------------------------------------------------------

8. Acknowledgments

...thank some 100+ contributors here...

---------------------------------------------------------------------------

== References ==

...lots and lots of papers...

