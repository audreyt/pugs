
        package Pugs::Grammar::Rule;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Emitter::Rule::Perl5::Ratchet;
        our %rule_terms;

*pod_begin = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1376} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1376} ) or 1 )
        && (
          ( substr( $s, $pos++, 1 ) ne '' )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
          && do {
            my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_begin
#Data::Bind->sub_signature( \&pod_begin, );
*pod_other = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1377} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'c' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'u' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 't' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1377} ) or 1 )
        && (
          ( substr( $s, $pos++, 1 ) ne '' )
          && do {
            while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
            $bool = 1;
          }
          && do {
            my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_other
#Data::Bind->sub_signature( \&pod_other, );
*ws = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1378} = $pos or 1 )
        && (
          (
            (
                ( substr( $s, $pos, 1 ) eq '#' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
              $bool = 1;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1378} ) or 1 )
          && (
            (
              ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
              : 0
            )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  (
                    ( $pad{I1379} = $pos or 1 )
                    && (
                      (
                        (
                          ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                        && (
                          ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                          $bool = 1;
                        }
                        && do {
                          while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                          $bool = 1;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && do {
                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                      )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
              || ( $bool = 1 )
            )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1378} ) or 1 )
          && (
              ( substr( $s, $pos ) =~ m/^\s/s )
            ? ( $pos += length($&) or 1 )
            : 0
          )
        )
      )
      && do {
        while (
          (
            ( $pad{I1378} = $pos or 1 )
            && (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '#' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                  $bool = 1;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1378} ) or 1 )
              && (
                (
                  ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      (
                        ( $pad{I1379} = $pos or 1 )
                        && (
                          (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            && (
                              ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                              $bool = 1;
                            }
                            && do {
                              while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                              $bool = 1;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1379} ) or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && do {
                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                          )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1378} ) or 1 )
              && (
                  ( substr( $s, $pos ) =~ m/^\s/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
            )
          )
          )
        {
        }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ws
#Data::Bind->sub_signature( \&ws, );
*ident = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1380} = $pos or 1 )
        && (
          (
            ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1380} ) or 1 )
          && (
            ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
            : 0
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1380} ) or 1 )
          && (
            ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 )
            : 0
          )
        )
      )
      && do {
        while ( ( ( $pad{I1380} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1380} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1380} ) or 1 ) && ( ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 ) : 0 ) ) ) ) { }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ident
#Data::Bind->sub_signature( \&ident, );
*literal = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      while ( ( ( $pad{I1381} = $pos or 1 ) && ( ( ( ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 ) : 0 ) && ( substr( $s, $pos++, 1 ) ne '' ) ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1381} ) or 1 ) && ( ( substr( $s, $pos ) =~ m/^[^\']/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) ) ) { }
      $bool = 1;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for literal
#Data::Bind->sub_signature( \&literal, );
*metasyntax = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          ( $pad{I1382} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && ( substr( $s, $pos++, 1 ) ne '' )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && do {
                my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              && (
                ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
            && (
              ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
              : 0
            )
          )
        )
        && do {
          while (
            (
              ( $pad{I1382} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && ( substr( $s, $pos++, 1 ) ne '' )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1382} ) or 1 )
                && (
                  ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
              )
            )
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'metasyntax' => $::_V6_MATCH_->()    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for metasyntax
#Data::Bind->sub_signature( \&metasyntax, );
*code = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1383} = $pos or 1 )
        && (
          (
            (
              ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
              : 0
            )
            && ( substr( $s, $pos++, 1 ) ne '' )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
          && (
            (
              ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && (
              ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
              : 0
            )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
          && (
            (
              ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            && (
              ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
              : 0
            )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
          && (
            ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
        )
      )
      && do {
        while (
          (
            ( $pad{I1383} = $pos or 1 )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && ( substr( $s, $pos++, 1 ) ne '' )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                && (
                  ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                  : 0
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                  my $bool = ( !$match != 1 );
                  $pos = $match->to if $bool;
                  $match;
                }
                && (
                  ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                  : 0
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1383} ) or 1 )
              && (
                ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
                : 0
              )
            )
          )
          )
        {
        }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for code
#Data::Bind->sub_signature( \&code, );
*named_capture_body = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1384} = $pos or 1 )
      && (
        (
          (
              ( substr( $s, $pos, 1 ) eq '(' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'rule'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
              ( substr( $s, $pos, 1 ) eq ')' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'capturing_group' => $::_V6_MATCH_->{'rule'}->()    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1384} ) or 1 )
        && (
          (
              ( substr( $s, $pos, 1 ) eq '[' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'rule'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
              ( substr( $s, $pos, 1 ) eq ']' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( $::_V6_MATCH_->{'rule'}->() );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1384} ) or 1 )
        && (
          (
              ( substr( $s, $pos, 1 ) eq '<' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'metasyntax'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
              ( substr( $s, $pos, 1 ) eq '>' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( $::_V6_MATCH_->{'metasyntax'}->() );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1384} ) or 1 )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          sub {
            die("invalid alias syntax");
            }
            ->();
          $::_V6_SUCCEED;
        }
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for named_capture_body
#Data::Bind->sub_signature( \&named_capture_body, );
%rule_terms = (
  '(' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq ')' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'capturing_group' => $::_V6_MATCH_->{'rule'}->()    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<after' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'after' => {
                    'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'before' => {
                    'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'not_before' => {
                    'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'negate' => {
                    'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'metasyntax'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return ( $::_V6_MATCH_->{'metasyntax'}->() );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'ident'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '>' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
          || ( $bool = 1 )
        )
        && (
            ( substr( $s, $pos, 2 ) eq ':=' )
          ? ( $pos += 2 or 1 )
          : 0
        )
        && (
          do {
            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
            my $bool = ( !$match != 1 );
            $pos = $match->to if $bool;
            $match;
          }
          || ( $bool = 1 )
        )
        && do {
          my $match = $grammar->named_capture_body( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'named_capture_body'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'named_capture' => {
                    'rule'  => $::_V6_MATCH_->{'named_capture_body'}->(),
                    'ident' => $::_V6_MATCH_->{'ident'}->()                 # hash
                    }    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1385} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'match_variable' => '$' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1386} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1386} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1386} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1386} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1386} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1386} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'variable' => '$' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'colon' => '$'    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '@' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1387} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'match_variable' => '@' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1387} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1388} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1388} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1388} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1388} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1388} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1388} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'variable' => '@' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '%' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1389} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'match_variable' => '%' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1389} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                ( $pad{I1390} = $pos or 1 )
                && (
                  (
                    ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1390} ) or 1 )
                  && (
                    ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1390} ) or 1 )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              && do {
                while ( ( ( $pad{I1390} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1390} ) or 1 ) && ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1390} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  return (
                    {
                      'variable' => '%' . $::_V6_MATCH_->()    # hash
                    }
                  );
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '{' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'code'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq '}' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'closure' => '{' . $::_V6_MATCH_->{'code'}->() . '}'    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '\\' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( substr( $s, $pos++, 1 ) ne '' )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return (
                {
                  'special_char' => '\\' . $::_V6_MATCH_->()    # hash
                }
              );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '.' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'dot' => 1    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '[' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
            ( substr( $s, $pos, 1 ) eq ']' )
          ? ( $pos += 1 or 1 )
          : 0
        )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              return ( $::_V6_MATCH_->{'rule'}->() );
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => ':::'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':?' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => ':?'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':+' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => ':+'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => '::'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => ':'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => '$$'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => '^^'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'colon' => '^'    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  }
);
*term = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1391} = $pos or 1 )
      && (
        (
          do {
            my $match = do {
              our $I1392;
              our $I1392_sizes;
              unless ($I1392) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1392_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1392 = $hash;
              }
              my $match = 0;
              my $key;
              for (@$I1392_sizes) {
                $key = (
                  $pos <= length($s)
                  ? substr( $s, $pos, $_ )
                  : ''
                );
                if ( exists $I1392->{$key} ) {

                  #$named{KEY} = $key;
                  #$::_V6_MATCH_ = $m;
                  #print "m: ", Dumper( $::_V6_MATCH_->data )
                  #    if ( $key eq 'until' );
                  $match = Pugs::Emitter::Rule::Perl5::Ratchet::preprocess_hash( $I1392, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                  last if $match;
                }
              }
              if ($match) {
                $pos = $match->to;

                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
              }
              ;    # else { $bool = 0 }
              $match;
            };
            if ($match) {
              $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}->() );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1391} ) or 1 )
        && (
          (
              ( substr( $s, $pos ) =~ m/^[^\]\}\)\>\:\?\+\*\|\&]/s )
            ? ( $pos += length($&) or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return (
                  {
                    'constant' => $::_V6_MATCH_->()    # hash
                  }
                );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for term
#Data::Bind->sub_signature( \&term, );
*quantifier = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws1'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $pos1 = $pos;
        do {
          my $pos  = $pos1;
          my $from = $pos;
          my @match;
          my %named;
          my $bool = 1;
          $bool = 0
            unless (
              ( substr( $s, $pos ) =~ m/^[\}\]\)\>]/s )
            ? ( $pos += length($&) or 1 )
            : 0
            );
          !$bool;
        };
      }
      && do {
        my $match = $grammar->term( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          $named{'term'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws2'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  (
                    (
                      ( substr( $s, $pos ) =~ m/^[\?\*\+]/s ) ? ( $pos += length($&) or 1 )
                      : 0
                    )
                    || ( $bool = 1 )
                  )
                  && (
                    (
                      ( substr( $s, $pos, 1 ) eq '?' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    || ( $bool = 1 )
                  )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'quant'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws3'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            return (
              {
                'quant' => {
                  'term'  => $::_V6_MATCH_->{'term'}->(),
                  'quant' => $::_V6_MATCH_->{'quant'}->(),
                  'ws1'   => $::_V6_MATCH_->{'ws1'}->(),
                  'ws2'   => $::_V6_MATCH_->{'ws2'}->(),
                  'ws3'   => $::_V6_MATCH_->{'ws3'}->()      # hash
                  }    # hash
              }
            );
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for quantifier
#Data::Bind->sub_signature( \&quantifier, );
*concat = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        do {
          my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            push @{ $named{'quantifier'} }, $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          while (
            do {
              my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                push @{ $named{'quantifier'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            my @a = map { $_->() } @{ $::_V6_MATCH_->{'quantifier'} };
            return { concat => \@a, } if scalar @a > 1;
            return $a[0];
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for concat
#Data::Bind->sub_signature( \&concat, );
*rule = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          (
            do {
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && (
              ( substr( $s, $pos, 1 ) eq '|' )
            ? ( $pos += 1 or 1 )
            : 0
          )
        )
        || ( $bool = 1 )
      )
      && do {
        my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
        if ($match) {
          push @{ $named{'concat'} }, $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && do {
        while (
          (
            (
                ( substr( $s, $pos, 1 ) eq '|' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                push @{ $named{'concat'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
          )
          )
        {
        }
        $bool = 1;
      }
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            my @a = map { $_->() } @{ $::_V6_MATCH_->{'concat'} };
            return { alt => \@a, } if scalar @a > 1;
            return $a[0];
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for rule
#Data::Bind->sub_signature( \&rule, );

1;
