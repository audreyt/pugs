# !!! DO NOT EDIT !!!
# This file was generated by util/patch-rule-pmc.pl at Mon Oct 29 17:44:41 2007

package Pugs::Grammar::Rule;
use utf8;
no strict 'refs';
use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;

our %rule_terms;
our %variables;
*pod_begin = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1540} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1541} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1541} ) && 0 ) )
             ## </group>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq 'e' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq 'n' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1542} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq 'd' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1542} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             do { while (
              (   ( $pad{I1543} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1543} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1540} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1544} = $pos or 1 ) &&

               ## <dot>
               ## pos: 
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I1544} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             do { while (
              (   ( $pad{I1545} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1545} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1546} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1546} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_begin
 # Data::Bind->sub_signature
#  (\&pod_begin, );
;
*pod_other = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1547} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1548} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1548} ) && 0 ) )
             ## </group>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq '=' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq 'c' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq 'u' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1549} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq 't' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1549} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             do { while (
              (   ( $pad{I1550} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1550} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1547} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1551} = $pos or 1 ) &&

               ## <dot>
               ## pos: 
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I1551} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             do { while (
              (   ( $pad{I1552} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1552} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1553} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1553} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for pod_other
 # Data::Bind->sub_signature
#  (\&pod_other, );
;
*ws = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       (
        (   ( $pad{I1554} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1555} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1556} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1556} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 
                 do { while (
                  (   ( $pad{I1557} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1557} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1558} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1558} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 
                 (
                  (   ( $pad{I1559} = $pos or 1 ) &&
                     ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1560} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1560} ) && 0 ) )
                       ## </group>

                     &&
                       ## <quant>
                       ## pos: 
                       (
                        (   ( $pad{I1561} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 
                           (
                               ( $pad{I1562} = $pos or 1 )
                               && (
                               ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1563} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1563} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1564} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1564} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1565} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1565} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1566} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                                 ## </group>

                               &&
                                 ## <quant>
                                 ## pos: 
                                 do { while (
                                  (   ( $pad{I1567} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1567} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               &&
                                 ## <quant>
                                 ## pos: 
                                 do { while (
                                  (   ( $pad{I1568} = $pos or 1 ) &&

                                     ## <dot>
                                     ## pos: 
                                     ( substr( $s, $pos++, 1 ) ne '' )
                                     ## </dot>
 ||    ( ( $pos = $pad{I1568} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1569} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1569} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1570} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1571} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1572} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1572} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1573} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1573} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1574} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1574} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1575} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1575} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1576} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1576} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1577} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1577} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1578} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1578} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1579} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1579} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1580} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1580} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1581} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1581} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1582} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1582} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1583} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1583} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1561} ) && 0 ) )
                       || ( $bool = 1 )
                       )
                       ## </quant>

                     )
                     ## </concat>
 ||    ( ( $pos = $pad{I1559} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1584} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1584} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1554} ) && 0 ) )
       && do { while (
        (   ( $pad{I1554} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1555} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1556} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '#' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1556} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 
                 do { while (
                  (   ( $pad{I1557} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
 ||    ( ( $pos = $pad{I1557} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1558} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
 ||    ( ( $pos = $pad{I1558} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 
                 (
                  (   ( $pad{I1559} = $pos or 1 ) &&
                     ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1560} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1560} ) && 0 ) )
                       ## </group>

                     &&
                       ## <quant>
                       ## pos: 
                       (
                        (   ( $pad{I1561} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 
                           (
                               ( $pad{I1562} = $pos or 1 )
                               && (
                               ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1563} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1563} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1564} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1564} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1565} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1565} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'E' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'N' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1566} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'D' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                                 ## </group>

                               &&
                                 ## <quant>
                                 ## pos: 
                                 do { while (
                                  (   ( $pad{I1567} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
 ||    ( ( $pos = $pad{I1567} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               &&
                                 ## <quant>
                                 ## pos: 
                                 do { while (
                                  (   ( $pad{I1568} = $pos or 1 ) &&

                                     ## <dot>
                                     ## pos: 
                                     ( substr( $s, $pos++, 1 ) ne '' )
                                     ## </dot>
 ||    ( ( $pos = $pad{I1568} ) && 0 ) )) {}; $bool = 1 }
                                 ## </quant>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1569} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'b' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1569} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'g' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1570} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'n' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1571} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1572} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'k' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1572} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'w' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'i' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1573} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1573} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1574} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1574} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1575} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'p' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1575} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1576} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1576} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1577} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1577} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1578} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'f' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1578} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1579} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'r' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1579} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1580} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1580} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                               &&                                ## <concat>
                               ## pos: 
                               (
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1581} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq 'h' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1581} ) && 0 ) )
                                 ## </group>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'a' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq 'd' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1582} = $pos or 1 ) &&

                                   ## <constant>
                                   ## pos: 
                                   ( ( substr( $s, $pos, 1 ) eq '1' )
                                       ? ( $pos += 1 or 1 )
                                       : 0
                                   )
                                   ## </constant>
 ||    ( ( $pos = $pad{I1582} ) && 0 ) )
                                 ## </group>

                               &&
  
                                 ## <group>
                                 ## pos: 
                                  (   ( $pad{I1583} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1583} ) && 0 ) )
                                 ## </group>

                               )
                               ## </concat>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1561} ) && 0 ) )
                       || ( $bool = 1 )
                       )
                       ## </quant>

                     )
                     ## </concat>
 ||    ( ( $pos = $pad{I1559} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1584} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1584} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1554} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ws
 # Data::Bind->sub_signature
#  (\&ws, );
;
*ident = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       (
        (   ( $pad{I1585} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1586} = $pos or 1 )
               && (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1587} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1587} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1588} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1588} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1589} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1589} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1585} ) && 0 ) )
       && do { while (
        (   ( $pad{I1585} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1586} = $pos or 1 )
               && (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1587} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1587} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1588} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '_' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1588} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1589} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 2 ) eq '::' )
                     ? ( $pos += 2 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1589} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1585} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for ident
 # Data::Bind->sub_signature
#  (\&ident, );
;
*alnum = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1590} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I1590} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alnum
 # Data::Bind->sub_signature
#  (\&alnum, );
;
*alpha = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1591} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I1591} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for alpha
 # Data::Bind->sub_signature
#  (\&alpha, );
;
*digit = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1592} = $pos or 1 ) &&
         ## <perl5>
         ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9]))\X)/ )
             ? ( $pos += length( $1 ) or 1 )
             : 0
         )
         ## </perl5>
 ||    ( ( $pos = $pad{I1592} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for digit
 # Data::Bind->sub_signature
#  (\&digit, );
;
*special_char = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1593} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1594} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 
                       (
                           ( $pad{I1595} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1596} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'c' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1596} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1595} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1597} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'C' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1597} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1594} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1598} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1598} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1599} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 
                       (
                        (   ( $pad{I1600} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 
                           (
                               ( $pad{I1601} = $pos or 1 )
                               && (
                               ## <named_capture>
                               ## pos: 
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               ## </named_capture>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1602} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1602} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1603} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1603} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1604} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1604} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1605} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1605} ) && 0 ) )
                               ## </group>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1600} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1600} = $pos or 1 ) &&
                           ## <alt>
                           ## pos: 
                           (
                               ( $pad{I1601} = $pos or 1 )
                               && (
                               ## <named_capture>
                               ## pos: 
                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                           $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'alnum'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                               ## </named_capture>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&                                ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1602} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq ';' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1602} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1603} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq '(' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1603} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1604} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq ')' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1604} ) && 0 ) )
                               ## </group>

                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1601} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1605} = $pos or 1 ) &&

                                 ## <constant>
                                 ## pos: 
                                 ( ( substr( $s, $pos, 1 ) eq '-' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
 ||    ( ( $pos = $pad{I1605} ) && 0 ) )
                               ## </group>

                             )
                           )
                           ## </alt>
 ||    ( ( $pos = $pad{I1600} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1599} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1606} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1606} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1607} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1607} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1593} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1608} = $pos or 1 ) &&
               ## <alt>
               ## pos: 
               (
                   ( $pad{I1609} = $pos or 1 )
                   && (
  
                   ## <group>
                   ## pos: 
                    (   ( $pad{I1610} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 
                     ( ( substr( $s, $pos, 1 ) eq 'x' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I1610} ) && 0 ) )
                   ## </group>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1609} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 
                    (   ( $pad{I1611} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 
                     ( ( substr( $s, $pos, 1 ) eq 'X' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I1611} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I1608} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1612} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1612} ) && 0 ) )
             && do { while (
              (   ( $pad{I1612} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1612} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1613} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1613} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1593} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1614} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 
                       (
                           ( $pad{I1615} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1616} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'x' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1616} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1615} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1617} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'X' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1617} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1614} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1618} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1618} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1619} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 
                       (
                        (   ( $pad{I1620} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I1620} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1620} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'xdigit'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I1620} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1619} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1621} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1621} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1622} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1622} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1593} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1623} = $pos or 1 ) &&
               ## <alt>
               ## pos: 
               (
                   ( $pad{I1624} = $pos or 1 )
                   && (
  
                   ## <group>
                   ## pos: 
                    (   ( $pad{I1625} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 
                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I1625} ) && 0 ) )
                   ## </group>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1624} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 
                    (   ( $pad{I1626} = $pos or 1 ) &&

                     ## <constant>
                     ## pos: 
                     ( ( substr( $s, $pos, 1 ) eq 'O' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
 ||    ( ( $pos = $pad{I1626} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I1623} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1627} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1627} ) && 0 ) )
             && do { while (
              (   ( $pad{I1627} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1627} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1628} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1628} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1593} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1629} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 
                       (
                           ( $pad{I1630} = $pos or 1 )
                           && (
  
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1631} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'o' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1631} ) && 0 ) )
                           ## </group>

                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1630} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 
                            (   ( $pad{I1632} = $pos or 1 ) &&

                             ## <constant>
                             ## pos: 
                             ( ( substr( $s, $pos, 1 ) eq 'O' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
 ||    ( ( $pos = $pad{I1632} ) && 0 ) )
                           ## </group>

                         )
                       )
                       ## </alt>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1629} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1633} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1633} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1634} = $pos or 1 ) &&

               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 
                       (
                        (   ( $pad{I1635} = $pos or 1 ) &&
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I1635} ) && 0 ) )
                       && do { while (
                        (   ( $pad{I1635} = $pos or 1 ) &&
                           ## <perl5>
                           ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                               ? ( $pos += length( $1 ) or 1 )
                               : 0
                           )
                           ## </perl5>
 ||    ( ( $pos = $pad{I1635} ) && 0 ) )) {}; $bool = 1 }
                       )
                       ## </quant>
;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
 ||    ( ( $pos = $pad{I1634} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1636} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1636} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1637} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_->[0] . $::_V6_MATCH_->[1]});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1637} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1593} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1638} = $pos or 1 ) &&

               ## <dot>
               ## pos: 
               ( substr( $s, $pos++, 1 ) ne '' )
               ## </dot>
 ||    ( ( $pos = $pad{I1638} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1639} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'special_char' => '\\' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1639} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for special_char
 # Data::Bind->sub_signature
#  (\&special_char, );
;
*literal = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       do { while (
        (   ( $pad{I1640} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1641} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1642} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1642} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1643} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1643} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1641} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1644} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1644} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1640} ) && 0 ) )) {}; $bool = 1 }
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for literal
 # Data::Bind->sub_signature
#  (\&literal, );
;
*double_quoted = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       do { while (
        (   ( $pad{I1645} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1646} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1647} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1647} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1648} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1648} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1649} = $pos or 1 ) &&
                ## <metasyntax>
                 ## pos: 
                 do{
                my $match = 
          ## <variable>
          ## pos: 
          do {
            our $I1650;
            our $I1650_sizes;
            unless ( $I1650 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1650_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1650 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1650_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1650->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1650, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                ## </metasyntax>
 ||    ( ( $pos = $pad{I1649} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1651} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1651} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1645} ) && 0 ) )) {}; $bool = 1 }
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for double_quoted
 # Data::Bind->sub_signature
#  (\&double_quoted, );
;
*metasyntax = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       (
        (   ( $pad{I1652} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1653} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1654} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1654} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1655} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1655} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1656} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1656} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1657} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1657} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1658} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1658} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1659} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1659} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1660} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1660} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1661} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1661} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1662} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1662} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1663} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1663} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1664} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1664} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1665} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1665} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1666} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1666} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1667} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1667} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1668} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1668} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1652} ) && 0 ) )
       && do { while (
        (   ( $pad{I1652} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1653} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1654} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1654} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1655} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1655} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1656} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1656} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1657} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1657} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1658} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1658} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1659} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1659} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1660} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1660} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1661} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1661} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1662} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1662} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1663} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1663} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1664} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1664} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1665} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1665} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1666} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1666} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1667} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1667} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1653} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1668} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1668} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1652} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for metasyntax
 # Data::Bind->sub_signature
#  (\&metasyntax, );
;
*char_range = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       (
        (   ( $pad{I1669} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1670} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1671} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1671} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1672} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1672} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1670} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1673} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1673} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1669} ) && 0 ) )
       && do { while (
        (   ( $pad{I1669} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1670} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1671} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1671} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1672} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1672} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1670} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1673} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1673} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1669} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_range
 # Data::Bind->sub_signature
#  (\&char_range, );
;
*char_class = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1674} = $pos or 1 )
           && (
           ## <quant>
           ## pos: 
           (
            (   ( $pad{I1675} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1675} ) && 0 ) )
           && do { while (
            (   ( $pad{I1675} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1675} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1674} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1676} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1676} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1677} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1677} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1678} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1678} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for char_class
 # Data::Bind->sub_signature
#  (\&char_class, );
;
*string_code = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <quant>
       ## pos: 
       (
        (   ( $pad{I1679} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1680} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1681} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1681} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1682} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1682} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1683} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1683} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1684} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1684} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1685} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1685} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1686} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1686} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1687} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1687} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1688} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1688} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1689} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1689} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1690} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1691} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1692} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1692} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1691} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1693} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1693} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1690} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1694} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1694} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1695} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1695} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1696} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1697} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1698} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1698} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1699} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1699} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1696} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1700} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1700} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1701} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1701} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1702} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1703} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1704} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1704} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1703} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1705} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1705} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1702} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1706} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1706} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1707} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1708} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1709} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1709} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1710} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1710} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1711} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1711} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1712} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1712} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1707} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1713} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1713} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1714} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1714} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1715} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1715} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1679} ) && 0 ) )
       && do { while (
        (   ( $pad{I1679} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1680} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1681} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1681} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1682} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1682} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1683} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1683} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1684} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1684} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1685} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1685} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1686} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1686} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1687} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1687} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1688} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '"' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1688} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1689} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1689} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1690} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1691} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1692} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1692} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1691} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1693} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1693} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1690} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1694} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1694} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1695} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1695} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1696} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1697} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1698} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1698} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1697} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1699} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1699} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1696} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1700} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1700} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1701} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1701} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1702} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1703} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1704} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1704} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1703} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1705} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1705} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1702} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1706} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1706} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1707} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1708} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1709} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1709} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1710} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '>' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1710} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1711} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '=' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1711} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1708} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1712} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '-' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1712} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1707} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1713} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1713} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1714} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1714} ) && 0 ) )
               ## </group>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1680} ) or 1 )
               &&   
               ## <group>
               ## pos: 
                (   ( $pad{I1715} = $pos or 1 ) &&
                 ## <perl5>
                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                     ? ( $pos += length( $1 ) or 1 )
                     : 0
                 )
                 ## </perl5>
 ||    ( ( $pos = $pad{I1715} ) && 0 ) )
               ## </group>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1679} ) && 0 ) )) {}; $bool = 1 }
       )
       ## </quant>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for string_code
 # Data::Bind->sub_signature
#  (\&string_code, );
;
*parsed_code = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1716} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1716} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1717} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return('{' . $::_V6_MATCH_ . '}');
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1717} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parsed_code
 # Data::Bind->sub_signature
#  (\&parsed_code, );
;
*named_capture_body = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1718} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1719} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '(' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1719} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1720} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I1720} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1721} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1721} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1722} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1722} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1723} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '[' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1723} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1724} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I1724} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1725} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1725} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1726} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1726} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1727} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '<' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1727} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1728} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I1728} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1729} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1729} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1730} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1730} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1731} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
 ||    ( ( $pos = $pad{I1731} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1732} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1732} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1733} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1733} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1718} ) or 1 )
           &&   
           ## <group>
           ## pos: 
            (   ( $pad{I1734} = $pos or 1 ) &&
             ## <closure>
             ## pos: 
             do { 
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               sub { my $_V6_SELF = shift;  { die("invalid alias syntax");
 } }->( $m );
               1;
             }
             ## </closure>
 ||    ( ( $pos = $pad{I1734} ) && 0 ) )
           ## </group>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_capture_body
 # Data::Bind->sub_signature
#  (\&named_capture_body, );
;
*parse_metasyntax = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1735} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do{
                my $from = $pos;
                my $bool =                    ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1736} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1737} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '!' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1737} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1736} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1738} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '?' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1738} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1736} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1739} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq '.' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1739} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1736} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1740} = $pos or 1 ) &&
 1 # null constant
 ||    ( ( $pos = $pad{I1740} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
;
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'modifier'} = $match;
                $bool
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1735} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1741} = $pos or 1 ) &&
           ## <alt>
           ## pos: 
           (
               ( $pad{I1742} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1743} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1743} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1744} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1744} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1745} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 2 ) eq '}>' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1745} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1746} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I1746} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1747} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1747} ) && 0 ) )
                 ## </group>

               &&
                 ## <quant>
                 ## pos: 
                 (
                  (   ( $pad{I1748} = $pos or 1 ) &&

                     ## <capture>
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             ## <concat>
                             ## pos: 
                             (
  
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1749} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I1749} ) && 0 ) )
                               ## </group>

                             &&
  
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1750} = $pos or 1 ) &&
                                 ## <named_capture>
                                 ## pos: 
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                 ## </named_capture>
 ||    ( ( $pos = $pad{I1750} ) && 0 ) )
                               ## </group>

                             )
                             ## </concat>
;
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     }
                     ## </capture>
 ||    ( ( $pos = $pad{I1748} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1748} = $pos or 1 ) &&

                     ## <capture>
                     do{
                         my $hash = do {
                           my $bool = 1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
                             ## <concat>
                             ## pos: 
                             (
  
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1749} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I1749} ) && 0 ) )
                               ## </group>

                             &&
  
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1750} = $pos or 1 ) &&
                                 ## <named_capture>
                                 ## pos: 
                                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                             $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                 ## </named_capture>
 ||    ( ( $pos = $pad{I1750} ) && 0 ) )
                               ## </group>

                             )
                             ## </concat>
;
                           { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                         };
                         my $bool = ${$hash->{'bool'}};
                         if ( $bool ) {
                             push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                         }
                         $bool;
                     }
                     ## </capture>
 ||    ( ( $pos = $pad{I1748} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1751} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1751} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1752} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if(${ $::_V6_MATCH_->{'modifier'}} eq '!') { return({'negate' => {'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]}});
 } 
;
return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I1752} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1753} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1753} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1754} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1755} = $pos or 1 )
                       && (
                       ## <concat>
                       ## pos: 
                       (
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1756} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
 ||    ( ( $pos = $pad{I1756} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1757} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I1757} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1758} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1758} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1759} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'rule' => ${ $::_V6_MATCH_->{'rule'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I1759} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1755} ) or 1 )
                       &&                        ## <concat>
                       ## pos: 
                       (
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1760} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq ':' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1760} ) && 0 ) )
                         ## </group>

                       &&
                         ## <quant>
                         ## pos: 
                         (
                          (   ( $pad{I1761} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
 ||    ( ( $pos = $pad{I1761} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1762} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 
                           do{
                my $from = $pos;
                my $bool =                                    ## <quant>
                                   ## pos: 
                                   do { while (
                                    (   ( $pad{I1763} = $pos or 1 ) &&
                                       ## <alt>
                                       ## pos: 
                                       (
                                           ( $pad{I1764} = $pos or 1 )
                                           && (
                                           ## <concat>
                                           ## pos: 
                                           (
  
                                             ## <group>
                                             ## pos: 
                                              (   ( $pad{I1765} = $pos or 1 ) &&

                                               ## <constant>
                                               ## pos: 
                                               ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                   ? ( $pos += 1 or 1 )
                                                   : 0
                                               )
                                               ## </constant>
 ||    ( ( $pos = $pad{I1765} ) && 0 ) )
                                             ## </group>

                                           &&
  
                                             ## <group>
                                             ## pos: 
                                              (   ( $pad{I1766} = $pos or 1 ) &&
                                               ## <named_capture>
                                               ## pos: 
                                               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'special_char'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                               ## </named_capture>
 ||    ( ( $pos = $pad{I1766} ) && 0 ) )
                                             ## </group>

                                           )
                                           ## </concat>

                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I1764} ) or 1 )
                                           &&   
                                           ## <group>
                                           ## pos: 
                                            (   ( $pad{I1767} = $pos or 1 ) &&
                                            ## <metasyntax>
                                             ## pos: 
                                             do{
                my $match = 
          ## <variable>
          ## pos: 
          do {
            our $I1768;
            our $I1768_sizes;
            unless ( $I1768 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1768_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1768 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1768_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1768->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1768, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                                            ## </metasyntax>
 ||    ( ( $pos = $pad{I1767} ) && 0 ) )
                                           ## </group>

                                           )
                                         || (
                                           ( ( $bool = 1 ) && ( $pos = $pad{I1764} ) or 1 )
                                           &&   
                                           ## <group>
                                           ## pos: 
                                            (   ( $pad{I1769} = $pos or 1 ) &&
                                             ## <perl5>
                                             ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                 ? ( $pos += length( $1 ) or 1 )
                                                 : 0
                                             )
                                             ## </perl5>
 ||    ( ( $pos = $pad{I1769} ) && 0 ) )
                                           ## </group>

                                         )
                                       )
                                       ## </alt>
 ||    ( ( $pos = $pad{I1763} ) && 0 ) )) {}; $bool = 1 }
                                   ## </quant>
;
                my $match = Pugs::Runtime::Match->new(
                    { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                ); $named{'str'} = $match;
                $bool
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I1762} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1770} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1770} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1771} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'ident'}} eq 'before' || ${ $::_V6_MATCH_->{'ident'}} eq 'after')) { return({${ $::_V6_MATCH_->{'ident'}} => {'rule' => {'metasyntax' => {'metasyntax' => '\'' . ${ $::_V6_MATCH_->{'str'}} . '\''}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } 
;
return({'metasyntax' => {'metasyntax' => ${ $::_V6_MATCH_->{'ident'}}, 'string' => ${ $::_V6_MATCH_->{'str'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I1771} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1755} ) or 1 )
                       &&                        ## <concat>
                       ## pos: 
                       (
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1772} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq '(' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1772} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1773} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 
                           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                           ## </named_capture>
 ||    ( ( $pos = $pad{I1773} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1774} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq ')' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1774} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1775} = $pos or 1 ) &&

                           ## <constant>
                           ## pos: 
                           ( ( substr( $s, $pos, 1 ) eq '>' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
 ||    ( ( $pos = $pad{I1775} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1776} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'call' => {'method' => ${ $::_V6_MATCH_->{'ident'}}, 'params' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
 ||    ( ( $pos = $pad{I1776} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>

                     )
                   )
                   ## </alt>
 ||    ( ( $pos = $pad{I1754} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1742} ) or 1 )
               &&                ## <concat>
               ## pos: 
               (
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1777} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 
                   do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                               $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                   ## </named_capture>
 ||    ( ( $pos = $pad{I1777} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1778} = $pos or 1 ) &&

                   ## <constant>
                   ## pos: 
                   ( ( substr( $s, $pos, 1 ) eq '>' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
 ||    ( ( $pos = $pad{I1778} ) && 0 ) )
                 ## </group>

               &&
  
                 ## <group>
                 ## pos: 
                  (   ( $pad{I1779} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' =>  "" . ${ $::_V6_MATCH_->{'metasyntax'}}, 'modifier' => ${ $::_V6_MATCH_->{'modifier'}}}});
 } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
 ||    ( ( $pos = $pad{I1779} ) && 0 ) )
                 ## </group>

               )
               ## </concat>

             )
           )
           ## </alt>
 ||    ( ( $pos = $pad{I1741} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for parse_metasyntax
 # Data::Bind->sub_signature
#  (\&parse_metasyntax, );
;
%variables = ('$<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1780} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1780} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1781} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1781} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1782} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' .  $::_V6_MATCH_->{'ident'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1782} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1783} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1784} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1784} ) && 0 ) )
             && do { while (
              (   ( $pad{I1784} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1784} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1785} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1785} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1783} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1786} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1786} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1787} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1788} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1789} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1789} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1788} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1790} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1790} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1788} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1791} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1791} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1792} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1792} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1787} ) && 0 ) )
             && do { while (
              (   ( $pad{I1787} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1788} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1789} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1789} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1788} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1790} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1790} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1788} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1791} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1791} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1792} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1792} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1787} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1793} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '$' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1793} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'@' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1794} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1795} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1795} ) && 0 ) )
             && do { while (
              (   ( $pad{I1795} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1795} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1796} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1796} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1794} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1797} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1797} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1798} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1799} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1800} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1800} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1799} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1801} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1801} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1799} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1802} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1802} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1803} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1803} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1798} ) && 0 ) )
             && do { while (
              (   ( $pad{I1798} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1799} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1800} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1800} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1799} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1801} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1801} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1799} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1802} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1802} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1803} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1803} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1798} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1804} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '@' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1804} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'%' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1805} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1806} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1806} ) && 0 ) )
             && do { while (
              (   ( $pad{I1806} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1806} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1807} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'match_variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1807} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1805} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1808} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '^' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1808} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1809} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1810} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1811} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1811} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1810} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1812} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1812} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1810} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1813} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1813} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1814} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1814} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1809} ) && 0 ) )
             && do { while (
              (   ( $pad{I1809} = $pos or 1 ) &&
                 ## <alt>
                 ## pos: 
                 (
                     ( $pad{I1810} = $pos or 1 )
                     && (
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1811} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
 ||    ( ( $pos = $pad{I1811} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1810} ) or 1 )
                     &&   
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1812} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 1 ) eq '_' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1812} ) && 0 ) )
                     ## </group>

                     )
                   || (
                     ( ( $bool = 1 ) && ( $pos = $pad{I1810} ) or 1 )
                     &&                      ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1813} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1813} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1814} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 1 ) eq ':' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1814} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>

                   )
                 )
                 ## </alt>
 ||    ( ( $pos = $pad{I1809} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1815} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'variable' => '%' . $::_V6_MATCH_});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1815} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
%rule_terms = ('{*}' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1816} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => 'null'}});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1816} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\'' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1817} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1817} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1818} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq chr(39) )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1818} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1819} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'metasyntax' => {'metasyntax' => '\'' . ${$::_V6_MATCH_}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1819} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'(' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1820} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1820} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1821} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq ')' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1821} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1822} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capturing_group' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1822} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<(' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1823} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1823} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1824} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 2 ) eq ')>' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1824} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1825} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'capture_as_result' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1825} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<+' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1826} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1826} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1827} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1828} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I1828} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1829} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I1829} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I1827} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1830} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1830} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1831} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1831} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<-' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1832} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1832} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1833} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1834} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I1834} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1835} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I1835} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I1833} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1836} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1836} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1837} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['-' .  $::_V6_MATCH_->{'char_class'},
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1837} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<[' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1838} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_range'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1838} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1839} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1839} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1840} = $pos or 1 ) &&

             ## <capture>
             do{
                 my $hash = do {
                   my $bool = 1;
                   my $from = $pos;
                   my @match;
                   my %named;
                   $bool = 0 unless
                     ## <concat>
                     ## pos: 
                     (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1841} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
 ||    ( ( $pos = $pad{I1841} ) && 0 ) )
                       ## </group>

                     &&
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1842} = $pos or 1 ) &&
                         ## <named_capture>
                         ## pos: 
                         do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                     $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'char_class'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                         ## </named_capture>
 ||    ( ( $pos = $pad{I1842} ) && 0 ) )
                       ## </group>

                     )
                     ## </concat>
;
                   { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                 };
                 my $bool = ${$hash->{'bool'}};
                 if ( $bool ) {
                     push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                 }
                 $bool;
             }
             ## </capture>
 ||    ( ( $pos = $pad{I1840} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1843} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '>' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1843} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1844} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'char_class' => ['+[' .  $::_V6_MATCH_->{'char_range'} . ']',
@{($::_V6_MATCH_->[0])}]});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1844} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1845} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parse_metasyntax'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1845} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1846} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'parse_metasyntax'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1846} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'{' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1847} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1847} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1848} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1848} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1849} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => {'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}, 'modifier' => 'plain'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1849} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'\\' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1850} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'special_char'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1850} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1851} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'special_char'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1851} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'.' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1852} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'dot' => 1});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1852} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'[' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1853} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1853} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1854} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq ']' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1854} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1855} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'rule'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1855} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':::' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1856} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1856} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':?' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1857} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':?'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1857} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':+' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1858} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':+'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1858} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'::' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1859} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '::'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1859} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1860} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => ':'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1860} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1861} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1861} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'$' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1862} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '$'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1862} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^^' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1863} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1863} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'^' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1864} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '^'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1864} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'>>' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1865} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1865} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'»' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1866} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '>>'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1866} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'<<' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1867} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1867} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
'«' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
  
       ## <group>
       ## pos: 
        (   ( $pad{I1868} = $pos or 1 ) &&
         ## <closure>
         ## pos: 
         do {
           local $::_V6_SUCCEED = 1;
           $::_V6_MATCH_ = $m;
           $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'colon' => '<<'});
 } }->( $m ) ); 
           $bool = $::_V6_SUCCEED;
           $::_V6_MATCH_ = $m if $bool; 
           return $m if $bool; 
         }
         ## </closure>
 ||    ( ( $pos = $pad{I1868} ) && 0 ) )
       ## </group>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':i' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1869} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1869} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1870} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1870} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1871} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1871} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':ignorecase' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1872} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1872} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1873} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1873} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1874} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => {'modifier' => 'ignorecase', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1874} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':s' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1875} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1875} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1876} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1876} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1877} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1877} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':sigspace' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1878} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1878} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1879} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1879} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1880} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'sigspace', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1880} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':P5' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1881} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1881} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1882} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1882} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1883} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1883} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':Perl5' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1884} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1884} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1885} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1885} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1886} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'Perl5', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1886} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':bytes' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1887} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1887} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1888} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1888} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1889} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'bytes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1889} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':codes' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1890} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1890} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1891} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1891} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1892} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'codes', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1892} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':graphs' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1893} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1893} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1894} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1894} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1895} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'graphs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1895} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
,
':langs' => ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              my $s       = $_[0] || '';
              my $grammar = $_[1] || __PACKAGE__;
              $_[3] = $_[2];
              $_[2] = undef;
            
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1896} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1896} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1897} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1897} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1898} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'modifier' => 'langs', 'rule'=>${ $::_V6_MATCH_->{ qw(rule) }}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1898} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
);
*term = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1899} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1900} = $pos or 1 ) &&
              ## <metasyntax>
               ## pos: 
               do{
                my $match = 
          ## <variable>
          ## pos: 
          do {
            our $I1901;
            our $I1901_sizes;
            unless ( $I1901 ) {
                my $hash = \%Pugs::Grammar::Rule::variables;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1901_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1901 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1901_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1901->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1901, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
              ## </metasyntax>
 ||    ( ( $pos = $pad{I1900} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1902} = $pos or 1 ) &&
               ## <alt>
               ## pos: 
               (
                   ( $pad{I1903} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 
                   (
                     ## <quant>
                     ## pos: 
                     (
                      (   ( $pad{I1904} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1904} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>

                   &&
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1905} = $pos or 1 ) &&

                       ## <constant>
                       ## pos: 
                       ( ( substr( $s, $pos, 2 ) eq ':=' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
 ||    ( ( $pos = $pad{I1905} ) && 0 ) )
                     ## </group>

                   &&
                     ## <quant>
                     ## pos: 
                     (
                      (   ( $pad{I1906} = $pos or 1 ) &&
                         ## <metasyntax>
                         ## pos: 
                         do {
                              my $prior = $::_V6_PRIOR_;
                              my $match =
                                     $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                              $::_V6_PRIOR_ = $prior;
                              my $bool = (!$match != 1);
                              $pos = $match->to if $bool;
                              $match;
                         }
                         ## </metasyntax>
 ||    ( ( $pos = $pad{I1906} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>

                   &&
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1907} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 
                       do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                                   $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_capture_body'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                       ## </named_capture>
 ||    ( ( $pos = $pad{I1907} ) && 0 ) )
                     ## </group>

                   &&
  
                     ## <group>
                     ## pos: 
                      (   ( $pad{I1908} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'named_capture' => {'rule' => ${ $::_V6_MATCH_->{'named_capture_body'}}, 'ident' => ${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}}}});
 } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
 ||    ( ( $pos = $pad{I1908} ) && 0 ) )
                     ## </group>

                   )
                   ## </concat>

                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1903} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 
                    (   ( $pad{I1909} = $pos or 1 ) &&
                     ## <closure>
                     ## pos: 
                     do {
                       local $::_V6_SUCCEED = 1;
                       $::_V6_MATCH_ = $m;
                       $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::variables'}});
 } }->( $m ) ); 
                       $bool = $::_V6_SUCCEED;
                       $::_V6_MATCH_ = $m if $bool; 
                       return $m if $bool; 
                     }
                     ## </closure>
 ||    ( ( $pos = $pad{I1909} ) && 0 ) )
                   ## </group>

                 )
               )
               ## </alt>
 ||    ( ( $pos = $pad{I1902} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1899} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1910} = $pos or 1 ) &&
              ## <metasyntax>
               ## pos: 
               do{
                my $match = 
          ## <variable>
          ## pos: 
          do {
            our $I1911;
            our $I1911_sizes;
            unless ( $I1911 ) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1911_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1911 = $hash;
            }
            my $match = 0;
            my $key;
            for ( @$I1911_sizes ) {
                $key = ( $pos <= length( $s )
                            ? substr( $s, $pos, $_ )
                            : '' );
                if ( exists $I1911->{$key} ) {
                    #$named{KEY} = $key;
                    #$::_V6_MATCH_ = $m;
                    #print "m: ", Dumper( $::_V6_MATCH_->data )
                    #    if ( $key eq 'until' );
                    $match = Pugs::Runtime::Regex::preprocess_hash( $I1911, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                    last if $match;
                }
            }
            if ( $match ) {
                $pos = $match->to;
                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
            }; # else { $bool = 0 }
            $match;
          }
          ## </variable>
;
                if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
              ## </metasyntax>
 ||    ( ( $pos = $pad{I1910} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1912} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1912} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1899} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1913} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1913} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1914} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'constant' => ${$::_V6_MATCH_}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1914} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for term
 # Data::Bind->sub_signature
#  (\&term, );
;
*quant = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I1915} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I1916} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 2 ) eq '**' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1916} ) && 0 ) )
             ## </group>

           &&
             ## <quant>
             ## pos: 
             (
              (   ( $pad{I1917} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
 ||    ( ( $pos = $pad{I1917} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1918} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1918} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1919} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'parsed_code'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I1919} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1920} = $pos or 1 ) &&

               ## <constant>
               ## pos: 
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
 ||    ( ( $pos = $pad{I1920} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I1921} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'closure' => ${ $::_V6_MATCH_->{'parsed_code'}}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I1921} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I1915} ) or 1 )
           &&            ## <quant>
           ## pos: 
           (
            (   ( $pad{I1922} = $pos or 1 ) &&
               ## <perl5>
               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                   ? ( $pos += length( $1 ) or 1 )
                   : 0
               )
               ## </perl5>
 ||    ( ( $pos = $pad{I1922} ) && 0 ) )
           || ( $bool = 1 )
           )
           ## </quant>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quant
 # Data::Bind->sub_signature
#  (\&quant, );
;
*quantifier = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1923} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 
                           (
                            (   ( $pad{I1924} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I1924} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws1'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1923} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1925} = $pos or 1 ) &&
           ## <negate>
           ## pos: 
           do{
               my $pos1 = $pos;
               do {
                 my $pos = $pos1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 
                     ## <before>
                     ## pos: 
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 0 unless
  
                               ## <group>
                               ## pos: 
                                (   ( $pad{I1926} = $pos or 1 ) &&
                                 ## <perl5>
                                 ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                     ? ( $pos += length( $1 ) or 1 )
                                     : 0
                                 )
                                 ## </perl5>
 ||    ( ( $pos = $pad{I1926} ) && 0 ) )
                               ## </group>
;
                           $bool;
                         };
                     }
                     ## </before>
 ? 0 : 1;
                 $bool;
               };
           }
           ## </negate>
 ||    ( ( $pos = $pad{I1925} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1927} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'term'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1927} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1928} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 
                           (
                            (   ( $pad{I1929} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I1929} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws2'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1928} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1930} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'quant'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1930} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1931} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 
                           (
                            (   ( $pad{I1932} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
 ||    ( ( $pos = $pad{I1932} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'greedy'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1931} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1933} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do{
                my $match = Pugs::Runtime::Match->new( do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless 
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 
                           (
                            (   ( $pad{I1934} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
 ||    ( ( $pos = $pad{I1934} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
;
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                } );
                if ( $match ) { $named{'ws3'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1933} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1935} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { if((${ $::_V6_MATCH_->{'quant'}} eq '' && (${ $::_V6_MATCH_->{'greedy'}} eq '' && (${ $::_V6_MATCH_->{'ws1'}} eq '' && (${ $::_V6_MATCH_->{'ws2'}} eq '' && ${ $::_V6_MATCH_->{'ws3'}} eq ''))))) { return(${ $::_V6_MATCH_->{'term'}});
 } 
;
return({'quant' => {'term' => ${ $::_V6_MATCH_->{'term'}}, 'quant' => ${ $::_V6_MATCH_->{'quant'}}, 'greedy' => ${ $::_V6_MATCH_->{'greedy'}}, 'ws1' => ${ $::_V6_MATCH_->{'ws1'}}, 'ws2' => ${ $::_V6_MATCH_->{'ws2'}}, 'ws3' => ${ $::_V6_MATCH_->{'ws3'}}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1935} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for quantifier
 # Data::Bind->sub_signature
#  (\&quantifier, );
;
*concat = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1936} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1936} ) && 0 ) )
         && do { while (
          (   ( $pad{I1936} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'quantifier'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1936} ) && 0 ) )) {}; $bool = 1 }
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1937} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
        return { concat => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1937} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for concat
 # Data::Bind->sub_signature
#  (\&concat, );
;
*conjunctive1 = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1938} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
               ## <quant>
               ## pos: 
               (
                (   ( $pad{I1939} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1939} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1940} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1940} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1941} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 
                                      (   ( $pad{I1942} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I1942} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I1941} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1938} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1943} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1943} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1944} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1945} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1945} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1946} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 
                                      (   ( $pad{I1947} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 
                                       ( ( substr( $s, $pos, 1 ) eq '&' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I1947} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I1946} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1948} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'concat'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1948} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1944} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1949} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
        return { conjunctive1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1949} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive1
 # Data::Bind->sub_signature
#  (\&conjunctive1, );
;
*disjunctive1 = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1950} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
               ## <quant>
               ## pos: 
               (
                (   ( $pad{I1951} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1951} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1952} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1952} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1953} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 
                                      (   ( $pad{I1954} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I1954} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I1953} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1950} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1955} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1955} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1956} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1957} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1957} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1958} = $pos or 1 ) &&
                 ## <negate>
                 ## pos: 
                 do{
                     my $pos1 = $pos;
                     do {
                       my $pos = $pos1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 
                           ## <before>
                           ## pos: 
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 0 unless
  
                                     ## <group>
                                     ## pos: 
                                      (   ( $pad{I1959} = $pos or 1 ) &&

                                       ## <constant>
                                       ## pos: 
                                       ( ( substr( $s, $pos, 1 ) eq '|' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
 ||    ( ( $pos = $pad{I1959} ) && 0 ) )
                                     ## </group>
;
                                 $bool;
                               };
                           }
                           ## </before>
 ? 0 : 1;
                       $bool;
                     };
                 }
                 ## </negate>
 ||    ( ( $pos = $pad{I1958} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1960} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1960} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1956} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1961} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
        return { alt1 => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1961} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for disjunctive1
 # Data::Bind->sub_signature
#  (\&disjunctive1, );
;
*conjunctive = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1962} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
               ## <quant>
               ## pos: 
               (
                (   ( $pad{I1963} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1963} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1964} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1964} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1965} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1965} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1962} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1966} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1966} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1967} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1968} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1968} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1969} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '&' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1969} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1970} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1970} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1967} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1971} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
        return { conjunctive => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1971} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for conjunctive
 # Data::Bind->sub_signature
#  (\&conjunctive, );
;
*rule = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1972} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
               ## <quant>
               ## pos: 
               (
                (   ( $pad{I1973} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I1973} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1974} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1974} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1975} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1975} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1972} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1976} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I1976} ) && 0 ) )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I1977} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
  
               ## <group>
               ## pos: 
                (   ( $pad{I1978} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1978} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1979} = $pos or 1 ) &&

                 ## <constant>
                 ## pos: 
                 ( ( substr( $s, $pos, 1 ) eq '|' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
 ||    ( ( $pos = $pad{I1979} ) && 0 ) )
               ## </group>

             &&
  
               ## <group>
               ## pos: 
                (   ( $pad{I1980} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'conjunctive'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I1980} ) && 0 ) )
               ## </group>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I1977} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1981} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { 
        my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
        return { alt => \@a ,}  if scalar @a > 1;
        return $a[0];;
 # use v6
;
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1981} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for rule
 # Data::Bind->sub_signature
#  (\&rule, );
;
*named_regex = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1982} = $pos or 1 ) &&

           ## <capture>
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <alt>
                   ## pos: 
                   (
                       ( $pad{I1983} = $pos or 1 )
                       && (
  
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1984} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 5 ) eq 'token' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1984} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1983} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1985} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 5 ) eq 'regex' )
                             ? ( $pos += 5 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                       ## </group>

                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1983} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 
                        (   ( $pad{I1986} = $pos or 1 ) &&

                         ## <constant>
                         ## pos: 
                         ( ( substr( $s, $pos, 4 ) eq 'rule' )
                             ? ( $pos += 4 or 1 )
                             : 0
                         )
                         ## </constant>
 ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                       ## </group>

                     )
                   )
                   ## </alt>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           }
           ## </capture>
 ||    ( ( $pos = $pad{I1982} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1987} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I1987} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1988} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1988} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1989} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I1989} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1990} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '{' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1990} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1991} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I1991} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1992} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'rule'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I1992} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1993} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq '}' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1993} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I1994} = $pos or 1 ) &&

             ## <constant>
             ## pos: 
             ( ( substr( $s, $pos, 1 ) eq ';' )
                 ? ( $pos += 1 or 1 )
                 : 0
             )
             ## </constant>
 ||    ( ( $pos = $pad{I1994} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1995} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => ${$::_V6_MATCH_->[0]}, 'name' => ${ $::_V6_MATCH_->{'ident'}}, 'ast' => ${ $::_V6_MATCH_->{'rule'}}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I1995} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for named_regex
 # Data::Bind->sub_signature
#  (\&named_regex, );
;
*verbatim = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
  
         ## <group>
         ## pos: 
          (   ( $pad{I1996} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 2 ) eq '%{' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I1996} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I1997} = $pos or 1 ) &&

           ## <capture>
           do{
               my $hash = do {
                 my $bool = 1;
                 my $from = $pos;
                 my @match;
                 my %named;
                 $bool = 0 unless
                   ## <quant>
                   ## pos: 
                   do { while (
                    (   ( $pad{I1998} = $pos or 1 ) &&
                       ## <concat>
                       ## pos: 
                       (
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I1999} = $pos or 1 ) &&
                           ## <negate>
                           ## pos: 
                           do{
                               my $pos1 = $pos;
                               do {
                                 my $pos = $pos1;
                                 my $from = $pos;
                                 my @match;
                                 my %named;
                                 $bool = 
                                     ## <before>
                                     ## pos: 
                                     do{
                                         my $pos1 = $pos;
                                         do {
                                           my $pos = $pos1;
                                           my $from = $pos;
                                           my @match;
                                           my %named;
                                           $bool = 0 unless

                                               ## <constant>
                                               ## pos: 
                                               ( ( substr( $s, $pos, 2 ) eq '%}' )
                                                   ? ( $pos += 2 or 1 )
                                                   : 0
                                               )
                                               ## </constant>
;
                                           $bool;
                                         };
                                     }
                                     ## </before>
 ? 0 : 1;
                                 $bool;
                               };
                           }
                           ## </negate>
 ||    ( ( $pos = $pad{I1999} ) && 0 ) )
                         ## </group>

                       &&
  
                         ## <group>
                         ## pos: 
                          (   ( $pad{I2000} = $pos or 1 ) &&

                           ## <dot>
                           ## pos: 
                           ( substr( $s, $pos++, 1 ) ne '' )
                           ## </dot>
 ||    ( ( $pos = $pad{I2000} ) && 0 ) )
                         ## </group>

                       )
                       ## </concat>
 ||    ( ( $pos = $pad{I1998} ) && 0 ) )) {}; $bool = 1 }
                   ## </quant>
;
                 { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
               };
               my $bool = ${$hash->{'bool'}};
               $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
               $bool;
           }
           ## </capture>
 ||    ( ( $pos = $pad{I1997} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2001} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 2 ) eq '%}' )
               ? ( $pos += 2 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2001} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2002} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'type' => 'block', 'value' => ${$::_V6_MATCH_->[0]}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2002} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for verbatim
 # Data::Bind->sub_signature
#  (\&verbatim, );
;
*item = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <alt>
       ## pos: 
       (
           ( $pad{I2003} = $pos or 1 )
           && (
           ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I2004} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'verbatim'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2004} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I2005} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'verbatim'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2005} ) && 0 ) )
             ## </group>

           )
           ## </concat>

           )
         || (
           ( ( $bool = 1 ) && ( $pos = $pad{I2003} ) or 1 )
           &&            ## <concat>
           ## pos: 
           (
  
             ## <group>
             ## pos: 
              (   ( $pad{I2006} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 
               do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                           $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'named_regex'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
               ## </named_capture>
 ||    ( ( $pos = $pad{I2006} ) && 0 ) )
             ## </group>

           &&
  
             ## <group>
             ## pos: 
              (   ( $pad{I2007} = $pos or 1 ) &&
               ## <closure>
               ## pos: 
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return(${ $::_V6_MATCH_->{'named_regex'}});
 } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
 ||    ( ( $pos = $pad{I2007} ) && 0 ) )
             ## </group>

           )
           ## </concat>

         )
       )
       ## </alt>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for item
 # Data::Bind->sub_signature
#  (\&item, );
;
*grammar = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I2008} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2008} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2009} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 7 ) eq 'grammar' )
               ? ( $pos += 7 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2009} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2010} = $pos or 1 ) &&
           ## <metasyntax>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                my $bool = (!$match != 1);
                $pos = $match->to if $bool;
                $match;
           }
           ## </metasyntax>
 ||    ( ( $pos = $pad{I2010} ) && 0 ) )
         ## </group>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2011} = $pos or 1 ) &&
           ## <named_capture>
           ## pos: 
           do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                       $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { $named{'ident'} = $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
           ## </named_capture>
 ||    ( ( $pos = $pad{I2011} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I2012} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2012} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2013} = $pos or 1 ) &&

           ## <constant>
           ## pos: 
           ( ( substr( $s, $pos, 1 ) eq ';' )
               ? ( $pos += 1 or 1 )
               : 0
           )
           ## </constant>
 ||    ( ( $pos = $pad{I2013} ) && 0 ) )
         ## </group>

       &&
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I2014} = $pos or 1 ) &&
             ## <metasyntax>
             ## pos: 
             do {
                  my $prior = $::_V6_PRIOR_;
                  my $match =
                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                  $::_V6_PRIOR_ = $prior;
                  my $bool = (!$match != 1);
                  $pos = $match->to if $bool;
                  $match;
             }
             ## </metasyntax>
 ||    ( ( $pos = $pad{I2014} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I2015} = $pos or 1 ) &&
             ## <concat>
             ## pos: 
             (
  
               ## <group>
               ## pos: 
                (   ( $pad{I2016} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 
                 do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                             $grammar->item( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'item'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
                 ## </named_capture>
 ||    ( ( $pos = $pad{I2016} ) && 0 ) )
               ## </group>

             &&
               ## <quant>
               ## pos: 
               (
                (   ( $pad{I2017} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
 ||    ( ( $pos = $pad{I2017} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>

             )
             ## </concat>
 ||    ( ( $pos = $pad{I2015} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2018} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({${ $::_V6_MATCH_->{'ident'}} =>  $::_V6_MATCH_->{'item'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2018} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for grammar
 # Data::Bind->sub_signature
#  (\&grammar, );
;
*spec = ## <global>
## sigspace: 0
## ratchet: 1
do { my $rule; $rule = sub {
  
              $_[3] = $_[2];
              eval{ $_[2] = undef };
              my $grammar
             = $_[0];
  my $s = $_[1];
  $_[3] = $_[2] unless defined $_[3]; # backwards compat
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  my $bool;
  my @pos;
  # XXX :pos(X) takes the precedence over :continue ?
  if (defined $_[3]{p}) {
    push @pos, $_[3]{p} || 0;
  } elsif ($_[3]{continue}) {
    push @pos, (pos($_[1]) || 0) .. length($s);
  } else {
    push @pos, 0..length($s);
  }
  for my $pos ( @pos ) {
    my %index;
    my @match;
    my %named;
    $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new( {
      str => \$s, from => \(0+$pos), to => \($pos),
      bool => \$bool, match => \@match, named => \%named, capture => undef,
    } );
    {
      my $prior = $::_V6_PRIOR_;
      local $::_V6_PRIOR_ = $prior;
      $bool = 0 unless
       ## <concat>
       ## pos: 
       (
         ## <quant>
         ## pos: 
         (
          (   ( $pad{I2019} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'verbatim'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2019} ) && 0 ) )
         || ( $bool = 1 )
         )
         ## </quant>

       &&
         ## <quant>
         ## pos: 
         do { while (
          (   ( $pad{I2020} = $pos or 1 ) &&
             ## <named_capture>
             ## pos: 
             do {
                my $prior = $::_V6_PRIOR_;
                my $match =
                         $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                $::_V6_PRIOR_ = $prior;
                if ( $match ) { push @{$named{'grammar'}}, $match;
                    $pos = $match->to;
                    1
                }
                else { 0 }
            }
             ## </named_capture>
 ||    ( ( $pos = $pad{I2020} ) && 0 ) )) {}; $bool = 1 }
         ## </quant>

       &&
  
         ## <group>
         ## pos: 
          (   ( $pad{I2021} = $pos or 1 ) &&
           ## <closure>
           ## pos: 
           do {
             local $::_V6_SUCCEED = 1;
             $::_V6_MATCH_ = $m;
             $m->data->{capture} = \( sub { my $_V6_SELF = shift;  { return({'block' =>  $::_V6_MATCH_->{'verbatim'}, 'grammar' =>  $::_V6_MATCH_->{'grammar'}});
 } }->( $m ) ); 
             $bool = $::_V6_SUCCEED;
             $::_V6_MATCH_ = $m if $bool; 
             return $m if $bool; 
           }
           ## </closure>
 ||    ( ( $pos = $pad{I2021} ) && 0 ) )
         ## </group>

       )
       ## </concat>
;
    }
    if ( $bool ) {
      my $prior = $::_V6_PRIOR_;
      $::_V6_PRIOR_ = sub {
        local $main::_V6_PRIOR_ = $prior;
        $rule->(@_);
      };
      #warn "pos2 = ", $pos, "\n";
      pos($_[1]) = $pos if $_[3]{continue};
      last;
    }
  } # /for
  $::_V6_MATCH_ = $m;
  return $m;
} }
## </global>
;## Signature for spec
 # Data::Bind->sub_signature
#  (\&spec, );
;

; 1;
