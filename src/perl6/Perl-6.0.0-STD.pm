grammar Perl-6.0.0-STD;          # (XXX maybe should be -PROTO or some such)

=begin things todo

    WHICH etc.
    contextualizers
    Array of Int
    bracket matching incl Unicode Ps/Pe
    Captures
    Signatures
    quote declarator
    right side of s///, tr///, s[] = expr
    &foo:(Int,Num)
    &foo\($a,$b)
    \c[LATIN CAPITAL LETTER A]
    sublanguages
    exporting grammars to the compiler vs namespace (which one is default?)
    add parsing this file to sanity tests :)

=end things todo

# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via
# the following #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to $/ within the action block, so we need not mention it explicitly.

# This grammar also assumes transitive longest-token semantics, though
# we make a feeble attempt to order rules so a procedural | can usually
# produce a correct parse.

rule TOP { <compunit> {*} }                             #= TOP

# Built-in or autogenerated rules:
#      <EXPR>: the operator precedence parser
#  <CATEGORY>: the rule matching any valid category names
#       <foo>: all tokens of foo category |-ed together

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implmentation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

my %term              ::= { :prec<z=>                           };
my %methodcall        ::= { :prec<w=>                           };
my %autoincrement     ::= { :prec<v=>, :assoc<non>, :lvalue     };
my %exponentiation    ::= { :prec<u=>, :assoc<right>            };
my %symbolic_unary    ::= { :prec<t=>                           };
my %multiplicative    ::= { :prec<s=>, :assoc<left>             };
my %additive          ::= { :prec<r=>, :assoc<left>             };
my %junctive_and      ::= { :prec<q=>, :assoc<list>             };
my %junctive_or       ::= { :prec<p=>, :assoc<list>             };
my %named_unary       ::= { :prec<o=>, :assoc<left>             };
my %nonchaining       ::= { :prec<n=>, :assoc<non>              };
my %chaining          ::= { :prec<m=>, :assoc<chain>            };
my %tight_and         ::= { :prec<l=>, :assoc<left>             };
my %tight_or          ::= { :prec<k=>, :assoc<left>             };
my %conditional       ::= { :prec<j=>, :assoc<right>            };
my %item_assignment   ::= { :prec<i=>, :assoc<right>, :lvalue   };
my %loose_unary       ::= { :prec<h=>, :assoc<right>            };
my %comma             ::= { :prec<g=>, :assoc<list>             };
my %list_infix        ::= { :prec<f=>                           };
my %list_prefix       ::= { :prec<e=>                           };
my %loose_and         ::= { :prec<d=>                           };
my %loose_or          ::= { :prec<c=>                           };
my %terminator        ::= { :prec<a=>, :assoc<list>             };

my $LOOSEST = "a=!";    # "epsilon" tighter than terminator

# XXX maybe shouldn't be hash, but for now.

our %quote_adverb := {
    Q => {                          # base form of all quotes
        use => &q_pickdelim,
        adv => &Q_adverb,
        esc => < >,
    },
    q  => {
        use => &q_pickdelim,
        adv => &q_quote_adverb,
        esc => < \\ >,
    },
    qq => {
        use => &q_pickdelim,
        adv => &q_quote_adverb,
        esc => < \\ $ @ % & { >,
    },
    b => {
        add => < \\ >,
    },
    s => {
        add => < $ >,
    },
    a => {
        add => < @ >,
    },
    h => {
        add => < % >,
    },
    f => {
        add => < & >,
    },
    c => {
        add => < { >,
    },
    to => {
        use => &q_herestub,
        adv => &q_quote_adverb,
        add => < ^^ >,          #  grabs leading whitespace
    },
    rx => {
        use => &q_regex,
        adv => &q_regex_adverb,
        esc => < >,             # let regex parser handle everything
    },
    m => {
        use => &q_regex,
        adv => &q_regex_adverb,
        esc => < >,             # let regex parser handle everything
    },
    s => {
        use => &q_regex,
        adv => &q_regex_adverb,
        esc => < >,             # let regex parser handle everything
    },
    tr => {
        use => &q_trans,
        adv => &q_trans_adverb,
        esc => < >,             # let trans parser handle everything
    },
}

our %regex_adverb := {
    g => {
        ...
    },
    # XXX --more--
}

our %trans_adverb := {
    d => {
        ...
    },
    # XXX --more--
}

role Term {...}
role Methodcall {...}
role Autoincrement {...}
role Exponentiation {...}
role Symbolic_unary {...}
role Multiplicative {...}
role Additive {...}
role Junctive_and {...}
role Junctive_or {...}
role Named_unary {...}
role Nonchaining {...}
role Chaining {...}
role Tight_and {...}
role Tight_or {...}
role Conditional {...}
role Item_assignment {...}
role Loose_unary {...}
role Comma {...}
role List_infix {...}
role List_prefix {...}
role Loose_and {...}
role Loose_or {...}
role Terminator {...}

# Categories are designed to be extensible in derived grammars.

# The endsym trait, if specified, says what to implicitly check for in each
# rule right after the initial :<symbol>.  Normally this is used to make sure
# there's appropriate whitespace, though Perl 6 also uses it to rule out
# the => (fatarrow) construct.

proto token noun_prefix_sigil;
proto token noun_prefix_twigil;
proto token special_variable;
proto token nameroot;
proto token version;

proto token term;
proto token quote;
proto token prefix  is defequiv(%symbolic_unary);
proto token infix   is defequiv(%additive);
proto token postfix is defequiv(%autoincrement);

proto token circumfix;
proto token postcircumfix;

proto token regex_metachar;
proto token regex_backslash;
proto token regex_assertion;
proto token regex_mod_internal;
proto token regex_mod_external;
proto token quote_mod;

proto token q_backslash;
proto token qq_backslash;

proto token trait_verb         is endsym(/ \s+ <nofat> /);
proto token trait_auxiliary    is endsym(/ \s+ <nofat> /);

proto token type_declarator    is endsym(/ >> <nofat> /);
proto token scope_declarator   is endsym(/ >> <nofat> /);
proto token package_declarator is endsym(/ >> <nofat> /);
proto token routine_declarator is endsym(/ >> <nofat> /);
proto rule statement_prefix   is endsym(/ >> <nofat> /);
proto rule statement_control  is endsym(/ \s <nofat> /);
proto rule statement_cond     is endsym(/ >> <nofat> /);
proto rule statement_loop     is endsym(/ >> <nofat> /);

proto token infix_prefix_meta_operator;
proto token infix_postfix_meta_operator;
proto token postfix_prefix_meta_operator;
proto token prefix_postfix_meta_operator;
proto token prefix_circumfix_meta_operator;

# Lexical routines

# make sure we're not an autoquoted identifier
regex nofat { <!before \h* <?unsp> =\> > }

class Herestub {
    has Str $.delim;
    has $.orignode;
    has $.lang;
}

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

method heredoc {
    while my $herestub = shift @herestub_queue {
        my $delim = $herestub.delim;
        my $lang = $herestub.lang;
        my $doc;
        my $ws = "";
        my $stoppat = $delim eq "" ?? rx[^^ \h* $$]
                                   !! rx[^^ $ws:=(\h*?) $delim \h* $$ \n?];
        my @heredoc_initial_ws is context is rw;
        if m:p/$doc:=<q_unbalanced($lang, :stop($stoppat))>/ {
            if $ws and @heredoc_initial_ws {
                my $wsequiv = $ws;
                $wsequiv ~~ s/^ (\t+) /{ ' ' x ($0 * 8) }/; # per spec
                for @heredoc_initial_strings {
                    next if s/^ $ws //;   # reward consistent tabbing
                    s/^^ (\t+) /{ ' ' x ($0 * 8) }/;
                    s/^ $wsequiv // or s/^ \h+ //;
                }
            }
            $herestub.orignode<doc> = $doc;
        }
        else {
            fail("Ending delimiter $delim not found");
        }
    }
}

token ws {
    || <?after \w> <?before \w> ::: <fail>        # must \s+ between words
    || [
       | <unsp>              {*}                        #= ws unsp
       | \v                  {*} <heredoc>              #= ws vwhite
       | <unv>               {*}                        #= ws unv
       ]*  {*}                                          #= ws all
}

token unsp {
    \\ <?before [\s|\#]>
    [
    | \v                     {*}                        #= unsp vwhite
    | <unv>                  {*}                        #= unsp unv
    ]*  {*}                                             #= unsp all
}

token unv {
       | \h+                 {*}                        #= unv hwhite
       | ^^ [
            | \# \N*         {*}                        #= unv comment line
            | <?pod_comment> {*}                        #= unv comment pod
            ]
       | <'#'> [
            # assuming <bracketed> defaults to standard set
            | <?bracketed>   {*}                        #= unv comment inline
            | \N*            {*}                        #= unv comment end
            ]
}

# XXX We need to parse the pod eventually to support $= variables.

token pod_comment {
    ^^ =
    [
    | begin <?ws> <ident> .*? \n
      =end <?ws> $<ident> \N* \n?                   {*} #= pod block
    | \N* \n?                                       {*} #= pod misc
    ]
                                                    {*} #= pod comment
}

# Top-level rules

rule comp_unit {
    ^
    [ <package_declarator> <module_name> <trait>* ; ]?
    <statement_list>
    [ $ || <panic: Parse terminated early> ]
                                                    {*} #= comp_unit
}

token block {
    \{
    <statement_list>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp> <?before <[,:]>> {*}                       #= block
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= block endline
    | {*} { let $<endlist> := 1; }                       #= block endlist
    ]
                                                        {*} #= block
}

token regex_block {  # perhaps parameterize and combine with block someday
    \{
    <regex \}>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp> <?before <[,:]>> {*}                       #= rxblock
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= rxblock endline
    | {*} { let $<endlist> := 1; }                       #= rxblock endlist
    ]
                                                        {*} #= rxblock
}

rule statement_list {
    <statement>*
                                                    {*} #= statement_list
}

token label { <ident> \: \s <?ws> {*} }                 #= label

rule statement {
    <label>*                                     {*}    #= label
    [
    | <statement_control>                        {*}    #= statement control
    | <block>                                    {*}    #= statement block
    | <EXPR>                                     {*}    #= statement expr
        [<statement_cond> <EXPR> {*} ]?                 #= statement mod cond
        [<statement_loop> <EXPR> {*} ]?                 #= statement mod loop
    ]
                                                        {*} #= statement
}

rule statement_control {
    :<use>
    <module_name_wild> <EXPR>? ;?                       {*} #? #= sc use
}

rule statement_control {
    :<if>
    <EXPR>                           {*}                #= sc if expr
    <block>                          {*}                #= sc if block
    @<elsif> := [ elsif <EXPR>       {*}                #= sc if elsif expr
                        <block>      {*} ]*             #= sc if elsif block
    @<else> := [ else <block>        {*} ]?             #= sc if else
                                                        {*} #= sc if
}

rule statement_control {
    :<unless>
    <EXPR>                           {*}                #= sc unless expr
    <block>                          {*}                #= sc unless block
                                                        {*} #= sc unless
}

rule statement_control {
    :<while>
    <EXPR>                             {*}                #= sc while expr
    <block>                            {*}                #= sc while block
                                                          {*} #= sc while
}

rule statement_control {
    :<until>
    <EXPR>                             {*}                #= sc until expr
    <block>                            {*}                #= sc until block
                                                          {*} #= sc until
}
rule statement_control {
    :<repeat>
    [
        | (while|until) <EXPR>         {*}              #= sc repeat wu expr
          <block>                      {*}              #= sc repeat wu block
        | <block>                      {*}              #= sc repeat block wu
          (while|until) <EXPR>         {*}              #= sc repeat expr wu
    ]
                                                          {*} #= sc repeat
}
rule statement_control {
    :<loop>
    $<eee> := [
        \(
            $<e1> := <EXPR> ;   {*}                     #= sc loop e1
            $<e2> := <EXPR> ;   {*}                     #= sc loop e2
            $<e3> := <EXPR>     {*}                     #= sc loop e3
        \)                      {*}                     #= sc loop eee
    ]?
    <block>                     {*}                     #= sc loop block
                                                        {*} #= sc loop
}

rule statement_control { :<for>     <block> {*} }        #= sc for
rule statement_control { :<when>    <block> {*} }        #= sc when
rule statement_control { :<BEGIN>   <block> {*} }        #= sc BEGIN
rule statement_control { :<CHECK>   <block> {*} }        #= sc CHECK
rule statement_control { :<INIT>    <block> {*} }        #= sc INIT
rule statement_control { :<END>     <block> {*} }        #= sc END
rule statement_control { :<START>   <block> {*} }        #= sc START
rule statement_control { :<ENTER>   <block> {*} }        #= sc ENTER
rule statement_control { :<LEAVE>   <block> {*} }        #= sc LEAVE
rule statement_control { :<KEEP>    <block> {*} }        #= sc KEEP
rule statement_control { :<UNDO>    <block> {*} }        #= sc UNDO
rule statement_control { :<FIRST>   <block> {*} }        #= sc FIRST
rule statement_control { :<NEXT>    <block> {*} }        #= sc NEXT
rule statement_control { :<LAST>    <block> {*} }        #= sc LAST
rule statement_control { :<PRE>     <block> {*} }        #= sc PRE
rule statement_control { :<POST>    <block> {*} }        #= sc POST
rule statement_control { :<CATCH>   <block> {*} }        #= sc CATCH
rule statement_control { :<CONTROL> <block> {*} }        #= sc CONTROL

token statement_control { %statement_control }

rule modifier_expr { <EXPR> ;? {*} }                    #? #= modifier_expr

token statement_modifier { <statement_cond> | <statement_loop> }

rule statement_cond { :<if>     <modifier_expr> {*} };     #= scond if
rule statement_cond { :<unless> <modifier_expr> {*} };     #= scond unless
rule statement_cond { :<when>   <modifier_expr> {*} };     #= scond for

rule statement_loop { :<for>    <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<given>  <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<while>  <modifier_expr> {*} };     #= sloop while
rule statement_loop { :<until>  <modifier_expr> {*} };     #= sloop until

token nameroot { <'perl6'> }
token nameroot { <'perl5'> }
token nameroot { <'parrot'> }
token nameroot { <'ruby'> }
token nameroot { <'python'> }
token nameroot { <'tcl'> }
token nameroot { <'js'> }
token nameroot { <'scheme'> }
token nameroot { <'lisp'> }
token nameroot { <'haskell'> }
token nameroot { <'java'> }
token nameroot { <'c'> }
token nameroot { <'cplusplus'> }
token nameroot { <'csharp'> }
token nameroot { <'ada'> }
token nameroot { <'lua'> }
token nameroot { <'php'> }

token module_name {
    <name>                                          {*} #= modulename name
    [- <version>                                    {*} #= modulename version
        [-
            <authority>                             {*} #= modulename auth
        ]?
    ]?
                                                    {*} #= modulename
}

token authority { <-[ \s ; \{ ]>+ }

token module_name_wild {
    [ <nameroot> \: {*} ]?                              #= modulewild root
    <name>                                          {*} #= modulewild name
    [- <version_wild>                               {*} #= modulewild version
        [-
            <authority_wild>                        {*} #= modulewild auth
        ]?
    ]?
                                                    {*} #= modwild
}

token version_wild   { <block> | <whatever> | <version> }
token authority_wild { <block> | <whatever> | <authority> }

token whatever { \* }

token version {
    v \d+ [ \. \d+ ]*                 {*}             #= version vstyle
}
token version {
    \d+ \. \d+ \. \d+ [ \. \d+]*      {*}             #= version dotted
}

###################################################

token expect_term {
    <?ws>

    [
        [
        | <prefix>                                      {*} #= Xterm prefix
        | <prefix_circumfix_meta_operator>              {*} #= Xterm precircum
        ]
        <prefix_postfix_meta_operator>*                 {*} #= Xterm prepost
    ]*

    <noun>                                              {*} #= Xterm noun
    <expect_postfix>*                                   {*} #= Xterm postfix
                                                        {*} #= Xterm
    <?ws>
    <adverbs>?
}

token adverbs {
    [ <colonpair> <?ws> ]+
    {
        my $prop = $+prevop err
            panic('No previous operator visible to adverbial pair (' ~
                $<colonpair> ~ ')');
        $prop.adverb($<colonpair>)
    }
}

token noun {
    | <pair>
    | <circumfix>
    | <package_block>
    | <variable>
    | <value>
    | <quote>
    | <term>
    | <scope_declarator>
    | <routine_block>
    | <regex_block>
    | <statement_prefix>
}

token pair {
    | $<key>:=<ident> \h* =\> $<val>:=<EXPR(%assignment<prec>)>
    | [ <colonpair> <?ws> ]+
}

token colonpair {
    [
    | \: !? <ident>
    | \: <ident>? <unsp>? <postcircumfix>
    ]
}

token expect_infix ($loosest) {
    <infix_prefix_meta_operator>*
    <infix>
    <infix_postfix_meta_operator>*
    ::: <?{ resolve_meta($/) and $<infix>.prec ge $loosest }>
                                                    {*} #= Xinfix
}

token dotty {
    | <'.+'>                                  {*}     #= dotty plus
    | <'.*'>                                  {*}     #= dotty star
    | <'.?'>                                  {*}     #= dotty query
    | <'.='>                                  {*}     #= dotty equals
    | <'.^'>                                  {*}     #= dotty caret
    | <'.:'>                                  {*}     #= dotty colon
    | <'.'>                                   {*}     #= dotty plain
}

token expect_postfix {
    [
    | \\ <?before \.>
    | <?unsp>
    | <null>
    ]

    [ [\. <?unsp>?]? <postfix_prefix_meta_operator> <?unsp>? ]*

    [
    | $<dot> := <dotty> <?unsp>? <methodop>
    | $<dot> := [ \.]   <?unsp>? <postop>
    |                            <postop>
    ]
                                                    {*} #= Xpostfix
}
token prefix_circumfix_meta_operator {
    :<[> <infix> :<]>                               {*}  #= precircum square
}

token prefix_postfix_meta_operator { :<«>     {*} }  #» #= prepost hyper
token prefix_postfix_meta_operator { :['<<'] {*} }      #= prepost HYPER

token postfix_prefix_meta_operator { :<»>     {*} }     #= postpre hyper
token postfix_prefix_meta_operator { :['>>'] {*} }      #= postpre HYPER

token infix_prefix_meta_operator { :<!>     {*} }       #= inpre not
token infix_prefix_meta_operator { :<«>     {*} }    #» #= inpre hyper dwim
token infix_prefix_meta_operator { :<»>     {*} }       #= inpre hyper asis
token infix_prefix_meta_operator { :['<<'] {*} }        #= inpre HYPER dwim
token infix_prefix_meta_operator { :['>>'] {*} }        #= inpre HYPER asis

token infix_postfix_meta_operator { :<=>     {*} }      #= inpost assign
token infix_postfix_meta_operator { :<«>     {*} }   #» #= inpost hyper asis
token infix_postfix_meta_operator { :<»>     {*} }      #= inpost hyper dwim
token infix_postfix_meta_operator { :['<<']  {*} }      #= inpost HYPER asis
token infix_postfix_meta_operator { :['>>']  {*} }      #= inpost HYPER dwim

token postfix { :<i> {*} }                              #= postfix i
token postfix { :<++> {*} }                             #= postfix incr
token postfix { :<--> {*} }                             #= postfix decr

token postcircumfix { :<(> <EXPR> :<)> {*} }            #= postcircumfix ( )

token postcircumfix { :<[> <EXPR> :<]> {*} }            #= postcircumfix [ ]

token postcircumfix { :<{> <EXPR> :<}> {*} }            #= postcircumfix { }
token postcircumfix { :['<'] <anglewords> :['>']
                                                    {*} #= postcircumfix < >
}

token postcircumfix { :['<'] <shellwords> :['>']
                                                    {*} #= postcircumfix << >>
}

token postcircumfix { :<«> <shellwords> :<»> {*} }      #= postcircumfix « »

token postop { <postfix> | <postcircumfix> }

token dot {
    (
    | \\ <?before \.>
    | <?unsp>
    )
    (\. [\>\>|»] )?
    \. (<[= * + ?]> <?unsp>? <?before \w>)?
                                                    {*} #= dot
}

token methodop {
    <ident>
    [
    | \.? \( <EXPR> \)
    | \: <?before \s> <listop_expr>
    | <null>
    ]
}

token circumfix { :<(> <EXPR> :<)> {*} }                #= circumfix ( )
token circumfix { :<[> <EXPR> :<]> {*} }                #= circumfix [ ]

token circumfix { :['<']  <anglewords>  :['>'] {*} }    #= circumfix < >
token circumfix { :['<<'] <shellwords> :['>>'] {*} }    #= circumfix << >>
token circumfix { :<«>    <shellwords> :<»>    {*} }    #= circumfix « »

token circumfix is Circumfix[:symbol<{ }>]
    { <block>         {*} }                             #= circumfix { }

rule scoped_variables {
    <scope_declarator> <variable>
}

token scope_declarator { :<my>       {*} }     #= sd my
token scope_declarator { :<our>      {*} }     #= sd our
token scope_declarator { :<state>    {*} }     #= sd state
token scope_declarator { :<constant> {*} }     #= sd constant
token scope_declarator { :<has>      {*} }     #= sd has

token package_declarator { :<class>     {*} }     #= td class
token package_declarator { :<grammar>   {*} }     #= td grammar
token package_declarator { :<module>    {*} }     #= td module
token package_declarator { :<role>      {*} }     #= td role
token package_declarator { :<package>   {*} }     #= td package

token package_block {
    <scope_declarator>?
    <package_declarator>
    <module_name>?              # XXX maybe shouldn't have version/auth?
    <trait>*
    <block>
}

token special_variable { :<$!>  {*} }
token special_variable { :<$/>  {*} }

token variable {
    | <special_variable>
    | <sigiltwigil> <name>
    | <name> <'::'> <hashpostfix>
}

token sigiltwigil {
    <noun_prefix_sigil>
    <noun_prefix_twigil>?
}

token noun_prefix_sigil { :<$>   {*} }               #= sigil $
token noun_prefix_sigil { :<@>   {*} }               #= sigil @
token noun_prefix_sigil { :<@@>  {*} }               #= sigil @@
token noun_prefix_sigil { :<%>   {*} }               #= sigil %
token noun_prefix_sigil { :<&>   {*} }               #= sigil &
token noun_prefix_sigil { :<::>  {*} }               #= sigil ::

token noun_prefix_twigil { :<.>  {*} }               #= twigil .
token noun_prefix_twigil { :<!>  {*} }               #= twigil !
token noun_prefix_twigil { :<^>  {*} }               #= twigil ^
token noun_prefix_twigil { :<*>  {*} }               #= twigil *
token noun_prefix_twigil { :<+>  {*} }               #= twigil +
token noun_prefix_twigil { :<?>  {*} }               #= twigil ?
token noun_prefix_twigil { :<=>  {*} }               #= twigil =

token name {
    | <ident> <nofat> [ <'::'> <ident> ]*
    | [ <'::'> <ident> ]+
}

token subname {
    | <name>
    | <CATEGORY> \: <postcurcumfix>
}

token value {
    | <string>
    | <number>
    | <version>
    | <typename>
}

regex typename {
    <name>
    <?{
        is_type($<name>)
    }>
}

token number {
    | <int>
    | <num>
    | <radix>
}

token integer {
    | 0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]*
        ]
    | \d+[_\d+]*
}

token num {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
}

token radix {
    \: $<radix> := [\d+] 
    [
    || \<
            $<radnum> := [<[ 0..9 a..z A..Z ]>+ [ \. <[ 0..9 a..z A..Z ]>+ ]? ]
            [ \* $<base> := <number> \*\* $<exp> := <number> ]?
       \>
      { return radcalc($<radix>, $<radnum>, $<base>, $<exp>) }
    || <?before \[> <postcircumfix>
    || <?before \(> <postcircumfix>
    }
}

token quote { <before :<'>>    <bracketed(%sublang<Q:q>)>   :<'>    }
token quote { <before :<">>    <bracketed(%sublang<Q:q>)>   :<">    }
token quote { <before :['<']>  <bracketed(%sublang<Q:w>)> :['>']  }
token quote { <before :['<<']> <bracketed(%sublang<Q:ww>)> :['>>'] }

token quote { (:<q>) <quotesnabber($0)> }
token quote { (:<qq>) <quotesnabber($0)> }
token quote { (:<qw>) <quotesnabber($0)> }
token quote { (:<qww>) <quotesnabber($0)> }
token quote { (:<qx>) <quotesnabber($0)> }
token quote { (:<qt>) <quotesnabber($0)> }
token quote { (:<qn>) <quotesnabber($0)> }
token quote { (:<qs>) <quotesnabber($0)> }
token quote { (:<qa>) <quotesnabber($0)> }
token quote { (:<qh>) <quotesnabber($0)> }
token quote { (:<qf>) <quotesnabber($0)> }
token quote { (:<qc>) <quotesnabber($0)> }
token quote { (:<qb>) <quotesnabber($0)> }

token quote { (:<rx>) <quotesnabber($0)> }
token quote { (:<m>) <quotesnabber($0)> }
token quote { (:<mm>) <quotesnabber($0)> }
token quote { (:<s>) <quotesnabber($0)> <finish_subst> } # XXX handwave
token quote { (:<ss>) <quotesnabber($0)> <finish_subst> } # XXX handwave
token quote { (:<tr>) <quotesnabber($0)> <finish_trans> } # XXX handwave

# The key observation here is that the inside of quoted constructs may
# be any of a lot of different sublanguages, and we have to parameterize
# which parse rule to use as well as what options to feed that parse rule.

token quotesnabber ($q, :$lang = $sublang{"Q:$q"}) {
    >> <nofat> ::
    <?ws>

    # Look for current lang's adverbs.
    [ <$($lang<adv>)($lang)> { $lang.tweak($/) } <?ws> ]*

      # Dispatch to current lang's subparser.
      <$($lang<use>)($lang)>
}

method tweaklang {
    # XXX assuming quote_mod returns a pair...
    $<lang>{$<quote_mod>.key} = $<quote_mod>.value;
}

# assumes whitespace is eaten already

regex q_pickdelim ($lang, @esc = $lang<esc>) {
    [
    | <?before @openers>
      <?before $<start> := [(.)$0*]>
      { $<stop> := flipbrack($<start>) }
      <q_balanced($lang, $<start>, $<stop>, @esc)>
    | [ $<stop> := [\S] || <panic: Quote delimiter must not be whitespace> ]
        <q_unbalanced($lang, $<stop>, @esc)>
    ]
}

regex q_balanced ($lang, $start, $stop, :@esc = $lang<esc>) {
    $<start> := <$start>
    $<text> := [.*?]
    @<more> := [
      <!before <$stop>>
      [
      || <?before <$start>> $<subtext> := <q_balanced($lang, $start, $stop, :@esc)>
      || <?before @esc> $<escape> := [ <q_escape($lang)> ]
      ]
      $<text> := [.*?]
    ]*
    $<stop> := <$stop>
}

regex q_unbalanced ($stop, @esc) {
    $<text> := [.*?]
    @<more> := [
      <!before <$stop>>
      [ <?before @esc> $<escape> := [ <q_escape($lang)> ]
      $<text> := [.*?]
    ]*
    $<stop> := <$stop>
}

##  rules for parsing interpolated values in quotes.
##  The first part of the rule handles non-scalar
##  interpolation (which must end with a postcircumfix operator);
##  the second part handles scalar interpolation.

token quote_interpolation {
    | <![$]> ::: <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )+
    | <variable>
          $<postfix>:=( <?dot> [ <postcircumfix> | $<method>:=<ident> ]
                     | <postcircumfix> )*
}

rule routine_block {
    <scope_declarator>?
    <subintro>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <block>
}

rule regex_method {
    <scope_declarator>?
    <regex_declarator>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <regex_block>
}

rule subintro { <routine_modifier> <routine_type>? | <routine_type> }

token routine_modifier { multi | proto }

token routine_declarator { :<sub> }
token routine_declarator { :<method> }
token routine_declarator { :<submethod> }
token routine_declarator { :<macro> }

token regex_declarator { :<regex> }
token regex_declarator { :<token> }
token regex_declarator { :<rule> }

rule trait { <trait_verb> | <trait_auxiliary> }

token trait_auxiliary { :<is>   <ident>[\( <EXPR> \)]? }
token trait_auxiliary { :<will> <ident> <block> }

token trait_verb { :<of>        <type> }
token trait_verb { :<returns>   <type> }

rule signature {
    [<parameter> [ [ \, | \: | ; | ;; ] <parameter> ]* ]?
    [ --\> <type> ]?
}

rule type_declarator {
    :<subset>
    <name>
    [ of <type_name> ]?
    where <subset>
}

rule type_constraint {
    | <value>
    | <type_name>
    | where <subset>
}

token parameter {
    <slurp>?
    <type_constraint>*
    [
    | \: <ident>? \(
      <sigiltwigil>  <ident>?
      \)
    | <sigiltwigil>  <ident>?
    ]
    <default_value>
}

rule statement_prefix { :<do>      <statement> {*} }    #= sp do
rule statement_prefix { :<try>     <statement> {*} }    #= sp try
rule statement_prefix { :<gather>  <statement> {*} }    #= sp gather
rule statement_prefix { :<contend> <statement> {*} }    #= sp contend
rule statement_prefix { :<async>   <statement> {*} }    #= sp async
rule statement_prefix { :<lazy>    <statement> {*} }    #= sp lazy

## term
token term is Term[]                            #= term:<*> def
    { :<*> {*} }                                #= term:<*>

token circumfix is Term[]                       #= circumfix:<( )> def
    { :<( )> {*} }                              #= circumfix:<( )>

token postcircumfix is Term[]                   #= postcircumfix:<( )> def
    is abstract('call')
    { :<( )> {*} }                              #= postcircumfix:<( )>

## autoincrement
token postfix is Autoincrement[]                #= postfix:<++> def
    { :<++> {*} }                               #= postfix:<++>

token postfix is Autoincrement[]                #= postfix:<--> def
    { :<--> {*} }                               #= postfix:<-->

token prefix is Autoincrement[]                 #= prefix:<++> def
    { :<++> {*} }                               #= prefix:<++>

token prefix is Autoincrement[]                 #= prefix:<--> def
    { :<--> {*} }                               #= prefix:<-->


## exponentiation
token infix is Exponentiate[]                   #= infix:<**> def
    { :<**> {*} }                               #= infix:<**>

## symbolic unary
token prefix is Symbolic_unary[]                #= prefix:<!> def
    { :<!> {*} }                                #= prefix:<!>

token prefix is Symbolic_unary[]                #= prefix:<+> def
    { :<+> {*} }                                #= prefix:<+>

token prefix is Symbolic_unary[]                #= prefix:<-> def
    { :<-> {*} }                                #= prefix:<->

token prefix is Symbolic_unary[]                #= prefix:<~> def
    { :<~> {*} }                                #= prefix:<~>

token prefix is Symbolic_unary[]                #= prefix:<?> def
    { :<?> {*} }                                #= prefix:<?>

token prefix is Symbolic_unary[]                #= prefix:<=> def
    { :<=> {*} }                                #= prefix:<=>

token prefix is Symbolic_unary[]                #= prefix:<*> def
    { :<*> {*} }                                #= prefix:<*>

token prefix is Symbolic_unary[]                #= prefix:<**> def
    { :<**> {*} }                               #= prefix:<**>

token prefix is Symbolic_unary[]                #= prefix:<~^> def
    { :<~^> {*} }                               #= prefix:<~^>

token prefix is Symbolic_unary[]                #= prefix:<+^> def
    { :<+^> {*} }                               #= prefix:<+^>

token prefix is Symbolic_unary[]                #= prefix:<?^> def
    { :<?^> {*} }                               #= prefix:<?^>

token prefix is Symbolic_unary[]                #= prefix:<^> def
    { :<^> {*} }                                #= prefix:<^>


## multiplicative
token infix is Multiplicative[]                 #= infix:<*> def
    { :<*> {*} }                                #= infix:<*>

token infix is Multiplicative[]                 #= infix:</> def
    { :</> {*} }                                #= infix:</>

token infix is Multiplicative[]                 #= infix:<%> def
    { :<%> {*} }                                #= infix:<%>

token infix is Multiplicative[]                 #= infix:<x> def
    { :<x> {*} }                                #= infix:<x>

token infix is Multiplicative[]                 #= infix:<xx> def
    { :<xx> {*} }                               #= infix:<xx>

token infix is Multiplicative[]                 #= infix:<+&> def
    { :<+&> {*} }                               #= infix:<+&>

token infix is Multiplicative[]                 #= infix:['+<'] def
    { :['+<'] {*} }                             #= infix:['+<']

token infix is Multiplicative[]                 #= infix:['+>'] def
    { :['+>'] {*} }                             #= infix:['+>']

token infix is Multiplicative[]                 #= infix:<~&> def
    { :<~&> {*} }                               #= infix:<~&>

token infix is Multiplicative[]                 #= infix:['~<'] def
    { :['~<'] {*} }                             #= infix:['~<']

token infix is Multiplicative[]                 #= infix:['~>'] def
    { :['~>'] {*} }                             #= infix:['~>']


## additive
token infix is Additive[]                       #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Additive[]                       #= infix:<-> def
    { :<-> {*} }                                #= infix:<->

token infix is Additive[]                       #= infix:<~> def
    { :<~> {*} }                                #= infix:<~>

token infix is Additive[]                       #= infix:<+|> def
    { :<+|> {*} }                               #= infix:<+|>

token infix is Additive[]                       #= infix:<+^> def
    { :<+^> {*} }                               #= infix:<+^>

token infix is Additive[]                       #= infix:<~|> def
    { :<~|> {*} }                               #= infix:<~|>

token infix is Additive[]                       #= infix:<~^> def
    { :<~^> {*} }                               #= infix:<~^>

token infix is Additive[]                       #= infix:<?|> def
    { :<?|> {*} }                               #= infix:<?|>

token infix is Additive[]                       #= infix:<?^> def
    { :<?^> {*} }                               #= infix:<?^>


## junctive and (all)
token infix is Junctive_and[]                   #= infix:<&> def
    { :<&> {*} }                                #= infix:<&>


## junctive or (any)
token infix is Junctive_or[]                    #= infix:<|> def
    { :<|> {*} }                                #= infix:<|>

token infix is Junctive_or[]                    #= infix:<^> def
    { :<^> {*} }                                #= infix:<^>


## named unary examples
token prefix is Named_unary[]                   #= prefix:<rand> def
    { :<rand> {*} }                             #= prefix:<rand>

token prefix is Named_unary[]                   #= prefix:<sleep> def
    { :<sleep> {*} }                            #= prefix:<sleep>

token prefix is Named_unary[]                   #= prefix:<abs> def
    { :<abs> {*} }                              #= prefix:<abs>

## nonchaining binary
token infix is Nonchaining[]                    #= infix:['<=>'] def
    { :['<=>'] {*} }                            #= infix:['<=>']

token infix is Nonchaining[]                    #= infix:<cmp> def
    { :<cmp> {*} }                              #= infix:<cmp>

token infix is Nonchaining[]                    #= infix:<is> def
    { :<is> {*} }                               #= infix:<is>

token infix is Nonchaining[]                    #= infix:<but> def
    { :<but> {*} }                              #= infix:<but>

token infix is Nonchaining[]                    #= infix:<does> def
    { :<does> {*} }                             #= infix:<does>

token infix is Nonchaining[]                    #= infix:<..> def
    { :<..> {*} }                               #= infix:<..>

token infix is Nonchaining[]                    #= infix:<^..> def
    { :<^..> {*} }                              #= infix:<^..>

token infix is Nonchaining[]                    #= infix:<..^> def
    { :<..^> {*} }                              #= infix:<..^>

token infix is Nonchaining[]                    #= infix:<^..^> def
    { :<^..^> {*} }                             #= infix:<^..^>

token infix is Nonchaining[]                    #= infix:<ff> def
    { :<ff> {*} }                               #= infix:<ff>

token infix is Nonchaining[]                    #= infix:<^ff> def
    { :<^ff> {*} }                              #= infix:<^ff>

token infix is Nonchaining[]                    #= infix:<ff^> def
    { :<ff^> {*} }                              #= infix:<ff^>

token infix is Nonchaining[]                    #= infix:<^ff^> def
    { :<^ff^> {*} }                             #= infix:<^ff^>

token infix is Nonchaining[]                    #= infix:<fff> def
    { :<fff> {*} }                              #= infix:<fff>

token infix is Nonchaining[]                    #= infix:<^fff> def
    { :<^fff> {*} }                             #= infix:<^fff>

token infix is Nonchaining[]                    #= infix:<fff^> def
    { :<fff^> {*} }                             #= infix:<fff^>

token infix is Nonchaining[]                    #= infix:<^fff^> def
    { :<^fff^> {*} }                            #= infix:<^fff^>


## chaining binary
token infix is Chaining[]                       #= infix:<==> def
    { :<==> {*} }                               #= infix:<==>

token infix is Chaining[]                       #= infix:<!=> def
    { :<!=> {*} }                               #= infix:<!=>

token infix is Chaining[]                       #= infix:['<'] def
    { :['<'] {*} }                              #= infix:['<']

token infix is Chaining[]                       #= infix:['<='] def
    { :['<='] {*} }                             #= infix:['<=']

token infix is Chaining[]                       #= infix:['>'] def
    { :['>'] {*} }                              #= infix:['>']

token infix is Chaining[]                       #= infix:['>='] def
    { :['>='] {*} }                             #= infix:['>=']

token infix is Chaining[]                       #= infix:<~~> def
    { :<~~> {*} }                               #= infix:<~~>

token infix is Chaining[]                       #= infix:<!~> def
    { :<!~> {*} }                               #= infix:<!~>

token infix is Chaining[]                       #= infix:<=~> def
    { :<=~> {*} }                               #= infix:<=~>

token infix is Chaining[]                       #= infix:<eq> def
    { :<eq> {*} }                               #= infix:<eq>

token infix is Chaining[]                       #= infix:<ne> def
    { :<ne> {*} }                               #= infix:<ne>

token infix is Chaining[]                       #= infix:<lt> def
    { :<lt> {*} }                               #= infix:<lt>

token infix is Chaining[]                       #= infix:<le> def
    { :<le> {*} }                               #= infix:<le>

token infix is Chaining[]                       #= infix:<gt> def
    { :<gt> {*} }                               #= infix:<gt>

token infix is Chaining[]                       #= infix:<ge> def
    { :<ge> {*} }                               #= infix:<ge>

token infix is Chaining[]                       #= infix:<=:=> def
    { :<=:=> {*} }                              #= infix:<=:=>

token infix is Chaining[]                       #= infix:<===> def
    { :<===> {*} }                              #= infix:<===>


## tight and
token infix is Tight_and[]                      #= infix:<&&> def
    is abstract('if')
    { :<&&> {*} }                               #= infix:<&&>


## tight or
token infix is Tight_or[]                       #= infix:<||> def
    is abstract('unless')
    { :<||> {*} }                               #= infix:<||>

token infix is Tight_or[:assoc<list>]           #= infix:<^^> def
    is assoc('list')
    is abstract('xor')
    { :<^^> {*} }                               #= infix:<^^>

token infix is Tight_or[]                       #= infix:<//> def
    { :<//> {*} }                               #= infix:<//>


## conditional
token infix is Conditional[]                    #= infix:<?? !!> def
    is abstract('if')
    { :<??> <EXPR(%conditional<prec>)> :<!!> {*} }   #= infix:<?? !!>


## assignment
token infix is Assignment[]                     #= infix:<=> def
    is abstract('assign')
    is lvalue(1)
    { :<=> {*} }                                #= infix:<=>

token infix is Assignment[]                     #= infix:<:=> def
    is abstract('bind')
    { :<:=> {*} }                               #= infix:<:=>

token infix is Assignment[]                     #= infix:<::=> def
    { :<::=> {*} }                              #= infix:<::=>

token infix is Assignment[]                     #= infix:<.=> def
    { :<.=> {*} }                               #= infix:<.=>

token infix is Assignment[]                     #= infix:<~=> def
    { :<~=> {*} }                               #= infix:<~=>

token infix is Assignment[]                     #= infix:<+=> def
    { :<+=> {*} }                               #= infix:<+=>

token infix is Assignment[]                     #= infix:<-=> def
    { :<-=> {*} }                               #= infix:<-=>

token infix is Assignment[]                     #= infix:<*=> def
    { :<*=> {*} }                               #= infix:<*=>

token infix is Assignment[]                     #= infix:</=> def
    { :</=> {*} }                               #= infix:</=>

token infix is Assignment[]                     #= infix:<%=> def
    { :<%=> {*} }                               #= infix:<%=>

token infix is Assignment[]                     #= infix:<x=> def
    { :<x=> {*} }                               #= infix:<x=>

token infix is Assignment[]                     #= infix:<Y=> def
    { :<Y=> {*} }                               #= infix:<Y=>

token infix is Assignment[]                     #= infix:<**=> def
    { :<**=> {*} }                              #= infix:<**=>

token infix is Assignment[]                     #= infix:<xx=> def
    { :<xx=> {*} }                              #= infix:<xx=>

token infix is Assignment[]                     #= infix:<||=> def
    { :<||=> {*} }                              #= infix:<||=>

token infix is Assignment[]                     #= infix:<&&=> def
    { :<&&=> {*} }                              #= infix:<&&=>

token infix is Assignment[]                     #= infix:<//=> def
    { :<//=> {*} }                              #= infix:<//=>

token infix is Assignment[]                     #= infix:<^^=> def
    { :<^^=> {*} }                              #= infix:<^^=>

token infix is Assignment[]                     #= infix:<+<=> def
    { :<+<=> {*} }                           #> #= infix:<+<=>

token infix=> is Assignment[]                   #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Assignment[]                     #= infix:<+|=> def
    { :<+|=> {*} }                              #= infix:<+|=>

token infix is Assignment[]                     #= infix:<+&=> def
    { :<+&=> {*} }                              #= infix:<+&=>

token infix is Assignment[]                     #= infix:<+^=> def
    { :<+^=> {*} }                              #= infix:<+^=>

token infix is Assignment[]                     #= infix:<~|=> def
    { :<~|=> {*} }                              #= infix:<~|=>

token infix is Assignment[]                     #= infix:<~&=> def
    { :<~&=> {*} }                              #= infix:<~&=>

token infix is Assignment[]                     #= infix:<~^=> def
    { :<~^=> {*} }                              #= infix:<~^=>

token infix is Assignment[]                     #= infix:<?|=> def
    { :<?|=> {*} }                              #= infix:<?|=>

token infix is Assignment[]                     #= infix:<?&=> def
    { :<?&=> {*} }                              #= infix:<?&=>

token infix is Assignment[]                     #= infix:<?^=> def
    { :<?^=> {*} }                              #= infix:<?^=>

token infix is Assignment[]                     #= infix:<|=> def
    { :<|=> {*} }                               #= infix:<|=>

token infix is Assignment[]                     #= infix:<&=> def
    { :<&=> {*} }                               #= infix:<&=>

token infix is Assignment[]                     #= infix:<^=> def
    { :<^=> {*} }                               #= infix:<^=>

## list item separator
token infix is Comma[]                          #= infix:<,> def
    { :<,> {*} }                                #= infix:<,>

## loose unary
token prefix is Loose_unary[]                   #= prefix:<true> def
    { :<true> {*} }                             #= prefix:<true>

token prefix is Loose_unary[]                   #= prefix:<not> def
    { :<not> {*} }                              #= prefix:<not>

## list prefix (really sub calls)
token prefix is List_prefix[]                   #= prefix:<print> def
    { :<print> {*} }                            #= prefix:<print>

## loose and
token infix is Loose_and[]                      #= infix:<and> def
    is abstract('if')
    { :<and> {*} }                              #= infix:<and>

## loose or
token infix is Loose_or[]                       #= infix:<or> def
    is abstract('unless')
    { :<or> {*} }                               #= infix:<or>

token infix is Loose_or[]                       #= infix:<xor> def
    is abstract('xor')
    { :<xor> {*} }                              #= infix:<xor>

token infix is Loose_or[]                       #= infix:<err> def
    { :<err> {*} }                              #= infix:<err>

## expression terminator

# XXX correct to eat semicolon here?
token terminator is Terminator[]                #= terminator:<;> def
    { :<;> {*} }                                #= terminator:<;>

token terminator is Terminator[]                #= terminator:['<=='] def
    { <?before :['<=='] > {*} }                 #= terminator:['<==']

token terminator is Terminator[]                #= terminator:['==>'] def
    { <?before :['==>'] > {*} }              #' #= terminator:['==>']

token terminator is Terminator[]                #= terminator:<)> def
    { <?before :<)> > {*} }                     #= terminator:<)>

token terminator is Terminator[]                #= terminator:<]> def
    { <?before :<]> > {*} }                     #= terminator:<]>

token terminator is Terminator[]                #= terminator:<}> def
    { <?before :<}> > {*} }                     #= terminator:<}>

token terminator is Terminator[]                #= terminator:<!!> def
    { <?before :<!!> > {*} }                    #= terminator:<!!>

token stdstopper { <terminator> | <statement_cond> | <statement_loop> | $ }
token assertstopper { <stdstopper> | \> }

# A fairly complete (but almost certainly buggy) operator precedence parser

method EXPR (:$prec = $LOOSEST, :$stop = &stdstoppers) {
    constant $TERMINATOR = ';' ~~ &terminator;
    if m:p/ <?before <$stop>> / {
        return;
    }
    my $prevop is context is rw;
    my @termstack;
    my @opstack;
    push @opstack, $TERMINATOR;         # (just a sentinel value)
    push @termstack, $.expect_term();

    my sub reduce {
        my $op = pop @opstack;
        given $op.assoc {
            when 'chain' {
                my @chain;
                push @chain, pop(@termstack);
                push @chain, $op;
                while @opstack {
                    last if $op.prec ne @opstack[-1].prec;
                    push @chain, pop(@termstack);
                    push @chain, pop(@opstack);
                }
                push @chain, pop(@termstack);
                $op.chain = reverse @chain;
                push @termstack, $op;
            }
            when 'list' {
                my @list;
                push @list, pop(@termstack);
                while @opstack {
                    last if $op.symbol ne @opstack[-1].symbol;
                    push @list, pop(@termstack);
                    pop(@opstack);
                }
                push @list, pop(@termstack);
                $op.list = reverse @list;
                push @termstack, $op;
            }
            default {
                $op.right = pop @termstack;
                $op.left = pop @termstack;
                push @termstack, $op;
            }
        }
    }

    while not m:p/ <?before <$stop> > / {
        my $infix := $.expect_infix($prec) // $TERMINATOR;
        my Str $newprec = $infix.prec;

        # Does new infix (or terminator) force any reductions?
        while @opstack[-1].prec lt $newprec {
            reduce();
        }

        # Not much point in reducing the sentinels...
        last if $newprec lt $LOOSEST;

        # Equal precedence, so use associativity to decide.
        if @opstack[-1].prec eq $newprec {
            given $infix.assoc {
                when 'non'   { panic(qq["$infix" is not associative]) }
                when 'left'  { reduce() }   # reduce immediately
                when 'right' | 'chain' { }  # just shift
                when 'list'  {              # if op differs reduce else shift
                    reduce() if $infix.symbol !eqv @opstack[-1].symbol;
                }
                default { panic(qq[Unknown associativity "$_" for "$infix"] }
            }
        }
        push @opstack, $infix;
        if m:p/ <?before <$stop>> / {
            fail("$infix.perl() is missing right term");
        }
        push @termstack, $.expect_term();
    }
    reduce() if @termstack > 1;
    @termstack == 1 or panic("Internal operator parser error");
    return @termstack[0];
}

#############################################3333
## Regex
#############################################3333

rule regex ($stop is context) {
    <regex_ordered_disjunction>
}

rule regex_ordered_disjunction {
    <'||'>?
    <regex_ordered_conjunction>
    [ :<||> <regex_ordered_conjunction> ]*
}

rule regex_ordered_conjunction {
    <regex_unordered_disjunction>
    [ :<&&> <regex_unordered_disjunction> ]*
}

rule regex_unordered_disjunction {
    <'|'>?
    <regex_unordered_conjunction>
    [ :<|> <regex_unordered_conjunction> ]*
}

rule regex_unordered_conjunction {
    <regex_sequence>
    [ :<&> <regex_sequence> ]*
}

rule regex_sequence {
    <regex_quantified_atom>+
    # Could combine unquantified atoms into one here...
}

rule regex_quantified_atom {
    <regex_atom>
    [ <regex_quantifier>
        <?{ $<regex_atom>.max_width }>
            || <panic: "Can't quantify zero-width atom")
    ]?
}

rule <regex_atom> {
    || <$+stop> :: <fail>
    || <regex_metachar>
    || (.)
}

# sequence stoppers
token regex_metachar { :['>'] :: <fail> }
token regex_metachar { :<&&>  :: <fail> }
token regex_metachar { :<&>   :: <fail> }
token regex_metachar { :<||>  :: <fail> }
token regex_metachar { :<|>   :: <fail> }
token regex_metachar { :<}>   :: <fail> }
token regex_metachar { :<]>   :: <fail> }
token regex_metachar { :<)>   :: <fail> }

# "normal" metachars
token regex_metachar { <block> }
token regex_metachar { <quantifier> <panic: quantifier quantifies nothing> }
token regex_metachar { <regex_mod_internal> }
token regex_metachar { :<[> <regex \]> :<]> }
token regex_metachar { :<(> <regex \)> :<)> }
token regex_metachar { :<\>> <regex_rightangle> }
token regex_metachar { :['<('] }
token regex_metachar { :[')>'] }
token regex_metachar { :['<<'] }
token regex_metachar { :['>>'] }
token regex_metachar { :['<'] <regex_assertion> :['>'] }
token regex_metachar { :<\\> <regex_backslash> }
token regex_metachar { :<.> }
token regex_metachar { :<^^> }
token regex_metachar { :<^> }
token regex_metachar { :<$$> }
token regex_metachar {
    | :<$> <before $
                 | \s
                 | \|
                 | \)
                 | \]
                 | \>
           >
    | <variable>
}

token q_backslash { :<qq> <qq_bracketed> }
token q_backslash { :<\> }
token q_backslash { (.) }

token qq_backslash { :<a> }
token qq_backslash { :<b> }
token qq_backslash { :<c> <bracket_named_unicode> }
token qq_backslash { :<e> }
token qq_backslash { :<f> }
token qq_backslash { :<n> }
token qq_backslash { :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token qq_backslash { :<r> }
token qq_backslash { :<t> }
token qq_backslash { :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token qq_backslash { :: \W || <panic: unrecognized backslash sequence> }

token regex_backslash { :i :<a> }
token regex_backslash { :i :<b> }
token regex_backslash { :i :<c> <bracket_named_unicode> }
token regex_backslash { :i :<d> }
token regex_backslash { :i :<e> }
token regex_backslash { :i :<f> }
token regex_backslash { :i :<h> }
token regex_backslash { :i :<n> }
token regex_backslash { :i :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token regex_backslash { :i :<r> }
token regex_backslash { :i :<t> }
token regex_backslash { :i :<v> }
token regex_backslash { :i :<w> }
token regex_backslash { :i :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token regex_backslash { :: <panic: unrecognized regex backslash sequence> }

token regex_assertion { :<?> <regex_assertion> }
token regex_assertion { :<!> <regex_assertion> }

token regex_assertion { <block> }
token regex_assertion { <variable> }
token regex_assertion { <ident> [               # is qq right here?
                                | \: <?ws>
                                    <q_unbalanced(%sublang<qq><esc>, :stop«>»))>
                                | \( <EXPR> \)
                                | <?ws> <EXPR>
                                ]?
}

token regex_assertion { <before :<[>> <cclass_elem>+ }
token regex_assertion { <before :<+>> <cclass_elem>+ }
token regex_assertion { <before :<->> <cclass_elem>+ }

token regex_assertion { <panic: unrecognized regex assertion> }

token cclass_elem {
    [ \+ | - | <null> ]
    [
    | <name>
    | <before \[> <bracketed(%sublang<cclass>)>
    ]
}

token regex_mod_internal { :<:i> <regex_mod_arg>? }
token regex_mod_internal { <panic: unrecognized regex modifier> }

token regex_mod_external { :<:nth> <regex_mod_arg> }
token regex_mod_external { <panic: unrecognized regex modifier> }

token regex_quantifier { :<**> <?ws> <block> <quantmod> }
token regex_quantifier { :<*> <quantmod> }
token regex_quantifier { :<+> <quantmod> }

token quantmod { [ \? | \! | \: | \+ ]? }

# The <panic: message> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

rule panic (Str $s) { <commit> <fail($s)> }

## vim: expandtab sw=4
