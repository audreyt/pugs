#!/usr/bin/env perl
package kp6;
use strict;

use Digest       ();
use Getopt::Long ();
use File::Spec::Functions qw(catdir);
use English;
use IO::File;
use IO::Handle;

# XXX: HACK around harness which calls us like this during `make test'
# to find out what's in our @INC
if ( $ENV{HARNESS_ACTIVE} and "@ARGV" =~ /-le print join qq/ ) {
    print join( qq[\n], @INC ) . "\n";
    exit 0;
}

=begin

=head1 NAME

kp6 - Frontend to the L<KindaPerl6> Perl 6 in Perl 6 compiler

=head1 SYNOPSIS

    kp6 [switches] [--] [programfile] [arguments]

=head1 OPTIONS

=over

=item -h, --help

Print a usage message listing all available options

=item -v, --version

Print the version number, then exit successfully.

=item -r, --runtime

The runtime to use, defaults to mp6 but kp6 can also be selected. This
option will go away when the compiler has been bootstraped to kp6.

=item -c

parse the file or -e, but do not run it.

=item -e 'commandline'

May be used to enter one line of program.

=item -B[backend]

execute use the compiler backend.

(valid backends are: ast, perl5, cl (add -sbcl, -clisp, -ecl under -B)

=item -C[backend]

parse the file or -e, but do not run it

=item -o or --output=[file]

Send output to this file

=item --secure

Tell the emitter L<KindaPerl6::Visitor::Emit::*> emitter being used to
disable any unsafe features (e.g. C<system>).

=item --noperltidy

Do not try to emit pretty code.

=item --perltidyrc=[file]

use [file] for the perltidyrc file.  NOTE: this code will default to
$ENV{ PERLTIDY } if available, and if not, it will default then to
util/perltidyrc

You can set the environment variable PERLTIDY to /dev/null to quickly turn off
perltidy-ification in script/kp6 and script/mp6.pl.  This will remove 1 minute
and 13 seconds from the compile time, reducing compile time by approximately 20%.

Unless you are doing a lot of debugging, I recommend that you do NOT use the
/dev/null feature.  A warning will be issued that you are writting non
prettified files to disk

=item --do

A comma seperated list of L<KindaPerl6::Visitor>s to use, some
pre-made sequences (listed below) are also availible.

Example:

    # process the ast by expanding 'token' into plain Perl;
    # then replace method calls with MO calls;
    # then emit Perl 5 code
    kp6 --do Token,MetaClass,Emit::Perl5 < examples/token.pl

=back

=head1 AUTHORS

The Pugs Team E<lt>perl6-compiler@perl.orgE<gt>.

=head1 SEE ALSO

The Perl 6 homepage at L<http://dev.perl.org/perl6>.

The Pugs homepage at L<http://pugscode.org/>.

=head1 COPYRIGHT

Copyright 2007 by Flavio Soibelmann Glock and others.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=cut

#
# Get command line options
#

my %opt = ( perltidy => 1, output => '' );

Getopt::Long::Parser->new( config => [qw( bundling no_ignore_case pass_through require_order)], )->getoptions(

    # help
    'h|help' => \$opt{help},

    # what version are we using
    'v|version' => \$opt{version},

    # Use the mp6 or kp6 backend? This'll go away in the future
    'r|runtime=s' => \( $opt{runtime} = 'mp6' ),    # or 'kp6'

    # Compile
    'C=s' => \$opt{C},

    # Execute
    'B=s' => \$opt{B},

    # Prettify the code
    'perltidy!' => \$opt{perltidy},

    # the visitor sequence to use
    'do=s' => \$opt{do},

    # Program on the command line, there can be multiple -e
    'e=s@' => \$opt{e},

    # emitter options
    'secure' => \my $secure,

    # Send output to this file, usually parsed perl5 code
    'output|o=s' => \$opt{ output },

) or help();

if ($opt{B} eq 'kp6-kp6') {
    #HACK until kp6-kp6 supports proper options
    system("perl script/kp6-kp6.pl < $ARGV[0] | perl");
    exit;
}

#
# Deal with --help, --version
#

help( verbose => 1, exitval => 0 )
    if $opt{help};

# Display version if requested
version( exitval => 0 )
    if $opt{version};

# turn on or off perltidy if it is available
eval { require Perl::Tidy };
if ( $@ ) {
    $opt{perltidy} = 0;
} else {
    $^W = 0; # perltidy globally turns on warnings, do NOT turn this on
             # unless you want to see a lot of complaints.

    if ( $opt{perltidy}  && ! $opt{perltidyrc} ) {
        # Perl::Tidy's documentation is being updated to note that it has a ENV option
        if ( $ENV{ PERLTIDY } ) { # I recommend you use YOUR full path
            $opt{perltidyrc} = $ENV{ PERLTIDY };
        } else {
            $opt{perltidyrc} = 'util/perltidyrc';
        }

        die "No perltidyrc file is available for use" unless -e $opt{perltidyrc};

        if ( $opt{perltidyrc} eq '/dev/null' ) {
            $opt{perltidy} = 0;
            delete $opt{perltidyrc};

            warn "You have turned off perltidy - please do not commit these files to the respository";
        }
    }
}

#
# Get the required runtime files for the backend we're using
#

sub runtime_dir {
    return "compiled/perl5-kp6-kp6/lib" if $opt{runtime} eq "kp6";
    return "compiled/perl5-kp6-mp6/lib" if $opt{runtime} eq "mp6";
}

sub install_dir {
    return "compiled/perl5-kp6-kp6" if $opt{runtime} eq "kp6";
    return "compiled/perl5-kp6-mp6" if $opt{runtime} eq "mp6";
}

my $lib;
{
    if ( -d ( my $dir = runtime_dir() ) ) {
        unshift @INC, $dir;
    }

    require KindaPerl6;

    $Main::_V6_COMPILER_NAME    = 'KindaPerl6';
    $Main::_V6_COMPILER_VERSION = $KindaPerl6::VERSION;

    if ( -d ( my $dir = runtime_dir() ) ) {

        # If we're in the kp6 directory use the lib-kp6-* libs there so
        # the developers do not have to 'make all install' for every little
        # change.
        unshift @INC, $dir;
        $lib = $dir;
    }
    else {
        my $path = $INC{"KindaPerl6.pm"};
        my ($kp_path) = $path =~ m/(.*)\.pm$/;
        my $runtime_dir     = catdir( $kp_path,     install_dir() );
        my $runtime_dir_lib = catdir( $runtime_dir, "lib" );
        my $runtime_dir_mod = catdir( $runtime_dir, "mod" );

        unshift @INC, $runtime_dir_lib;
        $lib = $runtime_dir_lib;
    }

    require KindaPerl6::Runtime::Perl5::Runtime;
    require KindaPerl6::Traverse;
    require KindaPerl6::Grammar::Regex;

    if ( $opt{runtime} eq 'kp6' ) {
        $ENV{KP6_TARGET_RUNTIME} = 'KindaPerl6::Runtime::Perl5::KP6Runtime';
    }
}

#
# Construct the visitor sequence from the command line options
#

my @visitor_sequence;
my @visitors;
{
    my %visitor_args = ( secure => $opt{secure} );

    # Manual visitor sequence specified on the command line
    push @visitor_sequence, split /[\s,]/, $opt{do} if $opt{do};

    if ( grep { $_ eq 'perl6' } @opt{qw(C B)} ) {
        push @visitor_sequence, qw( Emit::Perl6 )
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::Perl6';
    }
    elsif ( grep { $_ eq 'ast' } @opt{qw(C B)} ) {
        push @visitor_sequence, qw( Emit::AstPerl )
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::AstPerl';
    }
    elsif ( grep { $_ eq 'perl5' } @opt{qw(C B)} ) {
        push @visitor_sequence, qw( ExtractRuleBlock Token MetaClass  Global Emit::Perl5 )  # ShortCircuit
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::Perl5';
    }
    elsif ( grep { $_ eq 'parrot' } @opt{qw(C B)} ) {
        push @visitor_sequence, qw( Emit::Parrot )
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::Parrot';
    }
    elsif ( grep { $_ =~ /^cl/ } @opt{qw(C B)} ) {
        push @visitor_sequence, qw( Global Emit::Lisp )
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::Lisp';
    }
    elsif ( grep { $_ eq 'perl5rx' } @opt{qw(C B)} ) {
        push @visitor_sequence, qw(  MetaClass  Global Emit::Perl5Regex )  # RegexCapture ShortCircuit
            unless @visitor_sequence && $visitor_sequence[-1] eq 'Emit::Perl5Regex';
    }
    elsif ( !@visitor_sequence ) {

        # this is the default sequence
        push @visitor_sequence, qw( ExtractRuleBlock Token MetaClass  Global Emit::Perl5 );  # ShortCircuit
    }

    push @visitor_sequence, 'Emit::AstPerl'
        unless $visitor_sequence[-1] =~ /^Emit/;

    for (@visitor_sequence) {
        my $module_name = 'KindaPerl6::Visitor::' . $_;
        eval "require $module_name";
        die "Can't load $_ plugin: $@" if $@;
        push @visitors, $module_name->new( visitor_args => \%visitor_args );
    }
}

#
# Get the Perl 6 source
#

my $source = load_source();

$COMPILER::source_md5 = Digest->new("MD5")->add($source)->hexdigest;

#
# Good to go, pass the source through the selected visitors
#

my $pos = 0;
my $out;
while ( $pos < length($source) ) {
    my $p = KindaPerl6::Grammar->comp_unit( $source, $pos );

    my $ast = $$p;

    unless ( ref $ast && $ast->isa("CompUnit") ) {

        # Compilation failed, show the user where
        die report_error( \$source, $pos );
    }
    $ast = $ast->emit($_) for @visitors;
    $out .= $ast;
    $pos = $p->to;
}

# emit CHECK blocks
for (@COMPILER::CHECK) {
    my ( $ast, $pad ) = @$_;
    unshift @COMPILER::PAD, $pad;
    my $ast = COMPILER::begin_block($ast);
    $ast = $ast->emit($_) for @visitors;
    $out .= $ast;
    shift @COMPILER::PAD;
}

# We have source to print out, do so, but consider the backends
# We also the execute any code here.
{
    no warnings 'uninitialized';

    # did the user want us to output the file?
    my $output;
    if ( $opt{ output } ) {
    	$output = IO::File->new( $opt{ output }, 'w');
    } else {
     	$output = IO::Handle->new();
        $output->fdopen(fileno(STDOUT),'w');
    }

    # Make kp6 -e 'say "foo"' and echo 'say "foo"' | kp6 run stuff
    # under the p5 backend
    if ( $opt{ output } ) {
        if ( $opt{perltidy} && ( $opt{B} eq 'perl5' || $opt{C} eq 'perl5' ) ) {
            Perl::Tidy::perltidy(
                source => \$out,
                destination => $output,
                perltidyrc => $opt{ perltidyrc },
                argv => '',
             );
        } else {
            $output->print( $out );
            $output->close();
        }
    }
    elsif ( !grep {defined} @opt{qw( B C do )} ) {
        run_piped_command("$EXECUTABLE_NAME -I$lib - -- @ARGV");
    }
    elsif ( grep { $_ eq 'ast' } @opt{qw(C B)} ) {
        if ( $opt{B} ) {
            die "'ast' backend does not support compilation";
        }
        elsif ( $opt{C} ) {
            if ( $opt{perltidy} ) {
                Perl::Tidy::perltidy(
                    source => \$out,
                    destination => $output,
                    perltidyrc => $opt{ perltidyrc },
                    argv => '',
                 );
            } else {
                print $output $out
            }
        }
    }
    elsif ( grep { $_ eq 'perl5' } @opt{qw(C B)} ) {
        if ( $opt{B} ) {
            # Execute!
            run_piped_command("$EXECUTABLE_NAME -I$lib - -- @ARGV");
        }
        elsif ( $opt{C} ) {
            if ( $opt{perltidy} ) {
                Perl::Tidy::perltidy(
                    source => \$out,
                    destination => $output,
                    perltidyrc => $opt{ perltidyrc },
                    argv => '',
                 );
            } else {
                print $output $out
            }
        }
    }
    elsif ( grep { $_ eq 'perl5rx' } @opt{qw(C B)} ) {
        if ( $opt{B} ) {
            run_piped_command("$EXECUTABLE_NAME -I lib5regex -I$lib - -- @ARGV");
        }
        elsif ( $opt{C} ) {
            if ( $opt{perltidy} ) {
                Perl::Tidy::perltidy(
                    source => \$out,
                    destination => $output,
                    perltidyrc => $opt{ perltidyrc },
                    argv => '',
                 );
            } else {
                print $output $out;
            }
        }
    }
    elsif ( grep { $_ =~ /^cl/ } @opt{qw(C B)} ) {
        if ( $opt{C} ) {
            print $output $out;
        }
        elsif ( $opt{B} =~ /^cl(?:-(.*))$/ ) {
            my $compiler = $1;

            if ( $compiler eq 'sbcl' ) {
                run_piped_command( "sbcl --noinform --noprint --disable-debugger", '(main)' );
            }
            elsif ( $compiler eq 'clisp' ) {
                run_piped_command( "clisp -q -q -on-error exit|$EXECUTABLE_NAME -ne 'print unless 1..m{4\]> (.*)(?{print\$1,\$/})}i'", '(main)' );
            }
            elsif ( $compiler eq 'ecl' ) {
                run_piped_command( "ecl | $EXECUTABLE_NAME -ne 'do { s/^KP6-LISP-USER> //; print } unless 1 .. /bytecompiled/'", '(main)' );
            }
        }
    }
    else {
        print $output $out;
    }
}

#
# End of main program
#

exit(0);

#
# Utility functions
#

=head2 run_piped_command($command, @print_to_file)

run_piped_command executes "| $command", and then prints to the file descriptor
@print_to_file.

if '|' is not at the begining of $command then it will be added.

YOU ARE RESPONSIBLE for putting in "\n" into @print_to_file!!!

=cut

sub run_piped_command {
    my ( $command, @inputs ) = @_;
    $command = '| ' . $command unless $command =~ /^\|/;
    open my $fh, "$command" or die $!;
    local $/;
    print $fh $out;
    for my $input (@inputs) {
        print $fh $input;
    }
    close $fh;
}

# Eat that File::Slurp!
sub slurp {
    do {
        local ( @ARGV, $/ ) = $_[0];
        scalar <>;
    };
}

# Helper sub to show the user where the parser bailed out.
sub report_error {
    my ( $source, $pos ) = @_;

    # Is this the first line? We'll have to special case if it is
    my $first_line = 0;

    # So we died, find out what line we were on
    my $source_uptohere = substr $$source, 0, $pos;

    # Find how many lines we've been through
    my $lines = ( $source_uptohere =~ tr/\n// ) + 1;

    # The column is distance from the last newline to $pos :)
    my $last_n_pos = rindex $source_uptohere, "\n";

    if ( $last_n_pos == -1 ) {

        # No previous newline, this is the first line
        $first_line = 1;
        $last_n_pos = 0;
    }

    my $column = $pos - $last_n_pos;

    # Print out the offending newline
    my $next_n_pos  = index $$source, "\n", $last_n_pos + 1;
    my $line_length = $next_n_pos - $last_n_pos;
    my $line        = substr $$source, $last_n_pos, $line_length;

    # print out an arrow pointing to the column
    my $whitespace = ' ' x $column;

    return "syntax error at position $pos, line $lines column $column:" . ( $first_line ? "\n" : "" ) . $line . "\n" . $whitespace . "^ HERE\n";
}

sub load_source {
    my $source;

    if ( -t STDIN ) {

        # STDIN is open to a terminal, i.e. we're being run as `kp6
        # file.p6'. slurp the file
        my ( $file, @args ) = @ARGV;

        if ( $file and not $opt{e} ) {

            # XXX where does '-w' come from?  - fglock
            if ( $file eq '-w' ) {
                $file = shift @args;
            }

            $source = slurp($file);
        }
        elsif ( $opt{e} ) {

            # divide -e statements by ;
            $source = join ';', @{ $opt{e} };
        }
        else {
            $source = '';
        }
    }
    else {

        # Called as `kp6 < file.p6', get source code from STDIN
        local $/;
        $source = <>;
    }

    # this only removes a fraction in a second off of the parsing time
    # I am leaving this here, so that when our perl6 scripts get larger
    # or we parse the AST/Vistor/Grammar code, it will run faster.
    $source =~ s/^ +//gm;
    return $source;
}

sub help {
    print <<'HELP';
Usage: kp6 [switches] [--] [programfile] [arguments]
  -e program      one line of program (multiple -e are allowed, omit programfile)
  -c              parse the file or -e, but do not run it
  -Bbackend       execute using the compiler backend
  -Cbackend       compile using the compiler backend
                  (valid backends are: ast, perl5, cl (add -sbcl, -clisp, -ecl under -B)
  -o              output to file if using -B, required by some backends
  --do            visitors to use

  -h or --help    give this message
See kp6 documentation for details
HELP
    exit 0;
}

sub version {
    printf "kp6 %s\n", $KindaPerl6::VERSION;
    exit 0;
}

__END__

# un-used documentation

=item --ast

Dump the Abstract Syntax Tree of the program, see L<KindaPerl::Ast>
and L<KindaPerl::Visitor::Emit::AstPerl>.

=item --perl5

Emit Perl 5 code via L<KindaPerl::Visitor::Emit::Perl5>, this is not the
same thing as the default Perl 5 sequence which has more visitors.

=item --perl5rx

Use the L<KindaPerl6::Visitor::Emit::Perl5Regex> Perl 6 to Perl 5 regex emitter.

=item --perl6

Emit Perl 6 via L<KindaPerl6::Visitor::Emit::Perl6>.

=item --parrot

Emit PIR via L<KindaPerl6::Visitor::Parrot>, currently broken.

=item --lisp

Emit Common Lisp via L<KindaPerl6::Visitor::Emit::Lisp>.

