        package Pugs::Grammar::Rule;
        no strict 'refs';
        use Pugs::Runtime::Match;
        use Pugs::Emitter::Rule::Perl5::Ratchet;
        our %rule_terms;

*pod_begin = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1545} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            (
              ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
              : 0
            )
            && (
              (
                ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
              )
            )
          )
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1545} ) or 1 )
        && (
          ( substr( $s, $pos++, 1 ) ne '' )
          && (
            do {
              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
              $bool = 1;
            }
            && do {
              my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_begin
#Data::Bind->sub_signature( \&pod_begin, );
*pod_other = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1546} = $pos or 1 )
      && (
        (
          (
            ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
          && (
            (
              ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
              : 0
            )
            && (
              (
                ( substr( $s, $pos, 1 ) eq 'c' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && (
                (
                  ( substr( $s, $pos, 1 ) eq 'u' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  (
                    ( substr( $s, $pos, 1 ) eq 't' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && do {
                    while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                    $bool = 1;
                  }
                )
              )
            )
          )
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1546} ) or 1 )
        && (
          ( substr( $s, $pos++, 1 ) ne '' )
          && (
            do {
              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
              $bool = 1;
            }
            && do {
              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for pod_other
#Data::Bind->sub_signature( \&pod_other, );
*ws = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1547} = $pos or 1 )
        && (
          (
            (
                ( substr( $s, $pos, 1 ) eq '#' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
              $bool = 1;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1547} ) or 1 )
          && (
            ( $pad{I1548} = $pos or 1 )
            && (
              (
                (
                  ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
                  : 0
                )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      (
                        ( $pad{I1549} = $pos or 1 )
                        && (
                          (
                            (
                              ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            && (
                              (
                                ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                : 0
                              )
                              && (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  (
                                    ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                    : 0
                                  )
                                  && (
                                    (
                                      ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                      : 0
                                    )
                                    && (
                                      do {
                                        my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                        my $bool = ( !$match != 1 );
                                        $pos = $match->to if $bool;
                                        $match;
                                      }
                                      && (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          (
                                            ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                                            : 0
                                          )
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              do {
                                                while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                                                $bool = 1;
                                              }
                                              && do {
                                                while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                                                $bool = 1;
                                              }
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                        || (
                          ( ( $bool = 1 ) && ( $pos = $pad{I1549} ) or 1 )
                          && (
                            ( $pad{I1550} = $pos or 1 )
                            && (
                              (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  (
                                    ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                    : 0
                                  )
                                  && (
                                    (
                                      ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                      : 0
                                    )
                                    && (
                                      (
                                        ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                        : 0
                                      )
                                      && (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && do {
                                          my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                                          my $bool = ( !$match != 1 );
                                          $pos = $match->to if $bool;
                                          $match;
                                        }
                                      )
                                    )
                                  )
                                )
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1550} ) or 1 )
                              && (
                                ( $pad{I1551} = $pos or 1 )
                                && (
                                  (
                                    (
                                      ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                                      : 0
                                    )
                                    && (
                                      (
                                        ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                                        : 0
                                      )
                                      && (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          (
                                            ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                            : 0
                                          )
                                          && do {
                                            my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                            my $bool = ( !$match != 1 );
                                            $pos = $match->to if $bool;
                                            $match;
                                          }
                                        )
                                      )
                                    )
                                  )
                                )
                                || (
                                  ( ( $bool = 1 ) && ( $pos = $pad{I1551} ) or 1 )
                                  && (
                                    ( $pad{I1552} = $pos or 1 )
                                    && (
                                      (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          (
                                            ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                            : 0
                                          )
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && do {
                                              my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                              my $bool = ( !$match != 1 );
                                              $pos = $match->to if $bool;
                                              $match;
                                            }
                                          )
                                        )
                                      )
                                    )
                                    || (
                                      ( ( $bool = 1 ) && ( $pos = $pad{I1552} ) or 1 )
                                      && (
                                        ( $pad{I1553} = $pos or 1 )
                                        && (
                                          (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              (
                                                ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                                : 0
                                              )
                                              && (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && do {
                                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                  my $bool = ( !$match != 1 );
                                                  $pos = $match->to if $bool;
                                                  $match;
                                                }
                                              )
                                            )
                                          )
                                        )
                                        || (
                                          ( ( $bool = 1 ) && ( $pos = $pad{I1553} ) or 1 )
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              (
                                                ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                                : 0
                                              )
                                              && (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && (
                                                  (
                                                    ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                                    : 0
                                                  )
                                                  && (
                                                    (
                                                      ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                                                      : 0
                                                    )
                                                    && do {
                                                      my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                      my $bool = ( !$match != 1 );
                                                      $pos = $match->to if $bool;
                                                      $match;
                                                    }
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                  || ( $bool = 1 )
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
              && (
                  ( substr( $s, $pos ) =~ m/^\s/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
            )
          )
        )
      )
      && do {
        while (
          (
            ( $pad{I1547} = $pos or 1 )
            && (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '#' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                  $bool = 1;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1547} ) or 1 )
              && (
                ( $pad{I1548} = $pos or 1 )
                && (
                  (
                    (
                      ( substr( $s, $pos ) =~ m/^\n/s ) ? ( $pos += length($&) or 1 )
                      : 0
                    )
                    && (
                      (
                        (
                          ( substr( $s, $pos, 1 ) eq '=' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          (
                            ( $pad{I1549} = $pos or 1 )
                            && (
                              (
                                (
                                  ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                                && (
                                  (
                                    ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                    : 0
                                  )
                                  && (
                                    (
                                      ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                      : 0
                                    )
                                    && (
                                      (
                                        ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                        : 0
                                      )
                                      && (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          do {
                                            my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                                            my $bool = ( !$match != 1 );
                                            $pos = $match->to if $bool;
                                            $match;
                                          }
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'E' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              (
                                                ( substr( $s, $pos, 1 ) eq 'N' ) ? ( $pos += 1 or 1 )
                                                : 0
                                              )
                                              && (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'D' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && (
                                                  do {
                                                    while ( ( ( substr( $s, $pos ) =~ m/^[^\n]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                                                    $bool = 1;
                                                  }
                                                  && do {
                                                    while ( ( substr( $s, $pos++, 1 ) ne '' ) ) { }
                                                    $bool = 1;
                                                  }
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                            || (
                              ( ( $bool = 1 ) && ( $pos = $pad{I1549} ) or 1 )
                              && (
                                ( $pad{I1550} = $pos or 1 )
                                && (
                                  (
                                    (
                                      ( substr( $s, $pos, 1 ) eq 'b' ) ? ( $pos += 1 or 1 )
                                      : 0
                                    )
                                    && (
                                      (
                                        ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                        : 0
                                      )
                                      && (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'g' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          (
                                            ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                            : 0
                                          )
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'n' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && do {
                                              my $match = $grammar->pod_begin( $s, { p => $pos, args => {} }, undef );
                                              my $bool = ( !$match != 1 );
                                              $pos = $match->to if $bool;
                                              $match;
                                            }
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                                || (
                                  ( ( $bool = 1 ) && ( $pos = $pad{I1550} ) or 1 )
                                  && (
                                    ( $pad{I1551} = $pos or 1 )
                                    && (
                                      (
                                        (
                                          ( substr( $s, $pos, 1 ) eq 'k' ) ? ( $pos += 1 or 1 )
                                          : 0
                                        )
                                        && (
                                          (
                                            ( substr( $s, $pos, 1 ) eq 'w' ) ? ( $pos += 1 or 1 )
                                            : 0
                                          )
                                          && (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'i' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              (
                                                ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                                : 0
                                              )
                                              && do {
                                                my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                my $bool = ( !$match != 1 );
                                                $pos = $match->to if $bool;
                                                $match;
                                              }
                                            )
                                          )
                                        )
                                      )
                                    )
                                    || (
                                      ( ( $bool = 1 ) && ( $pos = $pad{I1551} ) or 1 )
                                      && (
                                        ( $pad{I1552} = $pos or 1 )
                                        && (
                                          (
                                            (
                                              ( substr( $s, $pos, 1 ) eq 'p' ) ? ( $pos += 1 or 1 )
                                              : 0
                                            )
                                            && (
                                              (
                                                ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                                : 0
                                              )
                                              && (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && do {
                                                  my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                  my $bool = ( !$match != 1 );
                                                  $pos = $match->to if $bool;
                                                  $match;
                                                }
                                              )
                                            )
                                          )
                                        )
                                        || (
                                          ( ( $bool = 1 ) && ( $pos = $pad{I1552} ) or 1 )
                                          && (
                                            ( $pad{I1553} = $pos or 1 )
                                            && (
                                              (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'f' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && (
                                                  (
                                                    ( substr( $s, $pos, 1 ) eq 'o' ) ? ( $pos += 1 or 1 )
                                                    : 0
                                                  )
                                                  && (
                                                    (
                                                      ( substr( $s, $pos, 1 ) eq 'r' ) ? ( $pos += 1 or 1 )
                                                      : 0
                                                    )
                                                    && do {
                                                      my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                      my $bool = ( !$match != 1 );
                                                      $pos = $match->to if $bool;
                                                      $match;
                                                    }
                                                  )
                                                )
                                              )
                                            )
                                            || (
                                              ( ( $bool = 1 ) && ( $pos = $pad{I1553} ) or 1 )
                                              && (
                                                (
                                                  ( substr( $s, $pos, 1 ) eq 'h' ) ? ( $pos += 1 or 1 )
                                                  : 0
                                                )
                                                && (
                                                  (
                                                    ( substr( $s, $pos, 1 ) eq 'e' ) ? ( $pos += 1 or 1 )
                                                    : 0
                                                  )
                                                  && (
                                                    (
                                                      ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
                                                      : 0
                                                    )
                                                    && (
                                                      (
                                                        ( substr( $s, $pos, 1 ) eq 'd' ) ? ( $pos += 1 or 1 )
                                                        : 0
                                                      )
                                                      && (
                                                        (
                                                          ( substr( $s, $pos, 1 ) eq '1' ) ? ( $pos += 1 or 1 )
                                                          : 0
                                                        )
                                                        && do {
                                                          my $match = $grammar->pod_other( $s, { p => $pos, args => {} }, undef );
                                                          my $bool = ( !$match != 1 );
                                                          $pos = $match->to if $bool;
                                                          $match;
                                                        }
                                                      )
                                                    )
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                          || ( $bool = 1 )
                        )
                      )
                      || ( $bool = 1 )
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
                  && (
                      ( substr( $s, $pos ) =~ m/^\s/s )
                    ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
              )
            )
          )
          )
        {
        }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ws
#Data::Bind->sub_signature( \&ws, );
*ident = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1554} = $pos or 1 )
        && (
          (
            ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
            : 0
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1554} ) or 1 )
          && (
            ( $pad{I1555} = $pos or 1 )
            && (
              (
                ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                : 0
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
              && (
                ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 )
                : 0
              )
            )
          )
        )
      )
      && do {
        while ( ( ( $pad{I1554} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1554} ) or 1 ) && ( ( $pad{I1555} = $pos or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 ) && ( ( substr( $s, $pos, 2 ) eq '::' ) ? ( $pos += 2 or 1 ) : 0 ) ) ) ) ) ) { }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for ident
#Data::Bind->sub_signature( \&ident, );
*capturing_group = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
          ( substr( $s, $pos, 1 ) eq '(' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq ')' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'capturing_group' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for capturing_group
#Data::Bind->sub_signature( \&capturing_group, );
*non_capturing_group = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
          ( substr( $s, $pos, 1 ) eq '[' )
        ? ( $pos += 1 or 1 )
        : 0
      )
      && (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq ']' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return ( $::_V6_MATCH_->{'rule'}->() );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for non_capturing_group
#Data::Bind->sub_signature( \&non_capturing_group, );
*literal = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless do {
      while ( ( ( $pad{I1556} = $pos or 1 ) && ( ( ( ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 ) : 0 ) && ( substr( $s, $pos++, 1 ) ne '' ) ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1556} ) or 1 ) && ( ( substr( $s, $pos ) =~ m/^[^\']/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) ) ) { }
      $bool = 1;
      };
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for literal
#Data::Bind->sub_signature( \&literal, );
*metasyntax = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          ( $pad{I1557} = $pos or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                : 0
              )
              && ( substr( $s, $pos++, 1 ) ne '' )
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1557} ) or 1 )
            && (
              ( $pad{I1558} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && (
                    do {
                      my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                      my $bool = ( !$match != 1 );
                      $pos = $match->to if $bool;
                      $match;
                    }
                    && (
                      ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1558} ) or 1 )
                && (
                  ( $pad{I1559} = $pos or 1 )
                  && (
                    (
                      (
                        ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && (
                        do {
                          my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                        && (
                          ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1559} ) or 1 )
                    && (
                      ( $pad{I1560} = $pos or 1 )
                      && (
                        (
                          (
                            ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                          && (
                            do {
                              my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            && (
                              ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                          )
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1560} ) or 1 )
                        && (
                          ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
                          : 0
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
        && do {
          while (
            (
              ( $pad{I1557} = $pos or 1 )
              && (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && ( substr( $s, $pos++, 1 ) ne '' )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1557} ) or 1 )
                && (
                  ( $pad{I1558} = $pos or 1 )
                  && (
                    (
                      (
                        ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && (
                        do {
                          my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                        && (
                          ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1558} ) or 1 )
                    && (
                      ( $pad{I1559} = $pos or 1 )
                      && (
                        (
                          (
                            ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                          && (
                            do {
                              my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            && (
                              ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                          )
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1559} ) or 1 )
                        && (
                          ( $pad{I1560} = $pos or 1 )
                          && (
                            (
                              (
                                ( substr( $s, $pos, 1 ) eq '<' ) ? ( $pos += 1 or 1 )
                                : 0
                              )
                              && (
                                do {
                                  my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                                  my $bool = ( !$match != 1 );
                                  $pos = $match->to if $bool;
                                  $match;
                                }
                                && (
                                  ( substr( $s, $pos, 1 ) eq '>' ) ? ( $pos += 1 or 1 )
                                  : 0
                                )
                              )
                            )
                          )
                          || (
                            ( ( $bool = 1 ) && ( $pos = $pad{I1560} ) or 1 )
                            && (
                              ( substr( $s, $pos ) =~ m/^[^\>]/s ) ? ( $pos += length($&) or 1 )
                              : 0
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'metasyntax' => $::_V6_MATCH_->()    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for metasyntax
#Data::Bind->sub_signature( \&metasyntax, );
*code = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        ( $pad{I1561} = $pos or 1 )
        && (
          (
            (
              ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
              : 0
            )
            && ( substr( $s, $pos++, 1 ) ne '' )
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1561} ) or 1 )
          && (
            ( $pad{I1562} = $pos or 1 )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  do {
                    my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  && (
                    ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
              && (
                ( $pad{I1563} = $pos or 1 )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      do {
                        my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      && (
                        ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1563} ) or 1 )
                  && (
                    ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
                    : 0
                  )
                )
              )
            )
          )
        )
      )
      && do {
        while (
          (
            ( $pad{I1561} = $pos or 1 )
            && (
              (
                (
                  ( substr( $s, $pos, 1 ) eq '\\' ) ? ( $pos += 1 or 1 )
                  : 0
                )
                && ( substr( $s, $pos++, 1 ) ne '' )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1561} ) or 1 )
              && (
                ( $pad{I1562} = $pos or 1 )
                && (
                  (
                    (
                      ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                      : 0
                    )
                    && (
                      do {
                        my $match = $grammar->literal( $s, { p => $pos, args => {} }, undef );
                        my $bool = ( !$match != 1 );
                        $pos = $match->to if $bool;
                        $match;
                      }
                      && (
                        ( substr( $s, $pos, 1 ) eq chr(39) ) ? ( $pos += 1 or 1 )
                        : 0
                      )
                    )
                  )
                )
                || (
                  ( ( $bool = 1 ) && ( $pos = $pad{I1562} ) or 1 )
                  && (
                    ( $pad{I1563} = $pos or 1 )
                    && (
                      (
                        (
                          ( substr( $s, $pos, 1 ) eq '{' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                        && (
                          do {
                            my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
                            my $bool = ( !$match != 1 );
                            $pos = $match->to if $bool;
                            $match;
                          }
                          && (
                            ( substr( $s, $pos, 1 ) eq '}' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                        )
                      )
                    )
                    || (
                      ( ( $bool = 1 ) && ( $pos = $pad{I1563} ) or 1 )
                      && (
                        ( substr( $s, $pos ) =~ m/^[^\}]/s ) ? ( $pos += length($&) or 1 )
                        : 0
                      )
                    )
                  )
                )
              )
            )
          )
          )
        {
        }
        $bool = 1;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for code
#Data::Bind->sub_signature( \&code, );
*named_capture_body = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1564} = $pos or 1 )
      && (
        (
          do {
            my $match = $grammar->capturing_group( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'capturing_group'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'rule' => $::_V6_MATCH_->{'capturing_group'}->()    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1564} ) or 1 )
        && (
          ( $pad{I1565} = $pos or 1 )
          && (
            (
              do {
                my $match = $grammar->non_capturing_group( $s, { p => $pos, args => {} }, undef );
                if ($match) {
                  $named{'non_capturing_group'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    {
                      return (
                        {
                          'rule' => $::_V6_MATCH_->{'non_capturing_group'}->()    # hash
                        }
                      );
                    }
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          || (
            ( ( $bool = 1 ) && ( $pos = $pad{I1565} ) or 1 )
            && (
              ( $pad{I1566} = $pos or 1 )
              && (
                (
                  (
                      ( substr( $s, $pos, 1 ) eq '<' )
                    ? ( $pos += 1 or 1 )
                    : 0
                  )
                  && (
                    do {
                      my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
                      if ($match) {
                        $named{'metasyntax'} = $match;
                        $pos = $match->to;
                        1;
                      }
                      else { 0 }
                    }
                    && (
                      (
                          ( substr( $s, $pos, 1 ) eq '>' )
                        ? ( $pos += 1 or 1 )
                        : 0
                      )
                      && do {
                        $::_V6_MATCH_ = $m;
                        local $::_V6_SUCCEED = 1;
                        $m->data->{capture} = \(
                          sub {
                            {
                              return (
                                {
                                  'rule' => $::_V6_MATCH_->{'metasyntax'}->()    # hash
                                }
                              );
                            }
                            }
                            ->()
                        );
                        $bool = $::_V6_SUCCEED;
                        $::_V6_MATCH_ = $m if $bool;
                        return $m if $bool;
                      }
                    )
                  )
                )
              )
              || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1566} ) or 1 )
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  sub {
                    {
                      die("invalid alias syntax");
                    }
                    }
                    ->();
                  $::_V6_SUCCEED;
                }
              )
            )
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for named_capture_body
#Data::Bind->sub_signature( \&named_capture_body, );
%rule_terms = (
  '(' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq ')' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'capturing_group' => $::_V6_MATCH_->{'rule'}->()    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<after' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && (
          do {
            my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'rule'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
            (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'after' => {
                          'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                          }    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && (
          do {
            my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'rule'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
            (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'before' => {
                          'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                          }    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!before' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
          my $bool = ( !$match != 1 );
          $pos = $match->to if $bool;
          $match;
        }
        && (
          do {
            my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'rule'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
            (
                ( substr( $s, $pos, 1 ) eq '>' )
              ? ( $pos += 1 or 1 )
              : 0
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'not_before' => {
                          'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                          }    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<!' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq '>' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'negate' => {
                        'rule' => $::_V6_MATCH_->{'rule'}->()    # hash
                        }    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->metasyntax( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'metasyntax'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq '>' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return ( $::_V6_MATCH_->{'metasyntax'}->() );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$<' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'ident'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq '>' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            (
              do {
                my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                my $bool = ( !$match != 1 );
                $pos = $match->to if $bool;
                $match;
              }
              || ( $bool = 1 )
            )
            && (
              (
                  ( substr( $s, $pos, 2 ) eq ':=' )
                ? ( $pos += 2 or 1 )
                : 0
              )
              && (
                (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                )
                && (
                  do {
                    my $match = $grammar->named_capture_body( $s, { p => $pos, args => {} }, undef );
                    if ($match) {
                      $named{'named_capture_body'} = $match;
                      $pos = $match->to;
                      1;
                    }
                    else { 0 }
                  }
                  && do {
                    $::_V6_MATCH_ = $m;
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \(
                      sub {
                        {
                          my $body = $::_V6_MATCH_->{'named_capture_body'}();
                          $body->{'ident'} = $::_V6_MATCH_->{'ident'}();
                          return { named_capture => $body, };
                        }
                        }
                        ->()
                    );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool;
                    return $m if $bool;
                  }
                )
              )
            )
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1567} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'match_variable' => '$' . $::_V6_MATCH_->()    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1567} ) or 1 )
          && (
            ( $pad{I1568} = $pos or 1 )
            && (
              (
                (
                  (
                    ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                    : 0
                  )
                  || ( $bool = 1 )
                )
                && (
                  (
                    (
                      ( $pad{I1569} = $pos or 1 )
                      && (
                        (
                          ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1569} ) or 1 )
                        && (
                          ( $pad{I1570} = $pos or 1 )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                          )
                          || (
                            ( ( $bool = 1 ) && ( $pos = $pad{I1570} ) or 1 )
                            && (
                              (
                                ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                                : 0
                              )
                              && (
                                ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                                : 0
                              )
                            )
                          )
                        )
                      )
                    )
                    && do {
                      while ( ( ( $pad{I1569} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1569} ) or 1 ) && ( ( $pad{I1570} = $pos or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1570} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) ) ) { }
                      $bool = 1;
                    }
                  )
                  && do {
                    $::_V6_MATCH_ = $m;
                    local $::_V6_SUCCEED = 1;
                    $m->data->{capture} = \(
                      sub {
                        {
                          return (
                            {
                              'variable' => '$' . $::_V6_MATCH_->()    # hash
                            }
                          );
                        }
                        }
                        ->()
                    );
                    $bool = $::_V6_SUCCEED;
                    $::_V6_MATCH_ = $m if $bool;
                    return $m if $bool;
                  }
                )
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1568} ) or 1 )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    {
                      return (
                        {
                          'colon' => '$'    # hash
                        }
                      );
                    }
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '@' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1571} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'match_variable' => '@' . $::_V6_MATCH_->()    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1571} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                (
                  ( $pad{I1572} = $pos or 1 )
                  && (
                    (
                      ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                      : 0
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1572} ) or 1 )
                    && (
                      ( $pad{I1573} = $pos or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1573} ) or 1 )
                        && (
                          (
                            ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                          && (
                            ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                        )
                      )
                    )
                  )
                )
                && do {
                  while ( ( ( $pad{I1572} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1572} ) or 1 ) && ( ( $pad{I1573} = $pos or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1573} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) ) ) { }
                  $bool = 1;
                }
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    {
                      return (
                        {
                          'variable' => '@' . $::_V6_MATCH_->()    # hash
                        }
                      );
                    }
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '%' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( $pad{I1574} = $pos or 1 )
        && (
          (
            (
              (
                  ( substr( $s, $pos ) =~ m/^[[:digit:]]/s )
                ? ( $pos += length($&) or 1 )
                : 0
              )
              && do {
                while ( ( ( substr( $s, $pos ) =~ m/^[[:digit:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) { }
                $bool = 1;
              }
            )
            && do {
              $::_V6_MATCH_ = $m;
              local $::_V6_SUCCEED = 1;
              $m->data->{capture} = \(
                sub {
                  {
                    return (
                      {
                        'match_variable' => '%' . $::_V6_MATCH_->()    # hash
                      }
                    );
                  }
                  }
                  ->()
              );
              $bool = $::_V6_SUCCEED;
              $::_V6_MATCH_ = $m if $bool;
              return $m if $bool;
            }
          )
        )
        || (
          ( ( $bool = 1 ) && ( $pos = $pad{I1574} ) or 1 )
          && (
            (
              (
                ( substr( $s, $pos, 1 ) eq '^' ) ? ( $pos += 1 or 1 )
                : 0
              )
              || ( $bool = 1 )
            )
            && (
              (
                (
                  ( $pad{I1575} = $pos or 1 )
                  && (
                    (
                      ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 )
                      : 0
                    )
                  )
                  || (
                    ( ( $bool = 1 ) && ( $pos = $pad{I1575} ) or 1 )
                    && (
                      ( $pad{I1576} = $pos or 1 )
                      && (
                        (
                          ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 )
                          : 0
                        )
                      )
                      || (
                        ( ( $bool = 1 ) && ( $pos = $pad{I1576} ) or 1 )
                        && (
                          (
                            ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                          && (
                            ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 )
                            : 0
                          )
                        )
                      )
                    )
                  )
                )
                && do {
                  while ( ( ( $pad{I1575} = $pos or 1 ) && ( ( ( substr( $s, $pos ) =~ m/^[[:alnum:]]/s ) ? ( $pos += length($&) or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1575} ) or 1 ) && ( ( $pad{I1576} = $pos or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq '_' ) ? ( $pos += 1 or 1 ) : 0 ) ) || ( ( ( $bool = 1 ) && ( $pos = $pad{I1576} ) or 1 ) && ( ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) && ( ( substr( $s, $pos, 1 ) eq ':' ) ? ( $pos += 1 or 1 ) : 0 ) ) ) ) ) ) ) { }
                  $bool = 1;
                }
              )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    {
                      return (
                        {
                          'variable' => '%' . $::_V6_MATCH_->()    # hash
                        }
                      );
                    }
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '{' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->code( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'code'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq '}' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'closure' => '{' . $::_V6_MATCH_->{'code'}->() . '}'    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '\\' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        ( substr( $s, $pos++, 1 ) ne '' )
        && do {
          $::_V6_MATCH_ = $m;
          local $::_V6_SUCCEED = 1;
          $m->data->{capture} = \(
            sub {
              {
                return (
                  {
                    'special_char' => '\\' . $::_V6_MATCH_->()    # hash
                  }
                );
              }
              }
              ->()
          );
          $bool = $::_V6_SUCCEED;
          $::_V6_MATCH_ = $m if $bool;
          return $m if $bool;
        }
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '.' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'dot' => 1    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '[' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless (
        do {
          my $match = $grammar->rule( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            $named{'rule'} = $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          (
              ( substr( $s, $pos, 1 ) eq ']' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return ( $::_V6_MATCH_->{'rule'}->() );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
        );
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => ':::'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':?' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => ':?'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':+' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => ':+'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '::' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => '::'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  ':' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => ':'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '$$' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => '$$'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => '^^'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  },
  '^' => sub {

    my $s       = $_[0] || '';
    my $grammar = $_[1] || __PACKAGE__;
    $_[3] = $_[2];
    $_[2] = undef;

    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      $bool = 0
        unless do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              return (
                {
                  'colon' => '^'    # hash
                }
              );
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
        };
      last if $m;
    }
    $::_V6_MATCH_ = $m;
    return $m;
  }
);
*term = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      ( $pad{I1577} = $pos or 1 )
      && (
        (
          do {
            my $match = do {
              our $I1578;
              our $I1578_sizes;
              unless ($I1578) {
                my $hash = \%Pugs::Grammar::Rule::rule_terms;
                my %sizes = map { length($_) => 1 } keys %$hash;
                $I1578_sizes = [ sort { $b <=> $a } keys %sizes ];
                $I1578 = $hash;
              }
              my $match = 0;
              my $key;
              for (@$I1578_sizes) {
                $key = (
                  $pos <= length($s)
                  ? substr( $s, $pos, $_ )
                  : ''
                );
                if ( exists $I1578->{$key} ) {

                  #$named{KEY} = $key;
                  #$::_V6_MATCH_ = $m;
                  #print "m: ", Dumper( $::_V6_MATCH_->data )
                  #    if ( $key eq 'until' );
                  $match = Pugs::Emitter::Rule::Perl5::Ratchet::preprocess_hash( $I1578, $key )->( $s, $grammar, { p => ( $pos + $_ ), args => { KEY => $key } }, undef );
                  last if $match;
                }
              }
              if ($match) {
                $pos = $match->to;

                #print "match: $key at $pos = ", Dumper( $match->data );
                $bool = 1;
              }
              ;    # else { $bool = 0 }
              $match;
            };
            if ($match) {
              $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return ( $::_V6_MATCH_->{'Pugs::Grammar::Rule::rule_terms'}->() );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      || (
        ( ( $bool = 1 ) && ( $pos = $pad{I1577} ) or 1 )
        && (
          (
              ( substr( $s, $pos ) =~ m/^[^\]\}\)\>\:\?\+\*\|\&]/s )
            ? ( $pos += length($&) or 1 )
            : 0
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  return (
                    {
                      'constant' => $::_V6_MATCH_->()    # hash
                    }
                  );
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for term
#Data::Bind->sub_signature( \&term, );
*quantifier = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      do {
        my $match = Pugs::Runtime::Match->new(
          do {
            my $bool = 1;
            my $from = $pos;
            my @match;
            my %named;
            $bool = 0 unless do {
              my $hash = do {
                my $bool = 1;
                my $from = $pos;
                my @match;
                my %named;
                $bool = 0
                  unless (
                  do {
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                  );
                { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
              };
              my $bool = ${ $hash->{'bool'} };
              $match[0] = Pugs::Runtime::Match->new($hash);
              $bool;
            };
            { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
            }
        );
        if ($match) {
          $named{'ws1'} = $match;
          $pos = $match->to;
          1;
        }
        else { 0 }
      }
      && (
        do {
          my $pos1 = $pos;
          do {
            my $pos  = $pos1;
            my $from = $pos;
            my @match;
            my %named;
            my $bool = 1;
            $bool = 0
              unless (
                ( substr( $s, $pos ) =~ m/^[\}\]\)\>]/s )
              ? ( $pos += length($&) or 1 )
              : 0
              );
            !$bool;
          };
        }
        && (
          do {
            my $match = $grammar->term( $s, { p => $pos, args => {} }, undef );
            if ($match) {
              $named{'term'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
            do {
              my $match = Pugs::Runtime::Match->new(
                do {
                  my $bool = 1;
                  my $from = $pos;
                  my @match;
                  my %named;
                  $bool = 0 unless do {
                    my $hash = do {
                      my $bool = 1;
                      my $from = $pos;
                      my @match;
                      my %named;
                      $bool = 0
                        unless (
                        do {
                          my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                          my $bool = ( !$match != 1 );
                          $pos = $match->to if $bool;
                          $match;
                        }
                        || ( $bool = 1 )
                        );
                      { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                    };
                    my $bool = ${ $hash->{'bool'} };
                    $match[0] = Pugs::Runtime::Match->new($hash);
                    $bool;
                  };
                  { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                  }
              );
              if ($match) {
                $named{'ws2'} = $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            && (
              do {
                my $match = Pugs::Runtime::Match->new(
                  do {
                    my $bool = 1;
                    my $from = $pos;
                    my @match;
                    my %named;
                    $bool = 0 unless do {
                      my $hash = do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0
                          unless (
                          (
                            (
                              ( substr( $s, $pos ) =~ m/^[\?\*\+]/s ) ? ( $pos += length($&) or 1 )
                              : 0
                            )
                            || ( $bool = 1 )
                          )
                          && (
                            (
                              ( substr( $s, $pos, 1 ) eq '?' ) ? ( $pos += 1 or 1 )
                              : 0
                            )
                            || ( $bool = 1 )
                          )
                          );
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                      };
                      my $bool = ${ $hash->{'bool'} };
                      $match[0] = Pugs::Runtime::Match->new($hash);
                      $bool;
                    };
                    { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                    }
                );
                if ($match) {
                  $named{'quant'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
              && (
                do {
                  my $match = Pugs::Runtime::Match->new(
                    do {
                      my $bool = 1;
                      my $from = $pos;
                      my @match;
                      my %named;
                      $bool = 0 unless do {
                        my $hash = do {
                          my $bool = 1;
                          my $from = $pos;
                          my @match;
                          my %named;
                          $bool = 0
                            unless (
                            do {
                              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                              my $bool = ( !$match != 1 );
                              $pos = $match->to if $bool;
                              $match;
                            }
                            || ( $bool = 1 )
                            );
                          { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                        };
                        my $bool = ${ $hash->{'bool'} };
                        $match[0] = Pugs::Runtime::Match->new($hash);
                        $bool;
                      };
                      { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \( 0 + $pos ), capture => undef };
                      }
                  );
                  if ($match) {
                    $named{'ws3'} = $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      {
                        return (
                          {
                            'quant' => {
                              'term'  => $::_V6_MATCH_->{'term'}->(),
                              'quant' => $::_V6_MATCH_->{'quant'}->(),
                              'ws1'   => $::_V6_MATCH_->{'ws1'}->(),
                              'ws2'   => $::_V6_MATCH_->{'ws2'}->(),
                              'ws3'   => $::_V6_MATCH_->{'ws3'}->()      # hash
                              }    # hash
                          }
                        );
                      }
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
          )
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for quantifier
#Data::Bind->sub_signature( \&quantifier, );
*concat = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        do {
          my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            push @{ $named{'quantifier'} }, $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && do {
          while (
            do {
              my $match = $grammar->quantifier( $s, { p => $pos, args => {} }, undef );
              if ($match) {
                push @{ $named{'quantifier'} }, $match;
                $pos = $match->to;
                1;
              }
              else { 0 }
            }
            )
          {
          }
          $bool = 1;
        }
      )
      && do {
        $::_V6_MATCH_ = $m;
        local $::_V6_SUCCEED = 1;
        $m->data->{capture} = \(
          sub {
            {
              my @a = map { $_->() } @{ $::_V6_MATCH_->{'quantifier'} };
              return { concat => \@a, } if scalar @a > 1;
              return $a[0];
            }
            }
            ->()
        );
        $bool = $::_V6_SUCCEED;
        $::_V6_MATCH_ = $m if $bool;
        return $m if $bool;
      }
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for concat
#Data::Bind->sub_signature( \&concat, );
*rule = sub {

  $_[3] = $_[2];
  $_[2] = undef;
  my $grammar = $_[0];
  my $s       = $_[1];
  no warnings 'substr', 'uninitialized', 'syntax';
  my %pad;
  my $m;
  for my $pos ( defined $_[3]{p} ? $_[3]{p} : ( 0 .. length($s) ) ) {
    my %index;
    my @match;
    my %named;
    my $bool = 1;
    $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
    $m = Pugs::Runtime::Match->new(
      {
        str     => \$s,
        from    => \( 0 + $pos ),
        to      => \($pos),
        bool    => \$bool,
        match   => \@match,
        named   => \%named,
        capture => undef,
      }
    );
    $bool = 0
      unless (
      (
        (
          (
            do {
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && (
              ( substr( $s, $pos, 1 ) eq '|' )
            ? ( $pos += 1 or 1 )
            : 0
          )
        )
        || ( $bool = 1 )
      )
      && (
        do {
          my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
          if ($match) {
            # $named{'concat'} = $match;
            push @{ $named{'concat'} }, $match;
            $pos = $match->to;
            1;
          }
          else { 0 }
        }
        && (
          do {
            while (
              (
                (
                    ( substr( $s, $pos, 1 ) eq '|' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && do {
                  my $match = $grammar->concat( $s, { p => $pos, args => {} }, undef );
                  if ($match) {
                    push @{ $named{'concat'} }, $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
              )
              )
            {
            }
            $bool = 1;
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                {
                  my @a = map { $_->() } @{ $::_V6_MATCH_->{'concat'} };
                  return { alt => \@a, } if scalar @a > 1;
                  return $a[0];
                }
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
        )
      )
      );
    last if $m;
  }
  $::_V6_MATCH_ = $m;
  return $m;
};    ## Signature for rule
#Data::Bind->sub_signature( \&rule, );

1;
