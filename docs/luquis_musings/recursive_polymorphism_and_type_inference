Haskell has concise and extremely rich support for strongly typed
data structures  (this is what allows PIL to be represented and
manipulated so easily).  

The key to strongly typed data structures are Haskell's polymorphic data 
types.

    data Foo where
        a :: Foo         -- leaf
        b :: Foo         -- leaf
        c :: Bar -> Foo  -- unary node
        d :: Bar -> Baz -> Foo  -- binary node

Haskell's types can take parameters so you can specify necessary agreement.

    data Tree a where
        zero :: Tree Int
        succ :: Tree Int -> Tree Int
        pred :: Tree Int -> Tree Int
        iszero :: Tree Int -> Tree Bool
        cond :: Tree Bool -> Tree a -> Tree a -> Tree a

One of the keys to these structures' usability is their conciseness.  Currently
in Perl 6, each line in the example above uses six or more lines of Perl.  This
draws attention away from the structure and to the nitty-gritty unimportant
details.

role Tree[::a] { }
class Zero   does Tree[Int]  { }
class Succ   does Tree[Int]  { has Tree[Int] $.in }
class Pred   does Tree[Int]  { has Tree[Int] $.in }
class IsZero does Tree[Bool] { has Tree[Int] ($.a, $.b) }
class Cond   does Tree[::a]  { has Tree[Bool] $.cond;  has Tree[a] ($.if, $.else) }

The last line is the key.  The a type should be inferred from the constructor.

* The trouble with this is that it doesn't provide any type safety.  In the case
of a type conflict, a just degenerates to the Any type.

~~~~~~~~~~~~~

During weak type inferrence, the compiler is trying to find the smallest set
that the value could be a member of.  But perhaps it would be possible to
specify a "cap" that, if the compiler tried to generalize beyond that, it would
die.

Perhaps an enum would specify a set of disjoint base types, for instance:

    enum Foo is disjoint {
        A, B, C
    }

Then if the compiler ever tried to generalize into Foo, it would die, such as
if you had an A in the same type variable as a B.  The question is what happens
if it tries to generalize beyond Foo instantly, such as A and Str.  Perhaps you
would have to declare it to be Foo in order to strongly type it.
