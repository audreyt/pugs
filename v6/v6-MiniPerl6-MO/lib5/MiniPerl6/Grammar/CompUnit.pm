# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package MiniPerl6::Grammar; sub new { shift; bless { @_ }, "MiniPerl6::Grammar" } our($Class_name); sub comp_unit { my $grammar = shift; my $List__ = \@_; my $str; my $pos; do {  $str = $List__->[0];  $pos = $List__->[1]; [$str, $pos] }; my  $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str,'from' => $pos,'to' => $pos,'bool' => 1, ); $MATCH->bool(do { my  $pos1 = $MATCH->to(); do { (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && (do { my  $pos1 = $MATCH->to(); (do { ((('use' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('v6-' eq substr($str, $MATCH->to(), 3)) ? (1 + $MATCH->to((3 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } })))))) } || do { $MATCH->to($pos1); 1 }) } && (do { my  $pos1 = $MATCH->to(); (do { (('class' eq substr($str, $MATCH->to(), 5)) ? (1 + $MATCH->to((5 + $MATCH->to()))) : 0) } || do { $MATCH->to($pos1); (('grammar' eq substr($str, $MATCH->to(), 7)) ? (1 + $MATCH->to((7 + $MATCH->to()))) : 0) }) } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'full_ident'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('{' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { $Class_name = ("" . $MATCH->{'full_ident'}) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $m2 = $grammar->exp_stmts($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'exp_stmts'} = $m2;1 } else { 0 } } } && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && ((('}' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && (do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } } && (do { my  $pos1 = $MATCH->to(); (do { (((';' eq substr($str, $MATCH->to(), 1)) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0) && do { my  $m2 = $grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());1 } else { 0 } } }) } || do { $MATCH->to($pos1); 1 }) } && do { my  $ret = sub  { my $List__ = \@_; do { [] }; do { my  $name = ${$MATCH->{'full_ident'}}; my  $List_body = ${$MATCH->{'exp_stmts'}}; my  $a = $List_body; my  $item; my  $methods; do { for my $item ( @{$a} ) { do { if (Main::isa($item, 'Method')) { push(@{$methods}, Lit::Object->new( 'fields' => [[Val::Buf->new( 'buf' => 'superclasses', ), Lit::Array->new( 'array' => [], )], [Val::Buf->new( 'buf' => 'name', ), Val::Buf->new( 'buf' => $item->name(), )], [Val::Buf->new( 'buf' => 'definition', ), $item]],'class' => 'MO::Compile::Method::Simple', )) } else {  } } } }; my  $attributes; do { for my $item ( @{$a} ) { do { if ((Main::isa($item, 'Decl') && ($item->decl() eq 'has'))) { push(@{$attributes}, Lit::Object->new( 'fields' => [[Val::Buf->new( 'buf' => 'name', ), Val::Buf->new( 'buf' => $item->var()->name(), )]],'class' => 'MO::Compile::Attribute::Simple', )) } else {  } } } }; do { for my $item ( @{$a} ) { do { if ((Main::isa($item, 'Decl') && ((($item->decl() eq 'our') || ($item->decl() eq 'my')) && ($item->var()->twigil() eq '.')))) { push(@{$methods}, Lit::Object->new( 'fields' => [[Val::Buf->new( 'buf' => 'superclasses', ), Lit::Array->new( 'array' => [], )], [Val::Buf->new( 'buf' => 'name', ), Val::Buf->new( 'buf' => $item->var()->name(), )], [Val::Buf->new( 'buf' => 'definition', ), Method->new( 'sig' => Sig->new( 'named' => {  },'invocant' => Var->new( 'name' => 'self','twigil' => '','sigil' => '$', ),'positional' => [], ),'name' => '','block' => [If->new( 'cond' => Index->new( 'obj' => Var->new( 'name' => '_','twigil' => '','sigil' => '@', ),'index' => Val::Int->new( 'int' => '0', ), ),'body' => [Bind->new( 'parameters' => Var->new( 'name' => ('_DOT_' . $item->var()->name()),'twigil' => '','sigil' => '$', ),'arguments' => Index->new( 'obj' => Var->new( 'name' => '_','twigil' => '','sigil' => '@', ),'index' => Val::Int->new( 'int' => '0', ), ), )],'otherwise' => [Var->new( 'name' => ('_DOT_' . $item->var()->name()),'twigil' => '','sigil' => '$', )], )], )]],'class' => 'MO::Compile::Method::Simple', )) } else {  } } } }; push(@{$methods}, Lit::Object->new( 'fields' => [[Val::Buf->new( 'buf' => 'superclasses', ), Lit::Array->new( 'array' => [], )], [Val::Buf->new( 'buf' => 'name', ), Val::Buf->new( 'buf' => 'new', )], [Val::Buf->new( 'buf' => 'definition', ), Method->new( 'sig' => Sig->new( 'named' => {  },'invocant' => Var->new( 'name' => 'self','twigil' => '','sigil' => '$', ),'positional' => [], ),'name' => '','block' => [], )]],'class' => 'MO::Compile::Method::Simple', )); my  $module; do { for my $item ( @{$a} ) { do { if ((Main::isa($item, 'Decl') && ((($item->decl() eq 'our') || ($item->decl() eq 'my')) && ($item->var()->twigil() eq '.')))) { push(@{$module}, Decl->new( 'decl' => $item->decl(),'var' => Var->new( 'name' => ('_DOT_' . $item->var()->name()),'twigil' => '','sigil' => '$', ),'type' => $item->type(), )) } else { do { if (((Main::isa($item, 'Decl') && ($item->decl() eq 'has')) || Main::isa($item, 'Method'))) {  } else { push(@{$module}, $item) } } } } } }; push(@{$module}, Use->new( 'mod' => 'MO::Compile::Method::Simple', )); push(@{$module}, Use->new( 'mod' => 'MO::Compile::Class::MI', )); push(@{$module}, Bind->new( 'parameters' => Decl->new( 'decl' => 'my','var' => Var->new( 'name' => '__base','twigil' => '','sigil' => '$', ),'type' => '', ),'arguments' => Lit::Object->new( 'fields' => [[Val::Buf->new( 'buf' => 'instance_methods', ), Lit::Array->new( 'array' => $methods, )], [Val::Buf->new( 'buf' => 'attributes', ), Lit::Array->new( 'array' => $attributes, )]],'class' => 'MO::Compile::Class::MI', ), )); push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $name, ), Var->new( 'name' => '__base','twigil' => '','sigil' => '$', )],'method' => 'register_class','invocant' => Apply->new( 'arguments' => [],'code' => 'MO::Run::Aux::registry', ), )); return(Module->new( 'name' => $name,'body' => $module, )) }; '974^213' }->(); do { if (($ret ne '974^213')) { $MATCH->capture($ret);return($MATCH) } else {  } }; 1 }))))))))))))))) } }); return($MATCH) }
;
1;
