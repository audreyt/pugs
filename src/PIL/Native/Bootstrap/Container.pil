## ------------------------------------------------------------------------- ##
## Container Types
## ------------------------------------------------------------------------- ##
# currently these are based largely on the quickref/data stuff in pugs, but
# our plans actually lean more towards something like this:
#   http://scala.epfl.ch/docu/files/api/index.html
# however, we need to make sure all our assumptions work, and quickref/data 
# is simple and quick :)
## ------------------------------------------------------------------------- ##


# --------------------------------------------------------------------------- #
# Scalar Container
# --------------------------------------------------------------------------- #

::Scalar.set_superclasses([ ::Object ]);
::Scalar.add_method('FETCH', ->    { self`fetch()         } );
::Scalar.add_method('STORE', -> $x { self`store($x); self } );

::rScalar := ::Role.new({ '$!name' => 'Scalar' });

::Scalar.set_roles([ ::rScalar ]);
::Scalar.resolve();

# --------------------------------------------------------------------------- #
# Array Container
# --------------------------------------------------------------------------- #

::Array.set_superclasses([ ::Object ]);
::Array.add_method('FETCH', -> $i     { self`fetch_elem($i)           } );
::Array.add_method('STORE', -> $i, $x { self`store_elem($i, $x); self } );

=pod

Array Role

stolen from docs/quickref/data # probably incomplete

.elems          # Number of elements
.join($sep)
.map:{ ... }
.grep:{ ... }
.pop
.push($elem)
.shift
.unshift($elem)
.reverse
.sort( { cond }, { cond }, ... )
.kv            # return index,value pairs

NOTE:
Currently this is an immutable array interface, I will be 
spliting this up and createing a mutable interface too which 
will be more Haskell-ish. 

=cut

::rArray := ::Role.new({ '$!name' => 'Array' });

::rArray.add_method('elems', -> { 
    self`fetch_list()`length() 
});

::rArray.add_method('join', -> $sep {
    -> @elems, $acc {
        $redo := &?SUB;
        @elems`is_empty()`cond(
            -> { $acc },
            -> { 
                $redo`(
                    @elems`splice(1), 
                    @elems`length()`eq(1)`cond(
                        -> { $acc`concat(@elems`fetch(0))              },
                        -> { $acc`concat(@elems`fetch(0))`concat($sep) }
                    )
                );
            }
        );
    }`(self`fetch_list(), '');
});

::rArray.add_method('map', -> $func {
    $?CLASS`create(
        -> $elem {
            $func`($elem)
        }`do_for(self`fetch_list())
    );
});

::rArray.add_method('grep', -> $func {
    @new :=  $?CLASS`create([]);
    -> $elem {
        $func`($elem)`as_bit`cond(
            -> { @new.push($elem) }, 
            -> {                  }
        );
    }`do_for(self`fetch_list());
    @new;
});

::rArray.add_method('pop', -> {
    $elem := self`fetch_elem(self.elems()`decrement());
    # this is a ugly kludge for now :-/
    self`store_list(self`fetch_list()`reverse()`splice(1)`reverse());
    $elem;    
});

::rArray.add_method('push', -> $elem {
    self`store_list(self`fetch_list()`concat([ $elem ]));
    self;
});

::rArray.add_method('shift', -> {
    $elem := self`fetch_elem(0);
    self`store_list(self`fetch_list()`splice(1));
    $elem;
});

::rArray.add_method('unshift', -> $elem {
    self`store_list([ $elem ]`concat(self`fetch_list()));
    self;    
});

::rArray.add_method('reverse', -> {
    self`store_list(self`fetch_list()`reverse());
    self;
});

# NOTE:
# I think sort is a more complex beast, 
# we will deal with this later
::rArray.add_method('sort', -> {});

# NOTE:
# kv should return a list of Pair objects
# in which case we will need some Pair objects
::rArray.add_method('kv', -> {});

::Array.set_roles([ ::rArray ]);
::Array.resolve();

# --------------------------------------------------------------------------- #
# Hash Container
# --------------------------------------------------------------------------- #

::Hash.set_superclasses([ ::Object ]);
::Hash.add_method('FETCH', -> $i     { self`fetch_elem($i)           } );
::Hash.add_method('STORE', -> $i, $x { self`store_elem($i, $x); self } );

=pod

stolen from docs/quickref/data # probably incomplete

.delete($key)
.exists($key)
.keys
.values
.kv                # List of key, value, key, value, ...

=cut

::rHash := ::Role.new({ '$!name' => 'Hash' });
::rHash.add_method('delete', -> $key {});
::rHash.add_method('exists', -> $key {});
::rHash.add_method('keys',   -> {});
::rHash.add_method('values', -> {});
::rHash.add_method('kv',     -> {});

::Hash.set_roles([ ::rHash ]);
::Hash.resolve();

# --------------------------------------------------------------------------- #
# Pair Container
# --------------------------------------------------------------------------- #
# Pair is an immutable object, you must pass in the $!key and $!value 
# arguments to the constructor, otherwise they will be nil.

::Pair := ::Class.new({});
::Pair.set_superclasses([ ::Object ]);

::Pair.add_attribute('$!key',   nil);
::Pair.add_attribute('$!value', nil);

::Pair.add_method('key',   -> { self`get_attr('$!key')   });
::Pair.add_method('value', -> { self`get_attr('$!value') });
::Pair.add_method('kv',    -> { self                     });

