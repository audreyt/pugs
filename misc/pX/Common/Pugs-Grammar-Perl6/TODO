TODO list for Pugs-Compiler-Tokenizer

Priorities

- pass t/01-sanity/*

    t/01-sanity failures:
    
      07-isa.t 
        - no closures 
      07-ref.t 
        - no $obj.method 
      07-tailcall.t
        - no &
      07-try.t
        - no $!
    
- merge Pod.pm into Perl6.pm

- special cases
 moose=>1
 moose:<elk>
 moose:{antler()}

TODO

- macro

- Implement compile-time dynamic 'add_token' (lexical at run-time)

- Implement double-quoted-string split on variables (interpolation)
- Implement %hash<qw string> and '<' and '>'
- Implement /rule/ and '/'
- Implement [op]@list
- Implement expressions inside names - like:
    prefix:{'+'}

- Make the tokenizer match eagerly (faster)

- Implement the "magic hash" dispatcher

    TimToady on #perl6 -
    xxx:<+> has to be considered just a funny looking name. 
    It's the grammar's responsibility (somehow) to pull in any existing xxx and 
    newly created xxx and combine them into any rules or %hash that references them.
    supposing a grammatical category shows up in %xxx, then we need two ways to deal 
    with it.
    first, if we want one category to hide another, you can get away with a mixin 
    style of
        rule { %xxx | %yyy | %zzz }
    but there are some syntactic categories that have to be magically combined like
    compile-time roles:
        rule { %xxx_or_yyy_or_zzz }
    that is, the longest-token rule is applies in parallel across all the categories
    simultaneously.
    that's why the magic hash was invented (or more accurately, is scheduled to 
    be invented :)

-   the tokenizer should get tokens lazily ?

-   is 'space-{' is found, is sent to the opp - if the opp is expecting an operator,
    it means end-of-expression

    TimToady in #perl6 - space + block is a top-level block only where an operator 
    is expected, and you're not in brackets.
    where a term is expected, it's just a closure argument. (or a hash composer)

- Specify/generate AST

P::C::R BUGS

- A Match doesn't stringify if there is a capture

- Fix %hash capture - it currently works like this:

  sub capture {
    # print Dumper ${$_[0]}->{match}[0]{match}[1]{capture}; 
    return ${$_[0]}->{match}[0]{match}[1]{capture};
  }

