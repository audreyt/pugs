# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;

package KindaPerl6::Visitor::Emit::MiniPerl6Like;
sub new { shift; bless {@_}, "KindaPerl6::Visitor::Emit::MiniPerl6Like" }

sub visit {
    my $self   = shift;
    my $List__ = \@_;
    my $node;
    do { $node = $List__->[0]; [$node] };
    (   '# Do not edit this file - Generated by KindaPerl6::Visitor::Emit::MiniPerlLike'
            . (
            Main->newline()
                . (
                'use v5;'
                    . (
                    Main->newline()
                        . (
                        'use strict;'
                            . ( Main->newline() . ( 'use MiniPerl6::Perl5::Runtime;' . ( Main->newline() . ( 'use MiniPerl6::Perl5::Match;' . ( Main->newline() . ( $node->emit_mp6like() . ( Main->newline() . ( '1;' . Main->newline() ) ) ) ) ) ) ) )
                        )
                    )
                )
            )
    );
}

package CompUnit;
sub new { shift; bless {@_}, "CompUnit" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'package '
            . ( $self->{name} . ( ';' . ( Main->newline() . ( 'sub new { shift; bless { @_ }, "' . ( $self->{name} . ( '" }' . ( Main->newline() . ( $self->{body}->emit_mp6like() . ( ';' . ( Main->newline() . Main->newline() ) ) ) ) ) ) ) ) ) ) );
}

package Val::Int;
sub new { shift; bless {@_}, "Val::Int" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    $self->{int};
}

package Val::Bit;
sub new { shift; bless {@_}, "Val::Bit" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    $self->{bit};
}

package Val::Num;
sub new { shift; bless {@_}, "Val::Num" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    $self->{num};
}

package Val::Buf;
sub new { shift; bless {@_}, "Val::Buf" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '\'' . ( $self->{buf} . '\'' ) );
}

package Val::Char;
sub new { shift; bless {@_}, "Val::Char" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'chr(' . ( $self->{char} . ')' ) );
}

package Val::Undef;
sub new { shift; bless {@_}, "Val::Undef" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    '(undef)';
}

package Val::Object;
sub new { shift; bless {@_}, "Val::Object" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'bless(' . ( Main::perl( $self->{fields}, ) . ( ', ' . ( Main::perl( $self->{class}, ) . ')' ) ) ) );
}

package Lit::Seq;
sub new { shift; bless {@_}, "Lit::Seq" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{seq} } ], ', ' ) . ')' ) );
}

package Lit::Array;
sub new { shift; bless {@_}, "Lit::Array" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '[' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{array} } ], ', ' ) . ']' ) );
}

package Lit::Hash;
sub new { shift; bless {@_}, "Lit::Hash" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $fields = $self->{hash};
    my $str    = '';
    do {
        for my $field ( @{$fields} ) { $str = ( $str . ( $field->[0]->emit_mp6like() . ( ' => ' . ( $field->[1]->emit_mp6like() . ',' ) ) ) ) }
    };
    ( '{ ' . ( $str . ' }' ) );
}

package Lit::Code;
sub new { shift; bless {@_}, "Lit::Code" }

sub emit_mp6like_declarations {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s;
    my $name;
    do {
        for my $name ( @{ $self->{pad}->lexicals() } ) {
            my $decl = Decl->new( 'decl' => 'my', 'type' => '', 'var' => Var->new( 'sigil' => '', 'twigil' => '', 'name' => $name, 'namespace' => [], ), );
            $s = ( $s . ( $name->emit_mp6like() . ( ';' . Main::newline() ) ) );
        }
    };
    return ($s);
}

sub emit_mp6like_arguments {
    my $self   = shift;
    my $List__ = \@_;
    my $invocant;
    do { $invocant = $List__->[0]; [$invocant] };
    my $str = '';
    my $i   = 0;
    do {
        for my $field ( @{ $self->{sig}->positional() } ) { $str = ( $str . ( $field->key()->emit_mp6like() . ( ' = $_[' . ( $i . ']; ' ) ) ) ); $i = ( $i + 1 ) }
    };
    ( ( $invocant ? 'my $self = shift; ' : '' ) . ( '$List__ = \@_; ' . $str ) );
}

sub emit_mp6like_body {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    Main::join( [ map { $_->emit_mp6like() } @{ $self->{body} } ], ( ';' . Main->newline() ) );
}

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( $self->emit_mp6like_declarations() . $self->emit_mp6like_body() );
}

package Lit::Object;
sub new { shift; bless {@_}, "Lit::Object" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $fields = $self->{fields};
    my $str    = '';
    do {
        for my $field ( @{$fields} ) { $str = ( $str . ( $field->[0]->emit_mp6like() . ( ' => ' . ( $field->[1]->emit_mp6like() . ',' ) ) ) ) }
    };
    ( $self->{class} . ( '->new( ' . ( $str . ' )' ) ) );
}

package Lit::NamedArgument;
sub new { shift; bless {@_}, "Lit::NamedArgument" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( $self->{key}->emit_mp6like() . ( '=>' . $self->{value}->emit_mp6like() ) );
}

package Lit::Pair;
sub new { shift; bless {@_}, "Lit::Pair" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( $self->{key}->emit_mp6like() . ( '=>' . $self->{value}->emit_mp6like() ) );
}

package Index;
sub new { shift; bless {@_}, "Index" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( $self->{obj}->emit_mp6like() . ( '->[' . ( $self->{index}->emit_mp6like() . ']' ) ) );
}

package Lookup;
sub new { shift; bless {@_}, "Lookup" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( $self->{obj}->emit_mp6like() . ( '->{' . ( $self->{index}->emit_mp6like() . '}' ) ) );
}

package Var;
sub new { shift; bless {@_}, "Var" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $table = { '$' => '$', '@' => '$List_', '%' => '$Hash_', '&' => '$Code_', };
    ( ( $self->{twigil} eq '.' ) ? ( '$self->{' . ( $self->{name} . '}' ) ) : ( ( $self->{name} eq '/' ) ? ( $table->{ $self->{sigil} } . 'MATCH' ) : ( $table->{ $self->{sigil} } . $self->{name} ) ) );
}

package Bind;
sub new { shift; bless {@_}, "Bind" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( Main::isa( $self->{parameters}, 'Lit::Array' ) ) {
            my $a   = $self->{parameters}->array();
            my $str = 'do { ';
            my $i   = 0;
            do {
                for my $var ( @{$a} ) {
                    my $bind = Bind->new( 'parameters' => $var, 'arguments' => Index->new( 'obj' => $self->{arguments}, 'index' => Val::Int->new( 'int' => $i, ), ), );
                    $str = ( $str . ( ' ' . ( $bind->emit_mp6like() . '; ' ) ) );
                    $i = ( $i + 1 );
                }
            };
            return ( ( $str . ( $self->{parameters}->emit_mp6like() . ' }' ) ) );
        }
        else { }
    };
    do {
        if ( Main::isa( $self->{parameters}, 'Lit::Hash' ) ) {
            my $a   = $self->{parameters}->hash();
            my $b   = $self->{arguments}->hash();
            my $str = 'do { ';
            my $i   = 0;
            my $arg;
            do {
                for my $var ( @{$a} ) {
                    $arg = Val::Undef->new();
                    do {
                        for my $var2 ( @{$b} ) {
                            do {
                                if ( ( $var2->[0]->buf() eq $var->[0]->buf() ) ) { $arg = $var2->[1] }
                                else                                             { }
                                }
                        }
                    };
                    my $bind = Bind->new( 'parameters' => $var->[1], 'arguments' => $arg, );
                    $str = ( $str . ( ' ' . ( $bind->emit_mp6like() . '; ' ) ) );
                    $i = ( $i + 1 );
                }
            };
            return ( ( $str . ( $self->{parameters}->emit_mp6like() . ' }' ) ) );
        }
        else { }
    };
    do {
        if ( Main::isa( $self->{parameters}, 'Lit::Object' ) ) {
            my $class = $self->{parameters}->class();
            my $a     = $self->{parameters}->fields();
            my $b     = $self->{arguments};
            my $str   = 'do { ';
            my $i     = 0;
            my $arg;
            do {
                for my $var ( @{$a} ) {
                    my $bind = Bind->new( 'parameters' => $var->[1], 'arguments' => Call->new( 'invocant' => $b, 'method' => $var->[0]->buf(), 'arguments' => [], 'hyper' => 0, ), );
                    $str = ( $str . ( ' ' . ( $bind->emit_mp6like() . '; ' ) ) );
                    $i = ( $i + 1 );
                }
            };
            return ( ( $str . ( $self->{parameters}->emit_mp6like() . ' }' ) ) );
        }
        else { }
    };
    do {
        if   ( ( Main::isa( $self->{parameters}, 'Var' ) && ( $self->{parameters}->sigil() eq '&' ) ) ) { return ( $self->{arguments}->emit_mp6like() ) }
        else                                                                                            { }
    };
    ( $self->{parameters}->emit_mp6like() . ( ' = ' . $self->{arguments}->emit_mp6like() ) );
}

package Proto;
sub new { shift; bless {@_}, "Proto" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( "" . $self->{name} );
}

package Call;
sub new { shift; bless {@_}, "Call" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $invocant = $self->{invocant}->emit_mp6like();
    do {
        if ( ( $invocant eq 'self' ) ) { $invocant = '$self' }
        else                           { }
    };
    do {
        if ( ( $self->{method} eq 'values' ) ) {
            do {
                if   ( $self->{hyper} ) { die('not implemented') }
                else                    { return ( ( '@{' . ( $invocant . '}' ) ) ) }
                }
        }
        else { }
    };
    do {
        if ( ( ( $self->{method} eq 'perl' ) || ( ( $self->{method} eq 'yaml' ) || ( ( $self->{method} eq 'say' ) || ( ( $self->{method} eq 'join' ) || ( ( $self->{method} eq 'chars' ) || ( $self->{method} eq 'isa' ) ) ) ) ) ) ) {
            do {
                if ( $self->{hyper} ) {
                    return ( ( '[ map { Main::' . ( $self->{method} . ( '( $_, ' . ( ', ' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ( ')' . ( ' } @{ ' . ( $invocant . ' } ]' ) ) ) ) ) ) ) ) );
                }
                else {
                    return ( ( 'Main::' . ( $self->{method} . ( '(' . ( $invocant . ( ', ' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) ) ) ) ) );
                }
                }
        }
        else { }
    };
    my $meth = $self->{method};
    do {
        if ( ( $meth eq 'postcircumfix:<( )>' ) ) { $meth = '' }
        else                                      { }
    };
    my $call = ( '->' . ( $meth . ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) ) );
    do {
        if ( $self->{hyper} ) { ( '[ map { $_' . ( $call . ( ' } @{ ' . ( $invocant . ' } ]' ) ) ) ) }
        else                  { ( $invocant . $call ) }
        }
}

package Apply;
sub new { shift; bless {@_}, "Apply" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $code = $self->{code};
    do {
        if ( ( Main::isa( $code, 'Var' ) && ( ( $code->sigil() eq '&' ) && ( $code->twigil() eq '' ) ) ) ) { $code = $code->name() }
        else                                                                                               { }
    };
    do {
        if ( Main::isa( $code, 'Str' ) ) { }
        else {
            return ( ( '(' . ( $self->{code}->emit_mp6like() . ( ')->(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) ) ) );
        }
    };
    do {
        if   ( ( $code eq 'self' ) ) { return ('$self') }
        else                         { }
    };
    do {
        if ( ( $code eq 'make' ) ) {
            return ( ( 'return(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'say' ) ) {
            return ( ( 'Main::say(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'print' ) ) {
            return ( ( 'Main::print(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'warn' ) ) {
            return ( ( 'warn(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'array' ) ) {
            return ( ( '@{' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . '}' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<~>' ) ) {
            return ( ( '("" . ' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<!>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . ' ? 0 : 1)' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<?>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . ' ? 1 : 0)' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<$>' ) ) {
            return ( ( '${' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . '}' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<@>' ) ) {
            return ( ( '@{' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . '}' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'prefix:<%>' ) ) {
            return ( ( '%{' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ' ) . '}' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<~>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' . ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<+>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' + ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<->' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' - ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<>>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' > ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<x>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' x ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<&&>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' && ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<||>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' || ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<eq>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' eq ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<ne>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' ne ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<==>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' == ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'infix:<!=>' ) ) {
            return ( ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ' != ' ) . ')' ) ) );
        }
        else { }
    };
    do {
        if ( ( $code eq 'ternary:<?? !!>' ) ) { return ( ( '(' . ( $self->{arguments}->[0]->emit_mp6like() . ( ' ? ' . ( $self->{arguments}->[1]->emit_mp6like() . ( ' : ' . ( $self->{arguments}->[2]->emit_mp6like() . ')' ) ) ) ) ) ) ) }
        else                                  { }
    };
    ( $code . ( '(' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{arguments} } ], ', ' ) . ')' ) ) );
}

package Return;
sub new { shift; bless {@_}, "Return" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    return ( ( 'return(' . ( $self->{result}->emit_mp6like() . ')' ) ) );
}

package If;
sub new { shift; bless {@_}, "If" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'do { if (' . ( $self->{cond}->emit_mp6like() . ( ') { ' . ( $self->{body}->emit_mp6like() . ( ' } else { ' . ( ( $self->{otherwise} ? $self->{otherwise}->emit_mp6like() : '' ) . ' } }' ) ) ) ) ) );
}

package For;
sub new { shift; bless {@_}, "For" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $cond = $self->{cond};
    do {
        if ( ( Main::isa( $cond, 'Var' ) && ( $cond->sigil() eq '@' ) ) ) { $cond = Apply->new( 'code' => 'prefix:<@>', 'arguments' => [$cond], ) }
        else                                                              { }
    };
    ( 'do { for my ' . ( $self->{topic}->emit_mp6like() . ( ' ( ' . ( $cond->emit_mp6like() . ( ' ) { ' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{body} } ], ';' ) . ' } }' ) ) ) ) ) );
}

package Decl;
sub new { shift; bless {@_}, "Decl" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $decl = $self->{decl};
    my $name = $self->{var}->name();
    (     ( $decl eq 'has' )
        ? ( 'sub ' . ( $name . ( ' { ' . ( '@_ == 1 ' . ( '? ( $_[0]->{' . ( $name . ( '} ) ' . ( ': ( $_[0]->{' . ( $name . ( '} = $_[1] ) ' . '}' ) ) ) ) ) ) ) ) ) )
        : ( $self->{decl} . ( ' ' . ( $self->{type} . ( ' ' . $self->{var}->emit_mp6like() ) ) ) ) );
}

package Sig;
sub new { shift; bless {@_}, "Sig" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ' print \'Signature - TODO\'; die \'Signature - TODO\'; ';
}

package Method;
sub new { shift; bless {@_}, "Method" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'sub ' . ( $self->{name} . ( ' { ' . ( $self->{block}->emit_mp6like_declarations() . ( $self->{block}->emit_mp6like_arguments(1) . ( $self->{block}->emit_mp6like_body() . ' }' ) ) ) ) ) );
}

package Sub;
sub new { shift; bless {@_}, "Sub" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'sub ' . ( $self->{name} . ( ' { ' . ( $self->{block}->emit_mp6like_declarations() . ( $self->{block}->emit_mp6like_arguments(0) . ( $self->{block}->emit_mp6like_body() . ' }' ) ) ) ) ) );
}

package Do;
sub new { shift; bless {@_}, "Do" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'do { ' . ( Main::join( [ map { $_->emit_mp6like() } @{ $self->{block} } ], '; ' ) . ' }' ) );
}

package Use;
sub new { shift; bless {@_}, "Use" }

sub emit_mp6like {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'use ' . $self->{mod} );
}

1;
