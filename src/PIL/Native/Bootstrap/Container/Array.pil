# --------------------------------------------------------------------------- #
# Array Container
# --------------------------------------------------------------------------- #

::Array.set_name('Array');
::Array.set_version('0.0.1');
::Array.set_authority('url:pugscode.org');

::Array.set_superclasses([ ::Object ]);

::Array.add_method('FETCH', -> $i     { self`fetch_elem($i)           } );
::Array.add_method('STORE', -> $i, $x { self`store_elem($i, $x); self } );

# --------------------------------------------------------------------------- #
# Array Role
# --------------------------------------------------------------------------- #

::rArray := ::Role.new({});
::rArray.set_name('Array');
::rArray.set_version('0.0.1');
::rArray.set_authority('url:pugscode.org');

::rArray.add_method('elems', -> { 
    self`fetch_list()`length() 
});

# List interface (as speced in S29) 
# NOTE: break this out into List.pil and List role maybe ...

::rArray.add_method('join', -> $sep {
    -> @elems, $acc {
        &redo := &?SUB;
        @elems`is_empty()`cond(
            -> { $acc },
            -> { 
                &redo`(
                    @elems`splice(1), 
                    @elems`length()`eq(1)`cond(
                        -> { $acc`concat(@elems`fetch(0)`as_str()) },
                        -> { $acc`concat(@elems`fetch(0)`as_str())`concat($sep`as_str()) }
                    )
                );
            }
        );
    }`(self`fetch_list(), '');
});

::rArray.add_method('map', -> &func {
    $?CLASS`create(
        -> $elem {
            &func`($elem)
        }`do_for(self`fetch_list())
    );
});

::rArray.add_method('grep', -> &func {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> {
                $elem := @list`fetch(0);
                &func`($elem)`as_bit()`cond(
                    -> { &redo`(@list`splice(1), @acc`push($elem)) },
                    -> { &redo`(@list`splice(1), @acc)             }            
                );
            }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('reverse', -> {
    self`store_list(self`fetch_list()`reverse());
    self;
});

::rArray.add_method('reduce', -> &func {
    -> @list, $acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $acc },
            -> { &redo`(@list`splice(1), &func`($acc, @list`fetch(0))) }
        );        
    }`(self`fetch_list()`splice(1), self`fetch_elem(0));
});

::rArray.add_method('zip', -> @values {
    -> @l, @r, @acc {
        &redo := &?SUB;
        @l`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { &redo`(@l`splice(1), @r`splice(1), @acc`concat([ @l`fetch(0), @r`fetch(0) ])) }
        );
    }`(self`fetch_list(), @values`fetch_list(), []);
});

# bottom up merge sort
::rArray.add_method('sort', -> &criterion {
    self.elems()`le(1)`cond(
        #-> { self },
        #-> { merge := -> l1 l2 { l1`elms()`eq(0)`cond(
        #                          -> { l2 }
        #                          -> { l2.elms()`eq(0)`cond(
        #                                -> { l1 }
        #                                -> { hl1 := l1`splice(0,1) ;
        #                                     hl2 := l2`splice(0,1) ;
        #                                     &criterion`(hl1, hl2)`eq(True)`cond(
        #                                       ->{ hl1`concat( merge( l1`splice(1)`concat(l2) ) ) }
        #                                       ->{ hl2`concat( merge( l1`concat(l2`splice(1)) ) ) } ) } ) } ) } ;
        #     mergepairs := -> lst { lst`elms()`le(1)`cond(
        #                             -> { [] }
        #                             -> { merge( lst`splice(0,1), lst`splice(1,1) )`concat( mergepairs( lst`splice(2) ))} ) } ;
        #      
        #     split := -> lst { lst`elems()`eq(0)`cond(
        #                       -> { [] }
        #                       -> { lst`splice(0, 1)`concat( split`( lst`splice(1) ) ) } ) } ;
        #
        #     mergesort := -> lst { lst`elms()`eq(1)`cond(
        #                            -> { lst`unshift() }
        #                            -> { mergsort( mergepairs( lst ) ) } ) } ;
        #
        #     mergesort( split( self ) );
        #                       
        #                       
        #                       
        #    #&c := &criterion`is_nil()`cond(
        #    #    -> { -> $a, $b { $a`eq($b)`cond(-> { 0 }, -> { $a`lt($b)`cond(-> { -1 }, -> { 1 }) }) } },
        #    #    -> { &criterion }
        #    #);
        #    # ... someone else do this one,.. I hate sorting algorithms
        }
    );
});

# Array method (as speced in S29)

::rArray.add_method('pop', -> {
    $elem := self`fetch_elem(self.elems()`decrement());
    # this is a ugly kludge for now :-/
    self`store_list(self`fetch_list()`reverse()`splice(1)`reverse());
    $elem;    
});

::rArray.add_method('push', -> $elem {
    self`store_list(self`fetch_list()`concat([ $elem ]));
    self;
});

::rArray.add_method('shift', -> {
    $elem := self`fetch_elem(0);
    self`store_list(self`fetch_list()`splice(1));
    $elem;
});

::rArray.add_method('unshift', -> $elem {
    self`store_list([ $elem ]`concat(self`fetch_list()));
    self;    
});

::rArray.add_method('delete', -> @indices {});
::rArray.add_method('exists', -> @indices {});
::rArray.add_method('splice', -> $offset, $length, @values {});

::rArray.add_method('keys', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { &redo`(@list`splice(1), @acc`push(@acc`length())) }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('values', -> { self });

::rArray.add_method('pairs', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { 
                &redo`(
                    @list`splice(1), 
                    @acc`push(::Pair.new({ 
                        'k' => @acc`length(), 
                        'v' => @list`fetch(0) 
                    }))
                ) 
            }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('kv', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { 
                &redo`(
                    @list`splice(1), 
                    @acc`push(::Array`create([ 
                        @acc`length(), 
                        @list`fetch(0) 
                    ]))
                ) 
            }
        );
    }`(self`fetch_list(), []);
});

# --------------------------------------------------------------------------- #
# Bootstrap Array Container to Array Role
# --------------------------------------------------------------------------- #

::Array.set_roles([ ::rArray ]);
::Array.resolve();
