=pod

=head1 Create Your Own Object Model

So all this meta-meta-stuff can be interesting, but the real question is 
how does it fit into a real-world scenario. I mean, what do you do with 
all this abstraction?

Why make your own object model of course :)

=head2 Designing your object model

First we need to decide what to put into our object model. For the sake 
of keeping the example small and clean I will keep it simple. 

Obviously we will have classes. We will define a class as simply a 
collection of properties and methods, and we wont bother about public/private
or any such things.

Now, the next we will add Abstract classes to our model. We will define an 
abstract class as being a class, but with no instance variables, and whose methods 
are defined but cannot be implemented. This is a very simplistic defintion of 
abstract classes, but we want to avoid complexity for this example.

The last thing we will add to our object model is ThreadSafe classes. These are 
classes for which will be guaranteed to be thread safe. And despite what you might 
think, this is very simple to implement.

Now with our object model defined, lets build it.

=head2 Building your object model

First we determine the structure of our meta-classes. In my mind, Abstract classes 
should be our base meta-class; with regular Classes being a subclass of abstract 
classes; and finally the ThreadSafe classes being a subclass of Classes.

So lets define our AbstractClass meta-class:

    {
        'class' => MetaClass,
        MetaClass => {
            'name' => 'AbstractClass',
            'parent' => undef,
            'instance_vars' => {
                AbstractClass => { 
                    'name'          => "",
                    'parents'       => [],
                    'method_table'  => {}
                }
            },
            'method_table' => {
                'create_instance' => { 
                    return { 'class' => AbstractClass, AbstractClass.<instance_vars> }
                },
                'add_method_to_class' => ($class, $label) -> {
                    $class.<method_table>.<$label> = \&abstractMethodHandler;
                },
                ...
            }
        }
    }

An AbstractClass does not have any 'instance_var' slot since they are not allowed.
We also implement an 'add_method_to_class' in our AbstractClass method_table which 
allows us to enforce that all our methods use the same C<\&abstractMethodHandler> 
which will throw the appropriate error.

Now we define the Class meta-class (which is actually a subclass of the 
AbstractClass meta-class):

    {
        'class' => MetaClass,
        MetaClass => {
            'name' => 'Class',
            'parent' => AbstractClass,
            'instance_vars' => {
                Class => { 
                    'instance_var' => {}
                }
            },
            'method_table' => {
                'create_instance' => { 
                    return merge(
                        Class.parent.<instance_vars>,
                        { 'class' => Class, Class.<instance_vars> }
                    ); 
                },
                'add_method_to_class' => ($class: $label, $impl) -> {
                    $class<method_table><$label> = $impl;
                },
                ...
            }
        }
    }

Notice the parent field, which points back to the AbstractClass meta-class. We
also now include an 'instance_var' slot into the Class meta-class's 'instance_var' 
slot, all the other slots are defined in AbstractClass. This allows our Class 
meta-class to have instance variables, which we denied to our AbstractClass meta-class.

Next is the 'create_instance' meta-class method which merges the instance_vars of 
the parent (AbstractClass) with the instance vars of the Class, and of course our 
'add_method_to_class' meta-class method now accepts a method implementation (C<$impl>).

Okay, so now we have a basic object model here. We have abstract classes as well as 
regular basic everyday classes. Simple right? :)

Now comes our last meta-class, the ThreadSafeClass. 

Now for the purposes of my example I am keeping it very simple and saying that in 
order to be thread safe every method must aquire an instance specific semaphore 
prior to executing, and then release that semaphore after execution. 

Here is what that would look like:

    {
        'class' => MetaClass,
        MetaClass => {
            'name' => 'ThreadSafeClass',
            'parent' => Class,
            'instance_vars' => {
                'semaphore' => <semaphore>
            },
            'method_table' => {
                'add_method_to_class' => ($class: $label, $impl) -> {
                    $class<method_table><$label> = ($self: @args) {
                        $self<semaphore>.aquire();
                        @return_vals = $self.invoke_method($impl, @args);
                        $self<semaphore>.release();                        
                        return @return_vals;
                    }
                },
                ...
            }
        }
    }

This is somewhat of a simplistic implementation, but it serves to illustrate the 
power of meta-classes quite well. We need to add the semaphore instance_var since
all our instances will need one. And then in the 'add_method_to_class', we simply 
wrap the method in our own thread-safe wrapper.

So as you can see, using meta-classes we can very easily create fairly robust 
object models quite simply. 

[... more to come later ...]

=head1 AUTHOR

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=cut
