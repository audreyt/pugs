mp6/kp6 FAQ

15:04:22 < fglock> I'm looking for a starting point for kp6 docs
15:08:10 < ZiggyE> you could start by documenting the way kp6 should be run and how to regenerate lib5
08:39 < avar> explain what subset of p6 it covers

- What subset of Perl 6 is covered by mp6?
  (from miniperl6-spec.pod)

    - A program is organized in compilation units. All statements must be inside a 'class' declaration:
    
    class X { ... }

    - Only allow one feed of positional arguments
    - In Signature, disallow "is slurpy", "is optional", "is named"
        (*@bad) ($bad?) (:$bad)
    - But we do allow Hash and Array and Tree unpacking:
        sub foo ([$a, $b, $c], {:$x, :$y}, ::Tree $top (:$left, :$right)) { ... }

        foo([1, 2, 3], { x => 1, y => 2 }, ::Tree( left => 1, right => 2 ));

        # This compiles to:
        sub foo {
            my perl6::Tree $top;
            my ($a, $b, $c, $top, $x, $y, $left, $right);
            ($a, $b, $c)  = @_[0];
            ($x, $y)      = @_[1]{'x', 'y'};
            $top          = @_[2];
            ($left, $right) = ($top.left, $top.right);
            ...
        }
        foo([1, 2, 3], { x => 1, y => 2 });

    - As a consequence, object constructor calls must be written in
      coercion form:
        ::Foo( x => 1, y => 2 );   # NOT Foo.new

    - Only allow item context
    - No laziness; all List are Seq
    - No subtyping (inheritance) or role mixins
    - No first-class Capture and Signature objects, which means no \$x nor :(foo)
    - No assignment, only bindings, but don't panic:
        $x := $x + 1;   # name = IntOp(named(Int))
        # $x = $x + 1
      The reason is we have to eliminate one of them to avoid dealing with:
        $x := $y;
        $x = 123;
      Because assignment always involve box(unbox()), so emitting binding to
      Perl 5 is much more straightforward as $x is always just a Int in
      ($x := $x + 1), never SomePossiblyTiedScalarContainerType that needs to
      have special FETCH magic associated with it.

      Also it's inevitable with eliminating list context, because:
        ($x, $y, $z) := (1, 2); # compile-time error
        ($x, $y, $z) = (1, 2);  # list-context-undef-fill that we don't want to deal with
      because infix:<=> almost always imply slurpiness with LHS is not a simple scalar,
      eliminating it is consistent with eliminating list context.

    - Allow Type annotations. Preserve them Perl 5 emitted code using simple Typed vars:
        # MiniPerl6
        my Int $x;
        my perl5:CGI $x;

        # Compiled Perl 5
        my perl6::Int $x;
        my CGI $x;
      However, the compiler adds no extra assertions so types never slows programs down
      in MiniPerl6 land.

    - Closures, but no coroutines nor continuations
    - Closed grammatical categories and precedence levels
    - No macros; no BEGIN blocks!
    - No multis

- Running mp6

There are control scripts for compiling mp6 to several backends:

Perl 5:

  perl mp6-perl5-boot.pl < source.pl > dest.pl
  
Parrot:

  perl mp6-parrot.pl < source.pl > dest.pir

Parrot-PAST:

  perl mp6-past.pl < source.pl > dest.past


- Bootstrapping mp6-perl5:

This script rebuilds the lib5 directory. It creates a directory named lib5-new:

  perl util/build-perl5.sh
  mv lib5 lib5-old
  mv lib5-new lib5


- What subset of Perl 6 is covered by kp6?

kp6 reuses the mp6 grammar.
The main differences are not visible - kp6 adds an extra AST processing step.


- Running kp6

kp6 works by creating a parse tree, which is then submitted to a list of AST processors.

The 'kp6-perl5.pl' script is one of the possible compiler 'workflows' that can be built with kp6.

  perl kp6-perl5.pl < source.pm > dest.pm


- Compiling kp6

As of this writing, kp6 is not bootstrapped.

The kp6 source files can be compiled with mp6. There is a 'mp6.pl' script in kp6 directory:

  perl mp6.pl < lib/KindaPerl6/Visitor/EmitPerl5.pm > lib5/KindaPerl6/Visitor/EmitPerl5.pm
  