# A set of rules for parsing Signatures in perl6

# XXX no support for isLValue, isWritable, or isLazy (don't understand isLazy)
#       described in InternalNames.hs line 798

# XXX trusting rules to DWIM for whitespace.
#   Do I have to be explicit in places where whitespace is _not_ allowed?
#     $ foo # should not be allowed
#   Do I have to be explicit about places where whitespace is required?
#     $foo is rwis deep # should not be allowed

grammar Signature {
    # stand-in for bracketing constructs
    # XXX add more or get unicode character classes working
    token open_group  { <[<({[]> }   # should be Ps and <
    token close_group { <[>)}\]]> } # should be Pe and >
    token close_param { <[,)]> }

    # separator used in multi sigs to separate multiple levels of invocants
    token tie_break { <[:]> }
    
    # perl6 sigils in signatures
    token is_array  { $<context> := <[@]> }
    token is_scalar { $<context> := <[$]> }
    token is_code   { $<context> := <[&]> }
    token is_hash   { $<context> := <[%]> }
    token sigil     { <is_scalar> | <is_array> | <is_hash> | <is_code> }

    # names don't have \d as the first character and have
    # at least one non-_ character
    token param_name   { [ <alpha> | _ ]+ [ <alpha> | \d | _ ]+  }
    token internal     { <param_name> }
    token external     { <param_name> }

    # defaults for arguments can be assigned in the sig
    rule default { = $<default> := <expression( terminates => ',' )> }
    
    # types start with an uppercase letter
    token type_name { <upper>+ [ <alpha> | _ | \d ]* }
    token type      { <type_name> }
    token ret_type  { <type_name> }
    token type_var  { <type_name> }
    token ret_arrow { \-\-\> }
    rule  returns   { <ret_arrow> <ret_type> }
    
    # parse *@x and :$x and mark for slurpy/named
    token is_named    { <[:]> }
    token is_slurpy   { <[*]> }
    token prefix_mod  { [ <is_named> | <is_slurpy> ] }

    # parse $x! and $x? and mark for required/optional
    token is_optional  { <[?]> }
    token is_required  { <[!]> }
    token postfix_mod  { [ <is_optional> | <is_required> ] }

    # parse $^x and mark it as an implicit.  leave room for other twigils
    token is_implicit { <[^]> }
    token twigil      { <is_implicit> }

    # traits have the same rules for names as params
    token trait_name := param_name;
    token trait { is \s+ <trait_name> }
    
    # this allows specifying a type on a parameter, as well parameterizing that type.
    token dwigil    { [:]**{2} }
    rule type_param { <type> [ <dwigil> <type_var> ]? }

    # $x, $^x, $
    rule positional {
        [ <sigil> <twigil>? $<internal> := <external>? ]
    }

    # :$x, :x($y), :$, :$(x)
    rule named {
        <is_named>
        [
        | <sigil> $<internal> := <external>?
        | <open_group> <external>? <sigil> <twigil>? <internal> <close_group>
        ]
    }

    # [ $x, *@y ]
    # XXX how should unpacked params be accessed?  in $<unpacked>?
    #  in some cases they'll be aliased to something in $<positional|named>
    #  in other cases, they'll act as anonymous $<positional>
    rule unpacked {
        <open_group> <type_param>? <positional>+ <trait>* <slurpy>? <close_group>
    }
        
    rule param {
        <type_param>?
        [
        | <positional>
        | <named>
        | <unpacked>
        ]
        <postfix_mod>? <trait>* <default>*
    }
        
    # *@x
    # need to keep slurpies separate from other params because they have to come last
    rule slurpy {
        <type_param>? <is_slurpy> <positional>? <trait>* <default>?
    }

    # signature for a single dispatch routine
    rule single_sig {
        [ <param> <unpacked>? <close_param> ]* <slurpy>? <returns>?
    }

    # sig for multi dispatch routine
    rule multi_sig {
        <single_sig> [ <tie_break> <single_sig> ]* <tieBreak>?
        : { @single_sig[ *..+$<tiebreak> ]<is_invocant> >>++ } # thanks audreyt++
    }
}
