pX/Common/iterator_engine_README - fglock

Latest changes:
2006-03-02:
- started 'macro'
2006-03-01:
- precompiled Prelude - loads in < 1s
2006-02-26:
- working Perl 6 compiler - about 100 lines of code are now written in perl6
- started a Prelude
    say 'compiling Prelude';
    sub infix:<+> { eval(' $_[0] + $_[1] ', :lang<perl5>); }
- optimized rules - use Text::Balanced for implementing <literal> and <code>
- 124 tests for p6rule.pl
- note: spec change '$<>' to '$()' not applied yet

Experimental implementation of:
- a parser engine (iterator_engine.pl)
- a Perl6 'rule' parser and perl5 emitter (iterator_engine_p6rule.pl)
- a 'Perl6' parser and perl5 emitter (iterator_engine_p6grammar.pl)
- a Perl6 'grammar' grammar (iterator_engine_p6rule_grammar.p6)

Special thanks for the brainstorming sessions in #perl6:
- putter
- audreyt
- TimToady 

Bootstrapping:
- core rule engine - backtracking, function composition - in Perl 5
- Perl 6 rules in Perl 5 - reuse to write itself
- Perl 6 grammar in Perl 5 - reuse to write itself
- Perl 6 to Perl 5 translator (parse p6, emit p5) - reuse to write itself
- Perl 6 compiler written in p6

Plan sketch:
- rewrite the compiler in p6, and emit the whole compiler to p5
- try to reuse pugs tests

Current tasks:
- implement 'macro' and '<%hash>', in order to define 'if' as in S04-Statement parsing
- implement operator precedence
- migrate primitives from http://svn.openfoundry.org/pugs/src/Pugs/Prim.hs
- find out more about grammar bootstrapping and the parse/compile/run cycle and BEGIN/CHECK/INIT
- see TODO and XXX notes everywhere
- split Prelude into base-syntax and primitives
- fix Perl 6 syntax errors in Prelude - usage of $<>, ...

More tasks:
- use putter's Match.pm
- bind special variables $0, ...
- see also the 'not implemented' rule list below
- optimize infix:<+> to 'native +' when possible
- mixing boxed/unboxed types (there are several tools available - which one to use?)
- Perl 6 OO - which tools to use? - talk to stevan
- un-source-filter rule return blocks
- coroutines

Other interesting things to do (low priority):
- reimplement iterator_engine.pl in 
  - Javascript - I like the 'run in the browser' idea very much
  - Perl 6 - Perl 6 version could be started with a source filter, since the syntax used is very simple
  - Parrot - not so useful - Parrot already has PGE
- test the compiler in Perl 5.5x
- try out Smart::Comments
- move project to a new subdir and give it a name?
  Extract 'Changes' and 'TODO' from README (extract old Changes from svn)
- make rule/grammar a pluggable module (pack for CPAN?)
  how about "Perl6::Grammar", and reuse Parse::RecDescent API?
- make grammars inherit from Grammar; make grammars inheritable
- write an emitter that generates perl5 regexes (or dies)
- implement "Rule|Str" with caching in <$var> rule
- pluggable emitters
- emit Pugs-compatible YAML 
- import Pugs-generated YAML precompiled code
- regex options :w :perl5 ...

Possible difficult problems to fix (all untested):
- package-wide lexical variables (incremental compilation and execution doesn't work with lexicals)
- modifying the grammar from inside a block (incremental compilation is currently disabled inside blocks)
- clonable closures (needed for proper working lazy lists)

Namespaces:
  Grammar - the base grammar - defines <ws>, <digit> 
  RuleGrammar - the pattern matching grammar ???
  Perl6Grammar - the Perl6 grammar

About P6Grammar:

implemented:
  
  grammar  <name>;
  rule     <name> {...}
  say print warn die <list>;
  my our local    <var>;
  {...}
  eval( '1+1', :lang<perl5> );

half-implemented:

  sub <name> {...}   -- need more work on fixity and precedence
  push unshift   -- bootstrapped with source filter
  macro <name> () {...}

About the Rules:

implemented:

 . ? * + *? +? ??
 \char <ws> <word> literal
 $variable @variable
 <'literal'>
 [] 
 ()     
 <subrule>
 <?subrule>
 <!subrule>
 |
 <@var>    - special-cased for array-of-rule (but not Rule|Str)
 {code}    - non-capturing closure
           - with perl5 code
 { return code } - capturing closure
           - bootstrapped with source filter
 $var := (capture)  - capture aliasing
 $<> $/<>  - special variables can't be used inside a match, yet
 $/ 
 $<0> $<1>

implemented but untested:
 <other::rule>
 <$var>

not implemented:
 $/<0> $/<1>
 $/0 $/1
 $0 $1
 <"literal">
 ^ ^^ $ $$
 <unicode-class> <+unicode-class> <+unicode-class+unicode-class>
 <&var> 
 <%var>
 **{n..m}
 : :: :::   (commit)
 $var := [non-capture]
 $var := <rule>
 <(closure-assertion)> <{code-returns-rule}>
 <<character-class>> <[character-class]>
 :flag :flag() :flag[]
 lookahead lookbehind
 #comment\n
 \x0a \0123 ...
 <?ws>  -- optional whitespace ???
 &    
 <!abc> -- is this !<abc> or !abc ?
 \n \N

not sure if specified:
 'literal' "literal"
 <!n,m>  -- <!{n..m}> ???

See also:

- some existing Perl6 'grammar' grammars:
  ../../Grammars/rx_grammar.pm
  http://svn.perl.org/parrot/trunk/compilers/pge/P6Rule.grammar
