# NOW
- Some system to manage/collect StablePtrs, then Finalizers 
- Use Judy to implement Pugs IHash substitute.
- CollectionsM: complete the subset of MapM and uncomment/complete CollectionM.
- Refeable vs. HashIO => unify?

- Bug on HSIter stuff when use a lot of memory 
- Dummy/Refeable Bug: need to ask in #haskell

- Add malloc error check for BitSet/Judy1 (it uses JERR not PJERR).
- Other missing malloc error checking

? Find something other than WordPtr (ghc 6.5) that works in GHC stable

# NEXT
- Use ByteString (seems to be trivial with Stringable, just instantiate Stringable?)
- Better testing
- Discuss APIs
-- Data.HashTable
-- Implementations specific to unboxed values like Int and Double
-- Unbounded arrays: see Bulat work on this

- Document this work.
- Create a LICENSE file (I think BSD3) and put license info in the
  necessary files. Mention that John Meacham as original author (how?).
- Check for Language Shootout entries that could benefit from HsJudy,
  and take Shootout times for them.
- Remember to test RBR with HsJudy. =)


# THINGS TO CONSIDER

nice mail from Bulat:
http://www.haskell.org/pipermail/haskell-cafe/2006-May/015915.html

## API SUGGESTIONS

Bulat: "Judy implements _mutable_ array/map/set, so closest interfaces for your
lib will be MArray and HashTable. DiffArray is a general way to make IArray
(interface) on the base of MArray (interface), that is usable with any
datastructure implementing MArray interface"


## STABLEPTR POSSIBLE OVERHEAD

StablePtr is used to store references of Haskell objects in external
datastructures. Maybe GHC isn't very efficient dealing with a lot of
StablePtrs, if that's true three obvious ways are:
 - GHC 6.5/6 is better at this.
 - Turn GHC better at this (wow!).
 - Find another way to do it (without StablePtr).


## REEVALUATE BENEFITS?

> all Haskell software that uses common data structures like Maps and
> Arrays would benefit from a faster implementation

Bulat says "sorry, i don't think so. especially for Arrays ;)"

