# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;

package KindaPerl6::Visitor::Emit::Perl5Regex;
sub new { shift; bless {@_}, "KindaPerl6::Visitor::Emit::Perl5Regex" }
use KindaPerl6::Visitor::Emit::Perl5;

sub visit {
    my $self   = shift;
    my $List__ = \@_;
    my $node;
    do { $node = $List__->[0]; [$node] };
    $node->emit_perl5();
}

package Token;
sub new { shift; bless {@_}, "Token" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    (   Main::indent(
            (   'sub _rule_'
                    . (
                    $self->{name}
                        . (
                        ' {'
                            . (
                            Main::newline()
                                . (
                                'local $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                                    . (
                                    Main::newline()
                                        . (
                                        '$GLOBAL::_M2 = $GLOBAL::_M; ' . ( $self->{regex}->emit_perl5() . ( ' && do { ' . ( '$GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; ' . ( Main::newline() . ( '$GLOBAL::_M2 = $GLOBAL::_M }; ' . '} ' ) ) ) ) )
                                        )
                                    )
                                )
                            )
                        )
                    )
            )
            )
            . (
            '::DISPATCH(::DISPATCH($::'
                . (
                $KindaPerl6::Visitor::Emit::Perl5::current_compunit
                    . (
                    ',"HOW"),'
                        . (
                        '"add_method", '
                            . (
                            '::DISPATCH( $::Str, "new", "'
                                . (
                                $self->{name}
                                    . (
                                    '" ), '
                                        . (
                                        '::DISPATCH( $::Method, "new", '
                                            . (
                                            '{ code => '
                                                . (
                                                'sub { '
                                                    . (
                                                    'local $GLOBAL::_Class = shift; '
                                                        . (
                                                        'undef $GLOBAL::_M2; '
                                                            . (
                                                            'local $_ = ( ref($_) ? ::DISPATCH( $_, "Str" )->{_value} : $_ ); '
                                                                . (
                                                                'if ( _rule_'
                                                                    . (
                                                                    $self->{name}
                                                                        . (
                                                                        '() ) { '
                                                                            . (
                                                                            'Match::from_global_data( $GLOBAL::_M2 ); '
                                                                                . (
                                                                                '$MATCH = $GLOBAL::MATCH = pop @Match::Matches; '
                                                                                    . (
                                                                                    '} '
                                                                                        . (
                                                                                        'else { '
                                                                                            . ( '$MATCH = $GLOBAL::MATCH = Match->new(); ' . ( '} ' . ( '@Match::Matches = (); ' . ( 'return $MATCH; ' . ( '} ' . ( '} ' . ( '), ' . ')' ) ) ) ) ) ) )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
    );
}

package P5Token;
sub new { shift; bless {@_}, "P5Token" }

sub rx {
    my $List__ = \@_;
    my $s;
    do { $s = $List__->[0]; [$s] };
    ( '/\G' . ( $s . '/g' ) );
}

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    P5Token::rx( $self->{regex} );
}

package Rule::Quantifier;
sub new { shift; bless {@_}, "Rule::Quantifier" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die('TODO');
    ( $self->{term}->emit_perl5() . ( $self->{quant} . $self->{greedy} ) );
}

package Rule::Or;
sub new { shift; bless {@_}, "Rule::Or" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'do{ my $_pos = pos(); ( ' . ( Main::join( [ map { $_->emit_perl5() } @{ $self->{or} } ], ' ) || ( ( pos($_pos) || 1 ) && ' ) . ' ) }' ) );
}

package Rule::Concat;
sub new { shift; bless {@_}, "Rule::Concat" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '( ' . ( Main::join( [ map { $_->emit_perl5() } @{ $self->{concat} } ], ' && ' ) . ' )' ) );
}

package Rule::Var;
sub new { shift; bless {@_}, "Rule::Var" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die('TODO');
    my $table = { '$' => '$', '@' => '$List_', '%' => '$Hash_', '&' => '$Code_', };
    ( $table->{ $self->{sigil} } . $self->{name} );
}

package Rule::Constant;
sub new { shift; bless {@_}, "Rule::Constant" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $str = $self->{constant};
    do {
        if   ( ( $str eq ' ' ) ) { return ( P5Token::rx('\\ ') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '...' ) ) { return ( P5Token::rx('\\.\\.\\.') ) }
        else                       { }
    };
    do {
        if   ( ( $str eq '#' ) ) { return ( P5Token::rx('\\#') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '$' ) ) { return ( P5Token::rx('\\$') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '$<' ) ) { return ( P5Token::rx('\\$<') ) }
        else                      { }
    };
    do {
        if   ( ( $str eq '@' ) ) { return ( P5Token::rx('\\@') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '%' ) ) { return ( P5Token::rx('\\%') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '?' ) ) { return ( P5Token::rx('\\?') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '+' ) ) { return ( P5Token::rx('\\+') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '*' ) ) { return ( P5Token::rx('\\*') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '??' ) ) { return ( P5Token::rx('\\?\\?') ) }
        else                      { }
    };
    do {
        if   ( ( $str eq '++' ) ) { return ( P5Token::rx('\\+\\+') ) }
        else                      { }
    };
    do {
        if   ( ( $str eq '**' ) ) { return ( P5Token::rx('\\*\\*') ) }
        else                      { }
    };
    do {
        if   ( ( $str eq '(' ) ) { return ( P5Token::rx('\\(') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq ')' ) ) { return ( P5Token::rx('\\)') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '[' ) ) { return ( P5Token::rx('\\[') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq ']' ) ) { return ( P5Token::rx('\\]') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '{' ) ) { return ( P5Token::rx('\\{') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '}' ) ) { return ( P5Token::rx('\\}') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '/' ) ) { return ( P5Token::rx('\\/') ) }
        else                     { }
    };
    do {
        if   ( ( $str eq '\\' ) ) { return ( P5Token::rx('\\\\') ) }
        else                      { }
    };
    do {
        if   ( ( $str eq '\'' ) ) { return ( P5Token::rx('\\\'') ) }
        else                      { }
    };
    P5Token::rx($str);
}

package Rule::Dot;
sub new { shift; bless {@_}, "Rule::Dot" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    P5Token::rx('(?:\n\r?|\r\n?|\X)');
}

package Rule::SpecialChar;
sub new { shift; bless {@_}, "Rule::SpecialChar" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $char = $self->{char};
    do {
        if   ( ( $char eq 'n' ) ) { return ( P5Token::rx('(?:\n\r?|\r\n?)') ) }
        else                      { }
    };
    do {
        if   ( ( $char eq 'N' ) ) { return ( P5Token::rx('(?:(?!\n\r?|\r\n?)\X)') ) }
        else                      { }
    };
    do {
        if   ( ( $char eq '\\' ) ) { return ( P5Token::rx('\\\\') ) }
        else                       { }
    };
    do {
        if   ( ( $char eq '\'' ) ) { return ( P5Token::rx('\\\'') ) }
        else                       { }
    };
    return ( P5Token::rx( ( '\\' . $char ) ) );
}

package Rule::Block;
sub new { shift; bless {@_}, "Rule::Block" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    (   'do { '
            . (
            'local $GLOBAL::_M = [ $GLOBAL::_M, "to", pos() ]; '
                . (
                Main::newline()
                    . (
                    'Match::from_global_data( $GLOBAL::_M ); '
                        . (
                        Main::newline()
                            . (
                            '$MATCH = '
                                . (
                                '$GLOBAL::MATCH = pop @Match::Matches; '
                                    . (
                                    Main::newline()
                                        . (
                                        '@Match::Matches = (); '
                                            . (
                                            Main::newline()
                                                . (
                                                $self->{closure}->emit_perl5()
                                                    . (
                                                    '; '
                                                        . (
                                                        'if ( ::DISPATCH( $GLOBAL::Code_defined, "APPLY", $GLOBAL::_REGEX_RETURN_ )->{_value} ) { '
                                                            . ( '$GLOBAL::_M = [ [ @$GLOBAL::_M ], "result", ::DISPATCH( $GLOBAL::_REGEX_RETURN_, "FETCH" ) ]; ' . ( '}' . ' 1 }' ) )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
    );
}

package Rule::InterpolateVar;
sub new { shift; bless {@_}, "Rule::InterpolateVar" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die( ( '# TODO: interpolate var ' . ( $self->{var}->emit_perl5() . '' ) ) );
}

package Rule::After;
sub new { shift; bless {@_}, "Rule::After" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( ( $self->{assertion_modifier} eq '!' ) ) { return ( ( '(?<!' . ( $self->{rule}->emit_perl5() . ')' ) ) ) }
        else                                          { }
    };
    do {
        if ( ( $self->{assertion_modifier} eq '?' ) ) { return ( ( '(?<=' . ( $self->{rule}->emit_perl5() . ')' ) ) ) }
        else                                          { }
    };
    do {
        if ( $self->{capture_to_array} ) {
            (   '(?<='
                    . (
                    '(?{ '
                        . (
                        'local $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                            . ( '})' . ( $self->{rule}->emit_perl5() . ( '(?{ ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, "named_capture_to_array", "after" ]; ' . ( '})' . ')' ) ) ) ) ) )
                        )
                    )
            );
        }
        else {
            (   '(?<='
                    . (
                    '(?{ '
                        . (
                        'local $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                            . ( '})' . ( $self->{rule}->emit_perl5() . ( '(?{ ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, "named_capture", "after" ]; ' . ( '})' . ')' ) ) ) ) ) )
                        )
                    )
            );
        }
        }
}

package Rule::Before;
sub new { shift; bless {@_}, "Rule::Before" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( ( $self->{assertion_modifier} eq '!' ) ) { return ( ( 'do { local $GLOBAL::_M; my $_pos = pos(); my $_res = ' . ( $self->{rule}->emit_perl5() . '; pos($_pos); !$res } ' ) ) ) }
        else                                          { }
    };
    do {
        if ( ( $self->{assertion_modifier} eq '?' ) ) { return ( ( 'do { local $GLOBAL::_M; my $_pos = pos(); my $_res = ' . ( $self->{rule}->emit_perl5() . '; pos($_pos); $res } ' ) ) ) }
        else                                          { }
    };
    do {
        if ( $self->{capture_to_array} ) {
            (   '(?='
                    . (
                    '(?{ '
                        . (
                        'local $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                            . ( '})' . ( $self->{rule}->emit_perl5() . ( '(?{ ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; ' . ( 'local $GLOBAL::_M = [ $GLOBAL::_M, "named_capture_to_array", "before" ]; ' . ( '})' . ')' ) ) ) ) ) )
                        )
                    )
            );
        }
        else {
            (   'do { my $_bak = $GLOBAL::_M; my $_pos = pos(); '
                    . (
                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                        . (
                        ' if ('
                            . (
                            $self->{rule}->emit_perl5()
                                . (
                                ') {'
                                    . (
                                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; '
                                        . ( ' $GLOBAL::_M = [ $GLOBAL::_M, "named_capture", "before" ]; pos($_pos);' . ( ' }' . ( ' else {' . ( ' $GLOBAL::_M = $_bak; pos($_pos);' . ( '   0 }' . ( ' }' . ' }' ) ) ) ) ) )
                                    )
                                )
                            )
                        )
                    )
            );
        }
        }
}

package Rule::NegateCharClass;
sub new { shift; bless {@_}, "Rule::NegateCharClass" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    Main::say('TODO NegateCharClass');
    die();
}

package Rule::CharClass;
sub new { shift; bless {@_}, "Rule::CharClass" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    Main::say('TODO CharClass');
    die();
}

package Rule::SubruleNoCapture;
sub new { shift; bless {@_}, "Rule::SubruleNoCapture" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $meth = Main::mangle_perl5rx_metasyntax( $self->{metasyntax} );
    ( 'do { local $GLOBAL::_M; ' . ( $meth . ( '()' . ' }' ) ) );
}

package Rule::Subrule;
sub new { shift; bless {@_}, "Rule::Subrule" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $meth = Main::mangle_perl5rx_metasyntax( $self->{metasyntax} );
    do {
        if   ( $self->{capture_to_array} ) { ( '( ' . ( $meth . ( '() && ' . ( '( $GLOBAL::_M = [ $GLOBAL::_M, "named_capture_to_array", "' . ( $self->{metasyntax} . ( '" ] )' . ') ' ) ) ) ) ) ) }
        else                               { ( '( ' . ( $meth . ( '() && ' . ( '( $GLOBAL::_M = [ $GLOBAL::_M, "named_capture", "' .          ( $self->{metasyntax} . ( '" ] )' . ') ' ) ) ) ) ) ) }
        }
}

package Rule::NamedCapture;
sub new { shift; bless {@_}, "Rule::NamedCapture" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( $self->{capture_to_array} ) {
            (   'do { my $_bak = $GLOBAL::_M; '
                    . (
                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                        . (
                        ' if ('
                            . (
                            $self->{rule}->emit_perl5()
                                . (
                                ') {'
                                    . (
                                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; '
                                        . ( ' $GLOBAL::_M = [ $GLOBAL::_M, "named_capture_to_array", "' . ( $self->{ident} . ( '" ]; ' . ( ' }' . ( ' else {' . ( ' $GLOBAL::_M = $_bak; ' . ( '   0 }' . ( ' }' . ' }' ) ) ) ) ) ) ) )
                                    )
                                )
                            )
                        )
                    )
            );
        }
        else {
            (   'do { my $_bak = $GLOBAL::_M; '
                    . (
                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                        . (
                        ' if ('
                            . (
                            $self->{rule}->emit_perl5()
                                . (
                                ') {'
                                    . (
                                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; '
                                        . ( ' $GLOBAL::_M = [ $GLOBAL::_M, "named_capture", "' . ( $self->{ident} . ( '" ]; ' . ( ' }' . ( ' else {' . ( ' $GLOBAL::_M = $_bak; ' . ( '   0 }' . ( ' }' . ' }' ) ) ) ) ) ) ) )
                                    )
                                )
                            )
                        )
                    )
            );
        }
        }
}

package Rule::Capture;
sub new { shift; bless {@_}, "Rule::Capture" }

sub emit_perl5 {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( $self->{capture_to_array} ) {
            (   'do { my $_bak = $GLOBAL::_M; '
                    . (
                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                        . (
                        ' if ('
                            . (
                            $self->{rule}->emit_perl5()
                                . (
                                ') {'
                                    . (
                                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; '
                                        . ( ' $GLOBAL::_M = [ $GLOBAL::_M, "positional_capture_to_array", ' . ( $self->{position} . ( ' ]; ' . ( ' }' . ( ' else {' . ( ' $GLOBAL::_M = $_bak; ' . ( '   0 }' . ( ' }' . ' }' ) ) ) ) ) ) ) )
                                    )
                                )
                            )
                        )
                    )
            );
        }
        else {
            (   'do { my $_bak = $GLOBAL::_M; '
                    . (
                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'create\', pos(), \\$_ ]; '
                        . (
                        ' if ('
                            . (
                            $self->{rule}->emit_perl5()
                                . (
                                ') {'
                                    . (
                                    ' $GLOBAL::_M = [ $GLOBAL::_M, \'to\', pos() ]; '
                                        . ( ' $GLOBAL::_M = [ $GLOBAL::_M, "positional_capture", ' . ( $self->{position} . ( ' ]; ' . ( ' }' . ( ' else {' . ( ' $GLOBAL::_M = $_bak; ' . ( '   0 }' . ( ' }' . ' }' ) ) ) ) ) ) ) )
                                    )
                                )
                            )
                        )
                    )
            );
        }
        }
}

1;
