Getting rid of the C stack in YAP6
=====================================================================

At first, a question must be made, which is "why do I need to get rid
of the C stack"? The answer resides in the Perl 6 feature set, more
than anything else. My inspiration on this is the stackless python
project (which was not adopted by the mainstream python) because it
makes the support for continuations and co-routines much easier. It
would be possible to implement it using the C stack, but this would
require mixing the manipulation of the C stack with the manipulation
of the Perl 6 stack, which may be very complex. Let's think about the
gather/take operators. They may be called from a very deep level of
the stack. Mixing that with interpreted code and the C stack would be
very much complex.

The solution would be to simply remove the C stack from the
story. This would make a single frame stack to exist, and considering
it's separated from the C stack, it's more easily manipulated. But how
to implement a simple stackless C code that supports that? The
solution is actually quite simple and is completely inspired in the
stackless project. The key thing is, instead of calling a function,
you just prepare it by putting it on top of the stack. The "machine"
runs by popping the message from the stack and calling it. The
difference here is that: if this call would call another message,
instead of calling it directly, it push the call to the stack and
returns immediatly. The "machine" would again pop from the stack and
now it would call the deeper method, having the Perl stack complete
but without feeding the C stack. Simple as:


YAP6__Object* stack = YAP6__STACK__Stack__Init();

// populate the stack here
YAP6__STACK__Stack__Push(stack, node);
// add a continuation to the top-most frame
YAP6__STACK__Stack__Continue(stack, node);

for (;;) {
    if (YAP6__STACK__Stack__IsEmpty(stack) {
       break;
    }
    YAP6__STACK__Stack_Next(stack);
    YAP6__STACK__Stack_Eval(stack);
}
YAP6_RELEASE(current_stack);

Not all frames will represent a lexical scope, but the lexical scopes
will be referenced from the stack, in a way that scope destructions
happens naturally once the frame is dropped. The same happens with
exeption handling and debug information. Any frame may contain debug
information about source and line number, as well as can mark a jail
for exeptions. The die code would simply pop the stack until it finds
a jail. Coroutines could simply keep a reference of the current frame
node (with the continuation reference) just before popping.

The YAP6 stack API would be:

YAP6__INTERNAL__Stack__Node* is the object of one message. It should
be a YAP6__Object and should have the following information:

 * metaclass: the metaclass that handles the message.
 * identifier: the message string identifier (probably the method
                 name).
 * capture: the arguments for this message, a Capture object.
 * outer: the outer stack frame to which this call should return.
 * result: if defined, this node has already been executed and references
                 the return value for it.
 * continuation: if defined, this references the continuation for this
                 node.
 * past: this defines the node that was continued by the current node.
 * debug: any debug information like source file name and line
                 number.
 * jail: if set, this is a stop point for an exception.
 * lexical: a reference to the lexical scope to which this frame 
                 points to.

YAP6__INTERNAL__Stack* is the object that holds the reference to the
top-most node. It's important that this should not be global, so we
can have different threads starting from any point and exiting after
an "async" block.


The methods would be

 * YAP6__INTERNAL__Stack__Init(): this would initialize an empty stack.
 * YAP6__INTERNAL__Stack__Push(stack, node):
                 push a message to the top of the stack.
 * YAP6__INTERNAL__Stack__Continue(stack,node):
                 add a message as a continuation for the top message.
 * YAP6__INTERNAL__Stack__Next(stack): returns the next message on the
                 stack, obeying continuations.
 * YAP6__INTERNAL__Stack__Eval(stack): Evaluate the top-most node.
 * YAP6__INTERNAL__Stack__Drop(stack): drop the top-most frame, ignoring
                 continuations (exceptions and coroutines).
 * YAP6__INTERNAL__Stack__Invoke(stack, message): Invokes a message that
                 is not in the stack anymore. This message may manipulate
                 the stack.


It is important to remember, however that all the objects referenced
here are also YAP6__Object. And the frame stack may be exposed to the
high-level language. A new stack may even be built in high-level
language and dispatched.


Stack navigation:

 <- means a "past" link
 -> means a "continuation" link
 |  means an "outer" link (from the upper to the lower)
 *  means the selected node for evaluation.

                          *
                1 <- 2 <- 3 -> 4 -> 5                  Frame 3
                          |
                1 <- 2 <- 3 -> 4 -> 5 -> 6             Frame 2
                          |
           1 <- 2 <- 3 <- 4 -> 5 -> 6 -> 7             Frame 1

This basically means that when a node is selected the links are
changed from:

            *
  1 <- 2 <- 3 -> 4 -> 5 -> 6
            |

to:

                 *
  1 <- 2 <- 3 <- 4 -> 5 -> 6
                 |

Where the stack has only a reference to the selected node.

One important point here is that the objects are destroyed when the
frame is destroyed, and the frame is subject to garbage
collection. This also means that when the frame is saved in some
variable, it won't be destroyed. You probably realised how easy it is
to implement co-routines with that.

Continuations may be easily implemented also, as it would mean
dropping and pushing a frame from the same node:

              original               continuation
                                          *
            1 <- 2 <- 3 (destroied)  1 <- 2 -> 3             Frame 2
                                          |
  1 <- 2 <- (3 ... ... ...  ... ... ... ...) -> 4 -> 5 -> 6  Frame 1
