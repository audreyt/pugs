# Generated by v6 0.015 (Module::Compile 0.20) - do not edit!
################((( 32-bit Checksum Validator III )))################
#line 1
BEGIN { use 5.006; local (*F, $/); ($F = __FILE__) =~ s!c$!!; open(F)
or die "Cannot open $F: $!"; binmode(F, ':crlf'); if (unpack('%32N*',
$F=readline(*F)) != 0x5C8A00D9) { use Filter::Util::Call; my $f = $F;
filter_add(sub { filter_del(); 1 while &filter_read; $_ = $f; 1; })}}
#line 1
package main;
use Config;
use lib split( /\Q$Config{path_sep}/, $ENV{PERL6LIB} || '' );
use Scalar::Util;
use Pugs::Runtime::Perl6;
use Pugs::Runtime::Perl6Prelude;
use Pugs::Runtime::Perl5Container;
use base 'Pugs::Grammar::Base';
use strict;
no strict 'refs';
no warnings( 'void', 'uninitialized' );
$::_V6_COMPILER_OS      = 'MSWin32';
$::_V6_COMPILER_NAME    = 'v6.pm';
$::_V6_COMPILER_VERSION = '0.015';
undef $::_V6_MATCH_;
my %_V6_PAD;
our %_V6_STATE;

# use v6-alpha
package MiniPerl6::Grammar;
use Pugs::Compiler::Rule;
use Moose;
use base 'Pugs::Grammar::Base';
no strict 'refs';
use Exporter 'import';
push our @ISA, 'Exporter';
our @EXPORT;
bool->import();    # True, False

sub CompUnit {
  my %_V6_PAD;
  my ($data);
  Data::Bind->arg_bind( \@_ );
  bless $data, 'CompUnit';

}
## Signature for CompUnit
Data::Bind->sub_signature( \&CompUnit, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '$data' } );

sub Var {
  my %_V6_PAD;
  my ($data);
  Data::Bind->arg_bind( \@_ );
  bless $data, 'Var';

}
## Signature for Var
Data::Bind->sub_signature( \&Var, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '$data' } );

sub array {
  my %_V6_PAD;
  my ($data);
  Data::Bind->arg_bind( \@_ );
  @$data;

}
## Signature for array
Data::Bind->sub_signature( \&array, { 'attribute' => [], 'is_slurpy' => '', 'named_only' => '', 'optional' => '', 'type' => undef, 'var' => '$data' } );
*comp_unit = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'c' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'l' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 'a' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 's' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            ( substr( $s, $pos, 1 ) eq 's' ) ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              $named{'ident'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
              ( substr( $s, $pos, 1 ) eq '{' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && (
              ( substr( $s, $pos, 1 ) eq '}' )
            ? ( $pos += 1 or 1 )
            : 0
          )
          && (
            do {
              my $prior = $::_V6_PRIOR_;
              my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
              $::_V6_PRIOR_ = $prior;
              my $bool = ( !$match != 1 );
              $pos = $match->to if $bool;
              $match;
            }
            || ( $bool = 1 )
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( CompUnit( [ \( { 'name' => $::_V6_MATCH_->{'ident'}, 'attributes' => {}, 'methods' => {}, 'body' => {} }, ) ], {} ) );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for comp_unit
Data::Bind->sub_signature( \&comp_unit, );
*control = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1857} = $pos or 1 )
            && (
              do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->call( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->apply( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->return( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->leave( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->if( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->when( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->for( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1857} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->while( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( ${ $::_V6_MATCH_->{'exp'} } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for control
Data::Bind->sub_signature( \&control, );
*val = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1858} = $pos or 1 )
            && (
              do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_undef( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1858} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_object( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1858} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_int( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1858} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_bit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1858} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_num( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1858} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val_buf( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( ${ $::_V6_MATCH_->{'exp'} } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for val
Data::Bind->sub_signature( \&val, );
*exp_seq = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->exp( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              $named{'exp'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && (
            ( $pad{I1859} = $pos or 1 )
            && (
              (
                (
                  do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                )
                && (
                    ( substr( $s, $pos, 1 ) eq ',' )
                  ? ( $pos += 1 or 1 )
                  : 0
                )
                && (
                  do {
                    my $prior = $::_V6_PRIOR_;
                    my $match = $grammar->ws( $s, { p => $pos, args => {} }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = ( !$match != 1 );
                    $pos = $match->to if $bool;
                    $match;
                  }
                  || ( $bool = 1 )
                )
                && do {
                  my $prior = $::_V6_PRIOR_;
                  my $match = $grammar->exp_seq( $s, { p => $pos, args => {} }, undef );
                  $::_V6_PRIOR_ = $prior;
                  if ($match) {
                    $named{'exp_seq'} = $match;
                    $pos = $match->to;
                    1;
                  }
                  else { 0 }
                }
                && do {
                  $::_V6_MATCH_ = $m;
                  local $::_V6_SUCCEED = 1;
                  $m->data->{capture} = \(
                    sub {
                      return ( [ ${ $::_V6_MATCH_->{'exp'} }, array( [ \( ${ $::_V6_MATCH_->{'exp_seq'} }, ) ], {} ) ] );
                      }
                      ->()
                  );
                  $bool = $::_V6_SUCCEED;
                  $::_V6_MATCH_ = $m if $bool;
                  return $m if $bool;
                }
              )
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1859} ) or 1 )
              && do {
                $::_V6_MATCH_ = $m;
                local $::_V6_SUCCEED = 1;
                $m->data->{capture} = \(
                  sub {
                    return ( [ ${ $::_V6_MATCH_->{'exp'} } ] );
                    }
                    ->()
                );
                $bool = $::_V6_SUCCEED;
                $::_V6_MATCH_ = $m if $bool;
                return $m if $bool;
              }
            )
          )
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for exp_seq
Data::Bind->sub_signature( \&exp_seq, );
*exp = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          (
            ( $pad{I1860} = $pos or 1 )
            && (
              do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->var( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->val( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->lit( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->bind( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->index( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->lookup( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
            || (
              ( ( $bool = 1 ) && ( $pos = $pad{I1860} ) or 1 )
              && do {
                my $prior = $::_V6_PRIOR_;
                my $match = $grammar->control( $s, { p => $pos, args => {} }, undef );
                $::_V6_PRIOR_ = $prior;
                if ($match) {
                  $named{'exp'} = $match;
                  $pos = $match->to;
                  1;
                }
                else { 0 }
              }
            )
          )
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( ${ $::_V6_MATCH_->{'exp'} } );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for exp
Data::Bind->sub_signature( \&exp, );
*var = do {
  my $rule;
  $rule = sub {

    $_[3] = $_[2];
    $_[2] = undef;
    my $grammar = $_[0];
    my $s       = $_[1];
    no warnings 'substr', 'uninitialized', 'syntax';
    my %pad;
    my $m;
    for my $pos (
      defined $_[3]{p} && !$_[3]{continue}
      ? $_[3]{p}
      : ( ( $_[3]{p} || 0 ) .. length($s) )
      )
    {
      my %index;
      my @match;
      my %named;
      my $bool = 1;
      $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
      $m = Pugs::Runtime::Match->new(
        {
          str     => \$s,
          from    => \( 0 + $pos ),
          to      => \($pos),
          bool    => \$bool,
          match   => \@match,
          named   => \%named,
          capture => undef,
        }
      );
      {
        my $prior = $::_V6_PRIOR_;
        local $::_V6_PRIOR_ = $prior;
        $bool = 0
          unless (
          do {
            my $from = $pos;
            my $bool = (
                ( substr( $s, $pos ) =~ m/^([\$\%\@\&])/ )
              ? ( $pos += length($1) or 1 )
              : 0
            );
            my $match = Pugs::Runtime::Match->new( { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \( 0 + $pos ), capture => undef } );
            $named{'sigil'} = $match;
            $bool;
          }
          && do {
            my $from = $pos;
            my $bool = (
              ( $pad{I1861} = $pos or 1 )
                && (
                (
                    ( substr( $s, $pos ) =~ m/^([\.\!\^])/ )
                  ? ( $pos += length($1) or 1 )
                  : 0
                )
                )
                || (
                ( ( $bool = 1 ) && ( $pos = $pad{I1861} ) or 1 )
                && 1    # null constant

                )
            );
            my $match = Pugs::Runtime::Match->new( { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \( 0 + $pos ), capture => undef } );
            $named{'twigil'} = $match;
            $bool;
          }
          && do {
            my $prior = $::_V6_PRIOR_;
            my $match = $grammar->ident( $s, { p => $pos, args => {} }, undef );
            $::_V6_PRIOR_ = $prior;
            if ($match) {
              $named{'ident'} = $match;
              $pos = $match->to;
              1;
            }
            else { 0 }
          }
          && do {
            $::_V6_MATCH_ = $m;
            local $::_V6_SUCCEED = 1;
            $m->data->{capture} = \(
              sub {
                return ( Var( [ \( { 'sigil' => "" . $::_V6_MATCH_->{'sigil'}, 'twigil' => "" . $::_V6_MATCH_->{'twigil'}, 'name' => "" . $::_V6_MATCH_->{'ident'} }, ) ], {} ) );
                }
                ->()
            );
            $bool = $::_V6_SUCCEED;
            $::_V6_MATCH_ = $m if $bool;
            return $m if $bool;
          }
          );
      }
      if ($bool) {
        my $prior = $::_V6_PRIOR_;
        $::_V6_PRIOR_ = sub {
          local $main::_V6_PRIOR_ = $prior;
          $rule->(@_);
        };
        last;
      }
    }    # /for
    $::_V6_MATCH_ = $m;
    return $m;
    }
};    ## Signature for var
Data::Bind->sub_signature( \&var, );

1;
