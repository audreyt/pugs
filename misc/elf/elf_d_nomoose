#!/usr/bin/perl -w
package main;
use Data::Dumper; # Used to render Buf strings.
use Perl6::Say;
use autobox; use autobox::Core; use autobox UNDEF => "UNDEF";
{package AssertCurrentModuleVersions;
 use autobox 2.23;
 use autobox::Core 0.4;
}
{package NoSideEffects; use Class::Multimethods;}


{package Object;
    sub new {
        my $self = shift;
        my $class = ref $self || $self;
        if (ref $_[0] eq "HASH") {
            bless {%{$_[0]}}, $class;
        } else {
            bless {@_}, $class;
        }
    }
}


our $a_ARGS = [@ARGV];

{package UNDEF;}
{package UNDEF; sub ref{"UNDEF"}}
{package UNIVERSAL; sub ref{CORE::ref($_[0]) || "SCALAR"} }
{package UNIVERSAL; sub WHAT{CORE::ref($_[0]) || "SCALAR"} }

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; my $s = `cat $file`; $s}
sub unslurp{
  my($text,$file)=@_; open(F,">$file") or CORE::die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{CORE::system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{CORE::exit(@_)}
sub ::defined{CORE::defined($_[0])}
sub ::substr ($$$){CORE::substr($_[0],$_[1],$_[2])}
sub ::not ($){CORE::not $_[0]}
sub ::exec{CORE::exec(@_)}
sub ::sleep{CORE::sleep(@_)}

# because the p5->p6 massage of ast_handlers isnt massaging join.
sub ::join{CORE::join(CORE::shift,@_)}
# end

{ package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}
}

{ package ARRAY;
# absent from autobox::Core
sub splice { my $a = CORE::shift; [CORE::splice(@{$a},$_[0],$_[1])] }
sub copy { my $a = CORE::shift; [@$a] }
# buggy in autobox::Core
BEGIN{my $x = *ARRAY::unshift; undef &$x;}
sub unshift (\@;@) { my $a = CORE::shift; CORE::unshift(@$a, @_); $a; }
}
{ package HASH;
  sub dup { my $h = CORE::shift; my $h1 = {%$h}; $h1 }
}

sub parser_name{
  my $f = $0;
  $f =~ s/[^\/]+$//;
  $f."../STD_red/STD_red_run"
}

our $a_INC = ["."];
sub ::require {
  my($module)=@_;
  my $file = find_required_module($module);
  $file || CORE::die "Cant locate $module in ( ".CORE::join(" ",@$a_INC)." ).\n";
  eval_file($file);
};
sub ::find_required_module {
  my($module)=@_;
  my @names = ($module,$module.".pm",$module.".p6");
  for my $dir (@$a_INC) {
    for my $name (@names) {
      my $file = $dir."/".$name;
      if(-f $file) {
        return $file;
      }
    }
  }
  return undef;
}

our $compiler0;
our $compiler1;
our $parser0;
our $parser1;
our $emitter0;
our $emitter1;
sub ::eval_file {
  my($file)=@_;
  $compiler0->eval_file($file);
}
sub ::eval_perl6 {
  my($code)=@_;
  $compiler0->eval_perl6($code);
}

package main;

package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package Match;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub rule {
  if (@_ == 2) {
      $_[0]{'rule'} = $_[1];
 } else {
     $_[0]{'rule'};
  }
}
;
sub str {
  if (@_ == 2) {
      $_[0]{'str'} = $_[1];
 } else {
     $_[0]{'str'};
  }
}
;
sub from {
  if (@_ == 2) {
      $_[0]{'from'} = $_[1];
 } else {
     $_[0]{'from'};
  }
}
;
sub to {
  if (@_ == 2) {
      $_[0]{'to'} = $_[1];
 } else {
     $_[0]{'to'};
  }
}
;
sub hash {
  if (@_ == 2) {
      $_[0]{'hash'} = $_[1];
 } else {
     $_[0]{'hash'};
  }
}
;
sub make_from_rsfth{my $self=CORE::shift;my($r,$s,$f,$t,$h)=@_;
my $init = {'rule', $r, 'str', $s, 'from', $f, 'to', $t, 'hash', $h};
$self->new($init)};
sub match_describe{my $self=CORE::shift;my $s = ((((((($self->rule . '<') . $self->from) . ',') . $self->to) . ',\'') . $self->str) . '\',{');
for($self->hash->keys()->flatten){
my $k = $_;
my $v = $self->hash->{$k};
my $vs = 'undef';
if(::defined($v)) {
($vs = $v->match_describe())
};
($s = ((((($s . '
  ') . $k) . ' => ') . $self->indent_except_top($vs)) . ','))
};
if($self->hash->keys()->elems()) {
($s = ($s . '
'))
};
($s = ($s . '}>'))};
sub indent{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?!\Z))/, '  ')};
sub indent_except_top{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?<!\A)(?!\Z))/, '  ')};
sub match_string{my $self=CORE::shift;$self->str}
}
;

{ package ARRAY;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub match_describe{my $self=CORE::shift;((('[
' . Match->indent($self->map(sub {my($e)=@_;
$e->match_describe()})->join(',
'))) . '
]'))}
}
;

{ package SCALAR;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub match_describe{my $self=CORE::shift;(('\'' . $self) . '\'')}
}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package ARRAY;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub irx1_describe{my $self=CORE::shift;(('[' . $self->map(sub {my($e)=@_;
$e->irx1_describe()})->join(',')) . ']')}
}
;

{ package SCALAR;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub irx1_describe{my $self=CORE::shift;($self . '')}
}
;

{ package UNDEF;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub irx1_describe{my $self=CORE::shift;'undef'}
}
;

{ package IRx1;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package IRx1::Base;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

}
;

{ package IRx1::CompUnit;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub statements {
  if (@_ == 2) {
      $_[0]{'statements'} = $_[1];
 } else {
     $_[0]{'statements'};
  }
}
;
sub filename {
  if (@_ == 2) {
      $_[0]{'filename'} = $_[1];
 } else {
     $_[0]{'filename'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$statements,$filename)=@_;
$self->new('match', $match, 'statements', $statements, 'filename', $filename)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__CompUnit($self)};
sub node_name{my $self=CORE::shift;'CompUnit'};
sub field_names{my $self=CORE::shift;['statements', 'filename']};
sub field_values{my $self=CORE::shift;[$self->statements, $self->filename]};
sub irx1_describe{my $self=CORE::shift;(((('CompUnit(' . $self->statements->irx1_describe()) . ',') . $self->filename->irx1_describe()) . ')')}
}
;

{ package IRx1::Block;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub statements {
  if (@_ == 2) {
      $_[0]{'statements'} = $_[1];
 } else {
     $_[0]{'statements'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
$self->new('match', $match, 'statements', $statements)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Block($self)};
sub node_name{my $self=CORE::shift;'Block'};
sub field_names{my $self=CORE::shift;['statements']};
sub field_values{my $self=CORE::shift;[$self->statements]};
sub irx1_describe{my $self=CORE::shift;(('Block(' . $self->statements->irx1_describe()) . ')')}
}
;

{ package IRx1::Use;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub kind {
  if (@_ == 2) {
      $_[0]{'kind'} = $_[1];
 } else {
     $_[0]{'kind'};
  }
}
;
sub module_name {
  if (@_ == 2) {
      $_[0]{'module_name'} = $_[1];
 } else {
     $_[0]{'module_name'};
  }
}
;
sub expr {
  if (@_ == 2) {
      $_[0]{'expr'} = $_[1];
 } else {
     $_[0]{'expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$kind,$module_name,$expr)=@_;
$self->new('match', $match, 'kind', $kind, 'module_name', $module_name, 'expr', $expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Use($self)};
sub node_name{my $self=CORE::shift;'Use'};
sub field_names{my $self=CORE::shift;['kind', 'module_name', 'expr']};
sub field_values{my $self=CORE::shift;[$self->kind, $self->module_name, $self->expr]};
sub irx1_describe{my $self=CORE::shift;(((((('Use(' . $self->kind->irx1_describe()) . ',') . $self->module_name->irx1_describe()) . ',') . $self->expr->irx1_describe()) . ')')}
}
;

{ package IRx1::PackageDecl;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub scope {
  if (@_ == 2) {
      $_[0]{'scope'} = $_[1];
 } else {
     $_[0]{'scope'};
  }
}
;
sub plurality {
  if (@_ == 2) {
      $_[0]{'plurality'} = $_[1];
 } else {
     $_[0]{'plurality'};
  }
}
;
sub kind {
  if (@_ == 2) {
      $_[0]{'kind'} = $_[1];
 } else {
     $_[0]{'kind'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$scope,$plurality,$kind,$name,$traits,$block)=@_;
$self->new('match', $match, 'scope', $scope, 'plurality', $plurality, 'kind', $kind, 'name', $name, 'traits', $traits, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__PackageDecl($self)};
sub node_name{my $self=CORE::shift;'PackageDecl'};
sub field_names{my $self=CORE::shift;['scope', 'plurality', 'kind', 'name', 'traits', 'block']};
sub field_values{my $self=CORE::shift;[$self->scope, $self->plurality, $self->kind, $self->name, $self->traits, $self->block]};
sub irx1_describe{my $self=CORE::shift;(((((((((((('PackageDecl(' . $self->scope->irx1_describe()) . ',') . $self->plurality->irx1_describe()) . ',') . $self->kind->irx1_describe()) . ',') . $self->name->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->block->irx1_describe()) . ')')}
}
;

{ package IRx1::MethodDecl;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub scope {
  if (@_ == 2) {
      $_[0]{'scope'} = $_[1];
 } else {
     $_[0]{'scope'};
  }
}
;
sub typenames {
  if (@_ == 2) {
      $_[0]{'typenames'} = $_[1];
 } else {
     $_[0]{'typenames'};
  }
}
;
sub plurality {
  if (@_ == 2) {
      $_[0]{'plurality'} = $_[1];
 } else {
     $_[0]{'plurality'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub multisig {
  if (@_ == 2) {
      $_[0]{'multisig'} = $_[1];
 } else {
     $_[0]{'multisig'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub sigil {
  if (@_ == 2) {
      $_[0]{'sigil'} = $_[1];
 } else {
     $_[0]{'sigil'};
  }
}
;
sub postcircumfix {
  if (@_ == 2) {
      $_[0]{'postcircumfix'} = $_[1];
 } else {
     $_[0]{'postcircumfix'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block,$sigil,$postcircumfix)=@_;
$self->new('match', $match, 'scope', $scope, 'typenames', $typenames, 'plurality', $plurality, 'name', $name, 'multisig', $multisig, 'traits', $traits, 'block', $block, 'sigil', $sigil, 'postcircumfix', $postcircumfix)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__MethodDecl($self)};
sub node_name{my $self=CORE::shift;'MethodDecl'};
sub field_names{my $self=CORE::shift;['scope', 'typenames', 'plurality', 'name', 'multisig', 'traits', 'block', 'sigil', 'postcircumfix']};
sub field_values{my $self=CORE::shift;[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block, $self->sigil, $self->postcircumfix]};
sub irx1_describe{my $self=CORE::shift;(((((((((((((((((('MethodDecl(' . $self->scope->irx1_describe()) . ',') . $self->typenames->irx1_describe()) . ',') . $self->plurality->irx1_describe()) . ',') . $self->name->irx1_describe()) . ',') . $self->multisig->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->block->irx1_describe()) . ',') . $self->sigil->irx1_describe()) . ',') . $self->postcircumfix->irx1_describe()) . ')')}
}
;

{ package IRx1::SubDecl;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub scope {
  if (@_ == 2) {
      $_[0]{'scope'} = $_[1];
 } else {
     $_[0]{'scope'};
  }
}
;
sub typenames {
  if (@_ == 2) {
      $_[0]{'typenames'} = $_[1];
 } else {
     $_[0]{'typenames'};
  }
}
;
sub plurality {
  if (@_ == 2) {
      $_[0]{'plurality'} = $_[1];
 } else {
     $_[0]{'plurality'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub multisig {
  if (@_ == 2) {
      $_[0]{'multisig'} = $_[1];
 } else {
     $_[0]{'multisig'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block)=@_;
$self->new('match', $match, 'scope', $scope, 'typenames', $typenames, 'plurality', $plurality, 'name', $name, 'multisig', $multisig, 'traits', $traits, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__SubDecl($self)};
sub node_name{my $self=CORE::shift;'SubDecl'};
sub field_names{my $self=CORE::shift;['scope', 'typenames', 'plurality', 'name', 'multisig', 'traits', 'block']};
sub field_values{my $self=CORE::shift;[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block]};
sub irx1_describe{my $self=CORE::shift;(((((((((((((('SubDecl(' . $self->scope->irx1_describe()) . ',') . $self->typenames->irx1_describe()) . ',') . $self->plurality->irx1_describe()) . ',') . $self->name->irx1_describe()) . ',') . $self->multisig->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->block->irx1_describe()) . ')')}
}
;

{ package IRx1::MacroDecl;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub scope {
  if (@_ == 2) {
      $_[0]{'scope'} = $_[1];
 } else {
     $_[0]{'scope'};
  }
}
;
sub typenames {
  if (@_ == 2) {
      $_[0]{'typenames'} = $_[1];
 } else {
     $_[0]{'typenames'};
  }
}
;
sub plurality {
  if (@_ == 2) {
      $_[0]{'plurality'} = $_[1];
 } else {
     $_[0]{'plurality'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub multisig {
  if (@_ == 2) {
      $_[0]{'multisig'} = $_[1];
 } else {
     $_[0]{'multisig'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block)=@_;
$self->new('match', $match, 'scope', $scope, 'typenames', $typenames, 'plurality', $plurality, 'name', $name, 'multisig', $multisig, 'traits', $traits, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__MacroDecl($self)};
sub node_name{my $self=CORE::shift;'MacroDecl'};
sub field_names{my $self=CORE::shift;['scope', 'typenames', 'plurality', 'name', 'multisig', 'traits', 'block']};
sub field_values{my $self=CORE::shift;[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block]};
sub irx1_describe{my $self=CORE::shift;(((((((((((((('MacroDecl(' . $self->scope->irx1_describe()) . ',') . $self->typenames->irx1_describe()) . ',') . $self->plurality->irx1_describe()) . ',') . $self->name->irx1_describe()) . ',') . $self->multisig->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->block->irx1_describe()) . ')')}
}
;

{ package IRx1::VarDecl;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub scope {
  if (@_ == 2) {
      $_[0]{'scope'} = $_[1];
 } else {
     $_[0]{'scope'};
  }
}
;
sub typenames {
  if (@_ == 2) {
      $_[0]{'typenames'} = $_[1];
 } else {
     $_[0]{'typenames'};
  }
}
;
sub plurality {
  if (@_ == 2) {
      $_[0]{'plurality'} = $_[1];
 } else {
     $_[0]{'plurality'};
  }
}
;
sub var {
  if (@_ == 2) {
      $_[0]{'var'} = $_[1];
 } else {
     $_[0]{'var'};
  }
}
;
sub postcircumfix {
  if (@_ == 2) {
      $_[0]{'postcircumfix'} = $_[1];
 } else {
     $_[0]{'postcircumfix'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub default_op {
  if (@_ == 2) {
      $_[0]{'default_op'} = $_[1];
 } else {
     $_[0]{'default_op'};
  }
}
;
sub default_expr {
  if (@_ == 2) {
      $_[0]{'default_expr'} = $_[1];
 } else {
     $_[0]{'default_expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$var,$postcircumfix,$traits,$default_op,$default_expr)=@_;
$self->new('match', $match, 'scope', $scope, 'typenames', $typenames, 'plurality', $plurality, 'var', $var, 'postcircumfix', $postcircumfix, 'traits', $traits, 'default_op', $default_op, 'default_expr', $default_expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__VarDecl($self)};
sub node_name{my $self=CORE::shift;'VarDecl'};
sub field_names{my $self=CORE::shift;['scope', 'typenames', 'plurality', 'var', 'postcircumfix', 'traits', 'default_op', 'default_expr']};
sub field_values{my $self=CORE::shift;[$self->scope, $self->typenames, $self->plurality, $self->var, $self->postcircumfix, $self->traits, $self->default_op, $self->default_expr]};
sub irx1_describe{my $self=CORE::shift;(((((((((((((((('VarDecl(' . $self->scope->irx1_describe()) . ',') . $self->typenames->irx1_describe()) . ',') . $self->plurality->irx1_describe()) . ',') . $self->var->irx1_describe()) . ',') . $self->postcircumfix->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->default_op->irx1_describe()) . ',') . $self->default_expr->irx1_describe()) . ')')}
}
;

{ package IRx1::Var;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub sigil {
  if (@_ == 2) {
      $_[0]{'sigil'} = $_[1];
 } else {
     $_[0]{'sigil'};
  }
}
;
sub twigil {
  if (@_ == 2) {
      $_[0]{'twigil'} = $_[1];
 } else {
     $_[0]{'twigil'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Var($self)};
sub node_name{my $self=CORE::shift;'Var'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name]};
sub irx1_describe{my $self=CORE::shift;(((((('Var(' . $self->sigil->irx1_describe()) . ',') . $self->twigil->irx1_describe()) . ',') . $self->name->irx1_describe()) . ')')}
}
;

{ package IRx1::Trait;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub verb {
  if (@_ == 2) {
      $_[0]{'verb'} = $_[1];
 } else {
     $_[0]{'verb'};
  }
}
;
sub expr {
  if (@_ == 2) {
      $_[0]{'expr'} = $_[1];
 } else {
     $_[0]{'expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$verb,$expr)=@_;
$self->new('match', $match, 'verb', $verb, 'expr', $expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Trait($self)};
sub node_name{my $self=CORE::shift;'Trait'};
sub field_names{my $self=CORE::shift;['verb', 'expr']};
sub field_values{my $self=CORE::shift;[$self->verb, $self->expr]};
sub irx1_describe{my $self=CORE::shift;(((('Trait(' . $self->verb->irx1_describe()) . ',') . $self->expr->irx1_describe()) . ')')}
}
;

{ package IRx1::ClosureTrait;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub kind {
  if (@_ == 2) {
      $_[0]{'kind'} = $_[1];
 } else {
     $_[0]{'kind'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$kind,$block)=@_;
$self->new('match', $match, 'kind', $kind, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__ClosureTrait($self)};
sub node_name{my $self=CORE::shift;'ClosureTrait'};
sub field_names{my $self=CORE::shift;['kind', 'block']};
sub field_values{my $self=CORE::shift;[$self->kind, $self->block]};
sub irx1_describe{my $self=CORE::shift;(((('ClosureTrait(' . $self->kind->irx1_describe()) . ',') . $self->block->irx1_describe()) . ')')}
}
;

{ package IRx1::ModuleName;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub pairs {
  if (@_ == 2) {
      $_[0]{'pairs'} = $_[1];
 } else {
     $_[0]{'pairs'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$name,$pairs)=@_;
$self->new('match', $match, 'name', $name, 'pairs', $pairs)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__ModuleName($self)};
sub node_name{my $self=CORE::shift;'ModuleName'};
sub field_names{my $self=CORE::shift;['name', 'pairs']};
sub field_values{my $self=CORE::shift;[$self->name, $self->pairs]};
sub irx1_describe{my $self=CORE::shift;(((('ModuleName(' . $self->name->irx1_describe()) . ',') . $self->pairs->irx1_describe()) . ')')}
}
;

{ package IRx1::PathName;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub path {
  if (@_ == 2) {
      $_[0]{'path'} = $_[1];
 } else {
     $_[0]{'path'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$path)=@_;
$self->new('match', $match, 'path', $path)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__PathName($self)};
sub node_name{my $self=CORE::shift;'PathName'};
sub field_names{my $self=CORE::shift;['path']};
sub field_values{my $self=CORE::shift;[$self->path]};
sub irx1_describe{my $self=CORE::shift;(('PathName(' . $self->path->irx1_describe()) . ')')}
}
;

{ package IRx1::SubName;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub category {
  if (@_ == 2) {
      $_[0]{'category'} = $_[1];
 } else {
     $_[0]{'category'};
  }
}
;
sub pairs {
  if (@_ == 2) {
      $_[0]{'pairs'} = $_[1];
 } else {
     $_[0]{'pairs'};
  }
}
;
sub desigilname {
  if (@_ == 2) {
      $_[0]{'desigilname'} = $_[1];
 } else {
     $_[0]{'desigilname'};
  }
}
;
sub signature {
  if (@_ == 2) {
      $_[0]{'signature'} = $_[1];
 } else {
     $_[0]{'signature'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$category,$pairs,$desigilname,$signature)=@_;
$self->new('match', $match, 'category', $category, 'pairs', $pairs, 'desigilname', $desigilname, 'signature', $signature)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__SubName($self)};
sub node_name{my $self=CORE::shift;'SubName'};
sub field_names{my $self=CORE::shift;['category', 'pairs', 'desigilname', 'signature']};
sub field_values{my $self=CORE::shift;[$self->category, $self->pairs, $self->desigilname, $self->signature]};
sub irx1_describe{my $self=CORE::shift;(((((((('SubName(' . $self->category->irx1_describe()) . ',') . $self->pairs->irx1_describe()) . ',') . $self->desigilname->irx1_describe()) . ',') . $self->signature->irx1_describe()) . ')')}
}
;

{ package IRx1::ShapedParamName;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub ident {
  if (@_ == 2) {
      $_[0]{'ident'} = $_[1];
 } else {
     $_[0]{'ident'};
  }
}
;
sub postcircumfix {
  if (@_ == 2) {
      $_[0]{'postcircumfix'} = $_[1];
 } else {
     $_[0]{'postcircumfix'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$ident,$postcircumfix)=@_;
$self->new('match', $match, 'ident', $ident, 'postcircumfix', $postcircumfix)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__ShapedParamName($self)};
sub node_name{my $self=CORE::shift;'ShapedParamName'};
sub field_names{my $self=CORE::shift;['ident', 'postcircumfix']};
sub field_values{my $self=CORE::shift;[$self->ident, $self->postcircumfix]};
sub irx1_describe{my $self=CORE::shift;(((('ShapedParamName(' . $self->ident->irx1_describe()) . ',') . $self->postcircumfix->irx1_describe()) . ')')}
}
;

{ package IRx1::Call;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub invocant {
  if (@_ == 2) {
      $_[0]{'invocant'} = $_[1];
 } else {
     $_[0]{'invocant'};
  }
}
;
sub method {
  if (@_ == 2) {
      $_[0]{'method'} = $_[1];
 } else {
     $_[0]{'method'};
  }
}
;
sub capture {
  if (@_ == 2) {
      $_[0]{'capture'} = $_[1];
 } else {
     $_[0]{'capture'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$invocant,$method,$capture)=@_;
$self->new('match', $match, 'invocant', $invocant, 'method', $method, 'capture', $capture)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Call($self)};
sub node_name{my $self=CORE::shift;'Call'};
sub field_names{my $self=CORE::shift;['invocant', 'method', 'capture']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->method, $self->capture]};
sub irx1_describe{my $self=CORE::shift;(((((('Call(' . $self->invocant->irx1_describe()) . ',') . $self->method->irx1_describe()) . ',') . $self->capture->irx1_describe()) . ')')}
}
;

{ package IRx1::Apply;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub function {
  if (@_ == 2) {
      $_[0]{'function'} = $_[1];
 } else {
     $_[0]{'function'};
  }
}
;
sub capture {
  if (@_ == 2) {
      $_[0]{'capture'} = $_[1];
 } else {
     $_[0]{'capture'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$function,$capture)=@_;
$self->new('match', $match, 'function', $function, 'capture', $capture)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Apply($self)};
sub node_name{my $self=CORE::shift;'Apply'};
sub field_names{my $self=CORE::shift;['function', 'capture']};
sub field_values{my $self=CORE::shift;[$self->function, $self->capture]};
sub irx1_describe{my $self=CORE::shift;(((('Apply(' . $self->function->irx1_describe()) . ',') . $self->capture->irx1_describe()) . ')')}
}
;

{ package IRx1::Hyper;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub operator {
  if (@_ == 2) {
      $_[0]{'operator'} = $_[1];
 } else {
     $_[0]{'operator'};
  }
}
;
sub capture {
  if (@_ == 2) {
      $_[0]{'capture'} = $_[1];
 } else {
     $_[0]{'capture'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$operator,$capture)=@_;
$self->new('match', $match, 'operator', $operator, 'capture', $capture)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Hyper($self)};
sub node_name{my $self=CORE::shift;'Hyper'};
sub field_names{my $self=CORE::shift;['operator', 'capture']};
sub field_values{my $self=CORE::shift;[$self->operator, $self->capture]};
sub irx1_describe{my $self=CORE::shift;(((('Hyper(' . $self->operator->irx1_describe()) . ',') . $self->capture->irx1_describe()) . ')')}
}
;

{ package IRx1::Capture;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub arguments {
  if (@_ == 2) {
      $_[0]{'arguments'} = $_[1];
 } else {
     $_[0]{'arguments'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$arguments)=@_;
$self->new('match', $match, 'arguments', $arguments)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Capture($self)};
sub node_name{my $self=CORE::shift;'Capture'};
sub field_names{my $self=CORE::shift;['arguments']};
sub field_values{my $self=CORE::shift;[$self->arguments]};
sub irx1_describe{my $self=CORE::shift;(('Capture(' . $self->arguments->irx1_describe()) . ')')}
}
;

{ package IRx1::MultiSig;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub signatures {
  if (@_ == 2) {
      $_[0]{'signatures'} = $_[1];
 } else {
     $_[0]{'signatures'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$signatures)=@_;
$self->new('match', $match, 'signatures', $signatures)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__MultiSig($self)};
sub node_name{my $self=CORE::shift;'MultiSig'};
sub field_names{my $self=CORE::shift;['signatures']};
sub field_values{my $self=CORE::shift;[$self->signatures]};
sub irx1_describe{my $self=CORE::shift;(('MultiSig(' . $self->signatures->irx1_describe()) . ')')}
}
;

{ package IRx1::Signature;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub parameters {
  if (@_ == 2) {
      $_[0]{'parameters'} = $_[1];
 } else {
     $_[0]{'parameters'};
  }
}
;
sub return_type {
  if (@_ == 2) {
      $_[0]{'return_type'} = $_[1];
 } else {
     $_[0]{'return_type'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$parameters,$return_type)=@_;
$self->new('match', $match, 'parameters', $parameters, 'return_type', $return_type)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Signature($self)};
sub node_name{my $self=CORE::shift;'Signature'};
sub field_names{my $self=CORE::shift;['parameters', 'return_type']};
sub field_values{my $self=CORE::shift;[$self->parameters, $self->return_type]};
sub irx1_describe{my $self=CORE::shift;(((('Signature(' . $self->parameters->irx1_describe()) . ',') . $self->return_type->irx1_describe()) . ')')}
}
;

{ package IRx1::Parameter;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub type_constraints {
  if (@_ == 2) {
      $_[0]{'type_constraints'} = $_[1];
 } else {
     $_[0]{'type_constraints'};
  }
}
;
sub quant {
  if (@_ == 2) {
      $_[0]{'quant'} = $_[1];
 } else {
     $_[0]{'quant'};
  }
}
;
sub param_var {
  if (@_ == 2) {
      $_[0]{'param_var'} = $_[1];
 } else {
     $_[0]{'param_var'};
  }
}
;
sub ident {
  if (@_ == 2) {
      $_[0]{'ident'} = $_[1];
 } else {
     $_[0]{'ident'};
  }
}
;
sub traits {
  if (@_ == 2) {
      $_[0]{'traits'} = $_[1];
 } else {
     $_[0]{'traits'};
  }
}
;
sub post_constraints {
  if (@_ == 2) {
      $_[0]{'post_constraints'} = $_[1];
 } else {
     $_[0]{'post_constraints'};
  }
}
;
sub default_expr {
  if (@_ == 2) {
      $_[0]{'default_expr'} = $_[1];
 } else {
     $_[0]{'default_expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$type_constraints,$quant,$param_var,$ident,$traits,$post_constraints,$default_expr)=@_;
$self->new('match', $match, 'type_constraints', $type_constraints, 'quant', $quant, 'param_var', $param_var, 'ident', $ident, 'traits', $traits, 'post_constraints', $post_constraints, 'default_expr', $default_expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Parameter($self)};
sub node_name{my $self=CORE::shift;'Parameter'};
sub field_names{my $self=CORE::shift;['type_constraints', 'quant', 'param_var', 'ident', 'traits', 'post_constraints', 'default_expr']};
sub field_values{my $self=CORE::shift;[$self->type_constraints, $self->quant, $self->param_var, $self->ident, $self->traits, $self->post_constraints, $self->default_expr]};
sub irx1_describe{my $self=CORE::shift;(((((((((((((('Parameter(' . $self->type_constraints->irx1_describe()) . ',') . $self->quant->irx1_describe()) . ',') . $self->param_var->irx1_describe()) . ',') . $self->ident->irx1_describe()) . ',') . $self->traits->irx1_describe()) . ',') . $self->post_constraints->irx1_describe()) . ',') . $self->default_expr->irx1_describe()) . ')')}
}
;

{ package IRx1::TypeConstraint;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub value {
  if (@_ == 2) {
      $_[0]{'value'} = $_[1];
 } else {
     $_[0]{'value'};
  }
}
;
sub where_expr {
  if (@_ == 2) {
      $_[0]{'where_expr'} = $_[1];
 } else {
     $_[0]{'where_expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$value,$where_expr)=@_;
$self->new('match', $match, 'value', $value, 'where_expr', $where_expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__TypeConstraint($self)};
sub node_name{my $self=CORE::shift;'TypeConstraint'};
sub field_names{my $self=CORE::shift;['value', 'where_expr']};
sub field_values{my $self=CORE::shift;[$self->value, $self->where_expr]};
sub irx1_describe{my $self=CORE::shift;(((('TypeConstraint(' . $self->value->irx1_describe()) . ',') . $self->where_expr->irx1_describe()) . ')')}
}
;

{ package IRx1::PostConstraint;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub multisig {
  if (@_ == 2) {
      $_[0]{'multisig'} = $_[1];
 } else {
     $_[0]{'multisig'};
  }
}
;
sub where_expr {
  if (@_ == 2) {
      $_[0]{'where_expr'} = $_[1];
 } else {
     $_[0]{'where_expr'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$multisig,$where_expr)=@_;
$self->new('match', $match, 'multisig', $multisig, 'where_expr', $where_expr)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__PostConstraint($self)};
sub node_name{my $self=CORE::shift;'PostConstraint'};
sub field_names{my $self=CORE::shift;['multisig', 'where_expr']};
sub field_values{my $self=CORE::shift;[$self->multisig, $self->where_expr]};
sub irx1_describe{my $self=CORE::shift;(((('PostConstraint(' . $self->multisig->irx1_describe()) . ',') . $self->where_expr->irx1_describe()) . ')')}
}
;

{ package IRx1::ParamVar;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub sigil {
  if (@_ == 2) {
      $_[0]{'sigil'} = $_[1];
 } else {
     $_[0]{'sigil'};
  }
}
;
sub twigil {
  if (@_ == 2) {
      $_[0]{'twigil'} = $_[1];
 } else {
     $_[0]{'twigil'};
  }
}
;
sub name {
  if (@_ == 2) {
      $_[0]{'name'} = $_[1];
 } else {
     $_[0]{'name'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__ParamVar($self)};
sub node_name{my $self=CORE::shift;'ParamVar'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name]};
sub irx1_describe{my $self=CORE::shift;(((((('ParamVar(' . $self->sigil->irx1_describe()) . ',') . $self->twigil->irx1_describe()) . ',') . $self->name->irx1_describe()) . ')')}
}
;

{ package IRx1::Undef;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Undef($self)};
sub node_name{my $self=CORE::shift;'Undef'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub irx1_describe{my $self=CORE::shift;('Undef(' . ')')}
}
;

{ package IRx1::NumInt;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub text {
  if (@_ == 2) {
      $_[0]{'text'} = $_[1];
 } else {
     $_[0]{'text'};
  }
}
;
sub base {
  if (@_ == 2) {
      $_[0]{'base'} = $_[1];
 } else {
     $_[0]{'base'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$text,$base)=@_;
$self->new('match', $match, 'text', $text, 'base', $base)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__NumInt($self)};
sub node_name{my $self=CORE::shift;'NumInt'};
sub field_names{my $self=CORE::shift;['text', 'base']};
sub field_values{my $self=CORE::shift;[$self->text, $self->base]};
sub irx1_describe{my $self=CORE::shift;(((('NumInt(' . $self->text->irx1_describe()) . ',') . $self->base->irx1_describe()) . ')')}
}
;

{ package IRx1::NumDec;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub intpart {
  if (@_ == 2) {
      $_[0]{'intpart'} = $_[1];
 } else {
     $_[0]{'intpart'};
  }
}
;
sub fracpart {
  if (@_ == 2) {
      $_[0]{'fracpart'} = $_[1];
 } else {
     $_[0]{'fracpart'};
  }
}
;
sub exp {
  if (@_ == 2) {
      $_[0]{'exp'} = $_[1];
 } else {
     $_[0]{'exp'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$intpart,$fracpart,$exp)=@_;
$self->new('match', $match, 'intpart', $intpart, 'fracpart', $fracpart, 'exp', $exp)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__NumDec($self)};
sub node_name{my $self=CORE::shift;'NumDec'};
sub field_names{my $self=CORE::shift;['intpart', 'fracpart', 'exp']};
sub field_values{my $self=CORE::shift;[$self->intpart, $self->fracpart, $self->exp]};
sub irx1_describe{my $self=CORE::shift;(((((('NumDec(' . $self->intpart->irx1_describe()) . ',') . $self->fracpart->irx1_describe()) . ',') . $self->exp->irx1_describe()) . ')')}
}
;

{ package IRx1::NumRad;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub radix {
  if (@_ == 2) {
      $_[0]{'radix'} = $_[1];
 } else {
     $_[0]{'radix'};
  }
}
;
sub intpart {
  if (@_ == 2) {
      $_[0]{'intpart'} = $_[1];
 } else {
     $_[0]{'intpart'};
  }
}
;
sub fracpart {
  if (@_ == 2) {
      $_[0]{'fracpart'} = $_[1];
 } else {
     $_[0]{'fracpart'};
  }
}
;
sub base {
  if (@_ == 2) {
      $_[0]{'base'} = $_[1];
 } else {
     $_[0]{'base'};
  }
}
;
sub exp {
  if (@_ == 2) {
      $_[0]{'exp'} = $_[1];
 } else {
     $_[0]{'exp'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$radix,$intpart,$fracpart,$base,$exp)=@_;
$self->new('match', $match, 'radix', $radix, 'intpart', $intpart, 'fracpart', $fracpart, 'base', $base, 'exp', $exp)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__NumRad($self)};
sub node_name{my $self=CORE::shift;'NumRad'};
sub field_names{my $self=CORE::shift;['radix', 'intpart', 'fracpart', 'base', 'exp']};
sub field_values{my $self=CORE::shift;[$self->radix, $self->intpart, $self->fracpart, $self->base, $self->exp]};
sub irx1_describe{my $self=CORE::shift;(((((((((('NumRad(' . $self->radix->irx1_describe()) . ',') . $self->intpart->irx1_describe()) . ',') . $self->fracpart->irx1_describe()) . ',') . $self->base->irx1_describe()) . ',') . $self->exp->irx1_describe()) . ')')}
}
;

{ package IRx1::Array;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub array {
  if (@_ == 2) {
      $_[0]{'array'} = $_[1];
 } else {
     $_[0]{'array'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$array)=@_;
$self->new('match', $match, 'array', $array)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Array($self)};
sub node_name{my $self=CORE::shift;'Array'};
sub field_names{my $self=CORE::shift;['array']};
sub field_values{my $self=CORE::shift;[$self->array]};
sub irx1_describe{my $self=CORE::shift;(('Array(' . $self->array->irx1_describe()) . ')')}
}
;

{ package IRx1::Hash;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub hash {
  if (@_ == 2) {
      $_[0]{'hash'} = $_[1];
 } else {
     $_[0]{'hash'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$hash)=@_;
$self->new('match', $match, 'hash', $hash)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Hash($self)};
sub node_name{my $self=CORE::shift;'Hash'};
sub field_names{my $self=CORE::shift;['hash']};
sub field_values{my $self=CORE::shift;[$self->hash]};
sub irx1_describe{my $self=CORE::shift;(('Hash(' . $self->hash->irx1_describe()) . ')')}
}
;

{ package IRx1::Pair;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub key {
  if (@_ == 2) {
      $_[0]{'key'} = $_[1];
 } else {
     $_[0]{'key'};
  }
}
;
sub value {
  if (@_ == 2) {
      $_[0]{'value'} = $_[1];
 } else {
     $_[0]{'value'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
$self->new('match', $match, 'key', $key, 'value', $value)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Pair($self)};
sub node_name{my $self=CORE::shift;'Pair'};
sub field_names{my $self=CORE::shift;['key', 'value']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value]};
sub irx1_describe{my $self=CORE::shift;(((('Pair(' . $self->key->irx1_describe()) . ',') . $self->value->irx1_describe()) . ')')}
}
;

{ package IRx1::Type;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub typename {
  if (@_ == 2) {
      $_[0]{'typename'} = $_[1];
 } else {
     $_[0]{'typename'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$typename)=@_;
$self->new('match', $match, 'typename', $typename)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Type($self)};
sub node_name{my $self=CORE::shift;'Type'};
sub field_names{my $self=CORE::shift;['typename']};
sub field_values{my $self=CORE::shift;[$self->typename]};
sub irx1_describe{my $self=CORE::shift;(('Type(' . $self->typename->irx1_describe()) . ')')}
}
;

{ package IRx1::Rx;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub pat {
  if (@_ == 2) {
      $_[0]{'pat'} = $_[1];
 } else {
     $_[0]{'pat'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$pat)=@_;
$self->new('match', $match, 'pat', $pat)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Rx($self)};
sub node_name{my $self=CORE::shift;'Rx'};
sub field_names{my $self=CORE::shift;['pat']};
sub field_values{my $self=CORE::shift;[$self->pat]};
sub irx1_describe{my $self=CORE::shift;(('Rx(' . $self->pat->irx1_describe()) . ')')}
}
;

{ package IRx1::Buf;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub buf {
  if (@_ == 2) {
      $_[0]{'buf'} = $_[1];
 } else {
     $_[0]{'buf'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$buf)=@_;
$self->new('match', $match, 'buf', $buf)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Buf($self)};
sub node_name{my $self=CORE::shift;'Buf'};
sub field_names{my $self=CORE::shift;['buf']};
sub field_values{my $self=CORE::shift;[$self->buf]};
sub irx1_describe{my $self=CORE::shift;(('Buf(' . $self->buf->irx1_describe()) . ')')}
}
;

{ package IRx1::For;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub expr {
  if (@_ == 2) {
      $_[0]{'expr'} = $_[1];
 } else {
     $_[0]{'expr'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$expr,$block)=@_;
$self->new('match', $match, 'expr', $expr, 'block', $block)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__For($self)};
sub node_name{my $self=CORE::shift;'For'};
sub field_names{my $self=CORE::shift;['expr', 'block']};
sub field_values{my $self=CORE::shift;[$self->expr, $self->block]};
sub irx1_describe{my $self=CORE::shift;(((('For(' . $self->expr->irx1_describe()) . ',') . $self->block->irx1_describe()) . ')')}
}
;

{ package IRx1::Cond;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub clauses {
  if (@_ == 2) {
      $_[0]{'clauses'} = $_[1];
 } else {
     $_[0]{'clauses'};
  }
}
;
sub default {
  if (@_ == 2) {
      $_[0]{'default'} = $_[1];
 } else {
     $_[0]{'default'};
  }
}
;
sub invert_first_test {
  if (@_ == 2) {
      $_[0]{'invert_first_test'} = $_[1];
 } else {
     $_[0]{'invert_first_test'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$clauses,$default,$invert_first_test)=@_;
$self->new('match', $match, 'clauses', $clauses, 'default', $default, 'invert_first_test', $invert_first_test)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Cond($self)};
sub node_name{my $self=CORE::shift;'Cond'};
sub field_names{my $self=CORE::shift;['clauses', 'default', 'invert_first_test']};
sub field_values{my $self=CORE::shift;[$self->clauses, $self->default, $self->invert_first_test]};
sub irx1_describe{my $self=CORE::shift;(((((('Cond(' . $self->clauses->irx1_describe()) . ',') . $self->default->irx1_describe()) . ',') . $self->invert_first_test->irx1_describe()) . ')')}
}
;

{ package IRx1::Loop;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base 'IRx1::Base';
sub match {
  if (@_ == 2) {
      $_[0]{'match'} = $_[1];
 } else {
     $_[0]{'match'};
  }
}
;
sub pretest {
  if (@_ == 2) {
      $_[0]{'pretest'} = $_[1];
 } else {
     $_[0]{'pretest'};
  }
}
;
sub block {
  if (@_ == 2) {
      $_[0]{'block'} = $_[1];
 } else {
     $_[0]{'block'};
  }
}
;
sub posttest {
  if (@_ == 2) {
      $_[0]{'posttest'} = $_[1];
 } else {
     $_[0]{'posttest'};
  }
}
;
sub label {
  if (@_ == 2) {
      $_[0]{'label'} = $_[1];
 } else {
     $_[0]{'label'};
  }
}
;
sub newp{my $self=CORE::shift;my($match,$pretest,$block,$posttest,$label)=@_;
$self->new('match', $match, 'pretest', $pretest, 'block', $block, 'posttest', $posttest, 'label', $label)};
sub callback{my $self=CORE::shift;my($emitter)=@_;
$emitter->cb__Loop($self)};
sub node_name{my $self=CORE::shift;'Loop'};
sub field_names{my $self=CORE::shift;['pretest', 'block', 'posttest', 'label']};
sub field_values{my $self=CORE::shift;[$self->pretest, $self->block, $self->posttest, $self->label]};
sub irx1_describe{my $self=CORE::shift;(((((((('Loop(' . $self->pretest->irx1_describe()) . ',') . $self->block->irx1_describe()) . ',') . $self->posttest->irx1_describe()) . ',') . $self->label->irx1_describe()) . ')')}
}

}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package IRx1_Build;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub constructors {
  if (@_ == 2) {
      $_[0]{'constructors'} = $_[1];
 } else {
     $_[0]{'constructors'};
  }
}
;
($main::irbuilder = IRx1_Build->new());
sub add_constructor{my $self=CORE::shift;my($k,$constructor)=@_;
if($self->constructors) {

}else {
my $h = {};
$self->constructors($h)
};
($self->constructors->{$k} = $constructor)};
sub make_ir_from_Match_tree{my $self=CORE::shift;my($m)=@_;
my $rule = $m->rule();
my $constructor = $self->constructors->{$rule};
if(($constructor)) {
$constructor->($m)
}else {
::die((('Unknown rule: ' . $rule) . '
It needs to be added to ast_handlers.
'))
}}
}
;

{ package Match;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$main::irbuilder->make_ir_from_Match_tree($self)}
}
;

{ package ARRAY;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self->map(sub {my($e)=@_;
$e->make_ir_from_Match_tree()})}
}
;

{ package SCALAR;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}
}
;

{ package UNDEF;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}
}
;
sub irbuild_ir{my($x)=@_;
$x->make_ir_from_Match_tree()};

{ package IRx1_Build;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub irbuild_ir{my($x)=@_;
$x->make_ir_from_Match_tree()};
$main::irbuilder->add_constructor('comp_unit', sub {my($m)=@_;
IRx1::CompUnit->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('statement', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('expect_term', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__expect_term_base'};local $::es_blackboard__expect_term_base = ::irbuild_ir($m->{'hash'}->{'noun'});
my $post = ($m->{'hash'}->{'post'} || []);
for($post->flatten){
($::es_blackboard__expect_term_base = ::irbuild_ir($_))
};
$::es_blackboard__expect_term_base});
$main::irbuilder->add_constructor('post', sub {my($m)=@_;
(::irbuild_ir($m->{'hash'}->{'dotty'}) or ::irbuild_ir($m->{'hash'}->{'postop'}))});
$main::irbuilder->add_constructor('dotty:methodop', sub {my($m)=@_;
IRx1::Call->newp($m, $::es_blackboard__expect_term_base, ::irbuild_ir($m->{'hash'}->{'ident'}), IRx1::Capture->newp($m, ::irbuild_ir($m->{'hash'}->{'semilist'})))});
$main::irbuilder->add_constructor('dotty:postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
my $args = ::irbuild_ir($m->{'hash'}->{'kludge_name'});
if(($args && (($args->ref() eq 'SCALAR')))) {
($args = [$args])
};
IRx1::Call->newp($m, $::es_blackboard__expect_term_base, $ident, IRx1::Capture->newp($m, $args))});
$main::irbuilder->add_constructor('postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
my $args = ::irbuild_ir($m->{'hash'}->{'kludge_name'});
if(($args && (($args->ref() eq 'SCALAR')))) {
($args = [$args])
};
IRx1::Call->newp($m, $::es_blackboard__expect_term_base, $ident, IRx1::Capture->newp($m, $args))});
$main::irbuilder->add_constructor('term:expect_term', sub {my($m)=@_;
::irbuild_ir($m->{'hash'}->{'noun'})});
$main::irbuilder->add_constructor('term', sub {my($m)=@_;
if((($m->match_string()) eq 'self')) {
IRx1::Apply->newp($m, 'self', IRx1::Capture->newp($m, []))
}else {
::die('AST term partially unimplemented.
')
}});
$main::irbuilder->add_constructor('integer', sub {my($m)=@_;
IRx1::NumInt->newp($m, ($m->match_string()))});
$main::irbuilder->add_constructor('subcall', sub {my($m)=@_;
my $t = ::irbuild_ir($m->{'hash'}->{'subshortname'}->{'hash'}->{'twigil'});
if(($t && ($t eq '.'))) {
IRx1::Call->newp($m, IRx1::Apply->newp($m, 'self', IRx1::Capture->newp($m, [])), ::irbuild_ir($m->{'hash'}->{'subshortname'}->{'hash'}->{'desigilname'}->{'hash'}->{'ident'}), IRx1::Capture->newp($m, ::irbuild_ir($m->{'hash'}->{'semilist'})))
}else {
IRx1::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'subshortname'}), IRx1::Capture->newp($m, ::irbuild_ir($m->{'hash'}->{'semilist'})))
}});
$main::irbuilder->add_constructor('name', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('statement_control:use', sub {my($m)=@_;
IRx1::Use->newp($m, 'use', ::irbuild_ir($m->{'hash'}->{'module_name'}))});
$main::irbuilder->add_constructor('module_name:depreciated', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('module_name:normal', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('statement_control:BEGIN', sub {my($m)=@_;
IRx1::ClosureTrait->newp($m, 'BEGIN', ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('term:listop', sub {my($m)=@_;
my $not_really_an_arglist = ::irbuild_ir($m->{'hash'}->{'arglist'});
if(::irbuild_ir($m->{'hash'}->{'arglist'})) {
IRx1::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), IRx1::Capture->newp($m, [$not_really_an_arglist]))
}else {
IRx1::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), IRx1::Capture->newp($m, []))
}});
$main::irbuilder->add_constructor('quote:q', sub {my($m)=@_;
IRx1::Buf->newp($m, ::irbuild_ir($m->{'hash'}->{'text'}))});
$main::irbuilder->add_constructor('quote:qq', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
$s->re_gsub(qr/(?<!\\)\\n/, '
');
$s->re_gsub(qr/(?<!\\)\\t/, '	');
IRx1::Buf->newp($m, $s)});
$main::irbuilder->add_constructor('quote:regex', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
IRx1::Rx->newp($m, $s)});
$main::irbuilder->add_constructor('infix', sub {my($m)=@_;
my $op = ($m->match_string());
if(($op eq 'str')) {
($op = '=')
};
IRx1::Apply->newp($m, ('infix:' . $op), IRx1::Capture->newp($m, [::irbuild_ir($m->{'hash'}->{'left'}), ::irbuild_ir($m->{'hash'}->{'right'})]))});
$main::irbuilder->add_constructor('scope_declarator:my', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IRx1::VarDecl->newp($m, 'my', ::undef(), ::undef(), $vd->[0], ::undef(), ::undef(), '=', $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:has', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IRx1::VarDecl->newp($m, 'has', ::undef(), ::undef(), $vd->[0], ::undef(), ::undef(), '=', $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:our', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IRx1::VarDecl->newp($m, 'our', ::undef(), ::undef(), $vd->[0], ::undef(), ::undef(), '=', $vd->[1])});
$main::irbuilder->add_constructor('scoped', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('variable_decl', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'variable'}), ::irbuild_ir($m->{'hash'}->{'default_value'})]});
$main::irbuilder->add_constructor('variable', sub {my($m)=@_;
IRx1::Var->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'desigilname'}))});
$main::irbuilder->add_constructor('sigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('twigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('circumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $args = ::irbuild_ir($m->{'hash'}->{'kludge_name'});
if(($args && (($args->ref() eq 'SCALAR')))) {
($args = [$args])
};
IRx1::Apply->newp($m, ('circumfix:' . $name), IRx1::Capture->newp($m, $args))});
$main::irbuilder->add_constructor('statement_control:for', sub {my($m)=@_;
IRx1::For->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:while', sub {my($m)=@_;
IRx1::Loop->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:if', sub {my($m)=@_;
my $els = ::irbuild_ir($m->{'hash'}->{'else'});
if($els) {
($els = $els->[0])
};
IRx1::Cond->newp($m, [[::irbuild_ir($m->{'hash'}->{'if_expr'}), ::irbuild_ir($m->{'hash'}->{'if_block'})]]->push(::irbuild_ir($m->{'hash'}->{'elsif'})->flatten()), $els)});
$main::irbuilder->add_constructor('elsif', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'elsif_expr'}), ::irbuild_ir($m->{'hash'}->{'elsif_block'})]});
$main::irbuilder->add_constructor('if__else', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('pblock', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('block', sub {my($m)=@_;
IRx1::Block->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('plurality_declarator:multi', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__plurality'};local $::es_blackboard__plurality = 'multi';
::irbuild_ir($m->{'hash'}->{'pluralized'})});
$main::irbuilder->add_constructor('routine_declarator:routine_def', sub {my($m)=@_;
my $plurality = $::es_blackboard__plurality;
{package main; use vars '$1es_blackboard__plurality'};local $::es_blackboard__plurality;
my $ident = '';
if(::irbuild_ir($m->{'hash'}->{'ident'})) {
($ident = ::irbuild_ir($m->{'hash'}->{'ident'})->[0])
};
my $sig = IRx1::Signature->newp($m, [], ::undef());
if(::irbuild_ir($m->{'hash'}->{'multisig'})) {
($sig = ::irbuild_ir($m->{'hash'}->{'multisig'})->[0])
};
IRx1::SubDecl->newp($m, ::undef(), ::undef(), $plurality, $ident, $sig, ::undef(), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('routine_declarator:method_def', sub {my($m)=@_;
my $plurality = $::es_blackboard__plurality;
{package main; use vars '$1es_blackboard__plurality'};local $::es_blackboard__plurality;
IRx1::MethodDecl->newp($m, ::undef(), ::undef(), $plurality, ::irbuild_ir($m->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'multisig'})->[0], ::undef(), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('signature', sub {my($m)=@_;
IRx1::Signature->newp($m, ::irbuild_ir($m->{'hash'}->{'parsep'}), ::undef())});
$main::irbuilder->add_constructor('parameter', sub {my($m)=@_;
IRx1::Parameter->newp($m, ::irbuild_ir($m->{'hash'}->{'type_constraint'}), ::irbuild_ir($m->{'hash'}->{'quantchar'}), ::irbuild_ir($m->{'hash'}->{'param_var'}))});
$main::irbuilder->add_constructor('param_var', sub {my($m)=@_;
IRx1::ParamVar->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('package_declarator:class', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'class';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:module', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'module';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:package', sub {my($m)=@_;
{package main; use vars '$1es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'package';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_def', sub {my($m)=@_;
IRx1::PackageDecl->newp($m, ::undef(), ::undef(), $::es_blackboard__package_declarator, ::irbuild_ir($m->{'hash'}->{'module_name'})->[0], ::irbuild_ir($m->{'hash'}->{'traits'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('fulltypename', sub {my($m)=@_;
::irbuild_ir($m->{'hash'}->{'typename'})->join('::')});
$main::irbuilder->add_constructor('typename', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('trait_verb:is', sub {my($m)=@_;
IRx1::Trait->newp($m, 'is', ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('circumfix:pblock', sub {my($m)=@_;
if((::not(::irbuild_ir($m->{'hash'}->{'lambda'})) and ::not(::irbuild_ir($m->{'hash'}->{'signature'})))) {
IRx1::Hash->newp($m, ::irbuild_ir($m->{'hash'}->{'block'}->{'hash'}->{'statementlist'}))
}else {
::die('AST handler circumfix:pblock partially unimplemented')
}})
}

;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package EmitSimpleP5;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub new_emitter{my $self=CORE::shift;my($ignore,$compiler)=@_;
$self->new('compiler', $compiler)};
sub compiler {
  if (@_ == 2) {
      $_[0]{'compiler'} = $_[1];
 } else {
     $_[0]{'compiler'};
  }
}
;
sub prelude_for_entering_a_package{my $self=CORE::shift;'use autobox; use autobox::Core; use autobox UNDEF => \'UNDEF\';
'};
sub prelude_oo{my $self=CORE::shift;'
{package AssertCurrentModuleVersions;
 use Moose 0.40;
 use Moose::Autobox 0.06;
}
'};
sub prelude{my $self=CORE::shift;my($n)=@_;
(('#!/usr/bin/perl -w
package main;
use Data::Dumper; # Used to render Buf strings.
use Perl6::Say;
use autobox; use autobox::Core; use autobox UNDEF => "UNDEF";
{package AssertCurrentModuleVersions;
 use autobox 2.23;
 use autobox::Core 0.4;
}
{package NoSideEffects; use Class::Multimethods;}

' . $self->prelude_oo()) . '

our $a_ARGS = [@ARGV];

{package UNDEF;}
{package UNDEF; sub ref{"UNDEF"}}
{package UNIVERSAL; sub ref{CORE::ref($_[0]) || "SCALAR"} }
{package UNIVERSAL; sub WHAT{CORE::ref($_[0]) || "SCALAR"} }

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; my $s = `cat $file`; $s}
sub unslurp{
  my($text,$file)=@_; open(F,">$file") or CORE::die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{CORE::system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{CORE::exit(@_)}
sub ::defined{CORE::defined($_[0])}
sub ::substr ($$$){CORE::substr($_[0],$_[1],$_[2])}
sub ::not ($){CORE::not $_[0]}
sub ::exec{CORE::exec(@_)}
sub ::sleep{CORE::sleep(@_)}

# because the p5->p6 massage of ast_handlers isnt massaging join.
sub ::join{CORE::join(CORE::shift,@_)}
# end

{ package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}
}

{ package ARRAY;
# absent from autobox::Core
sub splice { my $a = CORE::shift; [CORE::splice(@{$a},$_[0],$_[1])] }
sub copy { my $a = CORE::shift; [@$a] }
# buggy in autobox::Core
BEGIN{my $x = *ARRAY::unshift; undef &$x;}
sub unshift (\\@;@) { my $a = CORE::shift; CORE::unshift(@$a, @_); $a; }
}
{ package HASH;
  sub dup { my $h = CORE::shift; my $h1 = {%$h}; $h1 }
}

sub parser_name{
  my $f = $0;
  $f =~ s/[^\\/]+$//;
  $f."../STD_red/STD_red_run"
}

our $a_INC = ["."];
sub ::require {
  my($module)=@_;
  my $file = find_required_module($module);
  $file || CORE::die "Cant locate $module in ( ".CORE::join(" ",@$a_INC)." ).\\n";
  eval_file($file);
};
sub ::find_required_module {
  my($module)=@_;
  my @names = ($module,$module.".pm",$module.".p6");
  for my $dir (@$a_INC) {
    for my $name (@names) {
      my $file = $dir."/".$name;
      if(-f $file) {
        return $file;
      }
    }
  }
  return undef;
}

our $compiler0;
our $compiler1;
our $parser0;
our $parser1;
our $emitter0;
our $emitter1;
sub ::eval_file {
  my($file)=@_;
  $compiler0->eval_file($file);
}
sub ::eval_perl6 {
  my($code)=@_;
  $compiler0->eval_perl6($code);
}

package main;
')};
sub e{my $self=CORE::shift;my($x)=@_;
my $ref = $x->ref();
if(($ref eq 'UNDEF')) {
$x
}elsif(($ref eq 'SCALAR')) {
$x
}elsif(($ref eq 'ARRAY')) {
$x->map(sub {my($ae)=@_;
$self->e($ae)})
}else {
$x->callback($self)
}};
sub cb__CompUnit{my $self=CORE::shift;my($n)=@_;
{package main; use vars '$1es_whiteboard__in_package'};local $::es_whiteboard__in_package = [];
((('package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
' . $self->prelude_for_entering_a_package()) . $self->e($n->{'statements'})->join(';
')))};
sub cb__Block{my $self=CORE::shift;my($n)=@_;
(('' . $self->e($n->{'statements'})->join(';
')) . '')};
sub cb__Use{my $self=CORE::shift;my($n)=@_;
my $module = $n->{'module_name'};
if(($module eq 'v6-alpha')) {
''
}elsif($self->compiler->hook_for_use($module)) {
''
}else {
'***Unimplemented use()***'
}};
sub cb__ClosureTrait{my $self=CORE::shift;my($n)=@_;
((($n->{'kind'} . '{') . $self->e($n->{'block'})) . '}')};
sub cb__PackageDecl{my $self=CORE::shift;my($n)=@_;
{package main; use vars '$1es_whiteboard__in_package'};local $::es_whiteboard__in_package = [$::es_whiteboard__in_package->flatten(), $n->{'name'}];
my $name = $::es_whiteboard__in_package->join('::');
(((((((((('
{ package ' . $name) . ';
') . 'use Moose;') . ' __PACKAGE__->meta->make_mutable();
') . $self->prelude_for_entering_a_package()) . $self->e(($n->{'traits'} || []))->join('
')) . $self->e($n->{'block'})) . ';
__PACKAGE__->meta->make_immutable();
') . '
}
'))};
sub cb__Trait{my $self=CORE::shift;my($n)=@_;
if((($n->{'verb'} eq 'is'))) {
my $pkgname = $::es_whiteboard__in_package->join('::');
my $name = (($::es_whiteboard__in_package->splice(0, (0 - 1))->join('::') . '::') . $self->e($n->{'expr'}));
$name->re_gsub('^::', '');
((((('BEGIN { extends((grep{/^Moose::Object$/ ? () : $_} @' . $pkgname) . '::ISA),q(') . $name) . ')) }') . '
')
}else {
::say((('ERROR: Emitting p5 for Trait verb ' . $n->{'verb'}) . ' has not been implemented.
'));
'***Trait***'
}};
sub do_VarDecl_has{my $self=CORE::shift;my($n)=@_;
my $default = $self->e($n->{'default_expr'});
if((::defined($default))) {
($default = (', default => ' . $default))
}else {
($default = '')
};
(((('has \'' . $self->e($n->{'var'}->{'name'})) . '\' => (is => \'rw\'') . $default) . ');')};
sub cb__VarDecl{my $self=CORE::shift;my($n)=@_;
if((($n->{'scope'} eq 'has'))) {
$self->do_VarDecl_has($n)
}else {
my $default = '';
if($n->{'default_expr'}) {
($default = (' = ' . $self->e($n->{'default_expr'})))
};
if((($n->{'var'}->{'twigil'} eq '^'))) {
my $name = $self->e($n->{'var'});
$name->re_gsub('^(.)::', '$1');
((((((('{package main; use vars \'' . $name) . '\'};') . 'local') . ' ') . $self->e($n->{'var'})) . $default))
}else {
((($n->{'scope'} . ' ') . $self->e($n->{'var'})) . $default)
}
}};
sub multimethods_using_hack{my $self=CORE::shift;my($n,$name,$type0)=@_;
my $stem = (('_mmd__' . $name) . '__');
my $branch_name = ($stem . $type0);
my $setup_name = ('_reset' . $stem);
my $code = '';
($code = ((((((((((((($code . '
{ my $setup = sub {
    my @meths = __PACKAGE__->meta->compute_all_applicable_methods;
    my $h = {};
    for my $m (@meths) {
      next if not $m->{name} =~ /^') . $stem) . '(\\w+)/;
      my $type = $1;
      $h->{$type} = $m->{code}{q{&!body}};
    };
    my $s = eval q{sub {
      my $ref = ref($_[1]) || "SCALAR";
      my $f = $h->{$ref}; goto $f if $f;
      Carp::croak "multi method ') . $name) . ' cant dispatch on type: ".$ref."\\n";
    }};
    die $@ if $@;
    eval q{{no warnings; *') . $name) . ' = $s;}};
    die $@ if $@;
    goto &') . $name) . ';
  };
  eval q{{no warnings; *') . $setup_name) . ' = $setup;}};
  die $@ if $@;
  eval q{{no warnings; *') . $name) . ' = $setup;}};
  die $@ if $@;
};
'));
(((((('sub ' . $branch_name) . '{my $self=CORE::shift;') . $self->e($n->{'multisig'})) . $self->e($n->{'block'})) . '}') . $code)};
sub multimethods_using_CM{my $self=CORE::shift;my($n,$name,$type0)=@_;
my $n_args = $n->{'multisig'}->{'parameters'}->elems();
($type0 = $type0->re_gsub('^Any$', '*'));
($type0 = $type0->re_gsub('^SCALAR$', '$'));
my $param_padding = '';
my $i = 1;
while(($i < $n_args)) {
($i = ($i + 1));
($param_padding = ($param_padding . ' * '))
};
((((((((('Class::Multimethods::multimethod ' . $name) . ' =>qw( * ') . $type0) . $param_padding) . ' ) => ') . 'sub {my $self=CORE::shift;') . $self->e($n->{'multisig'})) . $self->e($n->{'block'})) . '};')};
sub cb__MethodDecl{my $self=CORE::shift;my($n)=@_;
if(($n->{'plurality'} && ($n->{'plurality'} eq 'multi'))) {
my $name = $self->e($n->{'name'});
my $param_types = $n->{'multisig'}->{'parameters'}->map(sub {my($p)=@_;
my $types = $self->e($p->{'type_constraints'});
if($types) {
if(($types->elems() != 1)) {
::die('only limited multi method support')
};
$types->[0]
}else {
::undef()
}});
my $type0 = $param_types->[0];
if(::not($type0)) {
::die((('implementation limitation: a multi method\'s first parameter must have a type: ' . $name) . '
'))
};
$self->multimethods_using_CM($n, $name, $type0)
}else {
((((('sub ' . $self->e($n->{'name'})) . '{my $self=CORE::shift;') . $self->e($n->{'multisig'})) . $self->e($n->{'block'})) . '}')
}};
sub cb__SubDecl{my $self=CORE::shift;my($n)=@_;
((((('sub ' . $self->e($n->{'name'})) . '{') . $self->e($n->{'multisig'})) . $self->e($n->{'block'})) . '}')};
sub cb__Signature{my $self=CORE::shift;my($n)=@_;
if((($n->{'parameters'}->elems() == 0))) {
''
}else {
((('my(' . $self->e($n->{'parameters'})->join(',')) . ')=@_;') . '
')
}};
sub cb__Parameter{my $self=CORE::shift;my($n)=@_;
$self->e($n->{'param_var'})};
sub cb__ParamVar{my $self=CORE::shift;my($n)=@_;
($n->{'sigil'} . $self->e($n->{'name'}))};
sub cb__Call{my $self=CORE::shift;my($n)=@_;
my $method = $self->e($n->{'method'});
if((($method =~ 'postcircumfix:< >'))) {
(((($self->e($n->{'invocant'}) . '->') . '{\'') . $self->e($n->{'capture'})) . '\'}')
}elsif((($method =~ 'postcircumfix:(.*)'))) {
my $op = $1;
my $arg = $self->e($n->{'capture'});
$op->re_gsub(' ', $arg);
(($self->e($n->{'invocant'}) . '->') . $op)
}else {
((((($self->e($n->{'invocant'}) . '->') . $self->e($n->{'method'})) . '(') . $self->e($n->{'capture'})) . ')')
}};
sub cb__Apply{my $self=CORE::shift;my($n)=@_;
if(($n->{'function'} =~ qr/^infix:(.+)$/)) {
my $op = $1;
my $a = $self->e($n->{'capture'}->{'arguments'});
my $l = $a->[0];
my $r = $a->[1];
if((($op eq '~'))) {
(((('(' . $l) . ' . ') . $r) . ')')
}elsif((($op eq ','))) {
(($l . ', ') . $r)
}elsif((($op eq '='))) {
my $t = $self->e($n->{'capture'}->{'arguments'}->[0]->{'twigil'});
if((($t && ($t eq '.')))) {
((($l . '(') . $r) . ')')
}else {
(((((('(' . $l) . ' ') . $op) . ' ') . $r) . ')')
}
}else {
(((((('(' . $l) . ' ') . $op) . ' ') . $r) . ')')
}
}elsif((($self->e($n->{'function'}) =~ qr/^circumfix:(.+)/))) {
my $op = $1;
my $arg = $self->e($n->{'capture'});
$op->re_gsub(' ', $arg)
}else {
my $f = $self->e($n->{'function'});
if((($f =~ qr/^\$\w+$/))) {
((($f . '->(') . $self->e($n->{'capture'})) . ')')
}elsif((($f eq 'self'))) {
'$self'
}elsif((($f eq 'last'))) {
'last'
}elsif((($f =~ qr/^\w/))) {
(((('::' . $f) . '(') . $self->e($n->{'capture'})) . ')')
}else {
((($f . '(') . $self->e($n->{'capture'})) . ')')
}
}};
sub cb__Capture{my $self=CORE::shift;my($n)=@_;
$self->e(($n->{'arguments'} || []))->join(',')};
sub cb__For{my $self=CORE::shift;my($n)=@_;
(((('for(' . $self->e($n->{'expr'})) . '->flatten){
') . $self->e($n->{'block'})) . '
}')};
sub cb__Cond{my $self=CORE::shift;my($n)=@_;
my $els = '';
if($n->{'default'}) {
($els = (('else {
' . $self->e($n->{'default'})) . '
}'))
};
my $clauses = $self->e($n->{'clauses'});
my $first = $clauses->shift();
my $first_test = $first->[0];
if($n->{'invert_first_test'}) {
($first_test = (('not(' . $first_test) . ')'))
};
((((((('if(' . $first_test) . ') {
') . $first->[1]) . '
}') . $clauses->map(sub {my($e)=@_;
(((('elsif(' . $e->[0]) . ') {
') . $e->[1]) . '
}')})->join('')) . $els))};
sub cb__Loop{my $self=CORE::shift;my($n)=@_;
(((('while(' . $self->e($n->{'pretest'})) . ') {
') . $self->e($n->{'block'})) . '
}')};
sub cb__Var{my $self=CORE::shift;my($n)=@_;
my $s = $n->{'sigil'};
my $t = ($n->{'twigil'} || '');
my $env = '';
my $pre = '';
if(($t eq '^')) {
($env = 'e')
};
if((($s eq '$') && ($env eq 'e'))) {
($pre = 's_')
};
if(($s eq '@')) {
($pre = 'a_')
};
if(($s eq '%')) {
($pre = 'h_')
};
my $name = (($env . $pre) . $self->e($n->{'name'}));
if((($t eq '.'))) {
('$self->' . $name)
}elsif((($t eq '^'))) {
$name->re_gsub('::', '__');
(('$' . '::') . $name)
}else {
('$' . $name)
}};
sub cb__NumInt{my $self=CORE::shift;my($n)=@_;
$self->e($n->{'text'})};
sub cb__Hash{my $self=CORE::shift;my($n)=@_;
(('{' . $self->e(($n->{'hash'} || []))->join(',')) . '}')};
sub cb__Buf{my $self=CORE::shift;my($n)=@_;
my $s = ::eval_perl5('sub{local $Data::Dumper::Terse = 1; Data::Dumper::Dumper($_[0])}')->($n->{'buf'});
$s->chomp();
$s};
sub cb__Rx{my $self=CORE::shift;my($n)=@_;
(('qr/' . $n->{'pat'}) . '/')}
}
;
if(::not($emitter0)) {
($emitter0 = EmitSimpleP5->new())
};
($emitter1 = EmitSimpleP5->new())
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package EmitNoMooseP5;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
use base '::EmitSimpleP5';
sub prelude_oo{my $self=CORE::shift;'
{package Object;
    sub new {
        my $self = shift;
        my $class = ref $self || $self;
        if (ref $_[0] eq "HASH") {
            bless {%{$_[0]}}, $class;
        } else {
            bless {@_}, $class;
        }
    }
}
'};
sub cb__PackageDecl{my $self=CORE::shift;my($n)=@_;
{package main; use vars '$1es_whiteboard__in_package'};local $::es_whiteboard__in_package = [$::es_whiteboard__in_package->flatten(), $n->{'name'}];
my $name = $::es_whiteboard__in_package->join('::');
((((((('
{ package ' . $name) . ';
 use base qw(Object);
') . $self->prelude_for_entering_a_package()) . $self->e(($n->{'traits'} || []))->join('
')) . $self->e($n->{'block'})) . '
}
'))};
sub cb__Trait{my $self=CORE::shift;my($n)=@_;
if((($n->{'verb'} eq 'is'))) {
my $name = (($::es_whiteboard__in_package->splice(0, (0 - 1))->join('::') . '::') . $self->e($n->{'expr'}));
(('use base \'' . $name) . '\';
')
}else {
::say((('ERROR: Emitting p5 for Trait verb ' . $n->{'verb'}) . ' has not been implemented.
'));
'***Trait***'
}};
sub do_VarDecl_has{my $self=CORE::shift;my($n)=@_;
my $default = $self->e($n->{'default_expr'});
if((::defined($default))) {
($default = (', default => ' . $default))
}else {
($default = '')
};
(((((((((((('sub ' . $self->e($n->{'var'}->{'name'})) . ' {
') . '  if (@_ == 2) {
') . '      $_[0]{\'') . $self->e($n->{'var'}->{'name'})) . '\'} = $_[1];
') . ' } else {
') . '     $_[0]{\'') . $self->e($n->{'var'}->{'name'})) . '\'};
') . '  }
') . '}
')}
}
;
($emitter0 = EmitNoMooseP5->new());
($emitter1 = EmitNoMooseP5->new())
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package Parser;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub is_for_active_runtime {
  if (@_ == 2) {
      $_[0]{'is_for_active_runtime'} = $_[1];
 } else {
     $_[0]{'is_for_active_runtime'};
  }
}
;
sub parse{my $self=CORE::shift;my($p6_code,$claim_as_filename)=@_;
::unslurp($p6_code, 'deleteme.p6');
my $parser = $self->parser_name();
my $msg = (('Parse error in: ' . $claim_as_filename) . '
');
my $cmd = ((($parser . ' --error-message=\'') . $msg) . '\' -q --format=p5a deleteme.p6 > deleteme.dump');
((::system($cmd) == 0) or ::die('Parse failed.
'));
my $dump5 = ::slurp('deleteme.dump');
my $tree = ::eval_perl5(('package Fastdump;' . $dump5));
$tree};
sub parser_name{my $self=CORE::shift;::parser_name()}
}
;
::eval_perl5('
{ package Fastdump;
  sub match {my($r,$s,$f,$t,$h)=@_; Match->make_from_rsfth($r,$s,$f,$t,$h)}
}');
if(::not($parser0)) {
($parser0 = Parser->new('is_for_active_runtime', 1))
};
($parser1 = Parser->new())
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package Compiler;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub is_for_active_runtime {
  if (@_ == 2) {
      $_[0]{'is_for_active_runtime'} = $_[1];
 } else {
     $_[0]{'is_for_active_runtime'};
  }
}
;
sub eval_perl6{my $self=CORE::shift;my($code)=@_;
$self->eval_fragment($code, '-e', 0)};
sub eval_file{my $self=CORE::shift;my($file)=@_;
$self->eval_fragment(::slurp($file), $file, 0)};
sub eval_fragment{my $self=CORE::shift;my($code,$filename,$verbose)=@_;
my $p5 = $self->compile_fragment($code, $filename, $verbose);
::eval_perl5($p5)};
sub compile_fragment_cache_get{my $self=CORE::shift;my($code,$filename)=@_;
::undef()};
sub compile_fragment_cache_set{my $self=CORE::shift;my($code,$filename,$value)=@_;
};
sub compile_fragment{my $self=CORE::shift;my($code,$filename,$verbose)=@_;
my $tree;
my $cached = $self->compile_fragment_cache_get($code, $filename);
if($cached) {
$cached
}else {
if($self->is_for_active_runtime) {
($tree = $parser0->parse($code, $filename))
}else {
($tree = $parser1->parse($code, $filename))
};
if($verbose) {
::say($tree->match_describe())
};
my $ir = $tree->make_ir_from_Match_tree();
if($verbose) {
::say($ir->irx1_describe())
};
my $p5;
if($self->is_for_active_runtime) {
($p5 = $ir->callback($emitter0->new_emitter('compiler', $self)))
}else {
($p5 = $ir->callback($emitter1->new_emitter('compiler', $self)))
};
if($verbose) {
::say($p5)
};
$self->compile_fragment_cache_set($code, $filename, $p5);
$p5
}};
sub todo {
  if (@_ == 2) {
      $_[0]{'todo'} = $_[1];
 } else {
     $_[0]{'todo'};
  }
}
;
sub compile_executable{my $self=CORE::shift;my($sources,$output_file)=@_;
$self->todo([]);
my $p5 = ($self->prelude() . '
');
for($sources->flatten){
my $code = $_->[0];
my $file = $_->[1];
my $verbose = $_->[2];
my $more_p5 = $self->compile_fragment($code, $file, $verbose);
while(($self->todo->elems() > 0)) {
my $filename = $self->todo->shift();
my $module_p5 = $self->compile_fragment(::slurp($filename), $filename, $verbose);
($p5 = (($p5 . $module_p5) . '
;
'))
};
($p5 = (($p5 . $more_p5) . '
;
'))
};
if(($output_file eq '-')) {
::say($p5)
}else {
::unslurp($p5, $output_file)
};
['perl', $output_file]};
sub prelude{my $self=CORE::shift;if($self->is_for_active_runtime) {
$emitter0->prelude()
}else {
$emitter1->prelude()
}};
sub hook_for_use{my $self=CORE::shift;my($module)=@_;
if($self->is_for_active_runtime) {
::require($module)
}else {
my $filename = (::find_required_module($module) || ::die((((('Didnt find ' . $module) . ' in ( ') . $a_INC->join(' ')) . ' ).
')));
$self->todo->push($filename)
};
1}
}
;
if(::not($compiler0)) {
($compiler0 = Compiler->new('is_for_active_runtime', 1))
};
($compiler1 = Compiler->new())
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package Program;
 use base qw(Object);
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub print_usage_and_die{my $self=CORE::shift;::say('
Usage: [-v] [-s0|-s|-x|-xr] [-o OUTPUT_FILE] [-I dir]
         [ P6_FILE | -e P6_CODE ]+ [ -- ARGS* ]

Unlike p5, multiple P6_FILE\'s and -e P6_CODE\'s and can be mixed.
Use -- to stop.

 -v                verbose.

 default  Compile0 and eval.
 -s0      Compile0 and show the resulting framgent.
 -s       Compile1 and show the resulting fragment.
 -x       Compile1 to an executable form.
 -xr      Compile1 to an executable form, and run.

One can also do
 [ P6_FILE | -e P6_CODE ]+  these are evaled,
 -x
 [ P6_FILE | -e P6_CODE ]+  these are compiled.

');
::exit(2)};
sub main{my $self=CORE::shift;my($args)=@_;
if(($args->elems() == 0)) {
$self->print_usage_and_die()
};
my $verbose;
my $mode = 'r';
my $output_file;
my $output = sub {my($text)=@_;
if($output_file) {
::unslurp($text, $output_file)
}else {
::say($text)
}};
my $sources = [];
my $handle = sub {my($filename,$code)=@_;
if(($mode eq 'r')) {
$compiler0->eval_fragment($code, $filename, $verbose)
}elsif((($mode eq 's0') || ($mode eq 's1'))) {
my $comp;
if(($mode eq 's0')) {
($comp = $compiler0)
}else {
($comp = $compiler1)
};
$output->($comp->compile_fragment($code, $filename, $verbose))
}else {
$sources->push([$code, $filename, $verbose])
}};
my $at_end = sub {if((($mode eq 'x') && ($sources->elems() != 0))) {
if(::not($output_file)) {
($output_file = '-')
};
my $exec_args = $compiler1->compile_executable($sources, $output_file)
}elsif((($mode eq 'xr') && ($sources->elems() != 0))) {
if(::not($output_file)) {
($output_file = 'deleteme_exe')
};
my $exec_args = $compiler1->compile_executable($sources, $output_file);
::say(((('# ' . $exec_args->join(' ')) . ' ') . $args->join(' ')));
::exec($exec_args->flatten(), $args)
}};
while($args->elems()) {
my $arg = $args->shift();
if(($arg eq '-v')) {
($verbose = 1)
}elsif(($arg eq '-s0')) {
($mode = 's0')
}elsif(($arg eq '-s')) {
($mode = 's1')
}elsif(($arg eq '-x')) {
($mode = 'x')
}elsif(($arg eq '-xr')) {
($mode = 'xr')
}elsif(($arg eq '-o')) {
($output_file = ($args->shift() || $self->print_usage_and_die()))
}elsif(($arg eq '-e')) {
my $p6_code = ($args->shift() || $self->print_usage_and_die());
$handle->('-e', $p6_code)
}elsif(::file_exists($arg)) {
$handle->($arg, ::slurp($arg))
}elsif(($arg eq '-I')) {
my $dir = ($args->shift() || $self->print_usage_and_die());
$a_INC->unshift($dir)
}elsif(($arg eq '--')) {
last
}else {
$self->print_usage_and_die()
}
};
$at_end->()}
}
;
Program->new()->main($a_ARGS)
;
package main; # not Main, otherwise ::foo() hack for sub()s doesnt work.
use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
;
;
;
;
;
;
;

;
