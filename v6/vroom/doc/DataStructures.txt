The idea behind YAP6 is quite simple, not to say simplistic.

We have a "superclass" wich is YAP6__CORE__Value. This is the struct
that everything must be binary-compatible to. This idea is absolutely
not original. In fact, that's the way perl 5 works regarding SV, HV
and AV, for instance.

What is particular here, is that this basic "object" only have three
defined fields:

 * rwlock, which is a pthread_rwlock_t, so we can implement
   thread-safeness.

 * ref_cnt, which is, as it looks, reference counting for garbage
   collection.

 * dispatcher, which is itself a YAP6__CORE__Value*, but one that is a
   little more specialized, this one have a APPLY member, which is a
   pointer to a function that deals with this value. For instance, if
   the value is a code, calling APPLY on it should result in the
   method being called.

For those wondering: why do reference counting when all the cool guys
are using trace garbage collection? Well, you just can say I am
silly... but, firstly refcount is simpler to implement, and I,
personally, dislike trace garbage collecting because it simply isn't
deterministic. I don't like the idea of eventually the program getting
stalled because an alloc operation needs to call the GC, which takes
some time to trace all the objects.

The idea behind thread safeness is simply to implement a share-all
schema where we just make sure the program doesn't segfault (at least
easily), but any other syncronization must be made explicitly by the
user. The idea here is:

  * do not lock the object when accessing any of the members defined
    in YAP6__CORE__Value, YAP6__CORE__Dispatcher,
    YAP6__CORE__ListDispatcher and YAP6__CORE__HashDispatcher.

  * lock when accessing any other member.

This means that if two threads are manipulating the same value, it is
likely that one does not try to destroy the object while the other is
using it. If you want to do that, well, do the locking
yourself. Optionally, you can just increment the refcount when you
want to make sure this value will not vanish (like, creating a local
reference to the object) and decrement the refcount later. If we avoid
the case of the object being destroyed while other thread is still
using it, we just can be safe in using the "core members" without
locking.

For instance, the YAP6_APPLY macro, looks for the dispatcher member,
and does so without locking. nor the value, nor it's
dispatcher. Considering that the dispatcher has one reference in the
value, the dispatcher will never be destroyed before the value. This
way, if you increment the refcount before you use the value, it is
guaranteed that it will not be destroyed while you're using...


