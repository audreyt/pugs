=encoding utf8

=head1 NAME

SQL::Routine::Language -
Authoritative human readable design document

=head1 DESCRIPTION

SQL::Routine provides an effective language for defining relational data
models, both the means to create them and the means to interact with them;
see the documentation of L<SQL::Routine> itself (in the current
distribution) for a further introduction.

This document, SQL::Routine::Language ("Language"), is the human readable
authoritative design document for that language.  The file SQL::Routine
itself contains the machine readable language specification, which is
derived from the human readable version.  If there's a conflict between the
two, then either SQL::Routine is in error, or the developers were negligent
in updating it before Language, so you can yell at them.  Likewise, believe
Language before any other conflicting documents, unless the other documents
are emails from SQL::Routine developers, in which case they can be yelled
at again for not keeping Language up to date.

Since the SQL::Routine language is largely derived from pre-existing
language specifications such as the ANSI/ISO SQL:2003 standard, it may be
tempting to just assume everything you know from them is also true here.
While that will work in some cases (and in fact I intentionally don't
repeat many details here for brevity), it won't in others, so you should
always check here for any possible conflicts.

=head1 DATA TYPES OVERVIEW

The SQL::Routine language is strongly typed, following the relational
model's ideals of stored data integrity, and the actual practice of SQL and
many database products, and SQL::Routine's own ideals of being rigorously
defined.  However, its native set of data types also includes
ones that have the range of typical weak types such as some database
products and languages like Perl use.

A data type is a set of representable values.  All data types are based on
the concept of domains; any variable or literal that is of a particular
data type may only hold a value that is part of the domain that defines the
data type.  SQL::Routine has some native data types that it implicitly
understands (eg, booleans, integers, rational numbers, character strings,
bit strings, arrays, rows, tables), and you can define custom ones too that
are based on these (eg, counting numbers, character strings that are
limited to 10 characters in length, rows having 3 specific fields).

All SQL::Routine "domain" Nodes (and schema objects) are user defined,
having a name that you pick, regardless of whether the domain corresponds
directly to a native data type, or to one you customized; this is so
there won't be any name conflicts regardless of any same named data types
that a particular database implementation used in conjunction with
SQL::Routine may have.

=head2 Generalities

It is the general case that every data type defines a domain of values that
is mutually exclusive from every other data type; 2 artifacts having a
common data type (eg, 2 character strings) can always be compared for
equality or inequality, and 2 artifacts of different data types (eg, 1
character string and 1 bit string) can not be compared and hence are always
considered inequal.  Following this, it is mandatory that every native
and custom data type define the 'eq' (equal) and 'ne' (not equal) operators
for comparing 2 artifacts that are of that same data type.  Moreover, it is
mandatory that no data type defines for themselves any 'eq' or 'ne'
operators for comparing 2 artifacts of different data types.

In order to compare 2 artifacts of different data types for equality or
inequality, either one must be cast into the other's data type, or they
must both be cast into a common third data type.  How exactly this is done
depends on the situation at hand.

The simplest casting scenario is when there is a common domain that both
artifacts belong to, such as happens when either one artifact's data type
is a sub-domain of the other (eg, an integer and a rational number), or the
data types of both are sub-domains of a common third data type (eg, even
numbers and square whole numbers).  Then both artifacts are cast as the
common parent type (eg, rationals and integers respectively).

A more difficult but still common casting scenario is when the data types
of two artifacts do not have a common actual domain, but yet there is one
or more commonly known or explicitly defined way of mapping members of one
type's domain to members of the other type's domain.  Then both artifacts
can be cast according to one of the candidate mappings.  A common example
of this is numbers and character strings, since numbers are often expressed
as characters, such as when they come from user input or will be displayed
to the user; sometimes characters are expressed as numbers too, as an
encoding.  One reason the number/character scenario is said to be more
difficult is due to there being multiple ways to express numbers in
character strings, such as octal vs decimal vs hexadecimal, so you have to
explicitly choose between multiple casting methods or formats for the
version you want; in other words, there are multiple members of one domain
that map to the same member of another domain, so you have to choose; a
cast method can not be picked simply on the data type of the operands.

A different casting scenario occurs when one or both of the data types are
composite types, such as 2 tuples that are either of different degrees or
that have different attribute names or value types.  Dealing with these
involves mapping all the attributes of each tuple against the other, with
or without casting of the individual attributes, possibly into a third data
type having attributes to represent all of those from the two.

Most data types support the extraction of part of an artifact to form a new
artifact, which is either of the same data type or a different one.  In
some cases, even if 2 artifacts can't be compared as wholes, it is possible
to compare an extract from one with the other, or extractions from both
with each other.  Commonly this is done with composite data types like
tuples, where some attributes are extracted for comparison, such when
joining the tuples, or filtering a tuple from a relation.

Aside from the 'eq' and 'ne' comparison operators, there are no other
mandatory operators that must be defined for a given custom data type,
though the native ones will include others.  However, it is strongly
recommended that each data type implement the 'cmp' (comparison) operator
so that linearly sorting 2 artifacts of that common data type is a
deterministic activity.

SQL::Routine requires that all data types are actually self-contained,
regardless of their complexity or size.  So nothing analagous to a
"reference" or "pointer" in the Perl or C or SQL:2003 sense may be stored;
the only valid way to say that two artifacts are related is for them to be
equal, or have attributes that are equal, or be stored in common or
adjoining locations.

=head2 Native Null Type

SQL::Routine natively supports the special NULL data type, whose value
domain is by definition mutually exclusive of the domains of all other data
types; in practice, a NULL is distinct from all possible values that the
other SQL::Routine native primitive types can have.  But some native
complex types and user customized types could be defined where their
domains are a super-set of NULL; those latter types are described as
"nullable", while types whose domains are not a super-set of NULL are
described as "not nullable".

The NULL data type represents situations where a value of an arbitrary data
type is desired but none is yet known; it sits in place of the absent value
to indicate that fact.  NULL artifacts will always explicitly compare as
being unequal to each other; since they all represent unknowns, we can not
logically say any are equal, so they are all treated as distinct.  This
data type corresponds to SQL's concept of NULL, and is similar to Perl's
concept of "undef".  A NULL does not natively cast between any data types.

SQL::Routine does not allow you to declare "domain" Nodes that are simply
of or based on the data type NULL; rather, to use NULL you must declare
"domain" Nodes that are either based on a not-nullable data type unioned
with the NULL type, or are based on a nullable data type.  The "domain"
Node type provides a short-hand to indicate the union of its base type with
NULL, in the form of the boolean "is_nullable" attribute; if the attribute
is undefined, then the nullability status of the base data type is
inherited; if it is defined, then it overrides the parent's status.

All not-nullable native data types default to their concept of empty or
nothingness, such as zero or the empty string.  All nullable native
types, and all not-nullable native types that you customize with a true
is_nullable, will default to NULL.  In either case, you can define an
explicit default value for your custom data type, which will override those
behaviours; details are given further below.

=head2 Native Primitive Types

These are the simplest data types, from which all others are derived:

=over

=item C<BOOLEAN>

This data type is a single logical boolean, whose only possible values are
FALSE and TRUE.  Its concept of nothingness is FALSE.

=item C<NUMERIC>

This data type is a single rational number.  Its concept of nothingness is
zero.  A subtype of NUMERIC must specify the radix-agnostic "num_precision"
and "num_scale" attributes, which determine the maximum valid range of the
subtype's values, and the subtype's storage representation can often be
derived from it too.

The "num_precision" attribute is an integer >= 1; it specifies the maximum
number of significant values that the subtype can represent.  The
"num_scale" attribute is an integer >= 0 and <= "num_precision"; if it is
>= 1, the subtype is a fixed radix point rational number, such that 1 /
"num_scale" defines the increment size between adjacent possible values;
the trivial case of "num_scale" = 1 means the increment size is 1, and the
number is an integer; if "num_scale" = 0, the subtype is a floating radix
point rational number where "num_precision" represents the product of the
maximum number of significant values that the subtype's mantissa and
exponent can represent.  SQL::Routine does not currently specify how much
of a floating point number's "num_precision" is for the mantissa and how
much for the exponent, but commonly the exponent takes a quarter.

The meanings of "precision" and "scale" are more generic for SQL::Routine
than they are in the SQL:2003 standard; in SQL, "precision" (P) means the
maximum number of significant figures, and the "scale" (S) says how many of
those are on the right side of the radix point.  Translating from base-R
(eg, R being 10 or 2) to the SQL::Routine meanings are as follows (assuming
negative numbers are allowed and zero is always in the middle of a range).
For fixed-point numerics, a (P,S) becomes (2*R^P,R^S), meaning an integer
(P,0) becomes (2*R^P,1).  For floating-point numerics, a (P) sort-of
becomes (2*R^P,0); I say sort-of because SQL:2003 says that the P shows
significant figures in just the mantissa, but SQL::Routine currently says
that the size of the exponent eats away from that, commonly a quarter.

As examples, a base-10 fixed in SQL defined as [p=10,s=0] (an integer in
-10^10..10^10-1) becomes [p=20_000_000_000,s=1] in SQL::Routine; the
base-10 [p=5,s=2] (a fixed in -1_000.00..999.99) becomes [p=200_000,s=100];
the base-2 [p=15,s=0] (a 16-bit int in -32_768..32_767) becomes
[p=65_536,s=1]; the base-2 float defined as [p=31] (a 32-bit float in
+/-8_388_608*2^+/-128) becomes [p=4_294_967_296,s=0].

A subtype of NUMERIC may specify the "num_min_value" and/or "num_max_value"
attributes, which further reduces the subtype's valid range.  For example,
a minimum of 1 and maximum of 10 specifies that only numbers in the range
1..10 (inclusive) are allowed.  Simply setting the minimum to zero and
leaving the maximum unset is the recommended way in SQL::Routine to specify
that you want to allow any non-negative number.  Setting the minimum >= 0
also causes the maximum value range allowable by "num_precision" to shift
into the positive, rather than it being half there and half in the
negative.  Eg, an (P,S) of (256,1) becomes 0..255 when the minimum = 0,
whereas it would be -128..127 if the min/max are unset.

=item C<CHAR_STR>

This data type is a string of characters.  Its concept of nothingness is
the empty string.  A subtype of CHAR_STR must specify the "char_max_length"
and "char_repertoire" attributes, which determine the maximum valid range
of the subtype's values, and the subtype's storage representation can often
be derived from it too.

The "char_max_length" attribute is an integer >= 0; it specifies the
maximum length of the string in characters (eg, a 100 means a string of
0..100 characters can be stored).  The "char_repertoire" enumerated
attribute specifies what individual characters there are to choose from
(eg, Unicode 4.1, Ascii 7-bit, Ansel; Unicode is the recommended choice).

A subtype of CHAR_STR may specify the "char_min_length" attribute, which
means the length of the character string must be at least that long (eg, to
say strings of length 6..10 are required, set min to 6 and max to 10).

=item C<STR_BIT>

This data type is a string of bits.  Its concept of nothingness is the
empty string.  A subtype of BIT_STR must specify the "bit_max_length"
attribute, which determines the maximum valid range of the subtype's
values, and the subtype's storage representation can often be derived from
it too.

The "bit_max_length" attribute is an integer >= 0; it specifies the maximum
length of the string in characters (eg, an 8000 means a string of 0..8000
bits can be stored).

A subtype of BIT_STR may specify the "bit_min_length" attribute, which
means the length of the bit string must be at least that long (eg, to say
strings of length 24..32 are required, set min to 24 and max to 32).

=back

A subtype of any of these native primitive types can define a default value
for the subtype, it can define whether the subtype is nullable or not (they
are all not-nullable by default), and it can enumerate an explicit list of
allowed values (eg, [4, 8, 15, 16, 23, 42], or ['foo', 'bar', 'baz'], or
[B'1100', B'1001']), one each in a child Node (these must fall within the
specified range/size limits otherwise defined for the subtype).

=head2 Native Scalar Type

SQL::Routine has native support for a special SCALAR data type, which is
akin to SQLite's weakly typed table columns, or to Perl's weakly typed
default scalar variables.  This data type is a union of the domains of the
BOOLEAN, NUMERIC, CHAR_STR, and BIT_STR data types; it is not-nullable by
default.  Its concept of nothingness is the empty string.

=head1 SEE ALSO

During my work on this project, I found the following resources to be
particularly useful:

=over

=item L<http://www.acm.org/classics/nov95/toc.html>

Edgar F. Codd - "A Relational Model of Data for Large Shared Data Banks"

Reprinted from I<Communications of the ACM>, Vol. 13, No. 6, June 1970, pp.
377-387. Copyright © 1970, Association for Computing Machinery, Inc.

This is the famous 1970 publication that first presented a relational model
of data to the world, which is the basis for the modern database industry.

=item L<http://www.wiscorp.com/SQLStandards.html>

This web page of Whitemarsh Information Systems Corporation, run by one of
the people on the SQL standard drafting community, has copies of the
official SQL:2003 and SQL:1999 specification documents, and other related
helpful documents about SQL, in PDF format.  For example, "an almost
indistinguishable delta on the actual SQL 2003 database standard" is at
L<http://www.wiscorp.com/sql/sql_2003_standard.zip> (warning, large file).

=item L<http://www.oreilly.com/catalog/databaseid/>

Chris J. Date - "Database in Depth: Relational Theory for Practitioners"

First Edition, May 2005.  Published by O'reilly.  ISBN: 0-596-10012-4

This book lays out what the relational data model really is, in partial
contrast to how SQL does it, from the man that was closer to and more
directly involved with Edgar F. Codd in this work work than anyone.

=item L<http://www.unicode.org/standard/standard.html>

Unicode Standard official documentation.

=item L<http://en.wikipedia.org/wiki/Relational_model>

The Wikipedia article on the relational data model, and related topics.

=back

Also, the vendor documentation for various relational and/or SQL databases
such as MySQL and SQLite were regularly consulted, and various other sites.

=head1 AUTHOR

Darren R. Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENCE AND COPYRIGHT

This file is part of the SQL::Routine database portability library.

SQL::Routine is Copyright (c) 2002-2005, Darren R. Duncan.

See the LICENCE AND COPYRIGHT of L<SQL::Routine> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<SQL::Routine> apply to this file too.

=cut
