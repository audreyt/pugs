Compile-Time objects

See Also: S06 

The compile-time system builds a 'Program' object.

"$program" stringifies to compiled code.

Environment

- contains the declarations in scope: variables, subroutines
- also contains 'want' info.

Methods

."" (overloaded stringification) - stringifies to source code

.boxed - creates a boxed object. Example: int.box -> Int
.unboxed - unboxes an object. Example: Int.unbox -> int

.WHAT  - returns the class as a Class (which stringifies to the class name)
.perl  - returns a Str, which contains the object dumped as Perl6 source code  XXX
.list  

Coercions

.str .num .int .bool

Class-specific operations - for example:

.print - returns the code to execute '.print'
.true
.not
.== (encoded to ASCII, as '_61__61_')
.eq
.elems

Container operations 

.bind( $cell )
.bind_from - returns this container's cell (as plain source code, not an object)

.VAR - returns this container's cell
    $native.bind_from is read-only
    $native.VAR is read-write 

.STORE( $value )
.FETCH - returns the cell value

.array .hash .scalar - coerce values into containers

.my .our - emit declarations

.[] 
.{} 

.[ $value ]
.{ $value }

--------------

Classes

See also: S06:Built-in Types

Native types

...


Undefined types

...


Immutable types

Seq
List
...

Mutable types

Array
Hash
...

Other types - See S06

Value types, Implementation types, Hierarchical types, Polymorphic types, Parameter types, Generic types, Return types

Special Classes

These classes are used internally to optimize the implementation, by moving boxing and type-checks to compile-time.

(Type)Scalar - a typed Scalar
  ArrayScalar
  HashScalar
  ValueScalar

(Type)Seq - a typed Seq 
  ArraySeq
    - An Array that doesn't contain Lazy components. This can be represented by a Perl5 Array.
  HashSeq

(Type)Expression - a typed expression
  AnyExpression 
  BoolExpression
  IntExpression
  StrExpression
  ...
  ArrayExpression
  HashExpression

NamedScalar - '$a'
  A Scalar called by name

NamedArray - '@a'
  An Array called by name

NamedHash - '%h'
  A Hash called by name

(TODO)
  A Hash that only has Stringified keys. This can be represented by a Perl5 Hash.

--------------

Miscellaneus 

* use ::unicode_sub sub {...} to define methods with non alphanumeric names

--------------

Data Structures for Pure-Perl Scalars

See also: 'type-example.pl'

-- Run time

    $$a - a Scalar's value - '=' lvalue or rvalue
    $a  - a Scalar's cell  - ':=' lvalue or rvalue

-- Compile time objects

    $$a - an Expression object
        - AnyExpression, IntExpression, ...
        - or, NamedRValue
    $a  - a NamedScalar object

        $a  = Array... 
                   - NamedArray scalar cell
      ${$a} = \@a  - NamedArray list (@a[]) or ArrayScalar ($a[])
      ${$a}->[1]   - ScalarExpression
    ${${$a}->[1]}  - RValueExpression

-- Method examples

    $a->set(...)
        - call .set method on $a's cell, with optional type checking
    $a->bind(...)
        - call .bind method on $a, with optional type checking

    $$a->str()
        - call stringification method on $a's value

--- Class Hierarchy

<TimToady> ?eval Scalar.isa(Any)
<evalbot_r14454> Bool::True
<TimToady> ?eval Junction.isa(Any)
<evalbot_r14454> Bool::False
<TimToady> Junctions are only quasi-objects, insofar as they represent a linguistic notion rather than an, er, object notion
<TimToady> when you say "if A equals 1 or 2" the 1 or 2 is not a real thing.
<fglock> ?eval undef.isa(Any)
<evalbot_r14454> Bool::True
<fglock> ?eval undef.WHAT
<evalbot_r14454> ::Scalar
<fglock> is it an ro Scalar?
<TimToady> ?eval undef = 1;
<evalbot_r14454> Error: Can't modify constant item: VUndef
<TimToady> apparently so.  :)

<fglock> ?eval {42}.WHAT
<evalbot_r14454> ::Scalar
<fglock> I didn't mean to execute the block
<fglock> ?eval {}.WHAT # Hash?
*** evalbot_r14454 is now known as evalbot_r14455
<evalbot_r14455> ::Scalar
<TimToady> ?eval ({42}.WHAT)
<evalbot_r14455> ::Block
<TimToady> ?eval {42}    .WHAT
<evalbot_r14455> ::Scalar
<TimToady> this is one of the suprising results of forcing statement-begining { to start a bare block.

-- Questions

    $a[10] := 1;
    @$a = ();  # error ???
  
    my Int $a;
    my Str $b;
    $a := $b;  # error ???

    (1,2,3)[1]     # ok - splice a List
    (1,2,3)[1]=5   # error - List is read-only; doesn't coerce List into Array
    [1,2,3][1]=5   # ok - Array is read-write

    - is the type of "0 but True" something like ::(Int|Bool) ?

    - can multis dispatch on a constant? multi a(1){ "first" }; multi a(2){ "second" }; multi a { "other" };

