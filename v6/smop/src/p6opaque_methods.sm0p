#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <smop.h>
#include <smop_oo.h>
#include <smop_lowlevel.h>
#include "p6opaque.h"

typedef struct SMOP__p6opaque__Array__methods_struct {
  SMOP__Object__BASE
  SMOP__Object* instance;
} SMOP__p6opaque__Array__methods_struct;

SMOP__Object* SMOP__p6opaque__Array__methods;

static SMOP__Object* p6opaque_methods_message(SMOP__Object* interpreter,
                                              SMOP__ResponderInterface* self,
                                              SMOP__Object* identifier,
                                              SMOP__Object* capture) {

  SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter,capture);

  if (identifier == SMOP__ID__DESTROYALL) {
    smop_lowlevel_wrlock(invocant);
    SMOP__Object* instance = ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance;
    ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance = NULL;
    smop_lowlevel_unlock(invocant);
    SMOP_RELEASE(interpreter,instance);

  } else if (identifier == SMOP__ID__push) {
    //fprintf(stderr,"[smop p6opaque methods] push called.\n");

  } else if (identifier == SMOP__ID__shift) {
    //fprintf(stderr,"[smop p6opaque methods] shift called.\n");

  } else {
    fprintf(stderr,"[smop p6opaque methods] unknown method called.\n");
  }

  SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return SMOP__NATIVE__bool_false;
}

static SMOP__Object* p6opaque_methods_reference(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__Array__methods != obj) {
    printf("+ %p\n",obj);
    smop_lowlevel_refcnt_inc(interpreter, responder, obj);
  }
  return obj;
}

static SMOP__Object* p6opaque_methods_release(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__Array__methods != obj) {
    printf("- %p\n",obj);
    smop_lowlevel_refcnt_dec(interpreter, responder, obj);
  }
  return obj;
}

extern void p6opaque_methods_init() {
  SMOP__p6opaque__Array__methods = calloc(1,sizeof(SMOP__ResponderInterface));
  assert(SMOP__p6opaque__Array__methods);
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->MESSAGE = p6opaque_methods_message;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->REFERENCE = p6opaque_methods_reference;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->RELEASE = p6opaque_methods_release;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->id = "p6opaque methods array";
}

extern void p6opaque_methods_destr() {
  free(SMOP__p6opaque__Array__methods);
}

extern SMOP__Object* p6opaque_methods_array_create(SMOP__Object* interpreter,
                                                   SMOP__Object* invocant) {
  SMOP__Object* ret = smop_lowlevel_alloc(sizeof(SMOP__p6opaque__Array__methods_struct));
  ret->RI = (SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods;
  ((SMOP__p6opaque__Array__methods_struct*)ret)->instance = SMOP_REFERENCE(interpreter,invocant);
  return ret;
}


