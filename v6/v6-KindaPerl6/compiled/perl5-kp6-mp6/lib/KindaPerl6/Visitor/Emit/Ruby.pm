# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;

package KindaPerl6::Visitor::Emit::Ruby;
sub new { shift; bless {@_}, "KindaPerl6::Visitor::Emit::Ruby" }
sub visitor_args { @_ == 1 ? ( $_[0]->{visitor_args} ) : ( $_[0]->{visitor_args} = $_[1] ) }

sub visit {
    my $self   = shift;
    my $List__ = \@_;
    my $node;
    do { $node = $List__->[0]; [$node] };
    $node->emit_ruby( $self->{visitor_args}->{'secure'} );
}

package CompUnit;
sub new { shift; bless {@_}, "CompUnit" }

sub set_secure_mode {
    my $List__ = \@_;
    my $args_secure;
    do { $args_secure = $List__->[0]; [$args_secure] };
    my $value = '0';
    do {
        if ($args_secure) { $value = '1' }
        else              { }
    };
    return ( ( 'use constant KP6_DISABLE_INSECURE_CODE => ' . ( $value . ( ';' . Main::newline() ) ) ) );
}

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    my $args_secure;
    do { $args_secure = $List__->[0]; [$args_secure] };
    $KindaPerl6::Visitor::Emit::Ruby::current_compunit = $self->{name};
    my $source = '';
    do {
        if ( $self->{body} ) { $source = $self->{body}->emit_ruby() }
        else                 { }
    };
    do {
        if ( ( ( $self->{unit_type} eq 'class' ) || ( $self->{unit_type} eq 'grammar' ) ) ) { $source = ( 'class ' . ( $self->{name} . ( Main::newline() . ( $source . ( Main::newline() . ( 'end' . Main::newline() ) ) ) ) ) ) }
        else                                                                                { }
    };
    my $src = (
        '# Machine-generated ruby code.'
            . (
            Main::newline() . ( '# Ruby version >= 1.9.0 2007-12-25 is needed. unit_type = ' . ( $self->{unit_type} . ( Main::newline() . ( 'require \'kp6_runtime\'' . ( Main::newline() . ( Main::newline() . ( $source . Main::newline() ) ) ) ) ) ) )
            )
    );
    Main::emit_ruby_kludge_commas($src);
}

package Val::Int;
sub new { shift; bless {@_}, "Val::Int" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' ' . ( $self->{int} . '' ) );
}

package Val::Bit;
sub new { shift; bless {@_}, "Val::Bit" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' Bit.new(' . ( ( $self->{bit} ? 'true' : 'false' ) . ')' ) );
}

package Val::Num;
sub new { shift; bless {@_}, "Val::Num" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' ' . ( $self->{num} . '' ) );
}

package Val::Buf;
sub new { shift; bless {@_}, "Val::Buf" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' ' . ( Main::singlequote() . ( Main::mangle_string( $self->{buf} ) . Main::singlequote() ) ) );
}

package Val::Char;
sub new { shift; bless {@_}, "Val::Char" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' ' . ( $self->{char} . '.chr()' ) );
}

package Val::Undef;
sub new { shift; bless {@_}, "Val::Undef" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ' Undef.new()';
}

package Val::Object;
sub new { shift; bless {@_}, "Val::Object" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die('Emitting of Val::Object not implemented');
}

package Native::Buf;
sub new { shift; bless {@_}, "Native::Buf" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die('Emitting of Native::Buf not implemented');
}

package Lit::Seq;
sub new { shift; bless {@_}, "Lit::Seq" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '(' . ( Main::join( [ map { $_->emit_ruby() } @{ $self->{seq} } ], ',,, ' ) . ')' ) );
}

package Lit::Array;
sub new { shift; bless {@_}, "Lit::Array" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( '[' . ( Main::join( [ map { $_->emit_ruby() } @{ $self->{array} } ], ',,, ' ) . ']' ) );
}

package Lit::Hash;
sub new { shift; bless {@_}, "Lit::Hash" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $fields = $self->{hash};
    my $str    = '';
    my $field;
    do {
        for my $field ( @{$fields} ) { $str = ( $str . ( ', ' . ( $field->[0]->emit_ruby() . ( ': ' . ( $field->[1]->emit_ruby() . '' ) ) ) ) ) }
    };
    $str = substr( $str, 1 );
    ( '{' . ( $str . ( ' }' . Main::newline() ) ) );
}

package Lit::Pair;
sub new { shift; bless {@_}, "Lit::Pair" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' Pair.new(' . ( $self->{key}->emit_ruby() . ( ', ' . ( $self->{value}->emit_ruby() . ')' ) ) ) );
}

package Lit::NamedArgument;
sub new { shift; bless {@_}, "Lit::NamedArgument" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' Ruddy::NamedArgument.new(' . ( $self->{key}->emit_ruby() . ( ', ' . ( ( defined( $self->{value} ) ? $self->{value}->emit_ruby() : 'Undef.new' ) . ')' ) ) ) );
}

package Lit::SigArgument;
sub new { shift; bless {@_}, "Lit::SigArgument" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    (   ' si('
            . (
            '\''
                . (
                $self->{key}->sigil()
                    . (
                    '\','
                        . (
                        '\''
                            . (
                            $self->{key}->twigil()
                                . (
                                '\','
                                    . (
                                    '\''
                                        . (
                                        $self->{key}->name()
                                            . (
                                            '\','
                                                . (
                                                ( ( $self->{has_default} && $self->{has_default}->bit() ) ? $self->{value}->emit_ruby() : 'nil' )
                                                . ( ''
                                                        . (
                                                        ( ( $self->{is_named_only} && $self->{is_named_only}->bit() ) ? ',:is_named_only' : '' )
                                                        . ( ( ( $self->{is_optional_only} && $self->{is_optional_only}->bit() ) ? ',:is_optional_only' : '' )
                                                            . ( ( ( $self->{is_slurpy} && $self->{is_slurpy}->bit() ) ? ',:is_slurpy' : '' )
                                                                . (   ( ( $self->{is_multidimensional} && $self->{is_multidimensional}->bit() ) ? ',:is_multidimensional' : '' )
                                                                    . ( ( ( $self->{is_rw} && $self->{is_rw}->bit() ) ? ',:is_rw' : '' ) . ( ( ( $self->{is_copy} && $self->{is_copy}->bit() ) ? ',:is_copy' : '' ) . ')' ) )
                                                                )
                                                            )
                                                        )
                                                        )
                                                )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
    );
}

sub emit_ruby_name {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $namespace = [];
    Main::mangle_name_ruby( $self->{key}->sigil(), $self->{key}->twigil(), $self->{key}->name(), $namespace );
}

package Lit::Code;
sub new { shift; bless {@_}, "Lit::Code" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( $self->{CATCH} ) { ( 'do { eval {' . ( $self->emit_ruby_declarations() . ( $self->emit_ruby_body() . ( '};if ($@) {' . ( $self->{CATCH}->emit_ruby() . '}}' ) ) ) ) ) }
        else {
            my $our_declarations = '';
            my $my_names         = '';
            my $my_containers    = '';
            do {
                for my $aDecl ( @{ $self->{pad}->lexicals() } ) {
                    my $var       = $aDecl->var();
                    my $container = $var->emit_ruby_container();
                    my $scope     = $aDecl->decl();
                    do {
                        if ( ( $scope eq 'our' ) ) { $our_declarations = ( $our_declarations . ( 'def_our(:' . ( $aDecl->emit_ruby() . ( ',' . ( $container . ( '.new)' . Main::newline() ) ) ) ) ) ) }
                        else                       { }
                    };
                    do {
                        if ( ( $scope eq 'my' ) ) { $my_names = ( $my_names . ( ',' . $aDecl->emit_ruby() ) ); $my_containers = ( $my_containers . ( ',' . ( $container . '.new' ) ) ) }
                        else                      { }
                        }
                }
            };
            $my_names      = substr( $my_names,      1 );
            $my_containers = substr( $my_containers, 1 );
            my $before_body = '';
            my $after_body  = '';
            do {
                if ( ( $my_names ne '' ) ) { $before_body = ( '(->(' . ( $my_names . ( '){ ' . Main::newline() ) ) ); $after_body = ( '}).(' . ( $my_containers . ( ')' . Main::newline() ) ) ) }
                else                       { }
            };
            my $result = ( $our_declarations . ( $before_body . ( $self->emit_ruby_body() . $after_body ) ) );
            return ($result);
        }
        }
}

sub emit_ruby_body {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    Main::join( [ map { $_->emit_ruby() } @{ $self->{body} } ], '; ' );
}

sub emit_ruby_signature {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    $self->{sig}->emit_ruby();
}

sub emit_ruby_comma_separated_names {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s = '';
    my $decl;
    do {
        for my $decl ( @{ $self->{pad}->lexicals() } ) { $s = ( $s . ( ',' . $decl->emit_ruby() ) ) }
    };
    $s = substr( $s, 1 );
    return ($s);
}

sub emit_ruby_comma_separated_containers {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s = '';
    my $decl;
    do {
        for my $decl ( @{ $self->{pad}->lexicals() } ) { my $var = $decl->var(); $s = ( $s . ( ',' . ( $var->emit_ruby_container() . '.new' ) ) ) }
    };
    $s = substr( $s, 1 );
    return ($s);
}

sub emit_ruby_declarations {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s;
    my $name;
    do {
        for my $name ( @{ $self->{pad}->lexicals() } ) {
            my $decl = Decl->new( 'decl' => 'my', 'type' => '', 'var' => Var->new( 'sigil' => '', 'twigil' => '', 'name' => $name, 'namespace' => [], ), );
            $s = ( $s . ( $name->emit_ruby() . ( ';' . Main::newline() ) ) );
        }
    };
    return ($s);
}

sub emit_ruby_arguments {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $array_  = Var->new( 'sigil' => '@', 'twigil' => '', 'name' => '_',       'namespace' => [], );
    my $hash_   = Var->new( 'sigil' => '%', 'twigil' => '', 'name' => '_',       'namespace' => [], );
    my $CAPTURE = Var->new( 'sigil' => '$', 'twigil' => '', 'name' => 'CAPTURE', 'namespace' => [], );
    my $CAPTURE_decl = Decl->new( 'decl' => 'my', 'type' => '', 'var' => $CAPTURE, );
    my $str = '';
    $str = ( $str . $CAPTURE_decl->emit_ruby() );
    $str = ( $str . Decl->new( 'decl' => 'my', 'type' => '', 'var' => $array_, )->emit_ruby() );
    $str = ( $str . '::DISPATCH_VAR($CAPTURE,"STORE",::CAPTURIZE(\@_));' );
    my $bind_array = Assign->new( 'parameters' => $array_, 'arguments' => Call->new( 'invocant' => $CAPTURE, 'method' => 'array', 'arguments' => [], ), );
    $str = ( $str . ( $bind_array->emit_ruby() . ';' ) );
    my $bind_hash = Bind->new( 'parameters' => $hash_, 'arguments' => Call->new( 'invocant' => $CAPTURE, 'method' => 'hash', 'arguments' => [], ), );
    $str = ( $str . ( $bind_hash->emit_ruby() . ';' ) );
    my $i = 0;
    my $field;
    $str = ( $str . '{ my $_param_index = 0; ' );
    do {

        for my $field ( @{ $self->{sig}->positional() } ) {
            my $bind_named = Bind->new( 'parameters' => $field->key(), 'arguments' => Call->new( 'invocant' => $hash_, 'arguments' => [ Val::Buf->new( 'buf' => $field->key()->name(), ) ], 'method' => 'LOOKUP', ), );
            my $bind_default = Bind->new( 'parameters' => $field->key(), 'arguments' => $field->value(), );
            $str = (
                $str
                    . (
                    ' if ( ::DISPATCH( $GLOBAL::Code_exists, '
                        . (
                        ' \'APPLY\', '
                            . (
                            ' ::DISPATCH( '
                                . (
                                ' $Hash__, \'LOOKUP\', '
                                    . (
                                    ' ::DISPATCH( $::Str, \'new\', \''
                                        . (
                                        $field->key()->name()
                                            . (
                                            '\' ) '
                                                . (
                                                ' ) )->{_value} '
                                                    . (
                                                    ' ) '
                                                        . (
                                                        ' { '
                                                            . (
                                                            $bind_named->emit_ruby()
                                                                . (
                                                                ' } '
                                                                    . (
                                                                    ' elsif ( ::DISPATCH( $GLOBAL::Code_exists, '
                                                                        . (
                                                                        ' \'APPLY\', '
                                                                            . (
                                                                            ' ::DISPATCH( '
                                                                                . (
                                                                                ' $List__, \'INDEX\', '
                                                                                    . (
                                                                                    ' ::DISPATCH( $::Int, \'new\', $_param_index ) '
                                                                                        . (
                                                                                        ' ) )->{_value} '
                                                                                            . (
                                                                                            ' ) '
                                                                                                . (
                                                                                                ' { '
                                                                                                    . (
                                                                                                    $field->key()->emit_ruby()
                                                                                                        . ( ' = ::DISPATCH( ' . ( ' $List__, \'INDEX\', ' . ( ' ::DISPATCH( $::Int, \'new\', $_param_index++ ) ' . ( ' ); ' . ' } ' ) ) ) )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
            );
            do {
                if ( $field->has_default()->bit() ) { $str = ( $str . ( ' else { ' . ( $bind_default->emit_ruby() . ' } ' ) ) ) }
                else                                { }
            };
            $i = ( $i + 1 );
        }
    };
    $str = ( $str . '} ' );
    return ($str);
}

package Lit::Object;
sub new { shift; bless {@_}, "Lit::Object" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $fields = $self->{fields};
    my $str    = '';
    my $field;
    do {
        for my $field ( @{$fields} ) { $str = ( $str . ( ', Ruddy::NamedArgument.new(' . ( $field->[0]->emit_ruby() . ( ', ' . ( $field->[1]->emit_ruby() . ')' ) ) ) ) ) }
    };
    $str = substr( $str, 1 );
    ( ' ' . ( $self->{class} . ( '.m_new(nil,nil,[ ' . ( $str . ( ' ])' . Main::newline() ) ) ) ) );
}

package Assign;
sub new { shift; bless {@_}, "Assign" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $node = $self->{parameters};
    do {
        if ( ( Main::isa( $node, 'Var' ) && @{ $node->namespace() } ) ) {
            $node = Apply->new(
                'code'      => Var->new( 'name' => 'ternary:<?? !!>', 'twigil' => '', 'sigil' => '&', 'namespace' => ['GLOBAL'], ),
                'arguments' => [
                    Apply->new( 'arguments' => [$node], 'code' => Var->new( 'name' => 'VAR_defined', 'twigil' => '', 'sigil' => '&', 'namespace' => ['GLOBAL'], ), ),
                    $node, Bind->new( 'parameters' => $node, 'arguments' => Call->new( 'invocant' => Var->new( 'name' => '::Scalar', 'twigil' => '', 'sigil' => '$', 'namespace' => [], ), 'method' => 'new', 'hyper' => '', ), )
                ],
            );
        }
        else { }
    };
    ( ' ' . ( $node->emit_ruby() . ( '._(' . ( $self->{arguments}->emit_ruby() . ')' ) ) ) );
}

package Var;
sub new { shift; bless {@_}, "Var" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $table = { '$' => '$', '@' => '$List_', '%' => '$Hash_', '&' => '$Code_', };
    do {
        if ( ( $self->{name} eq '/' ) ) { return ( ( $table->{ $self->{sigil} } . 'MATCH' ) ) }
        else                            { }
    };
    do {
        if ( @{ $self->{namespace} } ) {
            my $s;
            my $var = Main::mangle_name( $self->{sigil}, $self->{twigil}, $self->{name}, $self->{namespace} );
            do {
                if ( ( $self->{sigil} eq '$' ) ) { $s = '$::Scalar' }
                else                             { }
            };
            do {
                if ( ( $self->{sigil} eq '&' ) ) { $s = '$::Routine' }
                else                             { }
            };
            do {
                if ( ( $self->{sigil} eq '%' ) ) { $s = '$::HashContainer' }
                else                             { }
            };
            do {
                if ( ( $self->{sigil} eq '@' ) ) { $s = '$::ArrayContainer' }
                else                             { }
            };
            return ( ( ' ( ' . ( $var . ( ' = ' . ( $var . ( ' || ::DISPATCH( ' . ( $s . ( ', "new", ) ' . ( ' ) ' . Main::newline() ) ) ) ) ) ) ) ) );
        }
        else { }
    };
    return ( Main::mangle_name_ruby( $self->{sigil}, $self->{twigil}, $self->{name}, $self->{namespace} ) );
}

sub emit_ruby_container {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s;
    do {
        if ( ( $self->{sigil} eq '$' ) ) { $s = 'Scalar' }
        else                             { }
    };
    do {
        if ( ( $self->{sigil} eq '&' ) ) { $s = 'Routine' }
        else                             { }
    };
    do {
        if ( ( $self->{sigil} eq '%' ) ) { $s = 'HashContainer' }
        else                             { }
    };
    do {
        if ( ( $self->{sigil} eq '@' ) ) { $s = 'ArrayContainer' }
        else                             { }
    };
    return ($s);
}

package Bind;
sub new { shift; bless {@_}, "Bind" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( ( Main::isa( $self->{parameters}, 'Call' ) || ( Main::isa( $self->{parameters}, 'Var' ) && ( $self->{parameters}->sigil() eq '@' ) ) ) ) {
            return ( ( '::DISPATCH_VAR( ' . ( $self->{parameters}->emit_ruby() . ( ', "BIND", ' . ( $self->{arguments}->emit_ruby() . ' )' ) ) ) ) );
        }
        else { }
    };
    my $var = $self->{parameters}->emit_ruby();
    my $val = $self->{arguments}->emit_ruby();
    (   '->(defined,value){'
            . (
            'if not defined or defined == "local-variable"; ' . ( $var . ( ' = value;' . ( 'else; ' . ( 'self.' . ( $var . ( ' = value; end' . ( '}.(defined? ' . ( $var . ( ', ' . ( $val . ( '.containerize)' . Main::newline() ) ) ) ) ) ) ) ) ) ) )
            )
    );
}

package Proto;
sub new { shift; bless {@_}, "Proto" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    return ( ( ' ' . $self->{name} ) );
}

package Call;
sub new { shift; bless {@_}, "Call" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $invocant;
    do {
        if ( Main::isa( $self->{invocant}, 'Proto' ) ) {
            do {
                if   ( ( $self->{invocant}->name() eq 'self' ) ) { $invocant = 's_self' }
                else                                             { $invocant = $self->{invocant}->emit_ruby() }
                }
        }
        else { $invocant = $self->{invocant}->emit_ruby() }
    };
    do {
        if ( ( $invocant eq 'self' ) ) { $invocant = 's_self' }
        else                           { }
    };
    my $meth = $self->{method};
    do {
        if ( ( $meth eq 'postcircumfix:<( )>' ) ) { $meth = '' }
        else                                      { }
    };
    my $call = Main::join( [ map { $_->emit_ruby() } @{ $self->{arguments} } ], ',,, ' );
    do {
        if ( $self->{hyper} ) {
            ( '::DISPATCH( $::List, "new", { _array => [ '
                    . ( 'map { ::DISPATCH( $_, "' . ( $meth . ( '", ' . ( $call . ( ') } ' . ( '@{ ::DISPATCH( ' . ( $invocant . ( ', "array" )->{_value}{_array} } ' . ( '] } )' . Main::newline() ) ) ) ) ) ) ) ) ) );
        }
        else {
            do {
                if   ( ( $meth eq '' ) ) { ( $invocant . ( '.(cx(' . ( $call . '))' ) ) ) }
                else                     { ( $invocant . ( '.mc_' .  ( $meth . ( '.(cx(' . ( $call . '))' ) ) ) ) ) }
                }
        }
        }
}

package Apply;
sub new { shift; bless {@_}, "Apply" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if   ( ( Main::isa( $self->{code}, 'Var' ) && ( $self->{code}->name() eq 'self' ) ) ) { return ('$self') }
        else                                                                                  { }
    };
    do {
        if ( ( Main::isa( $self->{code}, 'Var' ) && ( $self->{code}->name() eq 'infix:<&&>' ) ) ) {
            return (
                (   '->(tmp1){ '
                        . ( 'tmp1 = ' . ( $self->{arguments}->[0]->emit_ruby() . ( '; ' . ( 'tmp1.mc_true.(cx()).is_true6? ' . ( '? ' . ( $self->{arguments}->[1]->emit_ruby() . ( ': Bit.new(false)' . ( '}.(nil)' . Main::newline() ) ) ) ) ) ) ) )
                )
            );
        }
        else { }
    };
    do {
        if ( ( Main::isa( $self->{code}, 'Var' ) && ( $self->{code}->name() eq 'infix:<||>' ) ) ) {
            return (
                ( '->(tmp1){ ' . ( 'tmp1 = ' . ( $self->{arguments}->[0]->emit_ruby() . ( '; ' . ( 'tmp1.mc_true.(cx()).is_true6? ' . ( '? tmp1' . ( ': ' . ( $self->{arguments}->[1]->emit_ruby() . ( '}.(nil)' . Main::newline() ) ) ) ) ) ) ) ) ) );
        }
        else { }
    };
    do {
        if ( ( Main::isa( $self->{code}, 'Var' ) && ( $self->{code}->name() eq 'make' ) ) ) {
            return ( ( '::DISPATCH_VAR( ' . ( '$GLOBAL::_REGEX_RETURN_, "STORE", ' . ( $self->{arguments}->[0]->emit_ruby() . ( '' . ( ' )' . Main::newline() ) ) ) ) ) );
        }
        else { }
    };
    return ( ( ' ' . ( $self->{code}->emit_ruby() . ( '.(cx(' . ( Main::join( [ map { $_->emit_ruby() } @{ $self->{arguments} } ], ',,, ' ) . ( '))' . Main::newline() ) ) ) ) ) );
}

package Return;
sub new { shift; bless {@_}, "Return" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( 'return(' . ( $self->{result}->emit_ruby() . ( ')' . Main::newline() ) ) );
}

package If;
sub new { shift; bless {@_}, "If" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    (   'if ('
            . (
            $self->{cond}->emit_ruby()
                . (
                ').is_true6? '
                    . (
                    Main::newline()
                        . (
                          ( $self->{body} ? ( ' ' . ( $self->{body}->emit_ruby() . '' ) ) : '' )
                        . ( ( $self->{otherwise} ? ( ' else ' . ( Main::newline() . ( $self->{otherwise}->emit_ruby() . ' ' ) ) ) : ' else; Bit.new(false); ' ) . ( Main::newline() . ( 'end' . Main::newline() ) ) )
                        )
                    )
                )
            )
    );
}

package While;
sub new { shift; bless {@_}, "While" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $cond = $self->{cond};
    do {
        if   ( ( Main::isa( $cond, 'Var' ) && ( $cond->sigil() eq '@' ) ) ) { }
        else                                                                { $cond = Apply->new( 'code' => Var->new( 'sigil' => '&', 'twigil' => '', 'name' => 'prefix:<@>', 'namespace' => ['GLOBAL'], ), 'arguments' => [$cond], ) }
    };
    ( ' while (' . ( $self->{cond}->emit_ruby() . ( ').is_true6? ' . ( Main::newline() . ( $self->{body}->emit_ruby() . ( 'end' . Main::newline() ) ) ) ) ) );
}

package Decl;
sub new { shift; bless {@_}, "Decl" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $decl = $self->{decl};
    my $name = $self->{var}->name();
    my $s;
    do {
        if ( ( $decl eq 'has' ) ) { $s = ( 'def_has(:' . ( $self->{var}->emit_ruby() . ( ',' . ( '->(){' . ( $self->{var}->emit_ruby_container() . ( '.new})' . Main::newline() ) ) ) ) ) ) }
        else                      { $s = $self->{var}->emit_ruby() }
    };
    return ($s);
}

package Sig;
sub new { shift; bless {@_}, "Sig" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' Signature.new(' . ( $self->{emit_ruby_spec} . ( ')' . Main::newline() ) ) );
}

sub emit_ruby_spec {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $inv = ' nil';
    do {
        if ( Main::isa( $self->{invocant}, 'Var' ) ) { $inv = $self->{invocant}->emit_ruby() }
        else                                         { }
    };
    my $pos;
    my $item;
    do {
        for my $item ( @{ $self->{positional} } ) { $pos = ( $pos . ( ', ' . ( $item->emit_ruby() . '' ) ) ) }
    };
    $pos = substr( $pos, 1 );
    my $named = '';
    ( '' . ( $inv . ( ',' . ( '[' . ( $pos . ( ' ],' . ' nil' ) ) ) ) ) );
}

sub emit_ruby_bind_cap {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s = '';
    $s = ( $s . ( 'p = cap.pos' . Main::newline() ) );
    my $idx = 0;
    my $item;
    do {
        for my $item ( @{ $self->{positional} } ) { $s = ( $s . ( $item->emit_ruby_name() . ( '._(p[' . ( $idx . ']); ' ) ) ) ); $idx = ( $idx + 1 ) }
    };
    $s = ( $s . Main::newline() );
    return ($s);
}

package Lit::Capture;
sub new { shift; bless {@_}, "Lit::Capture" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $s  = ' c(';
    my $sa = '';
    do {
        if ( defined( $self->{array} ) ) {
            $sa = ( $sa . '[' );
            my $item;
            do {
                for my $item ( @{ $self->{array} } ) { $sa = ( $sa . ( $item->emit_ruby() . ', ' ) ) }
            };
            $sa = ( $sa . ']' );
            $s = ( $s . ( $sa . ',' ) );
        }
        else { $s = ( $s . 'nil,' ) }
    };
    my $sh = '';
    do {
        if ( defined( $self->{hash} ) ) {
            $sh = ( $sh . '{' );
            my $item;
            do {
                for my $item ( @{ $self->{hash} } ) { $sh = ( $sh . ( ' ' . ( $item->[0]->emit_ruby() . ( ': ' . ( $item->[1]->emit_ruby() . ', ' ) ) ) ) ) }
            };
            $sh = ( $sh . '}' );
            $s = ( $s . ( $sh . ',' ) );
        }
        else { $s = ( $s . 'nil,' ) }
    };
    do {
        if ( defined( $self->{invocant} ) ) { $s = ( $s . ( $self->{invocant}->emit_ruby() . '' ) ) }
        else                                { $s = ( $s . 'nil' ) }
    };
    return ( ( $s . ( ')' . Main::newline() ) ) );
}

package Lit::Subset;
sub new { shift; bless {@_}, "Lit::Subset" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' Subset.new({ ' . ( 'base_class: ' . ( $self->{base_class}->emit_ruby() . ( ', ' . ( 'block: ' . ( '->(s__){ ' . ( $self->{block}->block()->emit_ruby() . ( ' }' . ( ' } )' . Main::newline() ) ) ) ) ) ) ) ) );
}

package Method;
sub new { shift; bless {@_}, "Method" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $sig     = $self->{block}->sig();
    my $routine = (
        '->(cap){->('
            . (
            's_self){s_self = self; ->('
                . (
                $self->{block}->emit_ruby_comma_separated_names()
                    . ( '){' . ( Main::newline() . ( $sig->emit_ruby_bind_cap() . ( $self->{block}->emit_ruby_body() . ( Main::newline() . ( '}.(' . ( $self->{block}->emit_ruby_comma_separated_containers() . ( ')}.(nil' . ')}' ) ) ) ) ) ) ) )
                )
            )
    );
    my $name = Main::mangle_name_ruby( '&', '', $self->{name}, (undef) );
    $name = ( 'm' . $name );
    ( 'def ' . ( $name . ( '; ' . ( $routine . ( Main::newline() . ( 'end' . Main::newline() ) ) ) ) ) );
}

package Sub;
sub new { shift; bless {@_}, "Sub" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    my $sig = $self->{block}->sig();
    (   ''
            . (
            '->(cap){->('
                . (
                $self->{block}->emit_ruby_comma_separated_names()
                    . ( '){' . ( Main::newline() . ( $sig->emit_ruby_bind_cap() . ( $self->{block}->emit_ruby_body() . ( Main::newline() . ( '}.(' . ( $self->{block}->emit_ruby_comma_separated_containers() . ')}' ) ) ) ) ) ) )
                )
            )
    );
}

package Macro;
sub new { shift; bless {@_}, "Macro" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    die('Macros are not currently supported by the ruby backend.');
}

package Do;
sub new { shift; bless {@_}, "Do" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( Main::newline() . ( 'begin; ' . ( $self->{block}->emit_ruby() . ( Main::newline() . ( 'end' . Main::newline() ) ) ) ) );
}

package BEGIN;
sub new { shift; bless {@_}, "BEGIN" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    ( ' ' . ( $self->{block}->emit_ruby() . ' ' ) );
}

package Use;
sub new { shift; bless {@_}, "Use" }

sub emit_ruby {
    my $self   = shift;
    my $List__ = \@_;
    do { [] };
    do {
        if ( ( $self->{mod} eq 'v6' ) ) { return ( ( Main::newline() . ( '#use v6' . Main::newline() ) ) ) }
        else                            { }
    };
    do {
        if   ( $self->{perl5} ) { die('ruby backend does not currently implement  use perl5') }
        else                    { return ( ( '#require ' . ( Main::singlequote() . ( $self->{mod} . ( Main::singlequote() . Main::newline() ) ) ) ) ) }
        }
}

1;
