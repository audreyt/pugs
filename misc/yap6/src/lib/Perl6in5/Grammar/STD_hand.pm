package Perl6in5::Grammar::STD_hand;

use warnings;
use strict;

use base 'Exporter';
our @EXPORT = qw ( make_parser );

#use Perl6in5::Compiler::Trace; # set env var TRACE for trace output

# isa Perl6in5::Grammar someday (to inherit some of the common features below)

use Perl6in5::Grammar;
use Perl6in5::Compiler::Parser ':all';

use Data::Dumper;

no warnings qw{ reserved closure recursion };

# <sigh> these "predeclaration" should be autogenerated someday, somehow
sub program();
sub pkgDecl();
sub usev6();
sub base();
sub expr();
sub factor();
sub program();
sub term();
sub sVari();
sub stringLit();
sub declare();
sub usev6();
sub stmtList();
sub newline();
sub blkBare();
sub blkPrmbl();
sub nbexpr();
sub blkType();
sub blkRetT();
sub blkModf();
sub stmtTrm();
sub scpDecl();
sub block();
sub arg();
sub blkPrm();
sub compUnit();
sub flowCtrl();
sub blkLabl();
sub clype();
sub impor();
sub assign();
sub op_numaddt();
sub blkTrait();
sub pkgDecl();
sub arrowInv();
sub prmDecl();
sub vsblty();
sub invcDecl();
sub func_say();
sub bareInt();
sub identifier();
sub bareString();
sub blkPrms();
sub condBlk();
sub blkTrm();

{
my @order;
my %rules;
sub rule {
    my ($name,$code) = @_;
    my $stub = parser { $rules{$name}->(@_) };
    $N{$stub} = ucfirst($name);
    {
        $Perl6in5::Grammar::STD_hand::{$name} = sub() {$stub};
    }
    push(@order,[$name,$code]);
}
sub finish_rule_creation {
    for (@order) {
        my ($name,$code) = @$_;
        $rules{$name} = $code->();
    }
}
}


sub make_parser {
    
    my $input = shift;

    my ($base, $expr, $factor, $program, $term, $sVari, $stringLit, $declare,
        $usev6, $stmtList, $newline, $blkBare, $blkPrmbl, $nbexpr,
        $blkType, $blkRetT, $blkModf, $stmtTrm, $scpDecl, $block, $arg,
        $blkPrm, $compUnit, $flowCtrl, $blkLabl, $clype, $impor, $assign,
        $op_numaddt, $blkTrait, $pkgDecl, $arrowInv, $prmDecl, $vsblty,
        $invcDecl, $func_say, $bareInt, $identifier, $bareString, $blkPrms,
        $condBlk, $blkTrm
    );

    my @compUnits    = qw{ eval PRE POST ENTER LEAVE KEEP UNDO FIRST 
                         LAST BEGIN END INIT CHECK UNITCHECK };
    my @blkTypes     = qw{ sub method submethod regex token rule
                         macro module class package grammar};
    my @bareFuncs    = qw{ use no say };
    
    my @blkDecls  = qw{ module class grammar };
    
    #   Rule Writing

    # The identifier of each of your rules must begin with a lowercase letter,
    # so that the source filter can transform/generate the grammar properly.

    rule program {
            # everything must start with a use v6; statement until
            # the perl5zone rule is operational.
            opt( usev6 - (stmtTrm | eoi) ) -
            opt(
              - opt( pkgDecl )
              - opt( stmtList ) ) - eoi
    };

    rule pkgDecl {
            keyword('package') + identifier - stmtTrm;
    };

    rule usev6 {
            keyword('use') + keywords(qw{ v6 Perl-6 })
          | keyword('module') + opt(keyword('Main'))
          | keywords(qw{ class v6.0.0 v6 6 })
    };

    rule identifier {
            match( qr|^([A-Za-z_]\w*)| )
    };

    rule bareInt {
            match( qr|^(\d+)| )
    };

    rule sVari {
            '$' . identifier
    };

    # this rule is directly right-recursive
    rule 'stmtList' => sub {
            opt( stmtTrm ) - ( block . opt( blkTrm . opt( stmtList ) )
              | nbexpr . opt( stmtTrm - opt( stmtList ) ) )
    };
    
    rule blkTrm {
            hit( "\n" ) | stmtTrm
    };
    
    rule bareString {
            #w('""',star(unmore('"'))) | w("''",star(unmore("'") . identifier))
    };

    rule nbexpr {
            one(
                panic( pkgDecl, "Can't declare a non-block package")
                , func_say
                , op_numaddt
                , assign
                , declare
                , impor
                , blkTrait )
    };

    rule func_say {
            keyword('say') + expr
    };

    rule blkBare {
            w("{}",opt(stmtList))
    };

    rule block {
            opt(blkPrmbl) - blkBare
    };

    rule blkPrmbl {
            one(
                opt( blkModf++ )
                . ( opt(scpDecl++) . ( clype + blkType | blkType ) | blkType )
                - opt( opt( '^' ) . identifier )
                - opt( vsblty )
                - opt( w( '()', -( opt( blkPrms ) ) ) )
                - star( blkTrait )
                , compUnit
                , flowCtrl
                , blkLabl
                , arrowInv . opt( -( ',' ) - blkPrms ) )
    };

    rule arrowInv {
            hit( '<-' ) - prmDecl
    };

    rule blkTrait {
            keywords( qw{ is does has } ) + clype
    };

    rule impor {
            keywords( qw{ no use require module class } ) + identifier . opt( +nbexpr )
    };

    rule flowCtrl {
            keywords( qw{ loop do while until } )
    };

    rule condBlk { # Until I die, I would cry unless unless/until were included.
            # if unless elsif else 
    };

    rule compUnit {
            keywords( @compUnits )
    };

    rule blkType {
            keywords( @blkTypes )
    };

    rule blkRetT {
            clype
    };

    rule clype {
            identifier  # just take any class/type name for now :)
            #  $Clype    # Class/Type
    };

    rule blkLabl {
            identifier . ':';
    };

    rule blkModf {
            keywords(qw{ multi proto only })
    };

    rule arg {
            'h'  #obviously this is just a stub.
    };

    # block parameter declaration
    rule blkPrms {
            opt( invcDecl ) . plus( -( ',' ) - prmDecl )
    };
    
    # invocant declaration
    rule invcDecl {
            prmDecl . ':'
    };

    rule prmDecl {
            sVari
            | clype + sVari
    };

    rule vsblty {
            keywords( qw{ public private } )
    };

    rule stmtTrm {
            plus( -( ';' ) )
    };

    rule scpDecl {
            keywords( qw{ my our } )
    };

    rule expr {
            block
            | nbexpr
    };
    
    rule declare {
            scpDecl + prmDecl
            | keywords( @blkDecls ) + clype
    };
    
    rule assign {
        #    hit('my $blah =') - block |
        #    (opt( keywords( qw{ my our } )++ ) . prmDecl - '=' - expr) |
            ( scpDecl | nothing ) - prmDecl - '=' - expr
    };
    
    # this will become some op prec lev (postfix)
    rule op_numaddt {
            term - star( ( '+' | '-' ) - term )
    };
    
    # this will become some op prec lev (postfix)
    rule term {
            factor - star( ( '*' | '/' ) - factor )
    };
    
    rule factor {
            base - opt( hit('**') - factor )
    };
    
    rule base {
            bareInt | sVari | w( '()', expr )
    };
    
    finish_rule_creation;

    sub {
        my $r = (program->($input));
        unless ($r->{success}) {
            my $msg;
            if ($r->{expected} eq 'EOI') {
                $msg = "syntax error near the end of input";
            } else {
                $msg = "syntax error at line "
                .($r->{line})." col ".$r->{col}." near ".
                (sprintf '%.20s', Dumper(left($r))).
                ($r->{expected}?"\nExpected: ".Dumper($r->{expected}).".":'');
            }
            print STDERR $msg."\n".Dumper($r->{ast});
            return 255;
        } else {
            print "parsed: ".Dumper($r->{ast})."\n";
            return 0;
        }
    }
}

1;
