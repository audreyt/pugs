grammar Perl-6.0.0-STD;          # (XXX maybe should be -PROTO or some such)

=begin things todo

    ensure declarators and other categories are driving rather than driven
       (think about multi-word keywords like "multi sub" vs "multi")
    right side of s///, tr///, s[] = expr
    sublanguages
    exporting grammars to the compiler vs namespace (which one is default?)
    add more suppositions and figure out exact error continuation semantics
    finish out all the {*} #= hookage
    add parsing this file to sanity tests :)

=end things todo

# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via
# the following #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to $/ within the action block, so we need not mention it explicitly.

rule TOP { <compunit> {*} }                             #= TOP

# This grammar also assumes transitive longest-token semantics, though
# we make a feeble attempt to order rules so a procedural | can usually
# produce a correct parse.

# Built-in or autogenerated rules:
#      <EXPR>: the operator precedence parser
#  <CATEGORY>: the rule matching any valid category names
#       <foo>: all tokens of foo category |-ed together

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implmentation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

my %term              ::= { :prec<z=>                           };
my %methodcall        ::= { :prec<w=>                           };
my %autoincrement     ::= { :prec<v=>, :assoc<non>, :lvalue     };
my %exponentiation    ::= { :prec<u=>, :assoc<right>            };
my %symbolic_unary    ::= { :prec<t=>                           };
my %multiplicative    ::= { :prec<s=>, :assoc<left>             };
my %additive          ::= { :prec<r=>, :assoc<left>             };
my %junctive_and      ::= { :prec<q=>, :assoc<list>             };
my %junctive_or       ::= { :prec<p=>, :assoc<list>             };
my %named_unary       ::= { :prec<o=>, :assoc<left>             };
my %nonchaining       ::= { :prec<n=>, :assoc<non>              };
my %chaining          ::= { :prec<m=>, :assoc<chain>            };
my %tight_and         ::= { :prec<l=>, :assoc<left>             };
my %tight_or          ::= { :prec<k=>, :assoc<left>             };
my %conditional       ::= { :prec<j=>, :assoc<right>            };
my %item_assignment   ::= { :prec<i=>, :assoc<right>, :lvalue   };
my %loose_unary       ::= { :prec<h=>, :assoc<right>            };
my %comma             ::= { :prec<g=>, :assoc<list>             };
my %list_infix        ::= { :prec<f=>                           };
my %list_prefix       ::= { :prec<e=>                           };
my %loose_and         ::= { :prec<d=>                           };
my %loose_or          ::= { :prec<c=>                           };
my %terminator        ::= { :prec<a=>, :assoc<list>             };

my $LOOSEST = "a=!";    # "epsilon" tighter than terminator

our @herestub_queue;

# XXX maybe shouldn't be hash, but for now...

our %quote_adverb := {
    Q => {                          # base form of all quotes
        adverbs => &Q_adverb,
        parser => &q_pickdelim,
        escset => < >,
        escrule => &quote_escapes,
    },
    q  => {
        adverbs => &q_quote_adverb,
        parser => &q_pickdelim,
        escset => < \\ >,
        escrule => &quote_escapes,
    },
    qq => {
        adverbs => &q_quote_adverb,
        parser => &q_pickdelim,
        escset => < \\ $ @ % & { >,
        escrule => &quote_escapes,
    },
    b => {
        escadd => < \\ >,
    },
    s => {
        escadd => < $ >,
    },
    a => {
        escadd => < @ >,
    },
    h => {
        escadd => < % >,
    },
    f => {
        escadd => < & >,
    },
    c => {
        escadd => < { >,
    },
    to => {
        adverbs => &q_quote_adverb,
        parser => &q_herestub,
        escadd => < ^^ >,          #  grabs leading whitespace
    },
    rx => {
        adverbs => &q_regex_adverb,
        parser => &q_regex,
        escset => < >,             # let regex parser handle everything
    },
    m => {
        adverbs => &q_regex_adverb,
        parser => &q_regex,
        escset => < >,             # let regex parser handle everything
    },
    s => {
        adverbs => &q_regex_adverb,
        parser => &q_regex,
        escset => < >,             # let regex parser handle everything
    },
    tr => {
        adverbs => &q_trans_adverb,
        parser => &q_trans,
        escset => < >,             # let trans parser handle everything
    },
};

our %regex_adverb := {
    g => {
        ...
    },
    # XXX --more--
};

our %trans_adverb := {
    d => {
        ...
    },
    # XXX --more--
};

token Q_adverb {}
token q_quote_adverb {}
token q_quote {}
token q_regex_adverb {}
token q_regex {}
token q_trans_adverb {}
token q_trans {}

role Term {}
role Methodcall {}
role Autoincrement {}
role Exponentiation {}
role Symbolic_unary {}
role Multiplicative {}
role Additive {}
role Junctive_and {}
role Junctive_or {}
role Named_unary {}
role Nonchaining {}
role Chaining {}
role Tight_and {}
role Tight_or {}
role Conditional {}
role Item_assignment {}
role Loose_unary {}
role Comma {}
role List_infix {}
role List_prefix {}
role Loose_and {}
role Loose_or {}
role Terminator {}

# Categories are designed to be extensible in derived grammars.

# The endsym trait, if specified, says what to implicitly check for in each
# rule right after the initial :<symbol>.  Normally this is used to make sure
# there's appropriate whitespace, though Perl 6 also uses it to rule out
# the => (fatarrow) construct.

proto token noun_prefix_sigil {  }
proto token noun_prefix_twigil {  }
proto token special_variable {  }
proto token nameroot {  }
proto token version {  }

proto token term {  }
proto token quote {  }
proto token prefix  is defequiv(%symbolic_unary) {  }
proto token infix   is defequiv(%additive) {  }
proto token postfix is defequiv(%autoincrement) {  }

proto token circumfix {  }
proto token postcircumfix {  }

proto token regex_metachar {  }
proto token regex_backslash {  }
proto token regex_assertion {  }
proto token regex_mod_internal {  }
proto token regex_mod_external is endsym(/ <?before \(> <postcircumfix> /) {  }
proto token quote_mod {  }

proto token q_backslash {  }
proto token qq_backslash {  }

proto token trait_verb         is endsym(/ \s+ <nofat> /) {  }
proto token trait_auxiliary    is endsym(/ \s+ <nofat> /) {  }

proto token type_declarator    is endsym(/ >> <nofat> /) {  }
proto token scope_declarator   is endsym(/ >> <nofat> /) {  }
proto token package_declarator is endsym(/ >> <nofat> /) {  }
proto token routine_declarator is endsym(/ >> <nofat> /) {  }
proto rule statement_prefix   is endsym(/ >> <nofat> /) {  }
proto rule statement_control  is endsym(/ \s <nofat> /) {  }
proto rule statement_cond     is endsym(/ >> <nofat> /) {  }
proto rule statement_loop     is endsym(/ >> <nofat> /) {  }

proto token infix_prefix_meta_operator {  }
proto token infix_postfix_meta_operator {  }
proto token postfix_prefix_meta_operator {  }
proto token prefix_postfix_meta_operator {  }
proto token prefix_circumfix_meta_operator {  }

# Lexical routines

# make sure we're not an autoquoted identifier
regex nofat { <!before \h* <?unsp>? =\> > }

token q_herestub ($lang) {
    $<delimstr> := <quotesnabber('Q')>  # force raw semantics on /END/ marker
    {
        push @herestub_queue:
            new Herestub:
                delim => $<delimstr><delimited><q><text>, # XXX or some such
                orignode => $/,
                lang => $lang;
    }
                                                        {*} #= herestub
}

class Herestub {
    has Str $.delim;
    has $.orignode;
    has $.lang;
}

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

method heredoc {
    while my $herestub = shift @herestub_queue {
        my $delim = $herestub.delim;
        my $lang = $herestub.lang;
        my $doc;
        my $ws = "";
        my $stoppat = $delim eq "" ?? rx[^^ \h* $$]
                                   !! rx[^^ $ws:=(\h*?) $delim \h* $$ \n?];
        my @heredoc_initial_ws is context is rw;
        if m:p/$doc:=<q_unbalanced($lang, :stop($stoppat))>/ {
            if $ws and @heredoc_initial_ws {
                my $wsequiv = $ws;
                $wsequiv ~~ s/^ (\t+) /{ ' ' x ($0 * 8) }/; # per spec
                for @heredoc_initial_strings {
                    next if s/^ $ws //;   # reward consistent tabbing
                    s/^^ (\t+) /{ ' ' x ($0 * 8) }/;
                    s/^ $wsequiv // or s/^ \h+ //;
                }
            }
            $herestub.orignode<doc> = $doc;
        }
        else {
            fail("Ending delimiter $delim not found");
        }
    }
}

token ws {
    || <?after \w> <?before \w> ::: <fail>        # must \s+ between words
    || [
       | <unsp>              {*}                        #= ws unsp
       | \v                  {*} <heredoc>              #= ws vwhite
       | <unv>               {*}                        #= ws unv
       ]*  {*}                                          #= ws all
}

token unsp {
    \\ <?before [\s|\#]>
    [
    | \v                     {*}                        #= unsp vwhite
    | <unv>                  {*}                        #= unsp unv
    ]*  {*}                                             #= unsp all
}

token unv {
       | \h+                 {*}                        #= unv hwhite
       | ^^ [
            | \# \N*         {*}                        #= unv comment line
            | <?pod_comment> {*}                        #= unv comment pod
            ]
       | <'#'> [
            # assuming <bracketed> defaults to standard set
            | <?bracketed>   {*}                        #= unv comment inline
            | \N*            {*}                        #= unv comment end
            ]
}

# XXX We need to parse the pod eventually to support $= variables.

token pod_comment {
    ^^ =
    [
    | begin <?ws> <ident> .*? \n
      =end <?ws> $<ident> \N* \n?                   {*} #= pod block
    | \N* \n?                                       {*} #= pod misc
    ]
                                                    {*} #= pod comment
}

# Top-level rules

rule comp_unit (:$define_compunit is context = 1) {
    ^
    <package_declarator>?
    <statement_list>
    [ $ || <panic: Parse terminated early> ]
                                                    {*} #= comp_unit
}

token block {
    \{
    <statement_list>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp>? <?before <[,:]>> {*}                       #= block
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= block endline
    | {*} { let $<endlist> := 1; }                       #= block endlist
    ]
                                                        {*} #= block
}

token regex_block {  # perhaps parameterize and combine with block someday
    \{
    <regex \}>
    [ \} || <panic: Missing right brace> ]
    [
    | <?unsp>? <?before <[,:]>> {*}                       #= rxblock
    | <?before <?unv>? \n > {*} { let $<endline> := 1; } #= rxblock endline
    | {*} { let $<endlist> := 1; }                       #= rxblock endlist
    ]
                                                        {*} #= rxblock
}

rule statement_list {
    <statement>*
                                                    {*} #= statement_list
}

token label { <ident>
    # XXX not sure if this is the right way to write a supposition yet...
    [ <!{ is_type($<ident>) }>
    || <suppose "Did you mean a label $<ident>: instead of a contextualizer?">
    ]
    \: \s <?ws>
                                                    {*} #= label
    }

rule statement {
    <label>*                                     {*}    #= label
    [
    | <statement_control>                        {*}    #= statement control
    | <block>                                    {*}    #= statement block
    | <EXPR>                                     {*}    #= statement expr
        [<statement_cond> <EXPR> {*} ]?                 #= statement mod cond
        [<statement_loop> <EXPR> {*} ]?                 #= statement mod loop
    ]
                                                        {*} #= statement
}

rule statement_control {
    :<use>
    <module_name_wild> <EXPR>? ;?                       {*} #? #= sc use
}

rule statement_control {
    :<if>
    <EXPR>                           {*}                #= sc if expr
    <block>                          {*}                #= sc if block
    @<elsif> := [ elsif <EXPR>       {*}                #= sc if elsif expr
                        <block>      {*} ]*             #= sc if elsif block
    @<else> := [ else <block>        {*} ]?             #= sc if else
                                                        {*} #= sc if
}

rule statement_control {
    :<unless>
    <EXPR>                           {*}                #= sc unless expr
    <block>                          {*}                #= sc unless block
                                                        {*} #= sc unless
}

rule statement_control {
    :<while>
    <EXPR>                             {*}                #= sc while expr
    <block>                            {*}                #= sc while block
                                                          {*} #= sc while
}

rule statement_control {
    :<until>
    <EXPR>                             {*}                #= sc until expr
    <block>                            {*}                #= sc until block
                                                          {*} #= sc until
}
rule statement_control {
    :<repeat>
    [
        | (while|until) <EXPR>         {*}              #= sc repeat wu expr
          <block>                      {*}              #= sc repeat wu block
        | <block>                      {*}              #= sc repeat block wu
          (while|until) <EXPR>         {*}              #= sc repeat expr wu
    ]
                                                          {*} #= sc repeat
}
rule statement_control {
    :<loop>
    $<eee> := [
        \(
            $<e1> := <EXPR> ;   {*}                     #= sc loop e1
            $<e2> := <EXPR> ;   {*}                     #= sc loop e2
            $<e3> := <EXPR>     {*}                     #= sc loop e3
        \)                      {*}                     #= sc loop eee
    ]?
    <block>                     {*}                     #= sc loop block
                                                        {*} #= sc loop
}

rule statement_control { :<for>     <block> {*} }        #= sc for
rule statement_control { :<when>    <block> {*} }        #= sc when
rule statement_control { :<BEGIN>   <block> {*} }        #= sc BEGIN
rule statement_control { :<CHECK>   <block> {*} }        #= sc CHECK
rule statement_control { :<INIT>    <block> {*} }        #= sc INIT
rule statement_control { :<END>     <block> {*} }        #= sc END
rule statement_control { :<START>   <block> {*} }        #= sc START
rule statement_control { :<ENTER>   <block> {*} }        #= sc ENTER
rule statement_control { :<LEAVE>   <block> {*} }        #= sc LEAVE
rule statement_control { :<KEEP>    <block> {*} }        #= sc KEEP
rule statement_control { :<UNDO>    <block> {*} }        #= sc UNDO
rule statement_control { :<FIRST>   <block> {*} }        #= sc FIRST
rule statement_control { :<NEXT>    <block> {*} }        #= sc NEXT
rule statement_control { :<LAST>    <block> {*} }        #= sc LAST
rule statement_control { :<PRE>     <block> {*} }        #= sc PRE
rule statement_control { :<POST>    <block> {*} }        #= sc POST
rule statement_control { :<CATCH>   <block> {*} }        #= sc CATCH
rule statement_control { :<CONTROL> <block> {*} }        #= sc CONTROL

token statement_control { %statement_control }

rule modifier_expr { <EXPR> ;? {*} }                    #? #= modifier_expr

token statement_modifier { <statement_cond> | <statement_loop> }

rule statement_cond { :<if>     <modifier_expr> {*} };     #= scond if
rule statement_cond { :<unless> <modifier_expr> {*} };     #= scond unless
rule statement_cond { :<when>   <modifier_expr> {*} };     #= scond for

rule statement_loop { :<for>    <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<given>  <modifier_expr> {*} };     #= sloop for
rule statement_loop { :<while>  <modifier_expr> {*} };     #= sloop while
rule statement_loop { :<until>  <modifier_expr> {*} };     #= sloop until

token nameroot { <'perl6'> }
token nameroot { <'perl5'> }
token nameroot { <'parrot'> }
token nameroot { <'ruby'> }
token nameroot { <'python'> }
token nameroot { <'tcl'> }
token nameroot { <'js'> }
token nameroot { <'scheme'> }
token nameroot { <'lisp'> }
token nameroot { <'haskell'> }
token nameroot { <'java'> }
token nameroot { <'c'> }
token nameroot { <'cplusplus'> }
token nameroot { <'csharp'> }
token nameroot { <'ada'> }
token nameroot { <'lua'> }
token nameroot { <'php'> }

token module_name {
    <name>                                          {*} #= modulename name
    [- <version>                                    {*} #= modulename version
        [-
            <authority>                             {*} #= modulename auth
        ]?
    ]?
                                                    {*} #= modulename
}

token authority { <-[ \s ; \{ ]>+ }

token module_name_wild {
    [ <nameroot> \: {*} ]?                              #= modulewild root
    <name>                                          {*} #= modulewild name
    [- <version_wild>                               {*} #= modulewild version
        [-
            <authority_wild>                        {*} #= modulewild auth
        ]?
    ]?
                                                    {*} #= modwild
}

token version_wild   { <block> | <whatever> | <version> }
token authority_wild { <block> | <whatever> | <authority> }

token whatever { \* {*} }                            #= whatever

token version {
    v \d+ [ \. \d+ ]*                 {*}             #= version vstyle
}
token version {
    \d+ \. \d+ \. \d+ [ \. \d+]*      {*}             #= version dotted
}

###################################################

token expect_term {
    <?ws>

    [
        [
        | <prefix>                                      {*} #= Xterm prefix
        | <prefix_circumfix_meta_operator>              {*} #= Xterm precircum
        ]
        <prefix_postfix_meta_operator>*                 {*} #= Xterm prepost
    ]*

    <noun>                                              {*} #= Xterm noun
    <expect_postfix>*                                   {*} #= Xterm postfix
                                                        {*} #= Xterm
    <?ws>
    <adverbs>?
}

token adverbs {
    [ <colonpair> <?ws> ]+
    {
        my $prop = $+prevop err
            panic('No previous operator visible to adverbial pair (' ~
                $<colonpair> ~ ')');
        $prop.adverb($<colonpair>)
    }
                                                        {*} #= adverbs
}

token noun {
    [
    | <pair>
    | <circumfix>
    | <package_block>
    | <variable>
    | <value>
    | <subcall>
    | <capterm>
    | <sigterm>
    | <quote>
    | <term>
    | <scope_declarator>
    | <routine_block>
    | <regex_block>
    | <statement_prefix>
    ]
                                                        {*} #= noun
}

token pair {
    [
    | $<key>:=<ident> \h* =\> $<val>:=<EXPR(%assignment<prec>)>
                                                        {*} #= pair fat
    | [ <colonpair> <?ws> ]+
                                                        {*} #= pair colon
    ]
                                                        {*} #= pair
}

token colonpair {
    [
    | \: !? <ident>                                     {*} #= colonpair bool
    | \: <ident>? <unsp>? <postcircumfix>               {*} #= colonpair value
    ]
                                                        {*} #= colonpair
}

token expect_infix ($loosest) {
    <infix_prefix_meta_operator>*
    <infix>
    <infix_postfix_meta_operator>*
    ::: <?{ resolve_meta($/) and $<infix>.prec ge $loosest }>
                                                    {*} #= Xinfix
}

token dotty {
    | <'.+'>                                  {*}     #= dotty plus
    | <'.*'>                                  {*}     #= dotty star
    | <'.?'>                                  {*}     #= dotty query
    | <'.='>                                  {*}     #= dotty equals
    | <'.^'>                                  {*}     #= dotty caret
    | <'.:'>                                  {*}     #= dotty colon
    | <'.'>                                   {*}     #= dotty plain
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

token expect_postfix {
    [
    | \\ <?before \.>
    | <?unsp>?
    ]

    [ [\. <?unsp>?]? <postfix_prefix_meta_operator> <?unsp>? ]*

    [
    | $<dot> := <dotty> <?unsp>? <methodop>
    | $<dot> := [ \.]   <?unsp>? <postop>
    |                            <postop>
    ]
                                                    {*} #= Xpostfix
}
token prefix_circumfix_meta_operator {
    :<[> <infix> :<]>                               {*}  #= precircum square
}

token prefix_postfix_meta_operator { :<«>     {*} }  #» #= prepost hyper
token prefix_postfix_meta_operator { :['<<'] {*} }      #= prepost HYPER

token postfix_prefix_meta_operator { :<»>     {*} }     #= postpre hyper
token postfix_prefix_meta_operator { :['>>'] {*} }      #= postpre HYPER

token infix_prefix_meta_operator { :<!>     {*} }       #= inpre not
token infix_prefix_meta_operator { :<«>     {*} }    #» #= inpre hyper dwim
token infix_prefix_meta_operator { :<»>     {*} }       #= inpre hyper asis
token infix_prefix_meta_operator { :['<<'] {*} }        #= inpre HYPER dwim
token infix_prefix_meta_operator { :['>>'] {*} }        #= inpre HYPER asis

token infix_postfix_meta_operator { :<=>     {*} }      #= inpost assign
token infix_postfix_meta_operator { :<«>     {*} }   #» #= inpost hyper asis
token infix_postfix_meta_operator { :<»>     {*} }      #= inpost hyper dwim
token infix_postfix_meta_operator { :['<<']  {*} }      #= inpost HYPER asis
token infix_postfix_meta_operator { :['>>']  {*} }      #= inpost HYPER dwim

token postfix { :<i> {*} }                              #= postfix i
token postfix { :<++> {*} }                             #= postfix incr
token postfix { :<--> {*} }                             #= postfix decr

token postcircumfix { :<(> <EXPR> :<)> {*} }            #= postcircumfix ( )

token postcircumfix { :<[> <EXPR> :<]> {*} }            #= postcircumfix [ ]

token postcircumfix { :<{> <EXPR> :<}> {*} }            #= postcircumfix { }
token postcircumfix { :['<'] <anglewords> :['>']
                                                    {*} #= postcircumfix < >
}

token postcircumfix { :['<'] <shellwords> :['>']
                                                    {*} #= postcircumfix << >>
}

token postcircumfix { :<«> <shellwords> :<»> {*} }      #= postcircumfix « »

token postop { <postfix> | <postcircumfix> }

token methodop {
    [
    | <ident>
    | <?before \$> <variable>
    | <?before <[ ' " ]>> <quote>
    ]

    [
    | \.? \( <EXPR> \)
    | \: <?before \s> <!{ $+inquote }> <listop_expr>
    | <null>
    ]
                                                        {*} #= methodop
}

token circumfix { :<(> <EXPR> :<)> {*} }                #= circumfix ( )
token circumfix { :<[> <EXPR> :<]> {*} }                #= circumfix [ ]

token circumfix { :['<']  <anglewords>  :['>'] {*} }    #= circumfix < >
token circumfix { :['<<'] <shellwords> :['>>'] {*} }    #= circumfix << >>
token circumfix { :<«>    <shellwords> :<»>    {*} }    #= circumfix « »

token circumfix is Circumfix[:symbol<{ }>]
    { <block>         {*} }                             #= circumfix { }

rule scoped_variables {
    <scope_declarator>
    <type>?
    [
    | <variable>
    | \( <signature> \)
    ]
                                                        {*} #= scopedvar
}

token scope_declarator { :<my>       {*} }     #= sd my
token scope_declarator { :<our>      {*} }     #= sd our
token scope_declarator { :<state>    {*} }     #= sd state
token scope_declarator { :<constant> {*} }     #= sd constant
token scope_declarator { :<has>      {*} }     #= sd has

token package_declarator { :<class>   <package_def> {*} }     #= pd class
token package_declarator { :<grammar> <package_def> {*} }     #= pd grammar
token package_declarator { :<module>  <package_def> {*} }     #= pd module
token package_declarator { :<role>    <package_def> {*} }     #= pd role
token package_declarator { :<package> <package_def> {*} }     #= pd package

token package_def {
    <scope_declarator>?
    <package_declarator>
    <module_name>?
    <trait>* {*}                                         #= pkgdef traits
    [
    || <?{ $+define_compunit } :: \;
        { defined $<module_name> or
            panic("Compilation unit cannot be anonymous"
        }
                                                        {*} #= pkgdef semi
    || <block>
                                                        {*} #= pkgdef block
    ]
                                                        {*} #= pkgdef
}

token special_variable { :<$!>  {*} }
token special_variable { :<$/>  {*} }

token variable {
    [
    | <special_variable>
    | <sigiltwigil>
        [
        || <?{ $<sigiltwigil><sigil> eq '&' }> :: <sublongname>
        || <name>
        ]
    | <sigil> \d+
    | <sigil> <?before \< | \(> <postcircumfix>
    | <name> <'::'> <hashpostfix>
    ]
                                                        {*} #= variable
}

token sigiltwigil {
    <noun_prefix_sigil>
    <noun_prefix_twigil>?
                                                        {*} #= sigiltwigil
}

token noun_prefix_sigil { :<$>   {*} }               #= sigil $
token noun_prefix_sigil { :<@>   {*} }               #= sigil @
token noun_prefix_sigil { :<@@>  {*} }               #= sigil @@
token noun_prefix_sigil { :<%>   {*} }               #= sigil %
token noun_prefix_sigil { :<&>   {*} }               #= sigil &
token noun_prefix_sigil { :<::>  {*} }               #= sigil ::

token noun_prefix_twigil { :<.>  {*} }               #= twigil .
token noun_prefix_twigil { :<!>  {*} }               #= twigil !
token noun_prefix_twigil { :<^>  {*} }               #= twigil ^
token noun_prefix_twigil { :<*>  {*} }               #= twigil *
token noun_prefix_twigil { :<+>  {*} }               #= twigil +
token noun_prefix_twigil { :<?>  {*} }               #= twigil ?
token noun_prefix_twigil { :<=>  {*} }               #= twigil =

token name {
    [
    | <ident> <nofat> [ <'::'> <ident> ]*
    | [ <'::'> <ident> ]+
    ]
                                                        {*} #= name
}

token subshortname {
    [
    | <name>
    | <CATEGORY> \: <?before \< | \{ > <postcircumfix>
    ]
                                                        {*} #= subshort
}

token sublongname {
    <subshortname>
    [
    | <capterm>
    | <sigterm>
    | <null>
    ]
                                                        {*} #= sublong
}

token subcall {
    <subshortname> <?unsp>? \.? \( <EXPR> \)            {*} #= subcall
}

token value {
    [
    | <string>
    | <number>
    | <version>
    | <fulltypename>
    ]
                                                        {*} #= value
}

token typename {
    <name>
    <?{
        is_type($<name>)
    }>
                                                        {*} #= typename
}

regex fulltypename {
    <typeident>
    [
    | <?before \[> <postcircumfix>
    | of <typename>
    | <null>
    ]
                                                        {*} #= fulltypenmae
}

token number {
    [
    | <integer>
    | <dec_number>
    | <radix_number>
    ]
                                                        {*} #= number
}

token integer {
    [
    | 0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]*
        ]
    | \d+[_\d+]*
    ]
                                                        {*} #= integer
}

token radint {
    [
    | <integer>
    | <rad_number> <?{
                        defined $<rad_number><radint>
                        and
                        not defined $<rad_number><radfrac>
                   }>
    ]
                                                        {*} #= radint
}

token dec_number {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
                                                        {*} #= dec_number
}

token rad_number {
    \: $<radix> := [\d+] 
    [
    || \<
            $<radint> := [<[ 0..9 a..z A..Z ]>+
            $<radfrac> := [ \. <[ 0..9 a..z A..Z ]>+ ]? ]
            [ \* $<base> := <radint> \*\* $<exp> := <radint> ]?
       \>
      { return radcalc($<radix>, $<radnum>, $<base>, $<exp>) }
    || <?before \[> <postcircumfix>
    || <?before \(> <postcircumfix>
    ]
                                                        {*} #= rad_number
}

token quote { <before :<'>>    <quotesnabber("q")> }
token quote { <before :<">>    <quotesnabber("qq")> }
token quote { <before :['«']> <quotesnabber("q",":ww")> }
token quote { <before :['<<']> <quotesnabber("q",":ww")> }
token quote { <before :['<']>  <quotesnabber("q",":w")> }

# handle composite forms like qww
token quote { :<qq> <regex_mod_external>
    <quotesnabber('qq', $<regex_mod_external>)> }
token quote { :<q>  <regex_mod_external>
    <quotesnabber('q', $<regex_mod_external>)> }

token regex_mod_external { :<:w> }
token regex_mod_external { :<:ww> }
token regex_mod_external { :<:x> }
token regex_mod_external { :<:t> }
token regex_mod_external { :<:n> }
token regex_mod_external { :<:s> }
token regex_mod_external { :<:a> }
token regex_mod_external { :<:h> }
token regex_mod_external { :<:f> }
token regex_mod_external { :<:c> }
token regex_mod_external { :<:b> }

token quote { :<rx> <quotesnabber('rx')> }

token quote { :<m>  <quotesnabber('m')> }
token quote { :<mm> <quotesnabber('m', ':s')> }
token quote { :<s>  <quotesnabber('s')> <finish_subst> } # XXX handwave
token quote { :<ss> <quotesnabber('s', ':s')> <finish_subst> } # XXX handwave

token quote { :<tr> <quotesnabber($0)> <finish_trans> } # XXX handwave

# The key observation here is that the inside of quoted constructs may
# be any of a lot of different sublanguages, and we have to parameterize
# which parse rule to use as well as what options to feed that parse rule.

class QLang {
    has %.escset;
    has $.adverbs;
    has $.parser;

    submethod new ($pedigree) {
        my ($starthere, @adv) = $pedigree.split(':');
        my %start := %quote_adverbs{$starthere};
        my $self = .bless(|%start);
        for @adv {
            $self.tweak($_);
        }
    }

    method tweak ($p) {
        # XXX more bogus hashiness, we need another polymorphic dispatch here
        given $p.key {
            when 'escset' {
                ...
            }
            when 'escadd' {
                ...
            }
        }
    }
}

sub qlang ($pedigree) {
    $pedigree ~~ s:g/ \s+ //;
    (state %qlang){$pedigree} //= new QLang($pedigree);
}

token quotesnabber ($q is copy) {
    <!before \w> <nofat> ::
    <?ws>

    [ (<colonpair>) { $q ~= $0 } <?ws> ]*

    { my $lang = qlang($q) }

    # Dispatch to current lang's subparser.
    $<delimited> := <$($<lang>.parser)($<lang>)>
                                                        {*} #= quotesnabber
}

# XXX should eventually be derived from current Unicode tables.
constant %open2close ::= {
    "\x0028" => "\x0029", "\x003C" => "\x003E", "\x005B" => "\x005D",
    "\x007B" => "\x007D", "\x00AB" => "\x00BB", "\x0F3A" => "\x0F3B",
    "\x0F3C" => "\x0F3D", "\x169B" => "\x169C", "\x2039" => "\x203A",
    "\x2045" => "\x2046", "\x207D" => "\x207E", "\x208D" => "\x208E",
    "\x2208" => "\x220B", "\x2209" => "\x220C", "\x220A" => "\x220D",
    "\x2215" => "\x29F5", "\x223C" => "\x223D", "\x2243" => "\x22CD",
    "\x2252" => "\x2253", "\x2254" => "\x2255", "\x2264" => "\x2265",
    "\x2266" => "\x2267", "\x2268" => "\x2269", "\x226A" => "\x226B",
    "\x226E" => "\x226F", "\x2270" => "\x2271", "\x2272" => "\x2273",
    "\x2274" => "\x2275", "\x2276" => "\x2277", "\x2278" => "\x2279",
    "\x227A" => "\x227B", "\x227C" => "\x227D", "\x227E" => "\x227F",
    "\x2280" => "\x2281", "\x2282" => "\x2283", "\x2284" => "\x2285",
    "\x2286" => "\x2287", "\x2288" => "\x2289", "\x228A" => "\x228B",
    "\x228F" => "\x2290", "\x2291" => "\x2292", "\x2298" => "\x29B8",
    "\x22A2" => "\x22A3", "\x22A6" => "\x2ADE", "\x22A8" => "\x2AE4",
    "\x22A9" => "\x2AE3", "\x22AB" => "\x2AE5", "\x22B0" => "\x22B1",
    "\x22B2" => "\x22B3", "\x22B4" => "\x22B5", "\x22B6" => "\x22B7",
    "\x22C9" => "\x22CA", "\x22CB" => "\x22CC", "\x22D0" => "\x22D1",
    "\x22D6" => "\x22D7", "\x22D8" => "\x22D9", "\x22DA" => "\x22DB",
    "\x22DC" => "\x22DD", "\x22DE" => "\x22DF", "\x22E0" => "\x22E1",
    "\x22E2" => "\x22E3", "\x22E4" => "\x22E5", "\x22E6" => "\x22E7",
    "\x22E8" => "\x22E9", "\x22EA" => "\x22EB", "\x22EC" => "\x22ED",
    "\x22F0" => "\x22F1", "\x22F2" => "\x22FA", "\x22F3" => "\x22FB",
    "\x22F4" => "\x22FC", "\x22F6" => "\x22FD", "\x22F7" => "\x22FE",
    "\x2308" => "\x2309", "\x230A" => "\x230B", "\x2329" => "\x232A",
    "\x23B4" => "\x23B5", "\x2768" => "\x2769", "\x276A" => "\x276B",
    "\x276C" => "\x276D", "\x276E" => "\x276F", "\x2770" => "\x2771",
    "\x2772" => "\x2773", "\x2774" => "\x2775", "\x27C3" => "\x27C4",
    "\x27C5" => "\x27C6", "\x27D5" => "\x27D6", "\x27DD" => "\x27DE",
    "\x27E2" => "\x27E3", "\x27E4" => "\x27E5", "\x27E6" => "\x27E7",
    "\x27E8" => "\x27E9", "\x27EA" => "\x27EB", "\x2983" => "\x2984",
    "\x2985" => "\x2986", "\x2987" => "\x2988", "\x2989" => "\x298A",
    "\x298B" => "\x298C", "\x298D" => "\x298E", "\x298F" => "\x2990",
    "\x2991" => "\x2992", "\x2993" => "\x2994", "\x2995" => "\x2996",
    "\x2997" => "\x2998", "\x29C0" => "\x29C1", "\x29C4" => "\x29C5",
    "\x29CF" => "\x29D0", "\x29D1" => "\x29D2", "\x29D4" => "\x29D5",
    "\x29D8" => "\x29D9", "\x29DA" => "\x29DB", "\x29F8" => "\x29F9",
    "\x29FC" => "\x29FD", "\x2A2B" => "\x2A2C", "\x2A2D" => "\x2A2E",
    "\x2A34" => "\x2A35", "\x2A3C" => "\x2A3D", "\x2A64" => "\x2A65",
    "\x2A79" => "\x2A7A", "\x2A7D" => "\x2A7E", "\x2A7F" => "\x2A80",
    "\x2A81" => "\x2A82", "\x2A83" => "\x2A84", "\x2A8B" => "\x2A8C",
    "\x2A91" => "\x2A92", "\x2A93" => "\x2A94", "\x2A95" => "\x2A96",
    "\x2A97" => "\x2A98", "\x2A99" => "\x2A9A", "\x2A9B" => "\x2A9C",
    "\x2AA1" => "\x2AA2", "\x2AA6" => "\x2AA7", "\x2AA8" => "\x2AA9",
    "\x2AAA" => "\x2AAB", "\x2AAC" => "\x2AAD", "\x2AAF" => "\x2AB0",
    "\x2AB3" => "\x2AB4", "\x2ABB" => "\x2ABC", "\x2ABD" => "\x2ABE",
    "\x2ABF" => "\x2AC0", "\x2AC1" => "\x2AC2", "\x2AC3" => "\x2AC4",
    "\x2AC5" => "\x2AC6", "\x2ACD" => "\x2ACE", "\x2ACF" => "\x2AD0",
    "\x2AD1" => "\x2AD2", "\x2AD3" => "\x2AD4", "\x2AD5" => "\x2AD6",
    "\x2AEC" => "\x2AED", "\x2AF7" => "\x2AF8", "\x2AF9" => "\x2AFA",
    "\x2E02" => "\x2E03", "\x2E04" => "\x2E05", "\x2E09" => "\x2E0A",
    "\x2E0C" => "\x2E0D", "\x2E1C" => "\x2E1D", "\x3008" => "\x3009",
    "\x300A" => "\x300B", "\x300C" => "\x300D", "\x300E" => "\x300F",
    "\x3010" => "\x3011", "\x3014" => "\x3015", "\x3016" => "\x3017",
    "\x3018" => "\x3019", "\x301A" => "\x301B", "\x301D" => "\x301E",
    "\xFD3E" => "\xFD3F", "\xFE17" => "\xFE18", "\xFE35" => "\xFE36",
    "\xFE37" => "\xFE38", "\xFE39" => "\xFE3A", "\xFE3B" => "\xFE3C",
    "\xFE3D" => "\xFE3E", "\xFE3F" => "\xFE40", "\xFE41" => "\xFE42",
    "\xFE43" => "\xFE44", "\xFE47" => "\xFE48", "\xFE59" => "\xFE5A",
    "\xFE5B" => "\xFE5C", "\xFE5D" => "\xFE5E", "\xFF08" => "\xFF09",
    "\xFF1C" => "\xFF1E", "\xFF3B" => "\xFF3D", "\xFF5B" => "\xFF5D",
    "\xFF5F" => "\xFF60", "\xFF62" => "\xFF63",
};

# assumes whitespace is eaten already

method findbrack {
    my $start;
    my $stop;
    if m:p/ <?before <isPe>> / {
        panic("Use a closing delimiter for an opener is reserved");
    }
    elsif m:p/ <?before $start := [ (<isPs>|<isMirrored>) $0* ] > / {
        $stop = %open2close{$0} err
            panic("Don't know how to flip $start bracket");
        $stop x= $start.chars;
        return $start, $stop;
    }
    else {
        return ();
    }
}

regex bracketed ($lang = QLang("Q")) {
     <?{ ($<start>,$<stop>) = $.findbrack() }>
     $<q> := <q_balanced($lang, $<start>, $<stop>)>
                                                        {*} #= bracketed
}

regex q_pickdelim ($lang) {
    [
    || <?{ ($<start>,$<stop>) = $.findbrack() }>
       $<q> := <q_balanced($lang, $<start>, $<stop>)>
    || [ $<stop> := [\S] || <panic: Quote delimiter must not be whitespace> ]
       $<q> := <q_unbalanced($lang, $<stop>)>
    ]
                                                        {*} #= q_pickdelim
}

regex rx_pickdelim ($lang) {
    [
    | <?{ ($<start>,$<stop>) = $.findbrack() }>
      $<start>
      $<r> := <regex($<stop>)>        # counts its own brackets, we hope
    | [ $<stop> := [\S] || <panic: Quote delimiter must not be whitespace> ]
      $<r> := <regex($<stop>)>
    ]
                                                        {*} #= rx_pickdelim
}

regex q_balanced ($lang, $start, $stop, :@esc = $lang<escset>) {
    $<start> := <$start>
    $<text> := [.*?]
    @<more> := [
      <!before <$stop>>
      [ # XXX triple rule should just be in escapes to be customizable
      | <?before <$start>**{3}> $<dequote> := <q_dequote($lang, $start, $stop, :@esc)>
      | <?before <$start>> $<subtext> := <q_balanced($lang, $start, $stop, :@esc)>
      | <?before @esc> $<escape> := [ <q_escape($lang)> ]
      ]
      $<text> := [.*?]
    ]*
    $<stop> := <$stop>
                                                        {*} #= q_balanced
}

regex q_unbalanced ($lang, $stop, :@esc = $lang<escset>) {
    $<text> := [.*?]
    @<more> := [
      <!before <$stop>>
      [ <?before @esc> $<escape> := [ <q_escape($lang)> ]
      $<text> := [.*?]
    ]*
    $<stop> := <$stop>
                                                        {*} #= q_unbalanced
}

# We only get here for escapes in escape set, even though more are defined.
regex q_escape ($lang) {
    <$($lang<escrule>)>
                                                        {*} #= q_escaped
}

token quote_escapes {
    [
    || \\ <qq_backslash>
    || <?before \{> <block>
    || <?before \$> <variable> <extrapost>?
    || <variable> <extrapost>
    || .
    ]
                                                        {*} #= quote_escapes
}

# Note, backtracks!  So expect_postfix mustn't commit to anything permanent.
regex extrapost ($inquote is context = 1) {
    <expect_postfix>*
    <?after <[ \] \} \> \) ]> > 
                                                        {*} #= extrapost
}

rule routine_block {
    <scope_declarator>?
    <subintro>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <block>
                                                        {*} #= routine_block
}

rule regex_method {
    <scope_declarator>?
    <regex_declarator>
    <ident>?
    <trait>*
    [ :? \( <signature> \)]?
    <regex_block>
                                                        {*} #= regex_method
}

rule subintro {
    [
    | <routine_modifier> <routine_declarator>?
    | <routine_declarator>
    ]
                                                        {*} #= subintro
}

token routine_modifier { multi | proto | only }

token routine_declarator { :<sub> }
token routine_declarator { :<method> }
token routine_declarator { :<submethod> }
token routine_declarator { :<macro> }

token regex_declarator { :<regex> }
token regex_declarator { :<token> }
token regex_declarator { :<rule> }

rule trait { <trait_verb> | <trait_auxiliary> }

token trait_auxiliary { :<is>   <ident>[\( <EXPR> \)]? }
token trait_auxiliary { :<will> <ident> <block> }

token trait_verb { :<of>        <type> }
token trait_verb { :<returns>   <type> }

token capterm {
    \\ \( <capture> \)
                                                        {*} #= capterm
}

rule capture {
    <EXPR>
                                                        {*} #= capture
}

token sigterm {
    \: \( <signature> \)
                                                        {*} #= sigterm
}

rule signature {
    [<parameter> [ [ \, | \: | ; | ;; ] <parameter> ]* ]?
    [ --\> <type> ]?
                                                        {*} #= signature
}

rule type_declarator {
    :<subset>
    <name>
    [ of <type_name> ]?
    where <subset>
                                                        {*} #= type_decl
}

rule type_constraint {
    [
    | <value>
    | <type_name>
    | where <subset>
    ]
                                                        {*} #= type_constraint
}

token parameter {
    <slurp>?
    <type_constraint>*
    [
    | \: <ident>? \(
      <sigiltwigil>  <ident>?
      \)
    | <sigiltwigil>  <ident>?
    ]
    <default_value>
                                                        {*} #= parameter
}

rule statement_prefix { :<do>      <statement> {*} }    #= sp do
rule statement_prefix { :<try>     <statement> {*} }    #= sp try
rule statement_prefix { :<gather>  <statement> {*} }    #= sp gather
rule statement_prefix { :<contend> <statement> {*} }    #= sp contend
rule statement_prefix { :<async>   <statement> {*} }    #= sp async
rule statement_prefix { :<lazy>    <statement> {*} }    #= sp lazy

## term
token term is Term[]                            #= term:<*> def
    { :<*> {*} }                                #= term:<*>

token circumfix is Term[:symbol<$( )>]            #= circumfix:<$( )> def
    { <noun_prefix_sigil> \( <EXPR> :\) {*} }  #= circumfix:<$( )> 

token circumfix is Term[:symbol<Type( )>]        #= circumfix:<Type( )> def
    { <typename> \( <EXPR> \) {*} }            #= circumfix:<Type( )> 

token circumfix is Term[]                       #= circumfix:<( )> def
    { :<(> <EXPR> :<)> {*} }                              #= circumfix:<( )>

token postcircumfix is Term[]                   #= postcircumfix:<( )> def
    is abstract('call')
    { :<(> <EXPR> :<)> {*} }                              #= postcircumfix:<( )>

## autoincrement
token postfix is Autoincrement[]                #= postfix:<++> def
    { :<++> {*} }                               #= postfix:<++>

token postfix is Autoincrement[]                #= postfix:<--> def
    { :<--> {*} }                               #= postfix:<-->

token prefix is Autoincrement[]                 #= prefix:<++> def
    { :<++> {*} }                               #= prefix:<++>

token prefix is Autoincrement[]                 #= prefix:<--> def
    { :<--> {*} }                               #= prefix:<-->


## exponentiation
token infix is Exponentiate[]                   #= infix:<**> def
    { :<**> {*} }                               #= infix:<**>

## symbolic unary
token prefix is Symbolic_unary[]                #= prefix:<!> def
    { :<!> {*} }                                #= prefix:<!>

token prefix is Symbolic_unary[]                #= prefix:<+> def
    { :<+> {*} }                                #= prefix:<+>

token prefix is Symbolic_unary[]                #= prefix:<-> def
    { :<-> {*} }                                #= prefix:<->

token prefix is Symbolic_unary[]                #= prefix:<~> def
    { :<~> {*} }                                #= prefix:<~>

token prefix is Symbolic_unary[]                #= prefix:<?> def
    { :<?> {*} }                                #= prefix:<?>

token prefix is Symbolic_unary[]                #= prefix:<=> def
    { :<=> {*} }                                #= prefix:<=>

token prefix is Symbolic_unary[]                #= prefix:<*> def
    { :<*> {*} }                                #= prefix:<*>

token prefix is Symbolic_unary[]                #= prefix:<**> def
    { :<**> {*} }                               #= prefix:<**>

token prefix is Symbolic_unary[]                #= prefix:<~^> def
    { :<~^> {*} }                               #= prefix:<~^>

token prefix is Symbolic_unary[]                #= prefix:<+^> def
    { :<+^> {*} }                               #= prefix:<+^>

token prefix is Symbolic_unary[]                #= prefix:<?^> def
    { :<?^> {*} }                               #= prefix:<?^>

token prefix is Symbolic_unary[]                #= prefix:<^> def
    { :<^> {*} }                                #= prefix:<^>


## multiplicative
token infix is Multiplicative[]                 #= infix:<*> def
    { :<*> {*} }                                #= infix:<*>

token infix is Multiplicative[]                 #= infix:</> def
    { :</> {*} }                                #= infix:</>

token infix is Multiplicative[]                 #= infix:<%> def
    { :<%> {*} }                                #= infix:<%>

token infix is Multiplicative[]                 #= infix:<x> def
    { :<x> {*} }                                #= infix:<x>

token infix is Multiplicative[]                 #= infix:<xx> def
    { :<xx> {*} }                               #= infix:<xx>

token infix is Multiplicative[]                 #= infix:<+&> def
    { :<+&> {*} }                               #= infix:<+&>

token infix is Multiplicative[]                 #= infix:['+<'] def
    { :['+<'] {*} }                             #= infix:['+<']

token infix is Multiplicative[]                 #= infix:['+>'] def
    { :['+>'] {*} }                             #= infix:['+>']

token infix is Multiplicative[]                 #= infix:<~&> def
    { :<~&> {*} }                               #= infix:<~&>

token infix is Multiplicative[]                 #= infix:['~<'] def
    { :['~<'] {*} }                             #= infix:['~<']

token infix is Multiplicative[]                 #= infix:['~>'] def
    { :['~>'] {*} }                             #= infix:['~>']


## additive
token infix is Additive[]                       #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Additive[]                       #= infix:<-> def
    { :<-> {*} }                                #= infix:<->

token infix is Additive[]                       #= infix:<~> def
    { :<~> {*} }                                #= infix:<~>

token infix is Additive[]                       #= infix:<+|> def
    { :<+|> {*} }                               #= infix:<+|>

token infix is Additive[]                       #= infix:<+^> def
    { :<+^> {*} }                               #= infix:<+^>

token infix is Additive[]                       #= infix:<~|> def
    { :<~|> {*} }                               #= infix:<~|>

token infix is Additive[]                       #= infix:<~^> def
    { :<~^> {*} }                               #= infix:<~^>

token infix is Additive[]                       #= infix:<?|> def
    { :<?|> {*} }                               #= infix:<?|>

token infix is Additive[]                       #= infix:<?^> def
    { :<?^> {*} }                               #= infix:<?^>


## junctive and (all)
token infix is Junctive_and[]                   #= infix:<&> def
    { :<&> {*} }                                #= infix:<&>


## junctive or (any)
token infix is Junctive_or[]                    #= infix:<|> def
    { :<|> {*} }                                #= infix:<|>

token infix is Junctive_or[]                    #= infix:<^> def
    { :<^> {*} }                                #= infix:<^>


## named unary examples
token prefix is Named_unary[]                   #= prefix:<rand> def
    { :<rand> {*} }                             #= prefix:<rand>

token prefix is Named_unary[]                   #= prefix:<sleep> def
    { :<sleep> {*} }                            #= prefix:<sleep>

token prefix is Named_unary[]                   #= prefix:<abs> def
    { :<abs> {*} }                              #= prefix:<abs>

## nonchaining binary
token infix is Nonchaining[]                    #= infix:['<=>'] def
    { :['<=>'] {*} }                            #= infix:['<=>']

token infix is Nonchaining[]                    #= infix:<cmp> def
    { :<cmp> {*} }                              #= infix:<cmp>

token infix is Nonchaining[]                    #= infix:<is> def
    { :<is> {*} }                               #= infix:<is>

token infix is Nonchaining[]                    #= infix:<but> def
    { :<but> {*} }                              #= infix:<but>

token infix is Nonchaining[]                    #= infix:<does> def
    { :<does> {*} }                             #= infix:<does>

token infix is Nonchaining[]                    #= infix:<..> def
    { :<..> {*} }                               #= infix:<..>

token infix is Nonchaining[]                    #= infix:<^..> def
    { :<^..> {*} }                              #= infix:<^..>

token infix is Nonchaining[]                    #= infix:<..^> def
    { :<..^> {*} }                              #= infix:<..^>

token infix is Nonchaining[]                    #= infix:<^..^> def
    { :<^..^> {*} }                             #= infix:<^..^>

token infix is Nonchaining[]                    #= infix:<ff> def
    { :<ff> {*} }                               #= infix:<ff>

token infix is Nonchaining[]                    #= infix:<^ff> def
    { :<^ff> {*} }                              #= infix:<^ff>

token infix is Nonchaining[]                    #= infix:<ff^> def
    { :<ff^> {*} }                              #= infix:<ff^>

token infix is Nonchaining[]                    #= infix:<^ff^> def
    { :<^ff^> {*} }                             #= infix:<^ff^>

token infix is Nonchaining[]                    #= infix:<fff> def
    { :<fff> {*} }                              #= infix:<fff>

token infix is Nonchaining[]                    #= infix:<^fff> def
    { :<^fff> {*} }                             #= infix:<^fff>

token infix is Nonchaining[]                    #= infix:<fff^> def
    { :<fff^> {*} }                             #= infix:<fff^>

token infix is Nonchaining[]                    #= infix:<^fff^> def
    { :<^fff^> {*} }                            #= infix:<^fff^>


## chaining binary
token infix is Chaining[]                       #= infix:<==> def
    { :<==> {*} }                               #= infix:<==>

token infix is Chaining[]                       #= infix:<!=> def
    { :<!=> {*} }                               #= infix:<!=>

token infix is Chaining[]                       #= infix:['<'] def
    { :['<'] {*} }                              #= infix:['<']

token infix is Chaining[]                       #= infix:['<='] def
    { :['<='] {*} }                             #= infix:['<=']

token infix is Chaining[]                       #= infix:['>'] def
    { :['>'] {*} }                              #= infix:['>']

token infix is Chaining[]                       #= infix:['>='] def
    { :['>='] {*} }                             #= infix:['>=']

token infix is Chaining[]                       #= infix:<~~> def
    { :<~~> {*} }                               #= infix:<~~>

token infix is Chaining[]                       #= infix:<!~> def
    { :<!~> {*} }                               #= infix:<!~>

token infix is Chaining[]                       #= infix:<=~> def
    { :<=~> {*} }                               #= infix:<=~>

token infix is Chaining[]                       #= infix:<eq> def
    { :<eq> {*} }                               #= infix:<eq>

token infix is Chaining[]                       #= infix:<ne> def
    { :<ne> {*} }                               #= infix:<ne>

token infix is Chaining[]                       #= infix:<lt> def
    { :<lt> {*} }                               #= infix:<lt>

token infix is Chaining[]                       #= infix:<le> def
    { :<le> {*} }                               #= infix:<le>

token infix is Chaining[]                       #= infix:<gt> def
    { :<gt> {*} }                               #= infix:<gt>

token infix is Chaining[]                       #= infix:<ge> def
    { :<ge> {*} }                               #= infix:<ge>

token infix is Chaining[]                       #= infix:<=:=> def
    { :<=:=> {*} }                              #= infix:<=:=>

token infix is Chaining[]                       #= infix:<===> def
    { :<===> {*} }                              #= infix:<===>


## tight and
token infix is Tight_and[]                      #= infix:<&&> def
    is abstract('if')
    { :<&&> {*} }                               #= infix:<&&>


## tight or
token infix is Tight_or[]                       #= infix:<||> def
    is abstract('unless')
    { :<||> {*} }                               #= infix:<||>

token infix is Tight_or[:assoc<list>]           #= infix:<^^> def
    is assoc('list')
    is abstract('xor')
    { :<^^> {*} }                               #= infix:<^^>

token infix is Tight_or[]                       #= infix:<//> def
    { :<//> {*} }                               #= infix:<//>


## conditional
token infix is Conditional[]                    #= infix:<?? !!> def
    is abstract('if')
    { :<??> <EXPR(%conditional<prec>)> :<!!> {*} }   #= infix:<?? !!>


## assignment
token infix is Assignment[]                     #= infix:<=> def
    is abstract('assign')
    is lvalue(1)
    { :<=> {*} }                                #= infix:<=>

token infix is Assignment[]                     #= infix:<:=> def
    is abstract('bind')
    { :<:=> {*} }                               #= infix:<:=>

token infix is Assignment[]                     #= infix:<::=> def
    { :<::=> {*} }                              #= infix:<::=>

# XXX need to do something to turn subcall into method call here...
token infix is Assignment[]                     #= infix:<.=> def
    { :<.=> {*} }                               #= infix:<.=>

token infix is Assignment[]                     #= infix:<~=> def
    { :<~=> {*} }                               #= infix:<~=>

token infix is Assignment[]                     #= infix:<+=> def
    { :<+=> {*} }                               #= infix:<+=>

token infix is Assignment[]                     #= infix:<-=> def
    { :<-=> {*} }                               #= infix:<-=>

token infix is Assignment[]                     #= infix:<*=> def
    { :<*=> {*} }                               #= infix:<*=>

token infix is Assignment[]                     #= infix:</=> def
    { :</=> {*} }                               #= infix:</=>

token infix is Assignment[]                     #= infix:<%=> def
    { :<%=> {*} }                               #= infix:<%=>

token infix is Assignment[]                     #= infix:<x=> def
    { :<x=> {*} }                               #= infix:<x=>

token infix is Assignment[]                     #= infix:<Y=> def
    { :<Y=> {*} }                               #= infix:<Y=>

token infix is Assignment[]                     #= infix:<**=> def
    { :<**=> {*} }                              #= infix:<**=>

token infix is Assignment[]                     #= infix:<xx=> def
    { :<xx=> {*} }                              #= infix:<xx=>

token infix is Assignment[]                     #= infix:<||=> def
    { :<||=> {*} }                              #= infix:<||=>

token infix is Assignment[]                     #= infix:<&&=> def
    { :<&&=> {*} }                              #= infix:<&&=>

token infix is Assignment[]                     #= infix:<//=> def
    { :<//=> {*} }                              #= infix:<//=>

token infix is Assignment[]                     #= infix:<^^=> def
    { :<^^=> {*} }                              #= infix:<^^=>

token infix is Assignment[]                     #= infix:<+<=> def
    { :<+<=> {*} }                           #> #= infix:<+<=>

token infix is Assignment[]                     #= infix:<+> def
    { :<+> {*} }                                #= infix:<+>

token infix is Assignment[]                     #= infix:<+|=> def
    { :<+|=> {*} }                              #= infix:<+|=>

token infix is Assignment[]                     #= infix:<+&=> def
    { :<+&=> {*} }                              #= infix:<+&=>

token infix is Assignment[]                     #= infix:<+^=> def
    { :<+^=> {*} }                              #= infix:<+^=>

token infix is Assignment[]                     #= infix:<~|=> def
    { :<~|=> {*} }                              #= infix:<~|=>

token infix is Assignment[]                     #= infix:<~&=> def
    { :<~&=> {*} }                              #= infix:<~&=>

token infix is Assignment[]                     #= infix:<~^=> def
    { :<~^=> {*} }                              #= infix:<~^=>

token infix is Assignment[]                     #= infix:<?|=> def
    { :<?|=> {*} }                              #= infix:<?|=>

token infix is Assignment[]                     #= infix:<?&=> def
    { :<?&=> {*} }                              #= infix:<?&=>

token infix is Assignment[]                     #= infix:<?^=> def
    { :<?^=> {*} }                              #= infix:<?^=>

token infix is Assignment[]                     #= infix:<|=> def
    { :<|=> {*} }                               #= infix:<|=>

token infix is Assignment[]                     #= infix:<&=> def
    { :<&=> {*} }                               #= infix:<&=>

token infix is Assignment[]                     #= infix:<^=> def
    { :<^=> {*} }                               #= infix:<^=>

## list item separator
token infix is Comma[]                          #= infix:<,> def
    { :<,> {*} }                                #= infix:<,>

## loose unary
token prefix is Loose_unary[]                   #= prefix:<true> def
    { :<true> {*} }                             #= prefix:<true>

token prefix is Loose_unary[]                   #= prefix:<not> def
    { :<not> {*} }                              #= prefix:<not>

## list prefix (really sub calls mostly defined in Prelude)
token prefix is List_prefix[:symbol<listop>]                   #= prefix:<print> def
    { <listop> \s <nofat>
        <EXPR(%list_prefix<prec>)>              {*} #= prefix:<print>
    }

# unrecognized identifiers are assumed to be post-declared subs.
token prefix is List_prefix[:symbol<listop_postdecl>]   #= prefix:<print> def
    { <ident> \s <nofat>
        <EXPR(%list_prefix<prec>)>              {*} #= prefix:<print>
    }

token prefix is List_prefix[:symbol<$:>]              #= prefix:<$:> def
    { <noun_prefix_sigil> \: \s
        <EXPR(%list_prefix<prec>)>              {*}  #= prefix:<$> 
    }

token prefix is List_prefix[:symbol<Type:>]           #= prefix:<Type:> def
    { <typename> \: \s
        <EXPR(%list_prefix<prec>)>              {*}  #= prefix:<Type:> 
    }

## loose and
token infix is Loose_and[]                      #= infix:<and> def
    is abstract('if')
    { :<and> {*} }                              #= infix:<and>

## loose or
token infix is Loose_or[]                       #= infix:<or> def
    is abstract('unless')
    { :<or> {*} }                               #= infix:<or>

token infix is Loose_or[]                       #= infix:<xor> def
    is abstract('xor')
    { :<xor> {*} }                              #= infix:<xor>

token infix is Loose_or[]                       #= infix:<err> def
    { :<err> {*} }                              #= infix:<err>

## expression terminator

# XXX correct to eat semicolon here?
token terminator is Terminator[]                #= terminator:<;> def
    { :<;> {*} }                                #= terminator:<;>

token terminator is Terminator[]                #= terminator:['<=='] def
    { <?before :['<=='] > {*} }                 #= terminator:['<==']

token terminator is Terminator[]                #= terminator:['==>'] def
    { <?before :['==>'] > {*} }              #' #= terminator:['==>']

token terminator is Terminator[]                #= terminator:<)> def
    { <?before :<)> > {*} }                     #= terminator:<)>

token terminator is Terminator[]                #= terminator:<]> def
    { <?before :<]> > {*} }                     #= terminator:<]>

token terminator is Terminator[:symbol<}>]      #= terminator:<}> def
    { <?before \}> {*} }                        #= terminator:<}>

token terminator is Terminator[]                #= terminator:<!!> def
    { <?before :<!!> > {*} }                    #= terminator:<!!>

token stdstopper { <terminator> | <statement_cond> | <statement_loop> | $ }
token assertstopper { <stdstopper> | \> }

# A fairly complete (but almost certainly buggy) operator precedence parser

method EXPR (:$prec = $LOOSEST, :$stop = &stdstopper) {
    constant $TERMINATOR = ';' ~~ &terminator;
    my $inquote is context = 0;
    if m:p/ <?before <$stop>> / {
        return;
    }
    my $prevop is context is rw;
    my @termstack;
    my @opstack;
    push @opstack, $TERMINATOR;         # (just a sentinel value)
    push @termstack, $.expect_term();

    my sub reduce () {
        my $op = pop @opstack;
        given $op.assoc {
            when 'chain' {
                my @chain;
                push @chain, pop(@termstack);
                push @chain, $op;
                while @opstack {
                    last if $op.prec ne @opstack[-1].prec;
                    push @chain, pop(@termstack);
                    push @chain, pop(@opstack);
                }
                push @chain, pop(@termstack);
                $op.chain = reverse @chain;
                push @termstack, $op;
            }
            when 'list' {
                my @list;
                push @list, pop(@termstack);
                while @opstack {
                    last if $op.symbol ne @opstack[-1].symbol;
                    push @list, pop(@termstack);
                    pop(@opstack);
                }
                push @list, pop(@termstack);
                $op.list = reverse @list;
                push @termstack, $op;
            }
            default {
                $op.right = pop @termstack;
                $op.left = pop @termstack;
                push @termstack, $op;
            }
        }
    }

    while not m:p/ <?before <$stop> > / {
        my $infix := $.expect_infix($prec) // $TERMINATOR;
        my Str $newprec = $infix.prec;

        # Does new infix (or terminator) force any reductions?
        while @opstack[-1].prec lt $newprec {
            reduce();
        }

        # Not much point in reducing the sentinels...
        last if $newprec lt $LOOSEST;

        # Equal precedence, so use associativity to decide.
        if @opstack[-1].prec eq $newprec {
            given $infix.assoc {
                when 'non'   { panic(qq["$infix" is not associative]) }
                when 'left'  { reduce() }   # reduce immediately
                when 'right' | 'chain' { }  # just shift
                when 'list'  {              # if op differs reduce else shift
                    reduce() if $infix.symbol !eqv @opstack[-1].symbol;
                }
                default { panic(qq[Unknown associativity "$_" for "$infix"]) }
            }
        }
        push @opstack, $infix;
        if m:p/ <?before <$stop>> / {
            fail("$infix.perl() is missing right term");
        }
        push @termstack, $.expect_term();
    }
    reduce() if @termstack > 1;
    @termstack == 1 or panic("Internal operator parser error");
    return @termstack[0];
}

#############################################3333
## Regex
#############################################3333

rule regex ($stop is context) {
    <regex_ordered_disjunction>
                                                        {*} #= rx
}

rule regex_ordered_disjunction {
    <'||'>?
    <regex_ordered_conjunction>
    [ :<||> <regex_ordered_conjunction> ]*
                                                        {*} #= rx_ord_dis
}

rule regex_ordered_conjunction {
    <regex_unordered_disjunction>
    [ :<&&> <regex_unordered_disjunction> ]*
                                                        {*} #= rx_ord_con
}

rule regex_unordered_disjunction {
    <'|'>?
    <regex_unordered_conjunction>
    [ :<|> <regex_unordered_conjunction> ]*
                                                        {*} #= rx_unord_dis
}

rule regex_unordered_conjunction {
    <regex_sequence>
    [ :<&> <regex_sequence> ]*
                                                        {*} #= rx_unord_con
}

rule regex_sequence {
    <regex_quantified_atom>+
    # Could combine unquantified atoms into one here...
                                                        {*} #= rx_seq
}

rule regex_quantified_atom {
    <regex_atom>
    [ <regex_quantifier>
        <?{ $<regex_atom>.max_width }>
            || <panic: "Can't quantify zero-width atom")
    ]?
                                                        {*} #= rx_quantatom
}

rule regex_atom {
    [
    || <$+stop> :: <fail>
    || <regex_metachar>
    || (.)
    ]
                                                        {*} #= rx_atom
}

# sequence stoppers
token regex_metachar { :['>'] :: <fail> }
token regex_metachar { :<&&>  :: <fail> }
token regex_metachar { :<&>   :: <fail> }
token regex_metachar { :<||>  :: <fail> }
token regex_metachar { :<|>   :: <fail> }
token regex_metachar { :<]>   :: <fail> }
token regex_metachar { :<)>   :: <fail> }
token regex_metachar is symbol<}>
                     { \}     :: <fail> }

# "normal" metachars
token regex_metachar { <block> }
token regex_metachar { <quantifier> <panic: quantifier quantifies nothing> }
token regex_metachar { <regex_mod_internal> }
token regex_metachar { :<[> <regex \]> :<]> }
token regex_metachar { :<(> <regex \)> :<)> }
token regex_metachar { :<\>> <regex_rightangle> }
token regex_metachar { :['<('] }
token regex_metachar { :[')>'] }
token regex_metachar { :['<<'] }
token regex_metachar { :['>>'] }
token regex_metachar { :['<'] <regex_assertion> :['>'] }
token regex_metachar { :<\\> <regex_backslash> }
token regex_metachar { :<.> }
token regex_metachar { :<^^> }
token regex_metachar { :<^> }
token regex_metachar { :<$$> }
token regex_metachar {
    | :<$> <before $
                 | \s
                 | \|
                 | \)
                 | \]
                 | \>
           >
    | <variable>
}

token codepoint {
    \[ (.*?) \]
}

token q_backslash { :<qq> <qq_bracketed> }
token q_backslash { :<\> }
token q_backslash { (.) }

token qq_backslash { :<a> }
token qq_backslash { :<b> }
token qq_backslash { :<c> <codepoint> }
token qq_backslash { :<e> }
token qq_backslash { :<f> }
token qq_backslash { :<n> }
token qq_backslash { :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token qq_backslash { :<r> }
token qq_backslash { :<t> }
token qq_backslash { :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token qq_backslash { :: \W || <panic: unrecognized backslash sequence> }

token regex_backslash { :i :<a> }
token regex_backslash { :i :<b> }
token regex_backslash { :i :<c> <codepoint> }
token regex_backslash { :i :<d> }
token regex_backslash { :i :<e> }
token regex_backslash { :i :<f> }
token regex_backslash { :i :<h> }
token regex_backslash { :i :<n> }
token regex_backslash { :i :<o> [ <octnum> | \[<octnum>[,<octnum>]*\] ] }
token regex_backslash { :i :<r> }
token regex_backslash { :i :<t> }
token regex_backslash { :i :<v> }
token regex_backslash { :i :<w> }
token regex_backslash { :i :<x> [ <hexnum> | \[<hexnum>[,<hexnum>]*\] ] }
token regex_backslash { :: <panic: unrecognized regex backslash sequence> }

token regex_assertion { :<?> <regex_assertion> }
token regex_assertion { :<!> <regex_assertion> }

token regex_assertion { <block> }
token regex_assertion { <variable> }
token regex_assertion { <ident> [               # is qq right here?
                                | \: <?ws>
                                    <q_unbalanced(%sublang<qq><esc>, :stop«>»))>
                                | \( <EXPR> \)
                                | <?ws> <EXPR>
                                ]?
}

token regex_assertion { <before :<[>> <cclass_elem>+ }
token regex_assertion { <before :<+>> <cclass_elem>+ }
token regex_assertion { <before :<->> <cclass_elem>+ }

token regex_assertion { <panic: unrecognized regex assertion> }

token cclass_elem {
    [ \+ | - | <null> ]
    [
    | <name>
    | <before \[> <bracketed(QLang('cclass'))>
    ]
}

token regex_mod_internal { :<:i> <regex_mod_arg>? }
token regex_mod_internal { <panic: unrecognized regex modifier> }

token regex_mod_external { :<:nth> <regex_mod_arg> }
token regex_mod_external { <panic: unrecognized regex modifier> }

token regex_quantifier { :<**> <?ws> <block> <quantmod> }
token regex_quantifier { :<*> <quantmod> }
token regex_quantifier { :<+> <quantmod> }

token quantmod { [ \? | \! | \: | \+ ]? }

# The <panic: message> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

rule panic (Str $s) { <commit> <fail($s)> }

## vim: expandtab sw=4
