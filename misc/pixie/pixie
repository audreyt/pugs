#!/usr/local/bin/perl

use Getopt::Long;
my $nocolor;
my $vertical;
my $yaml;
my $quiet;
BEGIN {
    GetOptions("nocolor"=>\$nocolor,"vertical"=>\$vertical,"quiet"=>\$quiet,"yaml"=>\$yaml);
    unless ($#ARGV <= 0) {
        die "USAGE: [--nocolor] [filename]\n";
    }
    if ($quiet) {
        $SIG{__WARN__} = sub {};
        open(STDERR,">/dev/null");
    }
}
eval {
use lib '../../src/perl6';
use STD5;
use ElfCore5;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
require 'mangle.pl'; 
use strict;
use warnings;

if ($nocolor) {
    $DumpMatch::NOCOLOR = 1;
}

my $what = 'comp_unit';
my $text;
{
local $/;
$text = Encode::decode('utf8', scalar <>);
}

{ package pixie_actions;
    use Moose;
    sub make($) {
        $_->{''} = $_[0];
    }
    sub adapter {
        local $_;
        if (ref $_[0] eq 'ARRAY') {
            [map {$_->item} @{$_[0]}];
        } else {
            $_[0]->item;
        }
    }
    sub comp_unit {
        make (IRx1::CompUnit->new(statements=>$_->{statementlist}->item));
    }
    sub term__S_356name__listop__args {
        make (IRx1::Apply->new(function=>$_->{name}->item,capture=>$_->{arglist}->item));
    }
    sub arglist {
        if ($_->{EXPR}{infix} && $_->{EXPR}{infix}->item eq ',') {
            make (IRx1::Capture->new(arguments=>[map {$_->{noun}{''}} @{$_->{EXPR}{list}}]));
        } elsif ($_->{EXPR}{noun}) {
            make (IRx1::Capture->new(arguments=>[$_->{EXPR}{noun}->item]));
        }
    }
    sub statement__expr {
        if ($_->{EXPR}{noun}) {
            make ($_->{EXPR}{noun}->item)
        }
    }
    sub noun {
        make($_->{term}->item) if $_->{term};
        make($_->{value}->item) if $_->{value}; 
    }
    sub value {
        make(IRx1::Buf->new(buf=>$_->{quote}{nibble}->item)) if $_->{quote};
    }
    sub statementlist {
        make(adapter($_->{statement}));
    }
}
#pixie_actions::comp_unit();
my $actions = pixie_actions->new();
{ package Perl_with_actions;
    use Term::ANSIColor qw(:constants);
    BEGIN {our @ISA = qw(Perl) }
    sub _REDUCE {
        my $self = shift;
        my $tag = shift;
        $tag =~ s/ /__/g;
        if ($actions->can($tag)) {
            print (GREEN,$tag,"\n",RESET) unless $quiet;
            {local $_ = $self;$actions->$tag();}
            $self;
        } else {
            print (RED,$tag,"\n",RESET) unless $quiet;
            $self->SUPER::_REDUCE($tag);
        }
    }
}

my $r = Perl_with_actions->new($text)->$what();
if ($yaml) {
    print Dump($r);
    exit;
} else {
    print dump_match($what=>$r,{vertical=>1,actions=>sub {Compiler::dump_IRx1(@_)}}),"\n" unless $quiet;
}
my $ir = $r->{''};
my $code = $GLOBAL::emitter1->prelude_lexical . $ir->callback($GLOBAL::emitter1);
print $GLOBAL::emitter1->tidy($code),"\n" unless $quiet;
eval($code);
print "error: $@" if $@;
};
if ($@) {
    print "fatal error: $@";
    die;
}

