Getting rid of the C stack in YAP6
=====================================================================

At first, a question must be made, which is "why do I need to get rid
of the C stack"? The answer resides in the Perl 6 feature set, more
than anything else. My inspiration on this is the stackless python
project (which was not adopted by the mainstream python) because it
makes the support for continuations and co-routines much easier. It
would be possible to implement it using the C stack, but this would
require mixing the manipulation of the C stack with the manipulation
of the Perl 6 stack, which may be very complex. Let's think about the
gather/take operators. They may be called from a very deep level of
the stack. Mixing that with interpreted code and the C stack would be
very much complex.

The solution would be to simply remove the C stack from the
story. This would make a single frame stack to exist, and considering
it's separated from the C stack, it's more easily manipulated. But how
to implement a simple stackless C code that supports that? The
solution is actually quite simple and is completely inspired in the
stackless project. The key thing is, instead of calling a function,
you just prepare it by putting it on top of the stack. The "machine"
runs by popping the message from the stack and calling it. The
difference here is that: if this call would call another message,
instead of calling it directly, it push the call to the stack and
returns immediatly. The "machine" would again pop from the stack and
now it would call the deeper method, having the Perl stack complete
but without feeding the C stack. Simple as:


// create a stack.
YAP6__Object* stack = YAP6__STACK__Stack__Init();
// populate the stack here
YAP6__STACK__Stack__Push(stack, node);
// add a continuation to the top-most frame
YAP6__STACK__Stack__Continue(stack, node);

while (!YAP6__STACK__Stack__IsEmpty(stack) {
    YAP6__STACK__Stack_Next(stack);
    YAP6__STACK__Stack_Eval(stack);
}
YAP6_RELEASE(stack);

Not all frames will represent a lexical scope, but the lexical scopes
will be referenced from the stack, in a way that scope destructions
happens naturally once the frame is dropped. The same happens with
exeption handling and debug information. Any frame may contain debug
information about source and line number, as well as can mark a jail
for exeptions. The die code would simply pop the stack until it finds
a jail. Coroutines could simply keep a reference of the current frame
node (with the continuation reference) just before popping.

The YAP6 stack API would be:

YAP6__INTERNAL__Stack__Node* is the object of one message. It should
be a YAP6__Object and should have the following information:

 * metaclass: the metaclass that handles the message.
 * identifier: the message string identifier (probably the method
                 name).
 * capture: the arguments for this message, a Capture object.
 * outer: the outer stack frame to which this call should return.
 * result: if defined, this node has already been executed and references
                 the return value for it.
 * continuation: if defined, this references the continuation for this
                 node.
 * past: this defines the node that was continued by the current node.
 * debug: any debug information like source file name and line
                 number.
 * jail: if set, this value is a marker that here might have a handler
                 for an exception. Stack manipulation will be required
                 to make the checking.
 * lexical: a reference to the lexical scope to which this frame 
                 points to.

YAP6__INTERNAL__Stack* is the object that holds the reference to the
top-most node. It's important that this should not be global, so we
can have different threads starting from any point and exiting after
an "async" block.


The methods would be

 * YAP6__INTERNAL__Stack__Init(): this would initialize an empty stack.
 * YAP6__INTERNAL__Stack__Push(stack, node):
                 push a message to the top of the stack.
 * YAP6__INTERNAL__Stack__Continue(stack,node):
                 add a message as a continuation for the top message.
 * YAP6__INTERNAL__Stack__Next(stack): returns the next message on the
                 stack, obeying continuations.
 * YAP6__INTERNAL__Stack__Eval(stack): Evaluate the top-most node.
 * YAP6__INTERNAL__Stack__Drop(stack): drop the top-most frame, ignoring
                 continuations (exceptions and coroutines).
 * YAP6__INTERNAL__Stack__Invoke(stack, message): Invokes a message that
                 is not in the stack anymore. This message may manipulate
                 the stack.


It is important to remember, however that all the objects referenced
here are also YAP6__Object. And the frame stack may be exposed to the
high-level language. A new stack may even be built in high-level
language and dispatched.


Stack navigation:

 <- means a "past" link
 -> means a "continuation" link
 |  means an "outer" link (from the upper to the lower)
 *  means the selected node for evaluation.

                          *
                1 <- 2 <- 3 -> 4 -> 5                  Frame 3
                          |
                1 <- 2 <- 3 -> 4 -> 5 -> 6             Frame 2
                          |
           1 <- 2 <- 3 <- 4 -> 5 -> 6 -> 7             Frame 1

This basically means that when a node is selected the links are
changed from:

            *
  1 <- 2 <- 3 -> 4 -> 5 -> 6
            |

to:

                 *
  1 <- 2 <- 3 <- 4 -> 5 -> 6
                 |

Where the stack has only a reference to the selected node.

One important point here is that the objects are destroyed when the
frame is destroyed, and the frame is subject to garbage
collection. This also means that when the frame is saved in some
variable, it won't be destroyed. You probably realised how easy it is
to implement co-routines with that.

Continuations may be easily implemented also, as it would mean
dropping and pushing a frame from the same node:

              original               continuation
                                          *
            1 <- 2 <- 3 (destroied)  1 <- 2 -> 3             Frame 2
                                          |
  1 <- 2 <- (3 ... ... ...  ... ... ... ...) -> 4 -> 5 -> 6  Frame 1


Return values are obtained from any past node in the same frame by
counting backwards (following the number of "past" links). An
optimizer may break the linkage when some data is known as not
important for the rest of the code. This is an important aspect, as
anyone wanting to manipulate the frame must realize that this may
cause breakage. If you want to discard the return value of a node, you
may just set the result to -1. This will avoid the return for staying
alive for more time than wanted.

You might notice that this causes a recursive problem, that for
fetching a past result you need a node, so how can you actually use a
past result?

When you think a bit more about it, you'll notice that having a C
method to get a result from a past node doesn't actually help you much
when you want to receive a capture in the next node. This is why you
can call lowlevel operators from the stack.

Basically, low-level modules exist in YAP6 as meta-classes that can
understand calls that other metaclasses don't. The identifier is still
used to identify which operator, and the capture is used as a opaque
data structure defined for each operator. Regarding the stack, some
operators are specially usefull. More interesting yet is the fact that
this metaclass objects will be available to the high-level.


===================
stack_capture_to_node:

struct stack_capture_to_node {
       int invocant;
       int** positional;
       int** named;
       int target;
}

Where:
  invocant: where in the past nodes to fetch the invocant;
  positional: a null terminated int array describing where
    to get the positional arguments.
  named: a null terminated int array describing where to
    get the pairs for each named argument.
  target: where in the continuation nodes to store the capture.

===================
stack_metaclass_to_node:

struct stack_metaclass_to_node {
       int metaclass;
       int target;
}

Where:
  metaclass: where in the past nodes to fetch the metaclass;
  target: where in the continuation nodes to store the metaclass;

===================
stack_identifier_to_node:

struct stack_identifier_to_node {
       int identifier;
       int target;
}

Where:
  identifier: where in the past nodes to fetch the identifier;
  target: where in the continuation nodes to store the identifier;