# pX/Common/iterator_engine_p6.pl - fglock
#
# experimental implementation of a grammar that could parse p6 
# files, like pge/P6Rule.grammar

use strict;
use warnings;

require 'iterator_engine_p6rule.pl';

# XXX - make grammars inherit from Grammar; make grammars inheritable
# XXX - write an emitter that generates perl5 regexes (or dies)
# XXX - add (API/documentation) to generate unnamed rules, unnamed grammars
# XXX - fix the extra commas in the generated code
# XXX - create error messages for compiling errors

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Pad = '# ';

{
  package grammar1;

  no warnings 'once';

  *grammar_name = 
        ruleop::capture( 
            'grammar_name', 
            ::compile_rule( 'grammar (.*?) \;' )
        ); 
  *rule_decl = 
        ruleop::capture( 
            'rule_decl',
            ::compile_rule( 'rule <ws>+ (<word>) <ws>* \{ (<rule>) \}' )
        ); 

  # XXX forward declaration of 'pod'
  my $pod = sub{};
  sub grammar1::podx { $pod->(@_) }

  *grammar = 
        ::compile_rule( '[<ws>*[<podx>|<grammar_name>|<rule_decl>]]*<ws>*' );

  # XXX - install the code in the grammar using an array ref

  Perl6Grammar::compile( <<'__END_GRAMMAR', { print_program=>0 } )->();
    grammar grammar1;
    rule pod { \=[pod|head1] .*? \=cut }
__END_GRAMMAR

  # TODO - rule comment { \# .*? <newline> }

  $pod = \&pod;

}

# ------ grammar emitter

my $namespace = 'grammar1::';

{
  package Perl6Grammar;
  use Data::Dumper; 

sub header {
    return <<EOT;
#! perl
#
# grammar file
# perl5 code generated by iterator_engine_p6grammar.pl - fglock

use strict;
use warnings;
require 'iterator_engine.pl';
require 'iterator_engine_p6rule_lib.pl';

EOT
}

# compile( $source, {flag=>value} );
#
# flags:
#   print_program=>1 - prints the generated program
#
sub compile {
    my $match = grammar1::grammar->( $_[0] );
    my $flags = $_[1];
    die "syntax error in rule '$_[0]' at '" . $match->{tail} . "'\n"
        if $match->{tail};
    die "syntax error in rule '$_[0]'\n"
        unless $match->{bool};
    my $program = emit( $match->{capture} );
    print "generated rule:\n$program" if $flags->{print_program};
    my $code = eval($program); die $@ if $@;
    return $code;
}

sub emit 
{
    my $n = $_[0];
    local $Data::Dumper::Indent = 0;
    #print "emit_rule: ", ref($n)," ",Dumper( $n ), "\n";

    # $n = $n->{match};

    if ( ! defined $n ) {
        # empty node; maybe a <null> match
        return;
    }
    if ( ref( $n ) eq 'ARRAY' ) {
        my @s;
        for ( @$n ) {
            push @s, emit( $_ );
        }
        return join( '', @s ) ;
    }
    elsif ( ref( $n ) eq 'HASH' ) 
    {
        my ( $k, $v ) = each %$n;
        #print "$k => $v \n";

        if ( $k eq 'pod' ) {
            return;
        }
        if ( $k eq 'grammar_name' ) {
            #print Dumper $v;
            my @captures = grep { ref($_) eq 'HASH' } @$v;
            my $name = join('', @{ $captures[0]{capturing_group} } );
            return "package $name;\n";
        }
        if ( $k eq 'rule_decl' ) {
            local $Data::Dumper::Indent = 1;
            # print "*** rule_decl:\n",Dumper $v;
            my @captures = grep { ref($_) eq 'HASH' } @$v;
            my $name = $captures[0]{capturing_group}[0];
            my $ast = $captures[1]{capturing_group};
            #print "*** ast:\n",Dumper $ast;

            my $program = main::emit_rule( $ast );

            #print "rule_decl captures:\n",Dumper @captures;
            return "*$name = \n$program;\n";
        }
        else {
            die "unknown node: ", Dumper( $n );
        }
    }
    else 
    {
        die "unknown node: ", Dumper( $n );
    }
}

} # /package

1;
