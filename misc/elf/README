OVERVIEW

Elf is a p6 compiler.

The currently recommended version is:
  elf_f

elf_f --help  for more info.

It uses perl from your path.  5.10 is recommended - it can have half
the startup time of 5.8.8.

elf_f_faster is faster, but not always equivalent.

P6 scripts:
  $ cat say3
  #!/usr/bin/env elf_f_faster
  say 3;
  $ ./say 3
  3


INSTALL

The elf executable is generic perl 5.
It can be called from any directory.  It can be renamed.
It can be moved to a different directory, but expects to find its STD_red
parser in either ../STD_red or elf_X_src/STD_red, relative to the
directory of the executable, and depending on whether it's on active
development or slushy/frozen.

STD_red requires ruby 1.9.  See it's README for installation info.

RUNNING TESTS

  See run-tests in elf_f_src.

  You can run a couple of tests with
    prove --exec 'perl elf_d' - < TESTS
  If you find that any other tests run please put them into TESTS.

TIPS

    eval_perl5('sub{print Data::Dumper::Dumper($_[0])}').($n);


VERSIONS

elf_f
Purpose:
  Use improved STD_red.
  Start working on t/ .
  Create PreludeP5 - p6 with p5 inline (agnostic to exact p5 backend via api).
  Drop support for compilation by elf_d.
Maybe:
  Branches - additional and renamed: Good / Main / Faster.(?)
Comparison: Like elf_e, but new parser version.
Written in: elf_f dialect.
Can be compiled by: elf_f.
Linkages: none.
Status: active development.

elf_e
Purpose: Using IR analysis to clean up the emitted runtime.
  sub decls no longer global.
  Start of p6 Prelude.
  Addressed some other inconvenient implementation limitations.(What?)
Comparison: Like elf_d.
Written in: elf_d dialect.
Can be compiled by: elf_e, elf_d.
Linkages: uses a couple of files from elf_d.
  CommandLine.pm EmitNoMooseP5.pm Match.pm Parser.pm
Status: slushy.

OLD VERSIONS

elf_d
Purpose: New IR.  New metaprogramming infrastructure.
Comparison:
  Like elf_c, but with new IR nodes.
  @ISA can be incrementally extended.
Written in: elf_c dialect.
Can be compiled by: elf_d, elf_c.
Status: frozen.

elf_c
Purpose: Refactored with has().  Added use().
Comparison: Like elf_b, but written in elf_b p6, not elf_a p6 (basically +has).
Written in: elf_b dialect.
Emits: Currently same as elf_b, but that may change. (Did it?)
Can be compiled by: elf_c only.
Linkages:
  ast_handlers and ir_nodes are copies of those in std_b.
  They can't be regenerated, but only recopied by hand.
  The hope is elf_c won't remain active long enough for that to be a problem.
Status: frozen.

elf_b
Purpose: Switch implementation language from p5 to p6.
Comparison: Like elf_a, but written in p6.
Written in: p6, elf_a dialect.
Emits: Slighly less simple and less fast p5 than elf_a.
Can be compiled by: elf_b, elf_a.
Linkages:
  Uses elf_a ast_handlers, mechanically massaged into p6.
  Uses elf_a's copy of STD_red.
Status: frozen.

elf_a
Why: First step.
Written in: p5
Emits: Simple and fast p5.
Status: frozen.


OTHER

A development story (a tale of two compilers)

  Say someone hands you a working perl6.
  What can you do with it?

  If you alrady have your own implementation of p6, written in p6,
  you could now compile it.
    six -o mysix -x MySix.pm

  But you could *not*, in general, do
    six MySix.pm
  If you tried, as MySix was compiled (which can involve running) and
  run, it would stomp all over the implementation of six.  In general,
  breaking it.

  If you instead wanted to make small, *compatible* changes to six,
  you could do
    six TweakSix.pm ...
  Which would likely give you 'mumble was redefined' warnings, but
  could otherwise be harmless and helpful.

  But what if you have something inbetween.  More than a compatible
  tweak, but less than a full implementation.  Some hook apis are
  provided to permit larger changes.

  To make it easier to work on new compilers, the compiler for
  internal use need not be the same one used to provide external
  compiled code.  And the compiler used for each, can be independently
  hot-swapped at runtime.  That's why there are conceptually two
  compilers.  And $*compiler0, $*compiler1, $*emitter0, $*emitter1, etc.

