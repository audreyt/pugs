
class EmitM0ld {

  method new_emitter($ignore,$compiler,$ignore2,$filename) {
    self.new('compiler',$compiler,'filename',$filename);
  };

  has $.SEQ = 1;
  has $.compiler;
  has $.filename;

  method tidy($source) {
      $source;
  }

  method prelude_lexical () {
      "# prelude lexical\n"
  }

  method prelude ($n) { "# prelude\n" }

  method e($x,$arg) {
    my $ref = $x.WHAT;
    if $ref eq 'Undef' { $x }
    elsif $ref eq 'Str' || $ref eq 'Int' || $ref eq 'Num' { $x }
    elsif $ref eq 'Array' { $x.map(sub($ae){$.e($ae,self.genid)}) }
    else {$x.callback(self,$arg)}
  }

  method genid () {
      # i'm too lazy to fix methods to be lvalues *again*
      self.SEQ = self.SEQ + 1;
      return 'id'~self.SEQ;
  }
  method cb__CompUnit ($n) {
      "# this is autogenerated m0ld code\n" ~ $.e($n.statements).join('')~'#';
  }
  method cb__Call ($n,$ret) {
      my $id = self.genid;
      my $args = "";
      my $arguments = $n.capture.arguments;
      if ($arguments.elems == 1 && $arguments[0].isa("IRx1::Apply") && $arguments[0].function eq "infix:,") {
          $arguments = $arguments[0].capture.arguments;
      }
      my $do_args = '';
      my $pass_args = '';
      for $arguments.keys -> $i {
          $do_args = $do_args ~ $.e($arguments[$i],"pos_"~$id~"_"~$i);
          $pass_args = '$' ~ $pass_args ~ "pos_"~$id~"_"~$i;
          if $i {
              $pass_args = $pass_args ~ ',';
          }
      }
      $.e($n.invocant,'i_'~$id) 
      ~ $do_args ~
#      ~ 'my $id_' ~ $id ~' = "'~$n.method~'"' ~ ";\n" 
      ~ 'my $' ~ $ret ~ ' = $i_' ~ $id ~ '."' ~ $n.method ~ '"('~$pass_args~");\n";
  }
  method cb__Apply ($n,$ret) {
      my $id = self.genid;
      if ($n.function eq 'return') {
          my $arguments = $n.capture.arguments;
          my $positionals = "";
          for $arguments.keys -> $i {
              $positionals = $positionals ~ $.e($arguments[$i],"pos_" ~ $id ~ "_" ~ $i);
          }
          'i_' ~ $id ~ ': $continuation;' ~ "\n" ~ 
          $positionals ~
          '$SMOP__SLIME__CurrentFrame.move_capturize('~self.capturize($arguments,$id)~");\n" ~
          $ret ~ ': $continuation.$SMOP__ID__setr();' ~ "\n"
      } elsif ($n.function eq 'infix:=') {
        IRx1::Call.new('invocant',$n.capture.arguments[0],'method','STORE','capture',IRx1::Capture.new('arguments',[$n.capture.arguments[1]])).callback(self,$ret);
      } elsif ($n.function eq 'circumfix:( )') {
          $n.capture.arguments[0].callback(self,$ret);
      } else {
          die "unsupported form of Apply\n";
      }
  }

  method cb__Buf ($n,$ret) {
      'my $' ~ $ret ~ " = " ~ '"' ~ $n.buf.re_gsub(/\n/,"\\n") ~ '"' ~ ";\n"; #TODO: quote \ and "
  }
  method cb__NumInt ($n,$ret) {
      'my $' ~ $ret ~ " = " ~ $n.text ~ ";\n";
  }
  method cb__Block ($n,$label) {
      $label ~ ": " ~ "{\n;\n"~ $.e($n.statements).join('') ~ "};\n"
  }
  method cb__SubDecl ($n,$label) {
      IRx1::Call.new('invocant',IRx1::Var.new('sigil','::','name','Code'),'method','new','capture',IRx1::Capture.new('arguments',[$n.block])).callback(self,$label);
  }

  method cb__Var ($n,$ret) {
      if $n.sigil eq '$' and $n.twigil ne '*' {
          'my $'~ $ret ~ ' = ¢' ~ $n.name ~ ";\n";
      } else {
          'my $'~ $ret ~ ' = ¢SMOP__S1P__RootNamespace."postcircumfix:{ }"("' ~ $n.sigil ~ ($n.twigil || '') ~ $n.name ~ '")' ~ ";\n";
      }
  }

}
