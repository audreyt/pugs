#!/usr/bin/perl
# Write the emitter source code file.
# Because p5 doesn't have macros, and people don't like Filter::Simple.
use strict;
use warnings;
require '../kp6_ast/kp6_ast_def.pl';
my @nodes = KP6_AST_Def::nodes();

our $write_to_file = "emit_from_kp6.pl";


sub method_name {
    my($node_name)=@_;
    $node_name =~ s/::/_/g;
    'emit_kp6_'.$node_name;
}

my $code = "";
$code .= <<"END";
# WARNING
# This file is written by $0.
# YOUR EDITS TO THIS FILE WILL BE LOST.

END

$code .= <<'END';

package BackendBarePerl5;
use SimpleDispatchOnTypeSuffix;
use strict;
use warnings;

sub new {
    my($cls)=@_;
    my $self = {
	dispatcher => SimpleDispatchOnTypeSuffix->new(),
    };
    bless $self,$cls;
    $self->initialize();
}

sub dispatch_type_to {
    my($self,$type,$to)=@_;
    $self->{dispatcher}->dispatch_type_to($type,$to);
}

sub emit {
    my($self,$obj,@rest)=@_;
    my $handler = $self->{dispatcher}->lookup($obj);
    die "No handler for $obj" if not $handler;
    $handler->($self,$obj,@rest);
}

sub initialize {
    my($self)=@_;
END

for my $node (@nodes) {
    my $name = $node->name;
    my $dispatch_name = 'KP6AST::'.$name;
    my $method_name = method_name($name);
    $code .= "    \$self->dispatch_type_to('$dispatch_name',\\\&$method_name);\n";
}

$code .= <<'END';
}

END

sub node {
    my($name,$emitter_code)=@_;
    my $node = KP6_AST_Def->node_from_name($name);
    my $method_name = method_name($name);
    $code .= 'sub '.$method_name." {\n".'    my($self,$obj)=@_;'."\n";
    my @fields = $node->fields;
    if(@fields) {
	$code .= '    my(';
	for my $field (@fields){ $code .= '$'.$field->identifier.','; }
	substr($code,-1) = ""; #clip the trailing comma
	$code .= ')=(';
	for my $field (@fields){ $code .= '$obj->{'.$field->identifier.'},'; }
	substr($code,-1) = ""; #clip the trailing comma
	$code .= ");\n";
    }
    $code .= $emitter_code;
    $code .= "}\n";
}


node 'CompUnit',<<'END';
{
    # $unit_type $name $traits $attributes $methods $body 

}
END
node 'Val::Int',<<'END';
{
    # $int 
    $int;
}
END
node 'Val::Bit',<<'END';
{
    # $bit 
    $bit;
}
END
node 'Val::Num',<<'END';
{
    # $num 
    $num;
}
END
node 'Val::Buf',<<'END';
{
    # $buf 
    $buf;
}
END
node 'Val::Char',<<'END';
{
    # $char 
    "chr($char)";
}
END
node 'Val::Undef',<<'END';
{
    # 
    'undef';
}
END
node 'Val::Object',<<'END';
{
    # $class $fields 
    die "Even kp6 Emit/Perl5 doesn't implement $obj";
}
END
node 'Lit::Seq',<<'END';
{
    # $seq 
    '('.join(', ',map{$self->emit($_)} @{$seq}).')';
}
END
node 'Lit::Array',<<'END';
{
    # $array 
    '['.join(', ',map{$self->emit($_)} @{$array}).']';
}
END
node 'Lit::Hash',<<'END';
{
    # $hash 
    '{'.join(', ',map{$self->emit($_)} @{$hash}).'}';
}
END
node 'Lit::Pair',<<'END';
{
    # $key $value 
    "[$key,$value]";
}
END
node 'Lit::SigArgument',<<'END';
{
    # $key $value $type $has_default $is_named_only $is_optional $is_slurpy $is_multidimensional $is_rw $is_copy 
    
}
END
node 'Lit::NamedArgument',<<'END';
{
    # $key $value 

}
END
node 'Lit::Code',<<'END';
{
    # $pad $state $sig $body $CATCH 
    join(";\n",map{$self->emit($_)} @{$body})
}
END
node 'Lit::Object',<<'END';
{
    # $class $fields 

}
END
node 'Var',<<'END';
{
    # $sigil $twigil $name $namespace 
    $sigil ne '&' ? '$'.$name : $name;
}
END
node 'Bind',<<'END';
{
    # $parameters $arguments 
    ('('.join(',',map{$self->emit($_)} @{$parameters}).')'.
     ' = '.
     '('.join(',',map{$self->emit($_)} @{$arguments}).')'.
     ';');
}
END
node 'Assign',<<'END';
{
    # $parameters $arguments 
    ('('.join(',',map{$self->emit($_)} @{$parameters}).')'.
     ' = '.
     '('.join(',',map{$self->emit($_)} @{$arguments}).')'.
     ';');
}
END
node 'Proto',<<'END';
{
    # $name 
    die;
}
END
node 'Call',<<'END';
{
    # $invocant $hyper $method $arguments 
    ($self->emit($invocant).'->'.$method.
     '('.join(',',map{$self->emit($_)} @{$arguments}).')'.
     '');
}
END
node 'Apply',<<'END';
{
    # $code $arguments 
    ($self->emit($code).'->'.
     '('.join(',',map{$self->emit($_)} @{$arguments}).')'.
     '');
}
END
node 'Return',<<'END';
{
    # $result 
    'return('.$self->emit($result).');'
}
END
node 'If',<<'END';
{
    # $cond $body $otherwise 
    ('if('.$self->emit($cond).") {\n".
     $self->emit($body).
     "\n}\nelse {\n".
     ($otherwise ? $self->emit($otherwise) : "").
     "\n}\n");
}
END
node 'While',<<'END';
{
    # $cond $body 
    ('while('.$self->emit($cond).") {\n".
     $self->emit($body).
     "\n}\n");
}
END
node 'Decl',<<'END';
{
    # $decl $type $var 
    my $var_sigil = $var->{sigil};
    my $setup = {
	'$' => '',
	'@' => '[]',
	'%' => '{}',
    }->{$var_sigil} || '';
    $decl.' '.$self->emit($var).$setup.";";
}
END
node 'Sig',<<'END';
{
    # $invocant $positional 
    
}
END
node 'Lit::Capture',<<'END';
{
    # $invocant $array $hash 

}
END
node 'Lit::Subset',<<'END';
{
    # $name $base_class $block 

}
END
node 'Method',<<'END';
{
    # $name $block 
    'sub '.$name.' '.$self->emit($block);
}
END
node 'Sub',<<'END';
{
    # $name $block 
    'sub '.$name.' '.$self->emit($block);
}
END
node 'Macro',<<'END';
{
    # $name $block 
    die;
}
END
node 'Coro',<<'END';
{
    # $name $block 
    die;
}
END
node 'P5Token',<<'END';
{
    # $regex 

}
END
node 'Token',<<'END';
{
    # $name $regex $sym 

}
END
node 'Do',<<'END';
{
    # $block 
    ("do{\n".$self->emit($block)."\n}");
}
END
node 'BEGIN',<<'END';
{
    # $block 
    ("INIT{\n".$self->emit($block)."\n}\n");
}
END
node 'Use',<<'END';
{
    # $mod $perl5 
    ($mod =~ /^v6/) ? "# use $mod\n" : "use $mod\n";
}
END
node 'Rule',<<'END';
{
    # 

}
END
node 'Rule::Quantifier',<<'END';
{
    # $term $quant $greedy $ws1 $ws2 $ws3 

}
END
node 'Rule::Or',<<'END';
{
    # $or 

}
END
node 'Rule::Concat',<<'END';
{
    # $concat 

}
END
node 'Rule::Subrule',<<'END';
{
    # $metasyntax $ident $capture_to_array 

}
END
node 'Rule::SubruleNoCapture',<<'END';
{
    # $metasyntax 

}
END
node 'Rule::Var',<<'END';
{
    # $sigil $twigil $name 

}
END
node 'Rule::Constant',<<'END';
{
    # $constant 

}
END
node 'Rule::Dot',<<'END';
{
    # 
    '.';
}
END
node 'Rule::SpecialChar',<<'END';
{
    # $char 

}
END
node 'Rule::Block',<<'END';
{
    # $closure 

}
END
node 'Rule::InterpolateVar',<<'END';
{
    # $var 

}
END
node 'Rule::NamedCapture',<<'END';
{
    # $rule $ident $capture_to_array 

}
END
node 'Rule::Before',<<'END';
{
    # $rule $assertion_modifier $capture_to_array 

}
END
node 'Rule::After',<<'END';
{
    # $rule $assertion_modifier $capture_to_array 

}
END
node 'Rule::NegateCharClass',<<'END';
{
    # $chars 

}
END
node 'Rule::CharClass',<<'END';
{
    # $chars 

}
END
node 'Rule::Capture',<<'END';
{
    # $rule $position $capture_to_array 

}
END

die "I don't see my target file, $write_to_file !" if !-f $write_to_file;
open(F,">$write_to_file") or die $!;
print F $code; close(F);
print "$write_to_file written.\n";
system("perl -cw $write_to_file");

1;
__END__
sub create_empty_emitter_template {
    for my $node (@nodes) {
	my $name = $node->name;
	print "node '$name',<<\'END\';\n{\n    # ";
	for my $f ($node->fields) {
	    print '$'.$f->identifier," ";
	}
	print "\n\n}\nEND\n"
    }
}
create_empty_emitter_template;
