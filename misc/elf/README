Running tests

  You can run a couple of tests with
    prove --exec 'perl elf_d' - < TESTS
  If you find that any other tests run please put them into TESTS.

Tips

    eval_perl5('sub{print Data::Dumper::Dumper($_[0])}').($n);

A development story (a tale of two compilers)

  Say someone hands you a working perl6.
  What can you do with it?

  If you alrady have your own implementation of p6, written in p6,
  you could now compile it.
    six -o mysix -x MySix.pm

  But you could *not*, in general, do
    six MySix.pm
  If you tried, as MySix was compiled (which can involve running) and
  run, it would stomp all over the implementation of six.  In general,
  breaking it.

  If you instead wanted to make small, *compatible* changes to six,
  you could do
    six TweakSix.pm ...
  Which would likely give you 'mumble was redefined' warnings, but
  could otherwise be harmless and helpful.

  But what if you have something inbetween.  More than a compatible
  tweak, but less than a full implementation.  Some hook apis are
  provided to permit larger changes.

  To make it easier to work on new compilers, the compiler for
  internal use need not be the same one used to provide external
  compiled code.  And the compiler used for each, can be independently
  hot-swapped at runtime.  That's why there are conceptually two
  compilers.  And $*compiler0, $*compiler1, $*emitter0, $*emitter1, etc.


Cast of Characters

After elf_d - subsequent objectives:
 Sufficient IR analysis for near-term backend goals.
 Facilitate start of various backends - smop, conformant p5, maybe ruby.
 Facilitate other components:
   Prelude.
   regex.
   Better command line.
   Start of STD5 integration.

elf_e
Purpose: Using IR analysis to clean up the emitted runtime.
  sub decls no longer global.
Maybe:
  Address some other inconvenient implementation limitations.
  Start of p6 Prelude.
  Change to plugin architecture?
Comparison: Like elf_d.
Written in: elf_d dialect.
Can be compiled by: elf_e, elf_d.
Linkages:
  Currently using many elf_d files.
Status: active development.

elf_d
Purpose: New IR.  New metaprogramming infrastructure.
Comparison:
  Like elf_c, but with new IR nodes.
  @ISA can be incrementally extended.
Written in: elf_c dialect.
Can be compiled by: elf_d, elf_c.
Status: active development, but getting near slush.

elf_c
Purpose: Refactored with has().  Added use().
Comparison: Like elf_b, but written in elf_b p6, not elf_a p6 (basically +has).
Written in: elf_b dialect.
Emits: Currently same as elf_b, but that may change.
Can be compiled by: elf_c only.
Linkages:
  ast_handlers and ir_nodes are copies of those in std_b.
  They can't be regenerated, but only recopied by hand.
  The hope is elf_c won't remain active long enough for that to be a problem.
Status: slushy.

elf_b
Purpose: Switch implementation language from p5 to p6.
Comparison: Like elf_a, but written in p6.
Written in: p6, elf_a dialect.
Emits: Slighly less simple and less fast p5 than elf_a.
Can be compiled by: elf_b, elf_a.
Linkages:
  Uses elf_a ast_handlers, mechanically massaged into p6.
  Uses elf_a's copy of STD_red.
Status: slushy.

elf_a
Why: First step.
Written in: p5
Emits: Simple and fast p5.
Status: slushy.
