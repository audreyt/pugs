# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package MiniPerl6::Grammar::Regex;
sub new { bless { @_ }, "MiniPerl6::Grammar::Regex" }
my $Hash_rule_terms;
sub ws { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(do { my $m2 = MiniPerl6::Grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.ws'
} = $m2;1 } else { 0 } } }); return($MATCH) };
sub ident { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = MiniPerl6::Grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.full_ident'
} = $m2;1 } else { 0 } } } || do { my $m2 = $grammar->digit($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'digit'
} = $m2;1 } else { 0 } } })); return($MATCH) };
sub literal { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { my $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'
} = $m2;1 } else { 0 } } })) || ((1 && do { my $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'
} = $m2;1 } else { 0 } } }) || 1))); return($MATCH) };
sub metasyntax { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || ((('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'
} = $m2;1 } else { 0 } } } && ('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) || ((('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->string_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'string_code'
} = $m2;1 } else { 0 } } } && ('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) || ((('\\\\<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } && ('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) || 1)))) && (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } || 1))); return($MATCH) };
sub char_range { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || 1) && (do { my $m2 = $grammar->char_range($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_range'
} = $m2;1 } else { 0 } } } || 1))); return($MATCH) };
sub char_class { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } || (('\\\\['
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->char_range($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_range'
} = $m2;1 } else { 0 } } } && ('\\\\]'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))); return($MATCH) };
sub string_code { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || ((('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'
} = $m2;1 } else { 0 } } } && ('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) || ((('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->string_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'string_code'
} = $m2;1 } else { 0 } } } && ('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) || 1))) && (do { my $m2 = $grammar->string_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'string_code'
} = $m2;1 } else { 0 } } } || 1))); return($MATCH) };
sub parsed_code { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->string_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'string_code'
} = $m2;1 } else { 0 } } } && do { return(('{'
 . ($MATCH . '}'
))) })); return($MATCH) };
sub named_capture_body { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('\\\\('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return({ capturing_group() => ${$MATCH->{'rule'
}}, }) }))) || ((('\\\\['
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\]'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(${$MATCH->{'rule'
}}) }))) || ((('\\\\<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Subrule->new( metasyntax() => ${$MATCH->{'metasyntax'
}}, )) }))) || do { die('invalid alias syntax'
) })))); return($MATCH) };
sub variables { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('$<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ident'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(('$/{'
 . ('\''
 . ($MATCH->{'ident'
} . ('\''
 . '}'
))))) }))) || ((do { my $m2 = MiniPerl6::Grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.sigil'
} = $m2;1 } else { 0 } } } && (do { my $m2 = MiniPerl6::Grammar->digits($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.digits'
} = $m2;1 } else { 0 } } } && do { return(($MATCH->{'MiniPerl6::Grammar.sigil'
} . ('/['
 . ($MATCH->{'MiniPerl6::Grammar.digits'
} . ']'
)))) })) || (do { my $m2 = MiniPerl6::Grammar->sigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.sigil'
} = $m2;1 } else { 0 } } } && (do { my $m2 = MiniPerl6::Grammar->twigil($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.twigil'
} = $m2;1 } else { 0 } } } && (do { my $m2 = MiniPerl6::Grammar->full_ident($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.full_ident'
} = $m2;1 } else { 0 } } } && do { return(Rul::Var->new( sigil() => ("" . $MATCH->{'MiniPerl6::Grammar.sigil'
}),twigil() => ("" . $MATCH->{'MiniPerl6::Grammar.twigil'
}),name() => ("" . $MATCH->{'MiniPerl6::Grammar.full_ident'
}), )) })))))); return($MATCH) };
sub rule_terms { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('('
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Capture->new( rule() => ${$MATCH->{'rule'
}}, )) }))) || ((('<('
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && ((')>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::CaptureResult->new( rule() => ${$MATCH->{'rule'
}}, )) }))) || ((('<after'
 eq (substr($str, $MATCH->to(), 6) ? (1 + $MATCH->to((6 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::After->new( rule() => ${$MATCH->{'rule'
}}, )) })))) || ((('<before'
 eq (substr($str, $MATCH->to(), 7) ? (1 + $MATCH->to((7 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Before->new( rule() => ${$MATCH->{'rule'
}}, )) })))) || ((('<!before'
 eq (substr($str, $MATCH->to(), 8) ? (1 + $MATCH->to((8 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return({ not_before() => { rule() => ${$MATCH->{'rule'
}}, }, }) })))) || ((('<!'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return({ negate() => { metasyntax() => ${$MATCH->{'metasyntax'
}}, }, }) }))) || ((('<+'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->char_class($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_class'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::CharClass->new( chars() => ("" . $MATCH->{'char_class'
}), )) }))) || ((('<-'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->char_class($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'char_class'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::NegateCharClass->new( chars() => ("" . $MATCH->{'char_class'
}), )) }))) || ((('\\\\<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->literal($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'literal'
} = $m2;1 } else { 0 } } } && (('\\\\\\\''
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Constant->new( constant() => ${$MATCH->{'literal'
}}, )) }))))) || ((('\\\\<'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((do { my $m2 = $grammar->variables($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'variables'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::InterpolateVar->new( var() => ${$MATCH->{'variables'
}}, )) })) || ((('\\\\?'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Subrule->new( metasyntax() => ${$MATCH->{'metasyntax'
}}, )) }))) || (do { my $m2 = $grammar->metasyntax($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'metasyntax'
} = $m2;1 } else { 0 } } } && (('\\\\>'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Subrule->new( metasyntax() => ${$MATCH->{'metasyntax'
}}, )) }))))) || ((('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->parsed_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parsed_code'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Block->new( closure() => ${$MATCH->{'parsed_code'
}}, )) }))) || ((('\\\\\\\\'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && ((''
 ne (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(Rul::SpecialChar->new( char() => ${$MATCH}, )) })) || ((('\\\\.'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return(Rul::Dot->new( dot() => 1, )) }) || (('['
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->rule($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule'
} = $m2;1 } else { 0 } } } && ((']'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && do { return(${$MATCH->{'rule'
}}) }))))))))))))))))); return($MATCH) };
sub term { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->variables($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'variables'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && ((':='
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->named_capture_body($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'named_capture_body'
} = $m2;1 } else { 0 } } } && do { return(Rul::NamedCapture->new( rule() => ${$MATCH->{'named_capture_body'
}},ident() => ${$MATCH->{'variables'
}}, )) })))) || do { return(${$MATCH->{'variables'
}}) })) || ((do { my $m2 = $grammar->rule_terms($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'rule_terms'
} = $m2;1 } else { 0 } } } && do { return(${$MATCH->{'rule_terms'
}}) }) || (1 && do { return(Rul::Constant->new( constant() => ${$MATCH}, )) })))); return($MATCH) };
sub quant { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((('**'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = MiniPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.opt_ws'
} = $m2;1 } else { 0 } } } && (('\\\\{'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->parsed_code($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'parsed_code'
} = $m2;1 } else { 0 } } } && (('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) && do { return({ closure() => ${$MATCH->{'parsed_code'
}}, }) }))))) || (('\\\\?'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\*'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('\\\\+'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))))); return($MATCH) };
sub greedy { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((('\\\\?'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\+'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || 1))); return($MATCH) };
sub quantifier { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = MiniPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.opt_ws'
} = $m2;1 } else { 0 } } } && ((('\\\\}'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || (('\\\\]'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)) || ('\\\\)'
 eq (substr($str, $MATCH->to(), 2) ? (1 + $MATCH->to((2 + $MATCH->to()))) : 0)))) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && ('X'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)))))) || (do { my $m2 = MiniPerl6::Grammar->opt_ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.opt_ws'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->term($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'term'
} = $m2;1 } else { 0 } } } && (do { my $m2 = MiniPerl6::Grammar->opt_ws2($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.opt_ws2'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->quant($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'quant'
} = $m2;1 } else { 0 } } } && (do { my $m2 = $grammar->greedy($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'greedy'
} = $m2;1 } else { 0 } } } && (do { my $m2 = MiniPerl6::Grammar->opt_ws3($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'MiniPerl6::Grammar.opt_ws3'
} = $m2;1 } else { 0 } } } && do { return(Rul::Quantifier->new( term() => ${$MATCH->{'term'
}},quant() => ${$MATCH->{'quant'
}},greedy() => ${$MATCH->{'greedy'
}},ws1() => ${$MATCH->{'MiniPerl6::Grammar.opt_ws'
}},ws2() => ${$MATCH->{'MiniPerl6::Grammar.opt_ws2'
}},ws3() => ${$MATCH->{'MiniPerl6::Grammar.opt_ws3'
}}, )) }))) || do { return(${$MATCH->{'term'
}}) })))))); return($MATCH) };
sub concat_list { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->quantifier($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'quantifier'
} = $m2;1 } else { 0 } } } && ((do { my $m2 = $grammar->concat_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat_list'
} = $m2;1 } else { 0 } } } && do { return([${$MATCH->{'q1'
}}, @{${$MATCH->{'q2'
}}}]) }) || do { return([${$MATCH->{'q1'
}}]) })) || do { return([]) })); return($MATCH) };
sub concat { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((do { my $m2 = $grammar->concat_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat_list'
} = $m2;1 } else { 0 } } } && do { return(Rul::Concat->new( 'concat'
 => ${$MATCH->{'concat_list'
}}, )) })); return($MATCH) };
sub or_list { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool(((do { my $m2 = $grammar->concat($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'concat'
} = $m2;1 } else { 0 } } } && ((('|'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0)) && (do { my $m2 = $grammar->or_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'or_list'
} = $m2;1 } else { 0 } } } && do { return([${$MATCH->{'q1'
}}, @{${$MATCH->{'q2'
}}}]) })) || do { return([${$MATCH->{'q1'
}}]) })) || do { return([]) })); return($MATCH) };
sub rule { my $grammar = $_[0]; my $str = $_[1]; my $pos = $_[2]; my $MATCH; $MATCH = MiniPerl6::Perl5::Match->new( 'str'
 => $str,'from'
 => $pos,'to'
 => $pos, ); $MATCH->bool((((do { my $m2 = $grammar->ws($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'ws'
} = $m2;1 } else { 0 } } } && ('|'
 eq (substr($str, $MATCH->to(), 1) ? (1 + $MATCH->to((1 + $MATCH->to()))) : 0))) || 1) && (do { my $m2 = $grammar->or_list($str, $MATCH->to()); do { if ($m2) { $MATCH->to($m2->to());$MATCH->{'or_list'
} = $m2;1 } else { 0 } } } && do { return(Rul::Or->new( 'or'
 => ${$MATCH->{'or_list'
}}, )) }))); return($MATCH) }
;
1;
