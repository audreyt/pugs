
YOU CAN HELP BY...

*** Update ../STD_red/PROBLEMS.
It's fallen out of sync with what actually parses.

*** Fix or document test failues.
Go through the run-tests results.
For each "ran but test failed", look at why.
If it's a missing or defective bit of prelude, either
 mention it below, or
 fix the prelude.
If it's an emitter problem, mention it below.

If it's a parser problem or failure ("X"), 
determine why the parse failed, and add a one-liner which
replicates it to ../STD_red/PROBLEMS.

*** Flesh out the prelude.
Go through S29 etc, adding p6 implementations to one of the preludes.
If it doesn't compile as spec'ed, comment it out so it serves as a todo.

*** Remove a distastefull deviation (see below)
Implement the proper feature and remove the ugly and distastefull workaround

BIG PICTURE

() Remove distastefull deviations
() Move to p6, and a full bootstrap.
   Switch the front-end to p6, and as much as possible of the runtime.
() Get additional backends working.  javascript, ruby, python, scheme, common lisp.
() Pass more tests.
() Switch to real p6 oo.
() Move towards full spec conformance.

DISTASTEFULL DEVIATIONS

* .re_gsub
    replace with .subst(rx:g/pattern/)
* eval_perl5
* file_exists
* =~ 
    =~ is explicitly forbidden in Perl 6, replace with ~~)
* faking named parameters with positional
    .new('foo',1) should be turned into .new(foo=>1)
* newp

PROJECTS

() Parser - increase t/ coverage (currently 73%).
() Parser - switch from ruby STD_red to p6 STD_gray.  Then merge with elf.

() Regex - get regex parsing and IR working.
() Regex - translate yet_another_regex_engine analysis and emitting to p6.

() Multimethods - absorb Class::Multimethods inline, and begin mutating it.
() Multimethods - attempt sufficent performance to refactor emit onto them.

() Emitter - refactor to use multimethods, making everything simpler.
   Caveat: requires an acceptably fast multimethod runtime.  At least on p5.

() Emitter - refactor so the emitted code is generated by separate methods,
   like emit_block_start() and emit_block() and emit_call(), rather than
   directly by the IR node handlers.  This is to simplify swapping in other
   backends.

() Prelude - flesh it out.
  - Allow fix:<x> to be defined in Prelude.  Make it work with unicode.
  - Create a 'is p5_macro' to replace the emitter doing it.

() Prelude - flesh out unboxed prelude classes.

() Backends - sketch try p6 oo designs for p5, and other backend languages.
() Backends - switch p5 to a true p6 oo model.
() Backends - start several backends, to stay honest and motivate emitter refactoring.

() Analysis - flesh out the IR analysis.

() Parser/FromAST - systematicall increase coverage.
  The parser and compiler were originally written with the intent of getting
  specific things working, rather than having full language coverage.  As the
  focus is now broader, it's time to go through the parser and FromAST and
  make sure all useful parses produce Match trees, and all those trees yield IR.


REQUESTED FEATURES

* The ability to say
    multi sub prefix:<~>($x) { $x.Str }
  in the Prelude, and have it work.


ASSORTED TODO

() Emitter:
  - add a whole-program IR node?

* Switch from $+foo to temp($foo).


* replace cruft like  $.var.sigil eq '$' in Emit with methods in/added-to Analysis.  eg, is_scalar. (http://irclog.perlgeek.de/perl6/2008-05-24#i_309702)

* my($x,$y)...

* Lists!


QUESTIONS

* kp6/60-inherited-accessors.t  are accessors spec'ed to do $.foo(new-value) ?
