Scalar, sigil: $

    list $foo        # $foo
        +$foo        # $foo as Num
        ~$foo        # $foo as Str
        ?$foo        # $foo as Bool
        "$foo"       # $foo as Str
    item $foo        # $foo

Scalar -> Str

    Methods:

    .chomp    # Returns chomped string with a .newline property giving the
                newline removed
    .chop
    .ord
    .lc
    .lcfirst
    .uc
    .ucfirst
    .chars    # Length in characters
    .graphs   # Length in graphemes
    .codes    # Length in codepoints
    .bytes    # Length in bytes
    .tr
    .reverse
    .split(/sep/)
    .hex
    .oct

Scalar -> Num

    .abs
    .cos
    .exp
    .int
    .log
    .rand
    .sin
    .sqrt
    .chr
    .floor
    .ceil
    
Array, sigil: @
    
    list @foo        # List of elements
        +@foo        # @foo.elems
        ~@foo        # join ' ', @foo
        ?@foo        # ? @foo.elems
        "@foo[]"     # join ' ', @foo
         @foo[i]     # subscript
         @foo[i, i]  # slice
         @foo[i; i]  # multi-dimensional access
    item @foo        # \@foo

    Methods:

    .elems          # Number of elements
    .join($sep)
    .map:{ ... }
    .grep:{ ... }
    .pop
    .push($elem)
    .shift
    .unshift($elem)
    .reverse
    .sort( { cond }, { cond }, ... )
    .kv            # return index,value pairs
    
    Shapes:

    XXX - someone summarize shapes and multi-dimension syntax

    Constructors:

    ARRAY = LIST
    [ LIST ]       # anonymous ref

    Note:
        (42)       # this is neither a list nor an array,
                   # but a scalar (the Num 42)
        (42,)      # this is an one-element array
        list 42    # this is an one-element array
        (42,23)    # this is a two-element array

        []         # this is a zero-element arrayref
        [42]       # this is an one-element arrayref
        [42,]      # this is an one-element arrayref
        [42,23]    # this is a two-element arrayref

    List construction (via the comma operator, &infix:<,>), does not create
    containers, meaning that the elements are aliases:

        ($foo,$bar)[0] =:= $foo;  # true
        ($foo,$bar)[0]   = $baz;  # $foo changed to $baz

    By contast, arrayref construction by the [] operator, &circumfix:<[ ]>,
    does create new containers:

        [$foo,$bar][0] =:= $foo;  # false
        [$foo,$bar][0]   = $baz;  # $foo not changed

Hash, sigil: %

    list %foo        # List of pairs
        +%foo        # +%foo.keys
        ~%foo        # ???
        ?%foo        # ? %foo.keys
        "%foo{}"     # ???
         %foo{k}     # subscript
         %foo{k, k}  # slice
         %foo<>      # %foo{<>}
         %foo<<>>    # %foo{<<>>}
         %foo{k; k}  # multi-dimensional access
    item %foo        # \%foo

    Methods:

    .delete($key)
    .exists($key)
    .keys
    .values
    .kv                # List of key, value, key, value, ...

    Shapes: 

    XXX - help me

    Constructors:

    HASH = LIST
    { PAIR, PAIR, ... }   # anonymous ref
    hash( LIST )

Pair (used via reference)

    list $foo        # $foo   # ref, so doesn't flatten to $k, $v
        +$foo        # ???
        ~$foo        # ???
        ?$foo        # ???
        "$foo"       # ???
    item $foo        # $foo

    Methods:

    .kv      # $key, $value
    .key
    .value
    
    Constructors: (all anonymous)

    :key            # 'key' => 1
    :key{'value'}   # 'key' => 'value'
    \__ thus: :key<>, :key<<>>
    key => 'value'  # 'key' => 'value' (LHS auto-quoted)

Things with blocks

    Named               Anonymous             See also
    class   Foo { }     class   { }           oo
    role    Foo { }     role    { }           oo
    sub     foo { }     sub     { }, or { }   sub
    method  foo { }     method  { }           oo, sub
    macro   foo { }                           sub
    rule    foo { }     rule    { }           rules
    grammar Foo { }     grammar { }           rules
    package Foo { }     package { }           mod
    module  Foo { }     module  { }           mod
