package Perl6in5::Grammar::STD_hand;

use warnings;
#use strict; #haha

use base 'Exporter';
our @EXPORT = qw ( make_parser );

use Perl6in5::Compiler::Trace; # set env var TRACE for trace output

# isa Perl6in5::Grammar someday (to inherit some of the common features below)

use Perl6in5::Grammar;
use Perl6in5::Compiler::Stream ':all';
use Perl6in5::Compiler::Parser ':all';
use Perl6in5::Compiler::Lexer ':all';

use Data::Dumper;
$Data::Dumper::Indent = 0;
$Data::Dumper::Terse = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Quotekeys = 0;
$Data::Dumper::Deparse = 1;

no warnings qw{ reserved closure recursion };

sub make_parser {
    my $input = shift;
    
    my $wS = sub { "" };
    
    my $lexer = iterator_to_stream(make_lexer($input,
    [ 'ID'              ,qr|[A-Za-z_]\w*|     ,                            ],
    [ 'INT'             ,qr|\d+|              ,                            ],
    # someday soon I'll need to remove whitespace from here and handle it
    # in the parser (not the lexer), since there are so many special rules
    # around ws and unspace.  Actually someday soon, all that should remain
    # here is the "C" pattern (unfortunately?), since there is so much that
    # will need to be redefinable at parse time, the lexing needs to go
    # character by character.  This means that the lexing step will merely
    # generate a sub generator that generates a stream of nested arrayrefs
    # (with the lexer as the tail) that each contain the next character.
    [ 'WS'              ,qr/\s+/              ,$wS                         ],
    [ "C"               ,qr#.#                ,                            ],

    )); 

    my %VAR;

    # <sigh> these "predeclaration" need to be autogenerated someday, somehow
    my ($base, $expr, $factor, $program, $term, $sVari, $stringLit, $declare,
        $usev6, $comma, $stmtList, $newline, $blkBare, $blkPrmbl, $nbexpr,
        $blkType, $blkRetT, $blkModf, $stmtTrm, $scpDecl, $block, $arg,
        $blkPrm, $compUnit, $flowCtrl, $blkLabl, $clype, $impor, $assign,
        $op_numaddt, $blkTrait, $pkgDecl
    );

    sub eoi () { $End_of_Input };
    # don't need a sub for $nothing, since it's always embedded in option()
    
    my $Op_numaddt         = parser { $op_numaddt      ->(@_) };
    sub op_numaddt () { $Op_numaddt };
    my $Nbexpr             = parser { $nbexpr          ->(@_) };
    sub nbexpr () { $Nbexpr };
    my $Clype              = parser { $clype           ->(@_) };
    sub clype () { $Clype };
    my $Declare            = parser { $declare         ->(@_) };
    sub declare () { $Declare };
    my $Assign             = parser { $assign          ->(@_) };
    sub assign () { $Assign };
    my $Impor              = parser { $impor           ->(@_) };
    sub impor () { $Impor };
    my $Base               = parser { $base            ->(@_) };
    sub base () { $Base };
    my $Expr               = parser { $expr            ->(@_) };
    sub expr () { $Expr };
    my $Factor             = parser { $factor          ->(@_) };
    sub factor () { $Factor };
    my $Program            = parser { $program         ->(@_) };
    sub program () { $Program };
    my $Term               = parser { $term            ->(@_) };
    sub term () { $Term };
    my $SVari              = parser { $sVari           ->(@_) };
    sub sVari () { $SVari };
    my $StringLit          = parser { $stringLit       ->(@_) };
    sub stringLit () { $StringLit };
    my $Usev6              = parser { $usev6           ->(@_) };
    sub usev6 () { $Usev6 };
    my $Comma              = parser { $comma           ->(@_) };
    sub comma () { $Comma };
    my $StmtList           = parser { $stmtList        ->(@_) };
    sub stmtList () { $StmtList };
    my $Newline            = parser { $newline         ->(@_) };
    sub newline () { $Newline };
    my $BlkBare            = parser { $blkBare         ->(@_) };
    sub blkBare () { $BlkBare };
    my $BlkPrmbl           = parser { $blkPrmbl        ->(@_) };
    sub blkPrmbl () { $BlkPrmbl };
    my $BlkType            = parser { $blkType         ->(@_) };
    sub blkType () { $BlkType };
    my $BlkRetT            = parser { $blkRetT         ->(@_) };
    sub blkRetT () { $BlkRetT };
    my $BlkModf            = parser { $blkModf         ->(@_) };
    sub blkModf () { $BlkModf };
    my $StmtTrm            = parser { $stmtTrm         ->(@_) };
    sub stmtTrm () { $StmtTrm };
    my $ScpDecl            = parser { $scpDecl         ->(@_) };
    sub scpDecl () { $ScpDecl };
    my $Block              = parser { $block           ->(@_) };
    sub block () { $Block };
    my $Arg                = parser { $arg             ->(@_) };
    sub arg () { $Arg };
    my $BlkPrms            = parser { $blkPrms         ->(@_) };
    sub blkPrms () { $BlkPrms };
    my $FlowCtrl           = parser { $flowCtrl        ->(@_) };
    sub flowCtrl () { $FlowCtrl };
    my $BlkLabl            = parser { $blkLabl         ->(@_) };
    sub blkLabl () { $BlkLabl };
    my $CompUnit           = parser { $compUnit        ->(@_) };
    sub compUnit () { $CompUnit };
    my $BlkTrait           = parser { $blkTrait        ->(@_) };
    sub blkTrait () { $BlkTrait };
    my $PkgDecl           = parser { $pkgDecl        ->(@_) };
    sub pkgDecl () { $PkgDecl };

    # these hash keys are coderef (addresses)
    our %N = (
        $End_of_Input     => 'EOI',
        $nothing          => 'nothing',
        $Expr             => 'Expr',
        $Term             => 'Term',
        $Factor           => 'Factor',
        $Base             => 'Base',
        $Program          => 'Program',
        $ScpDecl          => 'ScpDecl',
        $SVari            => 'SVari',
        $StringLit        => 'StringLit',
        $Usev6            => 'Usev6',
        $Comma            => 'Comma',
        $StmtList         => 'StmtList',
        $Newline          => 'Newline',
        $BlkBare          => 'BlkBare',
        $BlkPrmbl         => 'BlkPrmbl',
        $BlkType          => 'BlkType',
        $BlkRetT          => 'BlkRetT',
        $BlkModf          => 'BlkModf',
        $StmtTrm          => 'StmtTrm',
        $Block            => 'Block',
        $Arg              => 'Arg',
        $BlkPrms          => 'BlkPrms',
        $FlowCtrl         => 'FlowCtrl',
        $BlkLabl          => 'BlkLabl',
        $CompUnit         => 'CompUnit',
        $Clype            => 'Class/Type',
        $Impor            => 'Import',
        $Assign           => 'Assign',
        $Nbexpr           => 'Nbexpr',
        $Declare          => 'Declare',
        $Op_numaddt       => 'Op_numaddt',
        $BlkTrait         => 'BlkTrait',
        $PkgDecl          => 'PkgDecl',
    );

    #   Rule Writing
    # Rules that consist at the top level of alternatives (separated by "|")
    # generally represent "classes" of items that are encoded in the
    # source.
    # 
    # Rules that consist at the top level of a sequence (items separated by
    # "-") generally represent items that define the descent into
    # "subcontexts", or areas of the source code where things signify
    # differently from things in a "higher" context.
    # 
    # In order to specifiy precedence levels, just create another
    # level of indirection by creating a rule to represent the 
    # precedence level, and order the possibilities in the order of 
    # 1) whither recursion 2) whether the beginning of a match to
    # rule n is contained in the beginning of the next rule.
    
    # The identifier of each of your rules must begin with a lowercase letter,
    # so that the source filter can transform/generate the grammar properly.

    # The synopses specify that everything before a "use v6;" statement is
    # to be handled as Perl 5 code.
    
    
    # Note: 
    # I can't slurp "up until" until we're fully backtracking
    # I need a function "until($p,$q)" that returns a parser that 
    # iterates through the stream of tokens, trying $q against the
    # remaining input at each token, essentially using $q as a stop
    # phrase, then returns $p's and $q's matches, concatenated.
    # 
    # The until() parser generator would also be very helpful for
    # transforming ("tricking" the parser, as TimToady says) quotations
    # in preparation for parsing them in a "normal" context.  You could
    # have a parser generator that (internally) slurps up until the first
    # non-escaped stop character(-sequence), optionally counting/tracking
    # "balanced" stop characters (so that things like qq{ sub foo { $bar }; }
    # are parsed correctly.
    # 
    # rule perl5zone {
        # sl(); # grabs anything/everything...
    # }

    rule program {
            # everything must start with a use v6; statement until
            # the perl5zone rule is operational.
            o(newline)
          - o(usev6
              - error(o(pkgDecl)
                    - o(stmtList)))
          - o(newline)
          - eoi
    };

    rule pkgDecl {
        keyword('package') - l('ID') - stmtTrm;
    };

    rule usev6 {
                (keyword('use') - keywords(qw{ v6 Perl:ver(v6..*):auth(Any) Perl-6 })
              | keyword('module') - o(keyword('Main'))
              | keywords(qw{ class v6.0.0 v6 6 }))
          - stmtTrm
    };

    rule sVari {
        '$' - l('ID')
    };

    rule comma {
            ','
    };

    # option(Newline) (option(Newline)  option(StmtTrm option(StmtList)) option(Newline) | Block option((StmtTrm | Newline) StmtList) option(Newline))
    
    rule stmtList {
            # newlines can appear basically anywhere before, inside, or
            # after nearly all expressions.  Exceptions will get their
            # own rule as they are encountered (in the test suite)
            o(newline)
                # blocks and other expressions have different statement terminators
          - (   block
                  # either a newline or semicolon can terminate a block "statement"
                  # so that another statement (stmtList) can follow.
              - o(  (stmtTrm
                  | newline)
                  - stmtList)
              | nbexpr
              - o(newline)
              - o(stmtTrm
                  - o(stmtList))
            )
          - o(newline)
    };

    # non-block expression
    rule nbexpr {
            sVari
          | impor
          | assign
          | declare
          | blkTrait
          | keyword('say') - expr
          | w('()',expr)
          | op_numaddt
          | l('INT')
          | dieif(pkgDecl,"Can't declare a non-block package")
    };

    rule op_numaddt {
            term
              - star('+' - term
                   | '-' - term)
    };

    rule newline {
            gt0(l("C","\n"))
    };

    rule blkBare {
            w("{}",o(stmtList))
    };

    rule block {
            o(blkPrmbl) - blkBare
    };

    rule blkPrmbl {
            
            o(blkModf)
            # this is an example of sometimes having to enumerate various
            # possiblities during a sequence of variously optional terms
            # blkType is the only required term in the block preamble
          - (scpDecl - clype - blkType | scpDecl - blkType | blkType )
          - o(o('^') - l('ID')) - o(vsblty) - w('()',o(blkPrms))
          - o(blkTrait)
          | compUnit
          | flowCtrl
          | blkLabl
          | arrowInv - o(comma - clist(blkPrms))
    };

    rule blkTrait {
        gt0(keywords(qw{ is does has }) - l('ID'))
    };

    rule impor {
            keywords(qw{ use require module class }) - l('ID')
    };

    rule flowCtrl { # Until I die, I would cry unless unless/until were included.
            keywords(qw{ if unless elsif else loop do while until })
    };

    rule compUnit {
            keywords(qw{ eval PRE POST ENTER LEAVE KEEP UNDO FIRST 
                         LAST BEGIN END INIT CHECK UNITCHECK })
    };

    rule blkType {
            keywords(qw{ sub method submethod regex token rule
                         macro module class package })
    };

    rule blkRetT {
            clype
    };

    rule clype {
            l('ID')  # just take any class/type name for now :)
            #  $Clype    # Class/Type
    };

    rule blkLabl {
            l('ID') - ':';
    };

    rule blkModf {
            keywords(qw{ multi proto only })
    };

    rule arg {
            'h'  #obviously this is just a stub.
    };

    rule blkPrms {
            o(invcDecl) - o(semilist(prmDecl))
    };

    rule invcDecl {
            prmDecl - ':'
    };

    rule prmDecl {
            o(clype) - sVari
    };

    rule vsblty {
        keywords(qw{ public private })
    };

    rule stmtTrm {
            gt0(';')
    };

    rule scpDecl {
            keywords(qw{ my our })
    };

    rule expr {
            block
          | nbexpr
    };

    rule declare {
            scpDecl - prmDecl
          | keywords(qw{ module class }) - clype
    };

    rule assign {
            o(scpDecl) - prmDecl - '=' - expr
    };

    # This is a great example of how to structure an operator's
    # (recursive) grammar syntax.
    rule term {
            factor
          - star('*' - factor
               | '/' - factor)
    };

    rule factor {
            nbexpr - o(word('**') - factor)
    };

    sub {
        eval { program->($lexer) };
        if ($@) {
            print "  Syntax Error near: ".Dumper(tail(head(tail($@))));
            return 255;
        } else {
            print "Parse successful\n";
            return 0;
        }
    }
}

1;