= Laziness

A draft on the runtime view of how Lazy things (like Arrays) work.

The text assumes a knowledge of terms like "Container", "Scalar", "Cell", "Role".

References: 
- S09 Data Structures
- A bit of each of the other AES

TODO - include drawings
TODO - detail the behaviour of "Str Range"
TODO - compare with Ruby/Python should help explaining some concepts

== Definitions

TODO:
Native array / Native hash
Scalar / Array / Hash Container
Tuple / List / Generator / Iterator / Range
Signature / Argument List
Array / Hash slice
enum
tie / proxy / rw / env
Constrained Types (eg: Int / Even / 0..100 where Even)
Piddle

- native array / native hash

These are fast, in-memory structures provided by the virtual machine.
These structures are assumed to be one-dimensional.

- Array Container Class

The Array class defines all objects that implement the array API.

Array is a subclass of "Container"
Array contains an ordered set of Cells.
Array is multi-dimensional.

The actual implementation depends on the "Eager" or the "Lazy" roles.
Other implementations can be specified 

-- Eager Role

An Array object that wraps a native array.

-- Lazy Role

An Array object that generates Cells on demand.
This is the default implementation.

-- Shape (Role or parameter? trait?)

-- Compact Array Role

TODO

- Tuple ("List") class

List is an anonymous set of things.
List is a subclass of "Value".
List is one-dimensional.

At runtime, you only access List elements through Containers.
A List slice is an Array in which the Cells point to List elements.

-- Generator

Generator is an object that creates Values on demand.
Generator is "functional" rather than "physical memory"
At runtime, you only access Generator elements through Containers.
A Lazy slice is an Array in which the Cells point to Generator elements.

- Slice

Slice is a specialized Array, in which all the elements are bound to objects 
in other Containers (Array, Hash or Scalar).

- Hash

The Hash class defines all objects that implement the hash API.

Hash is like an Array, in which the Cell indexes can be of any type 
(not just numbers).

Hash is multi-dimensional.

== Generator Internals

- TODO


== Generator API

- match

This operator is used in a match statement:

    5 ~~ 1..10

- shift / pop

TODO - not sure if "Generator" is an iterator (read-only) or uses destructive 
read (shift/pop)

- sum / reverse / map / zip

- flatten

Takes all Values from the Generator, and returns an Array (possibly Native).

- elems

The number of elements

=== This part of the Generator API is only used by the runtime internals.

- head(n)

This operator is used by the Array splice operator.

Takes "n" Values from the Generator, like "shift" does. 
The result can be a Generator (when n is big), an Array (possibly Native), 
a single Value (when n == 1), or Void (when n <= 0).

TODO - not sure if "Generator" is an iterator (read-only) or uses destructive 
read (head/tail)

- tail(n)

This operator is used by the Array splice operator.

Takes "n" Values from the back of the Generator, like "pop" does. 
The result can be a Generator (when n is big), an Array (possibly Native), 
a single Value (when n == 1), or Void (when n <= 0).

TODO - check if "Generator" is an iterator (read-only) or uses destructive 
read (head/tail)

- is_contiguous

This is used for the optimization of Slice, when the sequence is used
as a slice index.

is_contiguous() is True is the generated sequence is like "2 .. 10".


= Array internals

== Array (base Class)

TODO

== Eager (Role)

An Eager Array contains a Native Array.

TODO - explain "Cell"

   Contents:  1 2 3
   Internals: [ 1, 2, 3 ] 

== Lazy (Role)

A Lazy Array contains a Native Array, which contains Generators, or Native Arrays.
This structure permits near O(1) complexity for most operations.

   Contents:  1 2 3
   Internals: [ 
                [ 1, 2, 3 ] 
              ]

   Contents:  10 20 30 100..10000 50 400..900
   Internals: [
                [ 10, 20, 30 ],
                Generator( 100, 10000 ),
                [ 50 ],
                Generator( 400, 900 )
              ]


= Array API

- TODO
Array can do "map", "grep", splice, push, pop, store, fetch. 
Array can be "bound" and "tied".


= Hash internals

A Hash contains a Native Hash.

Hash keys can be objects, but the objects must be immutable

   Contents:  a:1 b:2 c:3
   Internals: { a:1 b:2 c:3 } 

A Hash may contain Lazy items. 
This structure contains a Native Array, which contains Generators or Native Hashes.
This structure permits near O(1) complexity for most operations.

   Contents:  a:1 b:2 c:3
   Internals: [ 
                { a:1, b:2, c:3 }
              ]

   Contents:  a:10 b:20 c:30 (1:100 .. 10000:10100) d:50 
   Internals: [
                { a:10 b:20 c:30 },
                Generator( 1:100, 10000:10100 ),
                { d:50 },
              ]


= Hash API

- TODO


= Slice API

- TODO


= Slice Internals

- TODO - hash slice / array slice

... ... more ...
