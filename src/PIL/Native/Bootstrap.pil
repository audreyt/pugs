#!pil

## ------------------------------------------------------------------------- ##
## Class and Method iterators
## ------------------------------------------------------------------------- ##

&WALKCLASS := -> &dispatcher         { &dispatcher`() };
&WALKMETH  := -> &dispatcher, $label {
    -> { 
        &redo  := &?SUB;
        $class := &WALKCLASS`(&dispatcher);
        -> { 
            $method := $class.get_method($label);
            $method`is_nil`cond(
                -> { &redo`() },
                -> { $method  } 
            );
        }`do_if($class`not_nil);
    }`();
};

## ------------------------------------------------------------------------- ##
## Class
## ------------------------------------------------------------------------- ##
## We assume that ::Class and ::Class.add_method are already defined
## ------------------------------------------------------------------------- ##

## class construction methods

::Class.add_method('new', -> %params { 
    self.bless(nil, %params);
});

# S12 NOTE:
# According to the new S12, I think that new_opaque should not
# assign anything to the class slot. Instead &bless should handle
# this. In addition, &bless should only call &CREATE if $repr is
# an undefined value, otherwise it should call &BUILDALL on the 
# value assigned to $repr (after setting it's class slot that is)
# Of course this means that we need to be able to store the class
# value into other possible $reprs. I will need to give this some
# more thought.

::Class.add_method('bless', -> $repr, %params { 
    $obj := self.CREATE($repr, %params);
    $obj.BUILDALL(%params); 
    $obj;     
});

# S12 NOTE:
# It is said that CREATE should be able to take a number of 
# different $repr types. It is unclear /why/ this is a good
# idea (I should ask on p6l). In general any $repr type will 
# need to be able to respond to some kind of keyed attribute 
# accessing method so that attribute access code can be
# kept simple. 

::Class.add_method('CREATE', -> $repr, %params {
    $obj := self`new_opaque({});
    &dispatcher := self.dispatcher('descendant');
    -> {
        &redo  := &?SUB;
        $class := &WALKCLASS`(&dispatcher);
        -> {
            -> $key {
                $obj`set_attr($key, $class.get_attribute($key));
            }`do_for($class.get_attribute_list);
            &redo`();
        }`do_if($class`not_nil);
    }`();
    $obj;
});

::Class.add_method('BUILDALL', -> %params {
    &dispatcher := $?CLASS.dispatcher('descendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH`(&dispatcher, 'BUILD');
        -> {
            $method`(%params);
            &redo`();
        }`do_if($method`not_nil);
    }`();
});

::Class.add_method('BUILD', -> %params {
    -> $key {
        -> {
            self`set_attr($key, %params`fetch($key));
        }`do_if(self`has_attr($key))
    }`do_for(%params`keys);
});

## class destruction

::Class.add_method('DESTROYALL', -> { 
    &dispatcher := $?CLASS.dispatcher('ascendant');
    -> {
        &redo   := &?SUB;
        $method := &WALKMETH`(&dispatcher, 'DESTROY');
        -> {
            $method`($self);
            &redo`();
        }`do_if($method`not_nil);
    }`();
});

## informational methods

# NOTE:
# is_a is meant to check against class instances 
::Class.add_method('is_a', -> $class { 
    self`eq($class)`cond(
        -> { true },
        -> {
            &dispatcher := self.dispatcher('descendant');
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS`(&dispatcher);      
                -> {
                    $ancestor`eq($class)`cond(
                        -> { true     },
                        -> { &redo`() }
                    );
                }`do_if($ancestor`not_nil)
            }`();
        }
    );
});

# NOTE:
# isa is meant to check against class names
::Class.add_method('isa', -> $class {
    self.name`eq($class)`cond(
        -> { true },
        -> {
            &dispatcher := self.dispatcher('descendant');            
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS`(&dispatcher);                        
                -> {
                    $ancestor.name`eq($class)`cond(
                        -> { true     },
                        -> { &redo`() }
                    );
                }`do_if($ancestor`not_nil)
            }`();
        }
    );    
});

## (super|sub)classes

::Class.add_method('superclasses', -> { self`get_attr('@!superclasses') });
::Class.add_method('set_superclasses', -> @superclasses { 
    -> $super { 
        $super.add_subclass(self); 
    }`do_for(@superclasses);
    self`set_attr('@!superclasses', @superclasses);
    self`set_attr('@!MRO', self`mro_merge);    
});

::Class.add_method('MRO', -> {
    @mro := self`get_attr('@!MRO');
    @mro`is_empty`cond(
        ->{ self`set_attr('@!MRO', self`mro_merge) },
        ->{ @mro }
    );
});

::Class.add_method('subclasses',   ->        { self`get_attr('@!subclasses') });
::Class.add_method('add_subclass', -> $class { 
    self`set_attr('@!subclasses', self`get_attr('@!subclasses')`push($class));
});

## method related methods

::Class.add_method('has_method', -> $name { 
    self`get_attr('%!methods')`exists($name);
});

::Class.add_method('get_method', -> $name { 
    self`get_attr('%!methods')`fetch($name); 
});

::Class.add_method('get_method_list', -> { 
    self`get_attr('%!methods')`keys(); 
});

::Class.add_method('remove_method', -> $name { 
    self`set_attr('%!methods', self`get_attr('%!methods')`delete($name));
});

## private-method related methods

::Class.add_method('add_private_method', -> $name, $method { 
    self`set_attr_hash('%!private_methods', $name, $method);
});

::Class.add_method('has_private_method', -> $name { 
    self`get_attr('%!private_methods')`exists($name);
});

::Class.add_method('get_private_method', -> $name { 
    self`get_attr('%!private_methods')`fetch($name); 
});

::Class.add_method('get_private_method_list', -> { 
    self`get_attr('%!private_methods')`keys(); 
});

::Class.add_method('remove_private_method', -> $name { 
    self`set_attr('%!private_methods', self`get_attr('%!private_methods')`delete($name)); 
});

## Method dispatching

::Class.add_method('dispatcher', -> $order {
    $order := $order`is_nil`or($order`eq('canonical'))`cond(
        ->{ 'ascendant' }, 
        ->{ $order      }
    );
    $order`eq('descendant')`cond(
        ->{ self!make_descendant_dispatcher; },
        ->{ $order`eq('ascendant')`cond(
            ->{ self!make_ascent_dispatcher;             },
            ->{ self!unsupported_dispatch_order($order); }
        ) }
    );
});

::Class.add_private_method('make_dispatcher_iterator', -> @values {
    $counter := ::`new_opaque({'' => 0});
    -> {
        $idx := $counter`get_attr('');
        $counter`set_attr('', $idx`add(1));
        @values`fetch($idx);
    };
});

::Class.add_private_method('make_ascent_dispatcher', -> {
    self!make_dispatcher_iterator(self.MRO);
});

::Class.add_private_method('make_descendant_dispatcher', -> {
    self!make_dispatcher_iterator(self.MRO`reverse);
});


## attribute related methods

::Class.add_method('add_attribute', -> $name, $attr { 
    self`set_attr_hash('%!attributes', $name, $attr);
});

::Class.add_method('has_attribute', -> $name { 
    self`get_attr('%!attributes')`exists($name);
});

::Class.add_method('get_attribute', -> $name { 
    self`get_attr('%!attributes')`fetch($name); 
});

::Class.add_method('remove_attribute', -> $name { 
    self`set_attr('%!attributes', self`get_attr('%!attributes')`delete($name)); 
});

::Class.add_method('get_attribute_list', -> { 
    self`get_attr('%!attributes')`keys(); 
});

::Class.add_method('get_attributes', -> { 
    self`get_attr('%!attributes')`values(); 
});

## NOTE:
## we assume that when ::Class was defined, that it's attributes
## were also defined, but only in the Instance type, and not in 
## it's meta-self

::Class.add_attribute('@!MRO',             []);
::Class.add_attribute('@!superclasses',    []);
::Class.add_attribute('@!subclasses',      []);
::Class.add_attribute('%!private_methods', {});
::Class.add_attribute('%!methods',         {});
::Class.add_attribute('%!attributes',      {});

## ------------------------------------------------------------------------- ##
## Object
## ------------------------------------------------------------------------- ##

::Object := ::Class.new({});

# NOTE:
# these three methods need to also live as ::Object instance
# methods too. They would normally be inherited from ::Object
# by ::Class, but becuase they need to exist prior to the 
# creation of ::Object, we have to duplicate them. Better 
# suggestions welcome :)

::Object.add_method('BUILD',      ::Class.get_method('BUILD'));
::Object.add_method('BUILDALL',   ::Class.get_method('BUILDALL'));
::Object.add_method('DESTROYALL', ::Class.get_method('DESTROYALL'));

::Object.add_method('class', -> { self`class(); });
::Object.add_method('id',    -> { self`id();    });

::Object.add_method('isa', -> $class {
    $?CLASS.name`eq($class)`cond(
        -> { true },
        -> {
            &dispatcher := $?CLASS.dispatcher('descendant');            
            -> {
                &redo     := &?SUB;
                $ancestor := &WALKCLASS`(&dispatcher);                        
                -> {
                    $ancestor.name`eq($class)`cond(
                        -> { true     },
                        -> { &redo`() }
                    );
                }`do_if($ancestor`not_nil)
            }`();
        }
    );    
});

::Object.add_method('can', -> $label {
    &WALKMETH`($?CLASS.dispatcher('descendant'), $label)`not_nil`cond(
        -> { true  },
        -> { false }
    );
});

## ------------------------------------------------------------------------- ##
## Package
## ------------------------------------------------------------------------- ##

::Package := ::Class.new({});
::Package.set_superclasses([ ::Object ]);

::Package.add_attribute('$!name',      '');
::Package.add_attribute('%!namespace', {});

::Package.add_method('name',     -> { self`get_attr('$!name') });
::Package.add_method('set_name', -> $name {
    -> { self`set_attr('$!name', $name) }`do_if($name`not_nil);    
});

::Package.add_method('FETCH', -> $name { });
::Package.add_method('STORE', -> $name, $value { });

## ------------------------------------------------------------------------- ##
## Module
## ------------------------------------------------------------------------- ##

::Module := ::Class.new({});
::Module.set_superclasses([ ::Package ]);

::Module.add_attribute('$!version',   '');
::Module.add_attribute('$!authority', '');

::Module.add_method('version',     -> { self`get_attr('$!version') });
::Module.add_method('set_version', -> $version {
    -> { self`set_attr('$!version', $version) }`do_if($version`not_nil);
});

::Module.add_method('authority',     -> { self`get_attr('$!authority') });
::Module.add_method('set_authority', -> $authority {
    -> { self`set_attr('$!authority', $authority) }`do_if($authority`not_nil);
});

::Module.add_method('identifier', -> {
    $output := self`get_attr('$!name');
    $output := self`get_attr('$!version')`not_nil`cond(
        -> { $output`concat('-')`concat(self`get_attr('$!version')) },
        -> { $output }
    );
    $output := self`get_attr('$!authority')`not_nil`cond(
        -> { $output`concat('-')`concat(self`get_attr('$!authority')) },
        -> { $output }
    ); 
    $output;
});

## ------------------------------------------------------------------------- ##
## Bootstrapping
## ------------------------------------------------------------------------- ##

::Class.set_superclasses([ ::Module ]);

# NOTE:
# this attribute needs to be added manually to the
# class instances since ::Class would have inherited 
# it, but couldn't since they had not yet been defined. 

-> $class {
    $class`set_attr('%!namespace', {}); 
}`do_for([ ::Class, ::Object, ::Module, ::Package ]);

# ... now we can name and version all our objects 
# which has the side effect of creating the name, 
# version and authority slots in our classes, if we
# do not do this, then we need to add $!name, $!version
# and $!authority to the list above along with %!namespace

::Class.set_name('Class');     ::Class.set_version('0.0.1');   ::Class.set_authority('url:pugscode.org');
::Object.set_name('Object');   ::Object.set_version('0.0.1');  ::Object.set_authority('url:pugscode.org');
::Package.set_name('Package'); ::Package.set_version('0.0.1'); ::Package.set_authority('url:pugscode.org');
::Module.set_name('Module');   ::Module.set_version('0.0.1');  ::Module.set_authority('url:pugscode.org');

## end bootstrapping ...
## ------------------------------------------------------------------------- ##

## ------------------------------------------------------------------------- ##
## Roles
## ------------------------------------------------------------------------- ##

::Role := ::Class.new({});

::Role.set_name('Role');       
::Role.set_version('0.0.1');    
::Role.set_authority('url:pugscode.org');

::Role.set_superclasses([ ::Module ]);

::Role.add_attribute('@!roles',      []);
::Role.add_attribute('%!methods',    {});
::Role.add_attribute('%!attributes', {});

# NOTE:
# These methods are pretty much duplicates of the 
# ones in ::Class, so we can just copy them here.

::Role.add_method('add_method',      ::Class.get_method('add_method'));
::Role.add_method('has_method',      ::Class.get_method('has_method'));
::Role.add_method('get_method',      ::Class.get_method('get_method'));
::Role.add_method('get_method_list', ::Class.get_method('get_method_list'));

::Role.add_method('add_attribute',      ::Class.get_method('add_attribute'));
::Role.add_method('has_attribute',      ::Class.get_method('has_attribute'));
::Role.add_method('get_attribute',      ::Class.get_method('get_attribute'));
::Role.add_method('get_attribute_list', ::Class.get_method('get_attribute_list'));
::Role.add_method('get_attributes',     ::Class.get_method('get_attributes'));

::Role.add_method('roles',     -> { self`get_attr('@!roles') });
::Role.add_method('set_roles', -> @roles { 
    self`set_attr('@!roles', @roles); 
});

::Role.add_method('does', -> $role {
    self.name`eq($role)`cond(
        -> { true },
        -> {
            @roles := self.collect_all_roles(); 
            @roles`is_empty`cond(
                -> { false },
                -> {
                    -> @r {
                        &redo := &?SUB;
                        @r`is_empty`cond(
                            -> { false },
                            -> {
                                @r`fetch(0).name`eq($role)`cond(
                                    -> { true },
                                    -> { &redo`(@r`splice(1)) }
                                )                            
                            }
                        )
                    }`(@roles);                
                }
            );       
        }
    );     
});

::Role.add_method('collect_all_roles', -> {
    -> $c, $role {
        &recurse := &?SUB;
        -> $r {
           -> {
               $c`set_attr_hash('%seen', $r.name(), 1);
               $c`set_attr('@roles', $c`get_attr('@roles')`push($r));
               -> {
                   -> $subrole {
                       -> {
                           $c`set_attr_hash('%seen', $subrole.name(), 1);
                           $c`set_attr('@roles', $c`get_attr('@roles')`concat($subrole));
                       }`do_unless($c`get_attr('%seen')`exists($subrole.name()))
                   }`do_for(&recurse`($c, $r));
               }`do_unless($r.roles`is_empty());
           }`do_unless($c`get_attr('%seen')`exists($r.name()))
        }`do_for($role.roles());
        $c`get_attr('@roles');
    }`(::`new_opaque({ '@roles' => [], '%seen' => {} }), self);
});

::Role.add_method('resolve', -> {
    $conflicts := ::`new_opaque({ 'methods' => {}, 'attrs' => {} });
    -> $role {
        -> $method_name {
            $conflicts`get_attr('methods')`exists($method_name)`cond(
                -> { self.remove_method($method_name) },
                -> {
                    $conflicts`set_attr_hash('methods', $method_name, 1);
                    self.has_method($method_name)`cond(
                        -> { nil },
                        -> { self.add_method($method_name, $role.get_method($method_name)) }
                    );                        
                }
            );
        }`do_for($role.get_method_list);
        
        -> $attribute_name {
            $conflicts`get_attr('attrs')`exists($attribute_name)`cond(
                -> { self.remove_attribute($attribute_name) },
                -> {
                    $conflicts`set_attr_hash('attrs', $attribute_name, 1);
                    self.has_attribute($attribute_name)`cond(
                        -> { nil },
                        -> { self.add_attribute($attribute_name, $role.get_attribute($attribute_name)) }
                    );                        
                }
            );
        }`do_for($role.get_attribute_list);    
    }`do_for(self.collect_all_roles());
    -> {
        self.add_method('does', -> $role { 
            self.does($role) 
        });
    }`do_unless(self.isa('Role'));
});


## ------------------------------------------------------------------------- ##
## Autoboxing
## ------------------------------------------------------------------------- ##

::Bit.set_superclasses([ ::Object ]);
::Int.set_superclasses([ ::Object ]);
::Num.set_superclasses([ ::Object ]);
::Str.set_superclasses([ ::Object ]);
::Seq.set_superclasses([ ::Object ]);
::Map.set_superclasses([ ::Object ]);
::Sub.set_superclasses([ ::Object ]);

## ------------------------------------------------------------------------- ##
## Role Bootstrapping
## ------------------------------------------------------------------------- ##

# NOTE:
# we have to manually resolve ::Class's roles (::Role)
# this means we take all the attributes and methods
# from ::Role, which ::Class does not already have 
# and insert them into ::Class

# attributes ...
::Class.add_attribute('@!roles', []);

# methods ...
::Class.add_method('roles',             ::Role.get_method('roles'));
::Class.add_method('set_roles',         ::Role.get_method('set_roles'));
::Class.add_method('does',              ::Role.get_method('does'));
::Class.add_method('collect_all_roles', ::Role.get_method('collect_all_roles'));
::Class.add_method('resolve',           ::Role.get_method('resolve'));

# Class does Role
::Class`set_attr('@!roles', [ ::Role ]);

# Role does Role
::Role`set_attr('@!roles',  [ ::Role ]);

# make sure to add the @!roles attribute to these
# since they should have inherited from ::Class
-> $class {
    $class`set_attr('@!roles', []); 
    $class.add_attribute('@!roles', []);     
}`do_for([ ::Object, ::Module, ::Package ]);

## end Role bootstrapping ...
## ------------------------------------------------------------------------- ##

## ------------------------------------------------------------------------- ##
## Container Types
## ------------------------------------------------------------------------- ##

::Scalar.set_superclasses([ ::Object ]);
::Scalar.add_method('FETCH', -> { self`get_attr('') } );
::Scalar.add_method('STORE', -> $x { self`set_attr('', $x) } );

=pod

=head1 NAME

Perl 6 Object Model Bootstrap

=head1 DESCRIPTION 

This is the bootstrap code for the Perl 6 Object Model using the Perl 6 
Object-Space mini-language. 

=head1 SEE ALSO

NOTE: all paths from the root of the Pugs source tree.

=over 4

=item Perl 5 prototype of the Perl 6 Object Model

/perl5/Perl6-MetaModel/

In particular see the /perl5/Perl6-MetaModel/docs/*.jpg.

=item Perl 5 prototype of the Perl 6 Object Space 

/perl5/Perl6-ObjectSpace/

In particular see the /perl5/Perl6-MetaModel/docs/Object_Space.jpg

=back

=head1 AUTHORS

Audrey Tang <autrijus@autrijus.org>

Stevan Little <stevan@iinteractive.com>

=cut
