# !!! DO NOT EDIT !!!
# This file was generated by Pugs::Compiler::Rule's compile_p6grammar.pl
# script from examples/Grammar.grammar at Tue Oct 30 11:23:20 2007

use strict;
use warnings;

package Pugs::Grammar::Rule;

#use base 'Pugs::Grammar::Base';

use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;
use Pugs::Runtime::Tracer ();

# Code block from grammar spec


use utf8;
no strict 'refs';
no warnings 'redefine';
no warnings 'once';

#use Pugs::Runtime::Match;

our %rule_terms;
our %variables;



# token pod_begin
*pod_begin =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 632 675
           (
               ( $pad{I1170} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 633 652
               (
      
                 ## <group>
                 ## pos: 633 639
                  (   ( $pad{I1171} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1171} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 639 640
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 640 641
                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 641 642
                 ( ( substr( $s, $pos, 1 ) eq 'n' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 642 644
                  (   ( $pad{I1172} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 642 643
                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1172} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 644 652
                 do { while (
                  (   ( $pad{I1173} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1173} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1170} ) or 1 )
               &&            ## <concat>
               ## pos: 653 675
               (
      
                 ## <group>
                 ## pos: 653 658
                  (   ( $pad{I1174} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 656 657
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1174} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 658 662
                 do { while (
                  (   ( $pad{I1175} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1175} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 662 675
                  (   ( $pad{I1176} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 662 674
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1176} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token pod_other
*pod_other =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 700 743
           (
               ( $pad{I1177} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 701 720
               (
      
                 ## <group>
                 ## pos: 701 707
                  (   ( $pad{I1178} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1178} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 707 708
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 708 709
                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 709 710
                 ( ( substr( $s, $pos, 1 ) eq 'u' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 710 712
                  (   ( $pad{I1179} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 710 711
                   ( ( substr( $s, $pos, 1 ) eq 't' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1179} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 712 720
                 do { while (
                  (   ( $pad{I1180} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1180} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1177} ) or 1 )
               &&            ## <concat>
               ## pos: 721 743
               (
      
                 ## <group>
                 ## pos: 721 726
                  (   ( $pad{I1181} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 724 725
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1181} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 726 730
                 do { while (
                  (   ( $pad{I1182} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1182} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 730 743
                  (   ( $pad{I1183} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 730 742
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1183} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ws
*ws =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 761 1059
           (
            (   ( $pad{I1184} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1185} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1186} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1186} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1187} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1187} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1185} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1188} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1188} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1189} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1190} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1190} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1191} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1192} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1193} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1193} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1194} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1194} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1195} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1195} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1196} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1196} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1197} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1197} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1198} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1198} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1199} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1199} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1200} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1200} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1201} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1201} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1202} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1202} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1203} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1203} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1204} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1204} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1205} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1205} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1206} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1206} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1207} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1207} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1208} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1208} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1209} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1209} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1210} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1210} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1211} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1211} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1212} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1212} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1213} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1213} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1191} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1189} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1185} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1214} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1214} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1184} ) && 0 ) )
           && do { while (
            (   ( $pad{I1184} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1185} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1186} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1186} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1187} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1187} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1185} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1188} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1188} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1189} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1190} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1190} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1191} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1192} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1193} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1193} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1194} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1194} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1195} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1195} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1196} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1196} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1197} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1197} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1198} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1198} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1199} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1199} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1200} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1200} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1201} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1201} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1202} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1202} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1203} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1203} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1204} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1204} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1205} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1205} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1206} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1206} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1207} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1207} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1208} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1208} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1209} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1209} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1210} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1210} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1192} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1211} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1211} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1212} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1212} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1213} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1213} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1191} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1189} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1185} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1214} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1214} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1184} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ident
*ident =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 1118 1143
           (
            (   ( $pad{I1215} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I1216} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I1217} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1217} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1216} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I1218} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1218} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1216} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I1219} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1219} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1215} ) && 0 ) )
           && do { while (
            (   ( $pad{I1215} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I1216} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I1217} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1217} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1216} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I1218} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1218} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1216} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I1219} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1219} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1215} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alnum
*alnum =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1164 1178
            (   ( $pad{I1220} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1220} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alpha
*alpha =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1199 1210
            (   ( $pad{I1221} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1221} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token digit
*digit =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1231 1239
            (   ( $pad{I1222} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1222} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token special_char
*special_char =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 1284 2177
           (
               ( $pad{I1223} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 1285 1473
               (
      
                 ## <group>
                 ## pos: 1285 1296
                  (   ( $pad{I1224} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1287 1294
                           (
                               ( $pad{I1225} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1287 1290
                                (   ( $pad{I1226} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1288 1289
                                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1226} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1225} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1291 1294
                                (   ( $pad{I1227} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1292 1293
                                 ( ( substr( $s, $pos, 1 ) eq 'C' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1227} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1224} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1296 1299
                  (   ( $pad{I1228} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1296 1298
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1228} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1299 1340
                  (   ( $pad{I1229} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1300 1338
                           (
                            (   ( $pad{I1230} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I1231} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I1232} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1232} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I1233} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1233} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I1234} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1234} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I1235} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1235} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1230} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1230} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I1231} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I1232} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1232} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I1233} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1233} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I1234} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1234} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1231} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I1235} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1235} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1230} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1229} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1340 1385
                  (   ( $pad{I1236} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1340 1342
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1236} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1385 1473
                  (   ( $pad{I1237} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1385 1463
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1237} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1223} ) or 1 )
               &&            ## <concat>
               ## pos: 1474 1617
               (
      
                 ## <group>
                 ## pos: 1474 1485
                  (   ( $pad{I1238} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1476 1483
                   (
                       ( $pad{I1239} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1476 1479
                        (   ( $pad{I1240} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1477 1478
                         ( ( substr( $s, $pos, 1 ) eq 'x' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1240} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1239} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1480 1483
                        (   ( $pad{I1241} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1481 1482
                         ( ( substr( $s, $pos, 1 ) eq 'X' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1241} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1238} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1485 1535
                 (
                  (   ( $pad{I1242} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1242} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1242} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1242} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1535 1617
                  (   ( $pad{I1243} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1535 1608
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1243} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1223} ) or 1 )
               &&            ## <concat>
               ## pos: 1618 1777
               (
      
                 ## <group>
                 ## pos: 1618 1629
                  (   ( $pad{I1244} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1620 1627
                           (
                               ( $pad{I1245} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1620 1623
                                (   ( $pad{I1246} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1621 1622
                                 ( ( substr( $s, $pos, 1 ) eq 'x' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1246} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1245} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1624 1627
                                (   ( $pad{I1247} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1625 1626
                                 ( ( substr( $s, $pos, 1 ) eq 'X' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1247} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1244} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1629 1632
                  (   ( $pad{I1248} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1629 1631
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1248} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1632 1644
                  (   ( $pad{I1249} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1633 1642
                           (
                            (   ( $pad{I1250} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1250} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1250} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1250} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1249} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1644 1689
                  (   ( $pad{I1251} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1644 1646
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1251} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1689 1777
                  (   ( $pad{I1252} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1689 1767
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1252} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1223} ) or 1 )
               &&            ## <concat>
               ## pos: 1778 1915
               (
      
                 ## <group>
                 ## pos: 1778 1789
                  (   ( $pad{I1253} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1780 1787
                   (
                       ( $pad{I1254} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1780 1783
                        (   ( $pad{I1255} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1781 1782
                         ( ( substr( $s, $pos, 1 ) eq 'o' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1255} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1254} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1784 1787
                        (   ( $pad{I1256} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1785 1786
                         ( ( substr( $s, $pos, 1 ) eq 'O' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1256} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1253} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1789 1833
                 (
                  (   ( $pad{I1257} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1257} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1257} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1257} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1833 1915
                  (   ( $pad{I1258} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1833 1906
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1258} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1223} ) or 1 )
               &&            ## <concat>
               ## pos: 1916 2069
               (
      
                 ## <group>
                 ## pos: 1916 1927
                  (   ( $pad{I1259} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1918 1925
                           (
                               ( $pad{I1260} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1918 1921
                                (   ( $pad{I1261} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1919 1920
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1261} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1260} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1922 1925
                                (   ( $pad{I1262} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1923 1924
                                 ( ( substr( $s, $pos, 1 ) eq 'O' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1262} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1259} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1927 1930
                  (   ( $pad{I1263} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1927 1929
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1263} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1930 1936
                  (   ( $pad{I1264} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1931 1934
                           (
                            (   ( $pad{I1265} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I1265} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1265} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I1265} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1264} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1936 1981
                  (   ( $pad{I1266} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1936 1938
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1266} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1981 2069
                  (   ( $pad{I1267} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1981 2059
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1267} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1223} ) or 1 )
               &&            ## <concat>
               ## pos: 2070 2177
               (
      
                 ## <group>
                 ## pos: 2070 2103
                  (   ( $pad{I1268} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 2071 2072
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1268} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2103 2177
                  (   ( $pad{I1269} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 2103 2176
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1269} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token literal
*literal =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2200 2251
           do { while (
            (   ( $pad{I1270} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2201 2248
               (
                   ( $pad{I1271} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2207 2231
                   (
      
                     ## <group>
                     ## pos: 2207 2212
                      (   ( $pad{I1272} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2209 2211
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1272} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2212 2231
                      (   ( $pad{I1273} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2212 2226
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1273} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1271} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2232 2248
                    (   ( $pad{I1274} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1274} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1270} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token double_quoted
*double_quoted =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2280 2372
           do { while (
            (   ( $pad{I1275} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2281 2369
               (
                   ( $pad{I1276} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2287 2311
                   (
      
                     ## <group>
                     ## pos: 2287 2292
                      (   ( $pad{I1277} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2289 2291
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1277} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2292 2311
                      (   ( $pad{I1278} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2292 2306
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1278} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1276} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2312 2352
                    (   ( $pad{I1279} = $pos or 1 ) &&
                    ## <metasyntax>
                     ## pos: 2314 2347
                     do{
                    my $match = 
              ## <variable>
              ## pos: 2314 2347
              do {
                our $I1280;
                our $I1280_sizes;
                unless ( $I1280 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1280_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1280 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1280_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1280->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1280, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                    ## </metasyntax>
     ||    ( ( $pos = $pad{I1279} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1276} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2353 2369
                    (   ( $pad{I1281} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1281} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1275} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token metasyntax
*metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2398 2576
           (
            (   ( $pad{I1282} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I1283} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I1284} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1284} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I1285} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1285} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I1286} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1286} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I1287} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1287} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I1288} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1288} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I1289} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1289} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I1290} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1290} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I1291} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1291} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I1292} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1292} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I1293} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1293} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I1294} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1294} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I1295} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1295} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I1296} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1296} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I1297} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1297} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I1298} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1298} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1282} ) && 0 ) )
           && do { while (
            (   ( $pad{I1282} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I1283} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I1284} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1284} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I1285} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1285} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I1286} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1286} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I1287} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1287} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I1288} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1288} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I1289} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1289} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I1290} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1290} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I1291} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1291} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I1292} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1292} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I1293} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1293} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I1294} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1294} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I1295} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1295} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I1296} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1296} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I1297} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1297} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1283} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I1298} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1298} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1282} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_range
*char_range =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2602 2653
           (
            (   ( $pad{I1299} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I1300} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I1301} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1301} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I1302} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1302} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1300} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I1303} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1303} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1299} ) && 0 ) )
           && do { while (
            (   ( $pad{I1299} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I1300} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I1301} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1301} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I1302} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1302} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1300} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I1303} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1303} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1299} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_class
*char_class =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 2679 2721
           (
               ( $pad{I1304} = $pos or 1 )
               && (
               ## <quant>
               ## pos: 2680 2696
               (
                (   ( $pad{I1305} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2682 2690
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1305} ) && 0 ) )
               && do { while (
                (   ( $pad{I1305} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2682 2690
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1305} ) && 0 ) )) {}; $bool = 1 }
               )
               ## </quant>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1304} ) or 1 )
               &&            ## <concat>
               ## pos: 2697 2721
               (
      
                 ## <group>
                 ## pos: 2697 2703
                  (   ( $pad{I1306} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2699 2701
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1306} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2703 2718
                  (   ( $pad{I1307} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2703 2716
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1307} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2718 2721
                  (   ( $pad{I1308} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2718 2720
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1308} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token string_code
*string_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2771 3055
           (
            (   ( $pad{I1309} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2772 3052
               (
                   ( $pad{I1310} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2778 2802
                   (
      
                     ## <group>
                     ## pos: 2778 2783
                      (   ( $pad{I1311} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2780 2782
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1311} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2783 2802
                      (   ( $pad{I1312} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2783 2797
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1312} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2803 2831
                   (
      
                     ## <group>
                     ## pos: 2803 2809
                      (   ( $pad{I1313} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2805 2807
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1313} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2809 2824
                      (   ( $pad{I1314} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2809 2819
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1314} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2824 2831
                      (   ( $pad{I1315} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2824 2826
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1315} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2832 2864
                   (
      
                     ## <group>
                     ## pos: 2832 2838
                      (   ( $pad{I1316} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2834 2836
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1316} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2838 2857
                      (   ( $pad{I1317} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2838 2854
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1317} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2857 2864
                      (   ( $pad{I1318} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2857 2859
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1318} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2865 2903
                   (
      
                     ## <group>
                     ## pos: 2865 2871
                      (   ( $pad{I1319} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2867 2869
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1319} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2871 2896
                      (   ( $pad{I1320} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2872 2893
                       (
                           ( $pad{I1321} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2872 2888
                            (   ( $pad{I1322} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2873 2887
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1322} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1321} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2889 2893
                            (   ( $pad{I1323} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1323} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1320} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2896 2903
                      (   ( $pad{I1324} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2896 2898
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1324} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2904 2942
                   (
      
                     ## <group>
                     ## pos: 2904 2910
                      (   ( $pad{I1325} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2906 2908
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1325} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2910 2935
                      (   ( $pad{I1326} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2911 2932
                       (
                           ( $pad{I1327} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2911 2927
                            (   ( $pad{I1328} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2912 2926
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1328} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1327} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2928 2932
                            (   ( $pad{I1329} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1329} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1326} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2935 2942
                      (   ( $pad{I1330} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2935 2937
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1330} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2943 2981
                   (
      
                     ## <group>
                     ## pos: 2943 2949
                      (   ( $pad{I1331} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2945 2947
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1331} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2949 2974
                      (   ( $pad{I1332} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2950 2971
                       (
                           ( $pad{I1333} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2950 2966
                            (   ( $pad{I1334} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2951 2965
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1334} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1333} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2967 2971
                            (   ( $pad{I1335} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1335} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1332} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2974 2981
                      (   ( $pad{I1336} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2974 2976
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1336} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2982 3016
                   (
      
                     ## <group>
                     ## pos: 2982 3009
                      (   ( $pad{I1337} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2985 3007
                       (
                           ( $pad{I1338} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2985 2992
                            (   ( $pad{I1339} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2986 2991
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1339} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2993 2997
                            (   ( $pad{I1340} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 2994 2996
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1340} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2998 3002
                            (   ( $pad{I1341} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 2999 3001
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1341} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3003 3007
                            (   ( $pad{I1342} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3004 3006
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1342} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1337} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3009 3016
                      (   ( $pad{I1343} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3009 3011
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1343} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3017 3029
                    (   ( $pad{I1344} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3019 3024
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1344} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3030 3052
                    (   ( $pad{I1345} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1345} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1309} ) && 0 ) )
           && do { while (
            (   ( $pad{I1309} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2772 3052
               (
                   ( $pad{I1310} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2778 2802
                   (
      
                     ## <group>
                     ## pos: 2778 2783
                      (   ( $pad{I1311} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2780 2782
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1311} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2783 2802
                      (   ( $pad{I1312} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2783 2797
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1312} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2803 2831
                   (
      
                     ## <group>
                     ## pos: 2803 2809
                      (   ( $pad{I1313} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2805 2807
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1313} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2809 2824
                      (   ( $pad{I1314} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2809 2819
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1314} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2824 2831
                      (   ( $pad{I1315} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2824 2826
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1315} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2832 2864
                   (
      
                     ## <group>
                     ## pos: 2832 2838
                      (   ( $pad{I1316} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2834 2836
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1316} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2838 2857
                      (   ( $pad{I1317} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2838 2854
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1317} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2857 2864
                      (   ( $pad{I1318} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2857 2859
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1318} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2865 2903
                   (
      
                     ## <group>
                     ## pos: 2865 2871
                      (   ( $pad{I1319} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2867 2869
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1319} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2871 2896
                      (   ( $pad{I1320} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2872 2893
                       (
                           ( $pad{I1321} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2872 2888
                            (   ( $pad{I1322} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2873 2887
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1322} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1321} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2889 2893
                            (   ( $pad{I1323} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1323} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1320} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2896 2903
                      (   ( $pad{I1324} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2896 2898
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1324} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2904 2942
                   (
      
                     ## <group>
                     ## pos: 2904 2910
                      (   ( $pad{I1325} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2906 2908
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1325} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2910 2935
                      (   ( $pad{I1326} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2911 2932
                       (
                           ( $pad{I1327} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2911 2927
                            (   ( $pad{I1328} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2912 2926
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1328} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1327} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2928 2932
                            (   ( $pad{I1329} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1329} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1326} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2935 2942
                      (   ( $pad{I1330} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2935 2937
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1330} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2943 2981
                   (
      
                     ## <group>
                     ## pos: 2943 2949
                      (   ( $pad{I1331} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2945 2947
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1331} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2949 2974
                      (   ( $pad{I1332} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2950 2971
                       (
                           ( $pad{I1333} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2950 2966
                            (   ( $pad{I1334} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2951 2965
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1334} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1333} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2967 2971
                            (   ( $pad{I1335} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1335} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1332} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2974 2981
                      (   ( $pad{I1336} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2974 2976
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1336} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2982 3016
                   (
      
                     ## <group>
                     ## pos: 2982 3009
                      (   ( $pad{I1337} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2985 3007
                       (
                           ( $pad{I1338} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2985 2992
                            (   ( $pad{I1339} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2986 2991
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1339} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2993 2997
                            (   ( $pad{I1340} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 2994 2996
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1340} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2998 3002
                            (   ( $pad{I1341} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 2999 3001
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1341} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1338} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3003 3007
                            (   ( $pad{I1342} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3004 3006
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1342} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1337} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3009 3016
                      (   ( $pad{I1343} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3009 3011
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1343} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3017 3029
                    (   ( $pad{I1344} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3019 3024
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1344} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1310} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3030 3052
                    (   ( $pad{I1345} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1345} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1309} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parsed_code
*parsed_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3141 3187
           (
      
             ## <group>
             ## pos: 3141 3160
              (   ( $pad{I1346} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 3141 3155
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1346} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3160 3187
              (   ( $pad{I1347} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3160 3186
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return '{' . $_[0] . '}'; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1347} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_capture_body
*named_capture_body =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 3221 3712
           (
               ( $pad{I1348} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 3222 3354
               (
      
                 ## <group>
                 ## pos: 3222 3227
                  (   ( $pad{I1349} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3223 3225
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1349} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3227 3241
                  (   ( $pad{I1350} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3227 3233
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1350} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3241 3245
                  (   ( $pad{I1351} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3241 3243
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1351} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3245 3354
                  (   ( $pad{I1352} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3245 3349
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                                  _pos => [ $_[0]->from, $_[0]->to ], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1352} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1348} ) or 1 )
               &&            ## <concat>
               ## pos: 3355 3402
               (
      
                 ## <group>
                 ## pos: 3355 3360
                  (   ( $pad{I1353} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3356 3358
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1353} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3360 3374
                  (   ( $pad{I1354} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3360 3366
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1354} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3374 3378
                  (   ( $pad{I1355} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3374 3376
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1355} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3378 3402
                  (   ( $pad{I1356} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3378 3397
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1356} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1348} ) or 1 )
               &&            ## <concat>
               ## pos: 3403 3464
               (
      
                 ## <group>
                 ## pos: 3403 3408
                  (   ( $pad{I1357} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3404 3406
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1357} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3408 3428
                  (   ( $pad{I1358} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3408 3426
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1358} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3428 3464
                  (   ( $pad{I1359} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3428 3459
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1359} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1348} ) or 1 )
               &&            ## <concat>
               ## pos: 3465 3678
               (
      
                 ## <group>
                 ## pos: 3465 3470
                  (   ( $pad{I1360} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3466 3468
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1360} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3470 3484
                  (   ( $pad{I1361} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 3470 3480
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1361} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3484 3495
                  (   ( $pad{I1362} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3484 3486
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1362} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3495 3678
                  (   ( $pad{I1363} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3495 3673
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => "${$_[0]}",
                            },
                       _pos => [ $_[0]->from, $_[0]->to ],
                    };
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1363} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1348} ) or 1 )
               &&   
               ## <group>
               ## pos: 3679 3712
                (   ( $pad{I1364} = $pos or 1 ) &&
                 ## <closure>
                 ## pos: 3680 3711
                 do { 
                   local $::_V6_SUCCEED = 1;
                   $::_V6_MATCH_ = $m;
                   sub { die "invalid alias syntax"; }->( $m );
                   1;
                 }
                 ## </closure>
     ||    ( ( $pos = $pad{I1364} ) && 0 ) )
               ## </group>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parse_metasyntax
*parse_metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3748 6621
           (
      
             ## <group>
             ## pos: 3748 3792
              (   ( $pad{I1365} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3748 3787
               do{
                    my $from = $pos;
                    my $bool =                    ## <alt>
                       ## pos: 3764 3786
                       (
                           ( $pad{I1366} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3764 3769
                            (   ( $pad{I1367} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3765 3768
                             ( ( substr( $s, $pos, 1 ) eq '!' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1367} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1366} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3770 3775
                            (   ( $pad{I1368} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3771 3774
                             ( ( substr( $s, $pos, 1 ) eq '?' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1368} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1366} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3776 3781
                            (   ( $pad{I1369} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3777 3780
                             ( ( substr( $s, $pos, 1 ) eq '.' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1369} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1366} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3782 3786
                            (   ( $pad{I1370} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1370} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'modifier'} = $match;
                    $bool
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1365} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3792 6621
              (   ( $pad{I1371} = $pos or 1 ) &&
               ## <alt>
               ## pos: 3793 6619
               (
                   ( $pad{I1372} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 3793 4011
                   (
      
                     ## <group>
                     ## pos: 3793 3807
                      (   ( $pad{I1373} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3802 3805
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1373} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3807 3822
                      (   ( $pad{I1374} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 3807 3820
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1374} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3822 3835
                      (   ( $pad{I1375} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3822 3826
                       ( ( substr( $s, $pos, 2 ) eq '}>' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1375} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3835 4011
                      (   ( $pad{I1376} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 3835 4006
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { closure => {
                closure  => ${ $_[0]->{qw(parsed_code)} },
                modifier => ${ $_[0]->{qw(modifier)} },
            },
                _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1376} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1372} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4012 4505
                   (
      
                     ## <group>
                     ## pos: 4012 4042
                      (   ( $pad{I1377} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4021 4033
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1377} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 4042 4075
                     (
                      (   ( $pad{I1378} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4043 4064
                                 (
      
                                   ## <group>
                                   ## pos: 4043 4051
                                    (   ( $pad{I1379} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1379} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4051 4064
                                    (   ( $pad{I1380} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4051 4063
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I1380} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I1378} ) && 0 ) )
                     && do { while (
                      (   ( $pad{I1378} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4043 4064
                                 (
      
                                   ## <group>
                                   ## pos: 4043 4051
                                    (   ( $pad{I1379} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1379} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4051 4064
                                    (   ( $pad{I1380} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4051 4063
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I1380} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I1378} ) && 0 ) )) {}; $bool = 1 }
                     )
                     ## </quant>
    
                   &&
      
                     ## <group>
                     ## pos: 4075 4086
                      (   ( $pad{I1381} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 4075 4077
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1381} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4086 4505
                      (   ( $pad{I1382} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 4086 4500
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub {
                if ( ${ $_[0]->{qw(modifier)} } eq '!' ) {
                  return {
                    negate => {
                      char_class => [
                        '+' . $_[0]->{qw(char_class)},
                        @{$_[0]->[0]},   # TODO - stringify
                  ] } }
                }
                return {
                  char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1382} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1372} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4506 6394
                   (
      
                     ## <group>
                     ## pos: 4506 4531
                      (   ( $pad{I1383} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4515 4522
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1383} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4531 6394
                      (   ( $pad{I1384} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 4532 6388
                       (
                           ( $pad{I1385} = $pos or 1 )
                           && (
                           ## <concat>
                           ## pos: 4532 5149
                           (
      
                             ## <group>
                             ## pos: 4532 4549
                              (   ( $pad{I1386} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 4543 4548
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
     ||    ( ( $pos = $pad{I1386} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4549 4556
                              (   ( $pad{I1387} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 4549 4555
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1387} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4556 4569
                              (   ( $pad{I1388} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 4556 4558
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1388} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4569 5149
                              (   ( $pad{I1389} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 4569 5140
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule => ${ $_[0]->{qw(rule)} }, modifier => ${ $_[0]->{qw(modifier)} },
                         }, _pos => [ $_[0]->from - 1, $_[0]->to ], }
                }
                return { metasyntax => {
                            metasyntax => ${ $_[0]->{qw(ident)} },
                            rule       => ${ $_[0]->{qw(rule)} },
                            modifier   => ${ $_[0]->{qw(modifier)} },
                        },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1389} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 5150 6129
                           (
      
                             ## <group>
                             ## pos: 5150 5165
                              (   ( $pad{I1390} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5161 5164
                               ( ( substr( $s, $pos, 1 ) eq ':' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1390} ) && 0 ) )
                             ## </group>
    
                           &&
                             ## <quant>
                             ## pos: 5165 5182
                             (
                              (   ( $pad{I1391} = $pos or 1 ) &&
                                 ## <metasyntax>
                                 ## pos: 5165 5170
                                 do {
                                      my $prior = $::_V6_PRIOR_;
                                      my $match =
                                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                      $::_V6_PRIOR_ = $prior;
                                      my $bool = (!$match != 1);
                                      $pos = $match->to if $bool;
                                      $match;
                                 }
                                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1391} ) && 0 ) )
                             || ( $bool = 1 )
                             )
                             ## </quant>
    
                           &&
      
                             ## <group>
                             ## pos: 5182 5352
                              (   ( $pad{I1392} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 5182 5341
                               do{
                    my $from = $pos;
                    my $bool =                                    ## <quant>
                                       ## pos: 5193 5340
                                       do { while (
                                        (   ( $pad{I1393} = $pos or 1 ) &&
                                           ## <alt>
                                           ## pos: 5207 5327
                                           (
                                               ( $pad{I1394} = $pos or 1 )
                                               && (
                                               ## <concat>
                                               ## pos: 5221 5253
                                               (
      
                                                 ## <group>
                                                 ## pos: 5221 5226
                                                  (   ( $pad{I1395} = $pos or 1 ) &&
    
                                                   ## <constant>
                                                   ## pos: 5223 5225
                                                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                       ? ( $pos += 1 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
     ||    ( ( $pos = $pad{I1395} ) && 0 ) )
                                                 ## </group>
    
                                               &&
      
                                                 ## <group>
                                                 ## pos: 5226 5253
                                                  (   ( $pad{I1396} = $pos or 1 ) &&
                                                   ## <named_capture>
                                                   ## pos: 5226 5240
                                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                   ## </named_capture>
     ||    ( ( $pos = $pad{I1396} ) && 0 ) )
                                                 ## </group>
    
                                               )
                                               ## </concat>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I1394} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5254 5302
                                                (   ( $pad{I1397} = $pos or 1 ) &&
                                                ## <metasyntax>
                                                 ## pos: 5256 5289
                                                 do{
                    my $match = 
              ## <variable>
              ## pos: 5256 5289
              do {
                our $I1398;
                our $I1398_sizes;
                unless ( $I1398 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1398_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1398 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1398_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1398->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1398, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                ## </metasyntax>
     ||    ( ( $pos = $pad{I1397} ) && 0 ) )
                                               ## </group>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I1394} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5303 5327
                                                (   ( $pad{I1399} = $pos or 1 ) &&
                                                 ## <perl5>
                                                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                     ? ( $pos += length( $1 ) or 1 )
                                                     : 0
                                                 )
                                                 ## </perl5>
     ||    ( ( $pos = $pad{I1399} ) && 0 ) )
                                               ## </group>
    
                                             )
                                           )
                                           ## </alt>
     ||    ( ( $pos = $pad{I1393} ) && 0 ) )) {}; $bool = 1 }
                                       ## </quant>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'str'} = $match;
                    $bool
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1392} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5352 5365
                              (   ( $pad{I1400} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5352 5354
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1400} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5365 6129
                              (   ( $pad{I1401} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 5365 6120
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule     => { metasyntax => {
                                    metasyntax => '\'' . ${ $_[0]->{qw(str)} } . '\'',
                                },
                            _pos => [ $_[0]->{qw(str)}->from, $_[0]->{qw(str)}->to ],                   },
                        modifier => ${ $_[0]->{qw(modifier)} },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    } }
                }
                return { metasyntax => {
                    metasyntax => ${ $_[0]->{qw(ident)} },
                    string   => ${ $_[0]->{qw(str)} },
                    modifier => ${ $_[0]->{qw(modifier)} },
                },
                    _pos => [ $_[0]->from - 1, $_[0]->to ],
                }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1401} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1385} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 6130 6388
                           (
      
                             ## <group>
                             ## pos: 6130 6145
                              (   ( $pad{I1402} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6141 6143
                               ( ( substr( $s, $pos, 1 ) eq '(' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1402} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6145 6160
                              (   ( $pad{I1403} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 6145 6158
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1403} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6160 6163
                              (   ( $pad{I1404} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6160 6162
                               ( ( substr( $s, $pos, 1 ) eq ')' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1404} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6163 6176
                              (   ( $pad{I1405} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6163 6165
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1405} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6176 6388
                              (   ( $pad{I1406} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 6176 6379
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub { return { call => {
                  method   => ${ $_[0]->{qw(ident)} },
                  params   => ${ $_[0]->{qw(parsed_code)} },
                  modifier => ${ $_[0]->{qw(modifier)} },
              },
                  _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1406} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1384} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1372} ) or 1 )
                   &&                ## <concat>
                   ## pos: 6395 6619
                   (
      
                     ## <group>
                     ## pos: 6395 6418
                      (   ( $pad{I1407} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 6404 6416
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1407} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6418 6429
                      (   ( $pad{I1408} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 6418 6420
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1408} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6429 6619
                      (   ( $pad{I1409} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 6429 6614
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { metasyntax => {
                  metasyntax => "${ $_[0]->{qw(metasyntax)} }",
                  modifier   => ${ $_[0]->{qw(modifier)} },
            },
                  _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1409} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1371} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token var1
*var1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 6731 6833
           (
      
             ## <group>
             ## pos: 6731 6739
              (   ( $pad{I1410} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 6731 6738
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1410} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6739 6750
              (   ( $pad{I1411} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 6739 6741
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1411} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6750 6833
              (   ( $pad{I1412} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6750 6832
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0]->{ident}, _pos => [$_[0]->from - 2, $_[0]->to], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1412} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$<'} = sub { var1($_[1], $_[0], $_[2], $_[3]) }; 

# token var2
*var2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 6925 7149
           (
               ( $pad{I1413} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 6925 7023
               (
                 ## <quant>
                 ## pos: 6925 6943
                 (
                  (   ( $pad{I1414} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6925 6933
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1414} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1414} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6925 6933
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1414} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 6943 7023
                  (   ( $pad{I1415} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 6943 7018
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1415} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1413} ) or 1 )
               &&            ## <concat>
               ## pos: 7024 7149
               (
                 ## <quant>
                 ## pos: 7024 7045
                 (
                  (   ( $pad{I1416} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7033 7035
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1416} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7045 7079
                 (
                  (   ( $pad{I1417} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7046 7068
                     (
                         ( $pad{I1418} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7046 7056
                          (   ( $pad{I1419} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7047 7055
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1419} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1418} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7057 7060
                          (   ( $pad{I1420} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7058 7059
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1420} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1418} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7061 7068
                         (
      
                           ## <group>
                           ## pos: 7061 7065
                            (   ( $pad{I1421} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7062 7064
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1421} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7065 7068
                            (   ( $pad{I1422} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7065 7067
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1422} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1417} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1417} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7046 7068
                     (
                         ( $pad{I1418} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7046 7056
                          (   ( $pad{I1419} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7047 7055
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1419} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1418} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7057 7060
                          (   ( $pad{I1420} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7058 7059
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1420} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1418} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7061 7068
                         (
      
                           ## <group>
                           ## pos: 7061 7065
                            (   ( $pad{I1421} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7062 7064
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1421} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7065 7068
                            (   ( $pad{I1422} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7065 7067
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1422} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1417} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7079 7149
                  (   ( $pad{I1423} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7079 7148
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1423} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$'} = sub { var2($_[1], $_[0], $_[2], $_[3]) }; 

# token var3
*var3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7240 7462
           (
               ( $pad{I1424} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7240 7337
               (
                 ## <quant>
                 ## pos: 7240 7258
                 (
                  (   ( $pad{I1425} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7240 7248
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1425} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1425} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7240 7248
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1425} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7258 7337
                  (   ( $pad{I1426} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7258 7332
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1426} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1424} ) or 1 )
               &&            ## <concat>
               ## pos: 7338 7462
               (
                 ## <quant>
                 ## pos: 7338 7359
                 (
                  (   ( $pad{I1427} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7347 7349
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1427} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7359 7393
                 (
                  (   ( $pad{I1428} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7360 7382
                     (
                         ( $pad{I1429} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7360 7370
                          (   ( $pad{I1430} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7361 7369
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1430} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1429} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7371 7374
                          (   ( $pad{I1431} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7372 7373
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1431} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1429} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7375 7382
                         (
      
                           ## <group>
                           ## pos: 7375 7379
                            (   ( $pad{I1432} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7376 7378
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1432} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7379 7382
                            (   ( $pad{I1433} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7379 7381
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1433} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1428} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1428} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7360 7382
                     (
                         ( $pad{I1429} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7360 7370
                          (   ( $pad{I1430} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7361 7369
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1430} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1429} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7371 7374
                          (   ( $pad{I1431} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7372 7373
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1431} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1429} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7375 7382
                         (
      
                           ## <group>
                           ## pos: 7375 7379
                            (   ( $pad{I1432} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7376 7378
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1432} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7379 7382
                            (   ( $pad{I1433} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7379 7381
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1433} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1428} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7393 7462
                  (   ( $pad{I1434} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7393 7461
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1434} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'@'} = sub { var3($_[1], $_[0], $_[2], $_[3]) }; 

# token var4
*var4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7553 7773
           (
               ( $pad{I1435} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7553 7649
               (
                 ## <quant>
                 ## pos: 7553 7571
                 (
                  (   ( $pad{I1436} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7553 7561
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1436} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1436} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7553 7561
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1436} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7571 7649
                  (   ( $pad{I1437} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7571 7644
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1437} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1435} ) or 1 )
               &&            ## <concat>
               ## pos: 7650 7773
               (
                 ## <quant>
                 ## pos: 7650 7671
                 (
                  (   ( $pad{I1438} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7659 7661
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1438} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7671 7705
                 (
                  (   ( $pad{I1439} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7672 7694
                     (
                         ( $pad{I1440} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7672 7682
                          (   ( $pad{I1441} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7673 7681
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1441} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1440} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7683 7686
                          (   ( $pad{I1442} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7684 7685
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1442} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1440} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7687 7694
                         (
      
                           ## <group>
                           ## pos: 7687 7691
                            (   ( $pad{I1443} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7688 7690
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1443} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7691 7694
                            (   ( $pad{I1444} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7691 7693
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1444} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1439} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1439} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7672 7694
                     (
                         ( $pad{I1440} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7672 7682
                          (   ( $pad{I1441} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7673 7681
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1441} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1440} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7683 7686
                          (   ( $pad{I1442} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7684 7685
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1442} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1440} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7687 7694
                         (
      
                           ## <group>
                           ## pos: 7687 7691
                            (   ( $pad{I1443} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7688 7690
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1443} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7691 7694
                            (   ( $pad{I1444} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7691 7693
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1444} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1439} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7705 7773
                  (   ( $pad{I1445} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7705 7772
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1445} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'%'} = sub { var4($_[1], $_[0], $_[2], $_[3]) }; 

# token term1
*term1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 7974 8124
            (   ( $pad{I1446} = $pos or 1 ) &&
             ## <closure>
             ## pos: 7974 8123
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => 'null',
            },
                            _pos => [ $_[0]->from, $_[0]->to ],
            } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1446} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{*}'} = sub { term1($_[1], $_[0], $_[2], $_[3]) }; 

# token term2
*term2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8220 8435
           (
      
             ## <group>
             ## pos: 8220 8235
              (   ( $pad{I1447} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 8220 8230
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1447} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8235 8246
              (   ( $pad{I1448} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8235 8237
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1448} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8246 8435
              (   ( $pad{I1449} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8246 8434
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                    metasyntax => {
                        metasyntax => '\'' . ${$_[0]},
                    },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                };
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1449} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\''} = sub { term2($_[1], $_[0], $_[2], $_[3]) }; 

# token term3
*term3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8530 8646
           (
      
             ## <group>
             ## pos: 8530 8537
              (   ( $pad{I1450} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8530 8536
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1450} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8537 8548
              (   ( $pad{I1451} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8537 8539
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1451} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8548 8646
              (   ( $pad{I1452} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8548 8645
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 1, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1452} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'('} = sub { term3($_[1], $_[0], $_[2], $_[3]) }; 

# token term4
*term4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8740 8861
           (
      
             ## <group>
             ## pos: 8740 8748
              (   ( $pad{I1453} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8740 8746
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1453} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8748 8761
              (   ( $pad{I1454} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8748 8752
               ( ( substr( $s, $pos, 2 ) eq ')>' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1454} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8761 8861
              (   ( $pad{I1455} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8761 8860
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capture_as_result => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 2, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1455} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<('} = sub { term4($_[1], $_[0], $_[2], $_[3]) }; 

# token term5
*term5 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8956 9216
           (
      
             ## <group>
             ## pos: 8956 8977
              (   ( $pad{I1456} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8956 8968
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1456} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 8977 9010
             do { while (
              (   ( $pad{I1457} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 8978 8999
                         (
      
                           ## <group>
                           ## pos: 8978 8986
                            (   ( $pad{I1458} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1458} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 8986 8999
                            (   ( $pad{I1459} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 8986 8998
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1459} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1457} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9010 9021
              (   ( $pad{I1460} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9010 9012
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1460} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9021 9216
              (   ( $pad{I1461} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9021 9215
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1461} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<+'} = sub { term5($_[1], $_[0], $_[2], $_[3]) }; 

# token term6
*term6 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9311 9571
           (
      
             ## <group>
             ## pos: 9311 9332
              (   ( $pad{I1462} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9311 9323
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1462} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9332 9365
             do { while (
              (   ( $pad{I1463} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9333 9354
                         (
      
                           ## <group>
                           ## pos: 9333 9341
                            (   ( $pad{I1464} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1464} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9341 9354
                            (   ( $pad{I1465} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9341 9353
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1465} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1463} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9365 9376
              (   ( $pad{I1466} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9365 9367
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1466} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9376 9571
              (   ( $pad{I1467} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9376 9570
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '-' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1467} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<-'} = sub { term6($_[1], $_[0], $_[2], $_[3]) }; 

# token term7
*term7 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9666 9937
           (
      
             ## <group>
             ## pos: 9666 9680
              (   ( $pad{I1468} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9666 9678
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_range'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1468} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9680 9691
              (   ( $pad{I1469} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9680 9682
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1469} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9691 9724
             do { while (
              (   ( $pad{I1470} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9692 9713
                         (
      
                           ## <group>
                           ## pos: 9692 9700
                            (   ( $pad{I1471} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1471} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9700 9713
                            (   ( $pad{I1472} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9700 9712
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1472} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1470} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9724 9735
              (   ( $pad{I1473} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9724 9726
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1473} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9735 9937
              (   ( $pad{I1474} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9735 9936
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+[' . $_[0]->{qw(char_range)} . ']',
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1474} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<['} = sub { term7($_[1], $_[0], $_[2], $_[3]) }; 

# token term8
*term8 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10032 10091
           (
      
             ## <group>
             ## pos: 10032 10059
              (   ( $pad{I1475} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10032 10050
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1475} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10059 10091
              (   ( $pad{I1476} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10059 10090
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1476} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<'} = sub { term8($_[1], $_[0], $_[2], $_[3]) }; 

# token term9
*term9 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10185 10375
           (
      
             ## <group>
             ## pos: 10185 10200
              (   ( $pad{I1477} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10185 10198
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1477} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10200 10211
              (   ( $pad{I1478} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10200 10202
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1478} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10211 10375
              (   ( $pad{I1479} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10211 10374
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { closure => {
                closure => ${ $_[0]->{qw(parsed_code)} },
                modifier => 'plain',
            },
                _pos => [$_[0]->from - 1, $_[0]->to],
            } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1479} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{'} = sub { term9($_[1], $_[0], $_[2], $_[3]) }; 

# token term10
*term10 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10470 10521
           (
      
             ## <group>
             ## pos: 10470 10493
              (   ( $pad{I1480} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10470 10484
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'special_char'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1480} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10493 10521
              (   ( $pad{I1481} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10493 10520
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(special_char)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1481} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\\'} = sub { term10($_[1], $_[0], $_[2], $_[3]) }; 

# token term11
*term11 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10618 10677
            (   ( $pad{I1482} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10618 10676
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { 'dot' => 1, _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1482} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'.'} = sub { term11($_[1], $_[0], $_[2], $_[3]) }; 

# token term12
*term12 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10773 10811
           (
      
             ## <group>
             ## pos: 10773 10780
              (   ( $pad{I1483} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10773 10779
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1483} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10780 10791
              (   ( $pad{I1484} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10780 10782
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1484} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10791 10811
              (   ( $pad{I1485} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10791 10810
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1485} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'['} = sub { term12($_[1], $_[0], $_[2], $_[3]) }; 

# token term13
*term13 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10899 10962
            (   ( $pad{I1486} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10899 10961
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':::', _pos => [$_[0]->from - 3, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1486} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':::'} = sub { term13($_[1], $_[0], $_[2], $_[3]) }; 

# token term14
*term14 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11052 11114
            (   ( $pad{I1487} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11052 11113
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':?', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1487} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':?'} = sub { term14($_[1], $_[0], $_[2], $_[3]) }; 

# token term15
*term15 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11203 11265
            (   ( $pad{I1488} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11203 11264
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':+', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1488} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':+'} = sub { term15($_[1], $_[0], $_[2], $_[3]) }; 

# token term16
*term16 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11354 11416
            (   ( $pad{I1489} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11354 11415
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '::', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1489} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'::'} = sub { term16($_[1], $_[0], $_[2], $_[3]) }; 

# token term17
*term17 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11505 11566
            (   ( $pad{I1490} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11505 11565
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1490} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':'} = sub { term17($_[1], $_[0], $_[2], $_[3]) }; 

# token term18
*term18 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11654 11716
            (   ( $pad{I1491} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11654 11715
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$$', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1491} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$$'} = sub { term18($_[1], $_[0], $_[2], $_[3]) }; 

# token term19
*term19 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11805 11867
            (   ( $pad{I1492} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11805 11866
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$', _pos => [$_[0]->from - 1, $_[0]->to],  } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1492} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$'} = sub { term19($_[1], $_[0], $_[2], $_[3]) }; 

# token term20
*term20 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11955 12017
            (   ( $pad{I1493} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11955 12016
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^^', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1493} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^^'} = sub { term20($_[1], $_[0], $_[2], $_[3]) }; 

# token term21
*term21 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12106 12167
            (   ( $pad{I1494} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12106 12166
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^', _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1494} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^'} = sub { term21($_[1], $_[0], $_[2], $_[3]) }; 

# token term22
*term22 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12255 12317
            (   ( $pad{I1495} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12255 12316
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '>>', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1495} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'>>'} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{'»'} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# token term24
*term24 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12559 12621
            (   ( $pad{I1496} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12559 12620
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '<<', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1496} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<<'} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{'«'} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# token term26
*term26 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 12871 13048
           (
      
             ## <group>
             ## pos: 12871 12877
              (   ( $pad{I1497} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 12871 12876
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1497} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12877 12892
              (   ( $pad{I1498} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 12877 12883
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1498} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12892 13048
              (   ( $pad{I1499} = $pos or 1 ) &&
               ## <closure>
               ## pos: 12892 13047
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                modifier => {
                    modifier => 'ignorecase',
                    rule => ${ $_[0]->{qw(rule)} },
                    }
                },
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1499} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':i'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':ignorecase'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# token term28
*term28 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13328 13405
           (
      
             ## <group>
             ## pos: 13328 13334
              (   ( $pad{I1500} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13328 13333
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1500} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13334 13349
              (   ( $pad{I1501} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13334 13340
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1501} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13349 13405
              (   ( $pad{I1502} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13349 13404
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'sigspace', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1502} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':s'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':sigspace'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# token term30
*term30 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13684 13758
           (
      
             ## <group>
             ## pos: 13684 13690
              (   ( $pad{I1503} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13684 13689
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1503} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13690 13705
              (   ( $pad{I1504} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13690 13696
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1504} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13705 13758
              (   ( $pad{I1505} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13705 13757
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'Perl5', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1505} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':P5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':Perl5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# token term32
*term32 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14031 14105
           (
      
             ## <group>
             ## pos: 14031 14037
              (   ( $pad{I1506} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14031 14036
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1506} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14037 14052
              (   ( $pad{I1507} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14037 14043
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1507} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14052 14105
              (   ( $pad{I1508} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14052 14104
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'bytes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1508} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':bytes'} = sub { term32($_[1], $_[0], $_[2], $_[3]) }; 

# token term33
*term33 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14206 14280
           (
      
             ## <group>
             ## pos: 14206 14212
              (   ( $pad{I1509} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14206 14211
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1509} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14212 14227
              (   ( $pad{I1510} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14212 14218
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1510} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14227 14280
              (   ( $pad{I1511} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14227 14279
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'codes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1511} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':codes'} = sub { term33($_[1], $_[0], $_[2], $_[3]) }; 

# token term34
*term34 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14381 14456
           (
      
             ## <group>
             ## pos: 14381 14387
              (   ( $pad{I1512} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14381 14386
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1512} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14387 14402
              (   ( $pad{I1513} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14387 14393
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1513} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14402 14456
              (   ( $pad{I1514} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14402 14455
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'graphs', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1514} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':graphs'} = sub { term34($_[1], $_[0], $_[2], $_[3]) }; 

# token term35
*term35 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14558 14633
           (
      
             ## <group>
             ## pos: 14558 14564
              (   ( $pad{I1515} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14558 14563
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1515} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14564 14579
              (   ( $pad{I1516} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14564 14570
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1516} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14579 14633
              (   ( $pad{I1517} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14579 14632
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'langs',  rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1517} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':langs'} = sub { term35($_[1], $_[0], $_[2], $_[3]) }; 

# token term
*term =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 14728 15530
           (
               ( $pad{I1518} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 14729 15207
               (
      
                 ## <group>
                 ## pos: 14729 14772
                  (   ( $pad{I1519} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 14731 14764
                   do{
                    my $match = 
              ## <variable>
              ## pos: 14731 14764
              do {
                our $I1520;
                our $I1520_sizes;
                unless ( $I1520 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1520_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1520 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1520_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1520->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1520, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I1519} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 14772 15207
                  (   ( $pad{I1521} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 14773 15201
                   (
                       ( $pad{I1522} = $pos or 1 )
                       && (
                       ## <concat>
                       ## pos: 14773 15114
                       (
                         ## <quant>
                         ## pos: 14773 14782
                         (
                          (   ( $pad{I1523} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14775 14780
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1523} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14782 14787
                          (   ( $pad{I1524} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 14782 14786
                           ( ( substr( $s, $pos, 2 ) eq ':=' )
                               ? ( $pos += 2 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1524} ) && 0 ) )
                         ## </group>
    
                       &&
                         ## <quant>
                         ## pos: 14787 14794
                         (
                          (   ( $pad{I1525} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14787 14792
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1525} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14794 14825
                          (   ( $pad{I1526} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 14794 14814
                           do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                       $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_capture_body'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                           ## </named_capture>
     ||    ( ( $pos = $pad{I1526} ) && 0 ) )
                         ## </group>
    
                       &&
      
                         ## <group>
                         ## pos: 14825 15114
                          (   ( $pad{I1527} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 14825 15106
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub {
                return { named_capture => {
                            rule =>  ${ $_[0]->{qw(named_capture_body)} },
                            ident => ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} },
                         },
                            _pos => [ $_[0]->from, $_[0]->to ],
                         };
              }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
     ||    ( ( $pos = $pad{I1527} ) && 0 ) )
                         ## </group>
    
                       )
                       ## </concat>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1522} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 15115 15201
                        (   ( $pad{I1528} = $pos or 1 ) &&
                         ## <closure>
                         ## pos: 15126 15193
                         do {
                           local $::_V6_SUCCEED = 1;
                           $::_V6_MATCH_ = $m;
                           $m->data->{capture} = \( sub {
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} }
              }->( $m ) ); 
                           $bool = $::_V6_SUCCEED;
                           $::_V6_MATCH_ = $m if $bool; 
                           return $m if $bool; 
                         }
                         ## </closure>
     ||    ( ( $pos = $pad{I1528} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1521} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1518} ) or 1 )
               &&            ## <concat>
               ## pos: 15208 15376
               (
      
                 ## <group>
                 ## pos: 15208 15253
                  (   ( $pad{I1529} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 15210 15244
                   do{
                    my $match = 
              ## <variable>
              ## pos: 15210 15244
              do {
                our $I1530;
                our $I1530_sizes;
                unless ( $I1530 ) {
                    my $hash = \%Pugs::Grammar::Rule::rule_terms;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1530_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1530 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1530_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1530->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1530, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I1529} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15253 15376
                  (   ( $pad{I1531} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15253 15371
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                #print "term: ", Dumper( $_[0]->data );
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::rule_terms)} }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1531} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1518} ) or 1 )
               &&            ## <concat>
               ## pos: 15377 15530
               (
      
                 ## <group>
                 ## pos: 15377 15424
                  (   ( $pad{I1532} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1532} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15424 15530
                  (   ( $pad{I1533} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15424 15529
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                return { 'constant' => ${$_[0]},
                         _pos => [ $_[0]->from, $_[0]->to ] }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1533} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quant
*quant =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 15551 15665
           (
               ( $pad{I1534} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 15552 15643
               (
      
                 ## <group>
                 ## pos: 15552 15560
                  (   ( $pad{I1535} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15555 15559
                   ( ( substr( $s, $pos, 2 ) eq '**' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1535} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 15560 15567
                 (
                  (   ( $pad{I1536} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 15560 15565
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1536} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 15567 15571
                  (   ( $pad{I1537} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15567 15569
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1537} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15571 15586
                  (   ( $pad{I1538} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 15571 15584
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1538} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15586 15597
                  (   ( $pad{I1539} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15586 15588
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1539} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15597 15643
                  (   ( $pad{I1540} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15597 15638
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { closure => ${ $_[0]->{qw(parsed_code)} } } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1540} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1534} ) or 1 )
               &&            ## <quant>
               ## pos: 15644 15665
               (
                (   ( $pad{I1541} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1541} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quantifier
*quantifier =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 15691 16457
           (
      
             ## <group>
             ## pos: 15691 15716
              (   ( $pad{I1542} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15691 15711
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15704 15710
                               (
                                (   ( $pad{I1543} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15704 15709
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1543} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws1'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1542} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15716 15751
              (   ( $pad{I1544} = $pos or 1 ) &&
               ## <negate>
               ## pos: 15716 15746
               do{
                   my $pos1 = $pos;
                   do {
                     my $pos = $pos1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 
                         ## <before>
                         ## pos: 15726 15745
                         do{
                             my $pos1 = $pos;
                             do {
                               my $pos = $pos1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
      
                                   ## <group>
                                   ## pos: 15726 15745
                                    (   ( $pad{I1545} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1545} ) && 0 ) )
                                   ## </group>
    ;
                               $bool;
                             };
                         }
                         ## </before>
     ? 0 : 1;
                     $bool;
                   };
               }
               ## </negate>
     ||    ( ( $pos = $pad{I1544} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15751 15762
              (   ( $pad{I1546} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15751 15757
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'term'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1546} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15762 15787
              (   ( $pad{I1547} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15762 15782
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15775 15781
                               (
                                (   ( $pad{I1548} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15775 15780
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1548} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws2'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1547} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15787 15799
              (   ( $pad{I1549} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15787 15794
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'quant'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1549} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15799 15833
              (   ( $pad{I1550} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15799 15828
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15813 15827
                               (
                                (   ( $pad{I1551} = $pos or 1 ) &&
                                   ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
     ||    ( ( $pos = $pad{I1551} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'greedy'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1550} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15833 15858
              (   ( $pad{I1552} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15833 15853
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15846 15852
                               (
                                (   ( $pad{I1553} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15846 15851
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1553} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws3'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1552} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15858 16457
              (   ( $pad{I1554} = $pos or 1 ) &&
               ## <closure>
               ## pos: 15858 16456
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
          if (
                   ${$_[0]->{'quant'}}  eq ''
                && ${$_[0]->{'greedy'}} eq ''
                && ${$_[0]->{'ws1'}}    eq ''
                && ${$_[0]->{'ws2'}}    eq ''
                && ${$_[0]->{'ws3'}}    eq ''
          ) {
              return ${$_[0]->{'term'}};
          }
          return {
            quant => {
                    term    => ${$_[0]->{'term'}},
                    quant   => ${$_[0]->{'quant'}},
                    greedy  => ${$_[0]->{'greedy'}},
                    ws1     => ${$_[0]->{'ws1'}},
                    ws2     => ${$_[0]->{'ws2'}},
                    ws3     => ${$_[0]->{'ws3'}},
                },
            _pos => [$_[0]->from, $_[0]->to],
          }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1554} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token concat
*concat =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16479 16688
           (
             ## <quant>
             ## pos: 16479 16497
             (
              (   ( $pad{I1555} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16479 16491
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1555} ) && 0 ) )
             && do { while (
              (   ( $pad{I1555} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16479 16491
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1555} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16497 16688
              (   ( $pad{I1556} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16497 16687
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
            return { concat => \@a, _pos => [$_[0]->from, $_[0]->to] }
                if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1556} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive1
*conjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16716 16996
           (
             ## <quant>
             ## pos: 16716 16750
             (
              (   ( $pad{I1557} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16717 16742
                 (
                   ## <quant>
                   ## pos: 16717 16725
                   (
                    (   ( $pad{I1558} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 16718 16723
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1558} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 16725 16728
                    (   ( $pad{I1559} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16725 16727
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1559} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16728 16742
                    (   ( $pad{I1560} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16728 16741
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16737 16740
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16737 16740
                                          (   ( $pad{I1561} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16737 16739
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1561} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1560} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1557} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16750 16768
             (
              (   ( $pad{I1562} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16750 16758
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1562} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16768 16817
             do { while (
              (   ( $pad{I1563} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16769 16809
                 (
      
                   ## <group>
                   ## pos: 16769 16781
                    (   ( $pad{I1564} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16778 16780
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1564} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16781 16796
                    (   ( $pad{I1565} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16781 16794
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16790 16793
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16790 16793
                                          (   ( $pad{I1566} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16790 16792
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1565} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16796 16809
                    (   ( $pad{I1567} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 16796 16804
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1567} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1563} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16817 16996
              (   ( $pad{I1568} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16817 16995
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
            return { conjunctive1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1568} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token disjunctive1
*disjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17024 17313
           (
             ## <quant>
             ## pos: 17024 17058
             (
              (   ( $pad{I1569} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17025 17050
                 (
                   ## <quant>
                   ## pos: 17025 17033
                   (
                    (   ( $pad{I1570} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17026 17031
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17033 17036
                    (   ( $pad{I1571} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17033 17035
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17036 17050
                    (   ( $pad{I1572} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17036 17049
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17045 17048
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17045 17048
                                          (   ( $pad{I1573} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17045 17047
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1573} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1572} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1569} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17058 17082
             (
              (   ( $pad{I1574} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17058 17072
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1574} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17082 17136
             do { while (
              (   ( $pad{I1575} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17083 17128
                 (
      
                   ## <group>
                   ## pos: 17083 17095
                    (   ( $pad{I1576} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17092 17094
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1576} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17095 17109
                    (   ( $pad{I1577} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17095 17108
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17104 17107
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17104 17107
                                          (   ( $pad{I1578} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17104 17106
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1578} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1577} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17109 17128
                    (   ( $pad{I1579} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17109 17123
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1579} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1575} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17136 17313
              (   ( $pad{I1580} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17136 17312
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
            return { alt1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1580} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive
*conjunctive =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17340 17614
           (
             ## <quant>
             ## pos: 17340 17363
             (
              (   ( $pad{I1581} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17341 17355
                 (
                   ## <quant>
                   ## pos: 17341 17349
                   (
                    (   ( $pad{I1582} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17342 17347
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1582} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17349 17352
                    (   ( $pad{I1583} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17349 17351
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1583} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17352 17355
                    (   ( $pad{I1584} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17352 17354
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1584} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1581} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17363 17387
             (
              (   ( $pad{I1585} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17363 17377
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1585} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17387 17430
             do { while (
              (   ( $pad{I1586} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17388 17422
                 (
      
                   ## <group>
                   ## pos: 17388 17400
                    (   ( $pad{I1587} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17397 17399
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1587} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17400 17403
                    (   ( $pad{I1588} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17400 17402
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1588} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17403 17422
                    (   ( $pad{I1589} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17403 17417
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1589} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1586} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17430 17614
              (   ( $pad{I1590} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17430 17613
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
            return { conjunctive => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1590} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token rule
*rule =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17634 17898
           (
             ## <quant>
             ## pos: 17634 17657
             (
              (   ( $pad{I1591} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17635 17649
                 (
                   ## <quant>
                   ## pos: 17635 17643
                   (
                    (   ( $pad{I1592} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17636 17641
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1592} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17643 17646
                    (   ( $pad{I1593} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17643 17645
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1593} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17646 17649
                    (   ( $pad{I1594} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17646 17648
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1594} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1591} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17657 17680
             (
              (   ( $pad{I1595} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17657 17670
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1595} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17680 17722
             do { while (
              (   ( $pad{I1596} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17681 17714
                 (
      
                   ## <group>
                   ## pos: 17681 17693
                    (   ( $pad{I1597} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17690 17692
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1597} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17693 17696
                    (   ( $pad{I1598} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17693 17695
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1598} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17696 17714
                    (   ( $pad{I1599} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17696 17709
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1599} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1596} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17722 17898
              (   ( $pad{I1600} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17722 17897
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
            return { alt => \@a, _pos => [$_[0]->from, $_[0]->to], }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1600} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_regex
*named_regex =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17925 18145
           (
      
             ## <group>
             ## pos: 17925 17960
              (   ( $pad{I1601} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 17926 17954
                       (
                           ( $pad{I1602} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 17926 17935
                            (   ( $pad{I1603} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17927 17934
                             ( ( substr( $s, $pos, 5 ) eq 'token' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1603} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1602} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17936 17945
                            (   ( $pad{I1604} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17937 17944
                             ( ( substr( $s, $pos, 5 ) eq 'regex' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1604} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1602} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17946 17954
                            (   ( $pad{I1605} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17947 17953
                             ( ( substr( $s, $pos, 4 ) eq 'rule' )
                                 ? ( $pos += 4 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1605} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I1601} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17960 17966
              (   ( $pad{I1606} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 17960 17965
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1606} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17966 17974
              (   ( $pad{I1607} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 17966 17973
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1607} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 17974 17981
             (
              (   ( $pad{I1608} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 17974 17979
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1608} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17981 17993
              (   ( $pad{I1609} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 17981 17984
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1609} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 17993 18008
             (
              (   ( $pad{I1610} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 17993 17998
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1610} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18008 18019
              (   ( $pad{I1611} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18008 18014
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1611} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18019 18023
              (   ( $pad{I1612} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18019 18022
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1612} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18023 18033
             (
              (   ( $pad{I1613} = $pos or 1 ) &&
    
                 ## <constant>
                 ## pos: 18023 18026
                 ( ( substr( $s, $pos, 1 ) eq ';' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
     ||    ( ( $pos = $pad{I1613} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18033 18145
              (   ( $pad{I1614} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18033 18144
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => ${ $_[0]->[0] },
                name => ${ $_[0]->{qw(ident)} },
                ast => ${ $_[0]->{qw(rule)} }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1614} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token verbatim
*verbatim =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18207 18329
           (
      
             ## <group>
             ## pos: 18207 18212
              (   ( $pad{I1615} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18207 18211
               ( ( substr( $s, $pos, 2 ) eq '%{' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1615} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18212 18238
              (   ( $pad{I1616} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 18213 18236
                       do { while (
                        (   ( $pad{I1617} = $pos or 1 ) &&
                           ## <concat>
                           ## pos: 18215 18233
                           (
      
                             ## <group>
                             ## pos: 18215 18231
                              (   ( $pad{I1618} = $pos or 1 ) &&
                               ## <negate>
                               ## pos: 18216 18230
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 
                                         ## <before>
                                         ## pos: 18225 18229
                                         do{
                                             my $pos1 = $pos;
                                             do {
                                               my $pos = $pos1;
                                               my $from = $pos;
                                               my @match;
                                               my %named;
                                               $bool = 0 unless
    
                                                   ## <constant>
                                                   ## pos: 18225 18229
                                                   ( ( substr( $s, $pos, 2 ) eq '%}' )
                                                       ? ( $pos += 2 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
    ;
                                               $bool;
                                             };
                                         }
                                         ## </before>
     ? 0 : 1;
                                     $bool;
                                   };
                               }
                               ## </negate>
     ||    ( ( $pos = $pad{I1618} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 18231 18233
                              (   ( $pad{I1619} = $pos or 1 ) &&
    
                               ## <dot>
                               ## pos: 18231 18232
                               ( substr( $s, $pos++, 1 ) ne '' )
                               ## </dot>
     ||    ( ( $pos = $pad{I1619} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
     ||    ( ( $pos = $pad{I1617} ) && 0 ) )) {}; $bool = 1 }
                       ## </quant>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I1616} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18238 18247
              (   ( $pad{I1620} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18238 18242
               ( ( substr( $s, $pos, 2 ) eq '%}' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1620} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18247 18329
              (   ( $pad{I1621} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18247 18328
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => 'block',
                value => ${ $_[0]->[0] }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1621} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token item
*item =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 18349 18441
           (
               ( $pad{I1622} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 18350 18397
               (
      
                 ## <group>
                 ## pos: 18350 18368
                  (   ( $pad{I1623} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18351 18361
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'verbatim'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1623} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18368 18397
                  (   ( $pad{I1624} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18368 18392
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(verbatim)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1624} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1622} ) or 1 )
               &&            ## <concat>
               ## pos: 18398 18441
               (
      
                 ## <group>
                 ## pos: 18398 18413
                  (   ( $pad{I1625} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18399 18412
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_regex'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1625} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18413 18441
                  (   ( $pad{I1626} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18413 18440
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(named_regex)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1626} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token grammar
*grammar =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18464 18580
           (
             ## <quant>
             ## pos: 18464 18471
             (
              (   ( $pad{I1627} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18464 18469
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1627} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18471 18481
              (   ( $pad{I1628} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18471 18480
               ( ( substr( $s, $pos, 7 ) eq 'grammar' )
                   ? ( $pos += 7 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1628} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18481 18487
              (   ( $pad{I1629} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 18481 18486
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1629} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18487 18495
              (   ( $pad{I1630} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18487 18494
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1630} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18495 18502
             (
              (   ( $pad{I1631} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18495 18500
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1631} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18502 18510
              (   ( $pad{I1632} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18502 18505
               ( ( substr( $s, $pos, 1 ) eq ';' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1632} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18510 18521
             (
              (   ( $pad{I1633} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18510 18515
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1633} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18521 18544
             do { while (
              (   ( $pad{I1634} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 18522 18537
                 (
      
                   ## <group>
                   ## pos: 18522 18530
                    (   ( $pad{I1635} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 18523 18529
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->item( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'item'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1635} ) && 0 ) )
                   ## </group>
    
                 &&
                   ## <quant>
                   ## pos: 18530 18537
                   (
                    (   ( $pad{I1636} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 18530 18535
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1636} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1634} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18544 18580
              (   ( $pad{I1637} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18544 18579
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { ${ $_[0]->{qw(ident)} } => $_[0]->{qw(item)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1637} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token spec
*spec =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18600 18720
           (
             ## <quant>
             ## pos: 18600 18616
             (
              (   ( $pad{I1638} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18600 18610
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'verbatim'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1638} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18616 18631
             do { while (
              (   ( $pad{I1639} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18616 18625
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'grammar'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1639} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18631 18720
              (   ( $pad{I1640} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18631 18719
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                block => $_[0]->{qw(verbatim)},
                'grammar' => $_[0]->{qw(grammar)} }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1640} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;



1;
