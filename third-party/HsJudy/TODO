# NOW
- Some system to manage/collect StablePtrs, then Finalizers.
- Use Judy to implement Pugs IHash substitute. (First patch done, but it's old by now)
- CollectionsM: complete the subset of MapM and uncomment/complete CollectionM.

X Bug on HSIter stuff when use a lot of memory. (One of them is solved. Need to GC now.)
- Dummy/Refeable Bug: need to ask in #haskell and reply Simon's email.

- Add malloc error check for BitSet/Judy1 (it uses JERR not PJERR).
- Other missing malloc error checking

? Find something other than WordPtr (ghc 6.5) that works in GHC stable

- First RBR test: 1/3 running time when using MapL (via Map2). Not sure
if the results are correct (they seem to be).

# NEXT
- Data.HashTable
- http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all

- Refeable vs. HashIO => unify?
- Use ByteString (seems to be trivial with Stringable, just instantiate Stringable?)
- Better testing
- More test programs
- Discuss APIs
-- Implementations specific to unboxed values like Int and Double
-- Unbounded arrays: see Bulat work on this

- Document this work.
- Create a LICENSE file (I think BSD3) and put license info in the
  necessary files. Mention that John Meacham as original author (how?).


# THINGS TO CONSIDER

nice mail from Bulat:
http://www.haskell.org/pipermail/haskell-cafe/2006-May/015915.html

## API SUGGESTIONS

Bulat: "Judy implements _mutable_ array/map/set, so closest interfaces for your
lib will be MArray and HashTable. DiffArray is a general way to make IArray
(interface) on the base of MArray (interface), that is usable with any
datastructure implementing MArray interface"


## STABLEPTR POSSIBLE OVERHEAD

StablePtr is used to store references of Haskell objects in external
datastructures. Maybe GHC isn't very efficient dealing with a lot of
StablePtrs, if that's true three obvious ways are:
 - GHC 6.5/6 is better at this.
 - Turn GHC better at this (wow!).
 - Find another way to do it (without StablePtr).


## REEVALUATE BENEFITS?

> all Haskell software that uses common data structures like Maps and
> Arrays would benefit from a faster implementation

Bulat says "sorry, i don't think so. especially for Arrays ;)"

