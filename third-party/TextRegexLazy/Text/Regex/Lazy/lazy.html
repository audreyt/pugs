<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
  <head>
    <title>Text.Regex.Lazy</title>
  </head>
<body>
<h1><tt>Text.Regex.Lazy</tt></h1>
<h2>Version 0.33 (2006-03-18)</h2>

<h3>By Chris Kuklewicz (haskell (at) list (dot) mightyreason (dot) com)</h3>

See the LICENSE file for details on copyright.

This is a simple page to accompany the <tt>Text.Regex.Lazy</tt> library.

This is meant to be used in one of four ways:

<ul>
  <li> If you need to be compatible with <tt>Text.Regex</tt> then you
       can import <tt>Text.Regex.Lazy.Compat</tt> and report any
       infidelities as bugs.  Like <tt>Text.Regex</tt> this uses the
       longest-match rule.
  <li> You can use <tt>Text.Regex.Lazy.Full</tt> which uses a
       first-match rule and accepts lazy and possessive modifiers, and
       allows back references in the patterns.  More options will be
       added.  Also, <tt>Full</tt> handles NUL characters like normal
       characters whereas <tt>Compat</tt> cannot handle them at all.
  <li> For greedy patterns without the need for substring capture or
       anchors, you can use <tt>Text.Regex.Lazy.CompatDFA</tt> which
       is analogous to, but not a replacement for, the usual
       functions.  It uses <tt>Text.Regex.Lazy.DFAEngine</tt> to find
       the longest match without backtracking.
  <li> You can import <tt>Text.Regex.Lazy</tt>
       and <tt>Text.Regex.Lazy.DFAEngine</tt> or some other subset of
       included modules to allow for more customized semantics or
       usage.
</ul>

Some advantages of <tt>Text.Regex.Lazy.Compat</tt> over <tt>Text.Regex</tt>:

<ul>
  <li> It does not marshal to and from c-code arrays, so it is much
       faster on large input strings.
  <li> It consumes the input <tt>String</tt> in a mostly lazy manner.
       This makes streaming from input to output possible.
  <li> It performs sanity checks so that <tt>subRegex</tt>
       and <tt>splitRegex</tt> don't loop or go crazy if the pattern
       matches an empty string -- it will just return the input.
  <li> If the <tt>String</tt> regex does not parse then you get a nicer error
       message.
  <li> The laziest consumption of the input string is by
       the <tt>CompatDFA</tt> module.
</ul>

Internally these modules use <tt>Parsec</tt> to turn the string regex
into a <tt>Pattern</tt> data type, simplify the <tt>Pattern</tt>, then
transform the <tt>Pattern</tt> into a <tt>Parsec</tt> parser that
accepts matching strings and stores the sub-strings of parenthesized
groups.
<p>
For "dfaClean" patterns, the CompatDFA functions (and support in
DFAEngine) allow for faster matching.  This is really a heavily
modified lexer
from <a href="http://www.cse.unsw.edu.au/~chak/haskell/ctk/">CTK</a>.
<p>
A full list of the modules with a quick description:
<pre>
Text.Regex.Lazy.Compat : This is a replacement for Text.Regex
Text.Regex.Lazy.CompatParsec : Used by Compat to turn Pattern into Parsec
Text.Regex.Lazy.CompatReadRegex : Used by Compat to turn String into Pattern

Text.Regex.Lazy.CompatDFA : Alternative to Text.Regex for simple patterns, using a DFA
Text.Regex.Lazy.DFAEngine : DFA Evaluators Combinators and Pattern translation
Text.Regex.Lazy.DFAEngineFPS : A modified DFAEngine to search Data.FastPackedString

Text.Regex.Lazy : Re-exports Full,FullParsec,RegexParsecState,ReadRegex,Pattern
Text.Regex.Lazy.Full : This implements more complicated regular expressions
Text.Regex.Lazy.FullParsec : Used by Full to turn Pattern into Parsec
Text.Regex.Lazy.ReadRegex : Used by Full to turn String into Pattern
Test.Regex.Lazy.RegexParsecState : Used by CompatParsec and FullParsec to handle Parsec state

Test.Regex.Lazy.Common : Simple data types and type synonyms
Text.Regex.Lazy.Pattern : The algebraic data type of a parsed regular expression

Text.Regex.Lazy.TestCompat : Some HUnit tests for Compat (mostly from "Igloo" on #haskell)
Text.Regex.Lazy.TestFull : Some HUnit tests for Full (mostly from "Igloo" on #haskell)
</pre>

All of this was motivated by the inability to use <tt>Text.Regex</tt>
to complete
the <a
href="http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all">regex-dna
benchmark</a> on <a href="http://shootout.alioth.debian.org/">The
Computer Language Shootout</a>.  The current entry there, by Don
Stewart and Alson Kemp and Chris Kuklewicz, does not use this Parsec
solution, but rather a custom DFA lexer from the CTK library.
</body>
</HTML>
