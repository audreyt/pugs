My notes to myself as I read the 2005-08-04 IRC discussion of 
the MetaModel:

  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=356#l564

Clarification, corrections, and questions welcome.

    +--------------+
    |              |
    |   Instance   |
    |              |
    +--------------+
           |                       +--------------+
    +--------------+               |              |
    |              |               |     Role     |
    |    Class     |               |              |
    |              |               +--------------+
    +--------------+
           |
    +--------------+
    |              |
    |  MetaClass   |
    |              |
    +--------------+

Instance:

* holds an instance of the class it is created from
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=402#l646

* has attributes
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=362#l572

* holds instance data, which maps member names (in the MetaClass?) 
  to values (in the MetaClass instance?)
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=435#l695
  
Clarification:
  The instance has a map of names to instance-specific values. The information about
  the given attribute is stored in the metaclass (is private/public, accessor name, 
  attribute name, default value, etc.). The full list of names for a given instance
  are constructed by interogating the metaclass, then traversing the superclasses
  list of the metaclass in the BUILD order.
  
  The MetaClass only holds the information about each attribute, but not the actual
  attribute values. (Except for class attributes, but that is probably going to be 
  fixed soon.)

* $?CLASS and $?SELF are lexicals which are rebound at each method 
  execution
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=377#l607
  
Clarification:
  "pseudo-lexical/global" is probably a better word for it. They are not proper 
  lexical variables, but are more globals who only have bound values in certain
  contexts. For instance, inside a class definition scope and inside any method, 
  there is a value for $?CLASS. However, only inside methods does $?SELF have a 
  value bound to it.
  
  NOTE: In the p5 prototype there is no notion of "class defintion scope" this is
  just a limitation of the prototype implementation.  

* calling 'next METHOD' jumps to a label (called 'METHOD'?) by searching
  outside the method, back to the dispatcher, then to the resume loop
  (this is really fuzzy to me, the description more than the concept, I
  think)
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=379#l609
  
Clarifaction:
  The description above is how things work as described in AES12, however this 
  is just an implementation detail. Calling 'next METHOD' will simply take you 
  to the next most applicable method based on the calculated method resolution 
  order. If you are in a single inheritance heirarchy, calling 'next METHOD' is
  just like calling SUPER::. However under multiple inheritence, calling 'next METHOD'
  will find the next applicable method by using the C3 method resolution order, 
  which may or may not be a child of the current class, in fact is can easily be 
  a sibling. 

Class:

* is a singleton
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=835#l1333

Clarifaction:
  The Class (aka Perl6::Class) is not a singleton, but there is only one Perl6::Class
  instance for each named class. So there is only one class(Foo), but there are many
  instances of Class. Sorry for the ambiguity on IRC :)

* holds an instance of the MetaClass it is created from
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=480#l769

* has a 'bless' method which takes a candidate and returns an instance
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=405#l650
  
Clarifaction:
  `bless` is actually defined in Perl6::Object as a class method. The role of the
  `bless` method if very different in p6, it actually just calls the CREATE class
  method and the BUILDALL instance method on the given class.

* is a thin layer between the meta and user worlds
  (see also 10000 ft view)
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-05,Fri&sel=619#l1125

* is a mapping between Name and ID (in member fields)
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=475#l763
  
Clarifaction:
  This is part of the Haskell metamodel to implement Pseudo-hash type instance 
  attribute access.

* all questions asked of a class are passed to its metaclass
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=628#l1023

MetaClass:

* is a singleton
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=835#l1333
  
Clarifaction:
  This is the same as with Class. There is a Perl6::MetaClass, but that has many
  instances, each of which is associated with a class instance, which is associated
  with many instance instances.

* has attribute definitions
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=364#l575

* has _add_method to add methods (all instances magically have the new
  method available to them)
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=507#l818
  
Clarifaction:
  Actually the method is 'add_method', the '_add_method' is the system primative which
  needs to be defined so that MetaClass can add the 'add_method' to it's method table.
  Of course 'add_method' is just a reference to '_add_method'.
  
  That help clarify things? ;)
  
  This is part of the bootstrapping, in which MetaClass is defined as an instance of
  MetaClass. The bootstrapping can be quick a head trip :)

* private attributes can only be accessed from methods defined in the same
  class as the private attribute
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=585#l938

* examples: Perl6::Instance (which defines the UNIVERSAL:: methods 'isa',
  'can', and 'AUTOLOAD')
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=653#l1067
  http://colabti.de/irclogger/irclogger_log/perl6?date=2005-08-04,Thu&sel=655#l1072
  
Correction:
  Perl6::Instance is not a MetaClass. It is only a bit of p5 magic. If I bless all
  the instances with Perl6::Instance, then I automatically get p5 dispatching (isa, can
  and AUTOLOAD). Otherwise I have to manually dispatch all methods. 
  
  This part is probably best not addressed, it is part of the p5 syntactic sugar, and 
  not the real metamodel.
  

Role:

Hmm. Nothing to see here.
