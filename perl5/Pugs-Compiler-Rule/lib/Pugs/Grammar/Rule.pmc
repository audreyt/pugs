# !!! DO NOT EDIT !!!
# This file was generated by Pugs::Compiler::Rule's compile_p6grammar.pl
# script from examples/Grammar.grammar at Tue Jul 22 16:53:23 2008

use strict;
use warnings;

package Pugs::Grammar::Rule;

#use base 'Pugs::Grammar::Base';

use Pugs::Runtime::Match;
use Pugs::Runtime::Regex;
use Pugs::Runtime::Tracer ();

# Code block from grammar spec


use utf8;
no strict 'refs';
no warnings 'redefine';
no warnings 'once';

#use Pugs::Runtime::Match;

our %rule_terms;
our %variables;



# token pod_begin
*pod_begin =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 632 675
           (
               ( $pad{I1533} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 633 652
               (
      
                 ## <group>
                 ## pos: 633 639
                  (   ( $pad{I1534} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1534} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 639 640
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 640 641
                 ( ( substr( $s, $pos, 1 ) eq 'e' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 641 642
                 ( ( substr( $s, $pos, 1 ) eq 'n' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 642 644
                  (   ( $pad{I1535} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 642 643
                   ( ( substr( $s, $pos, 1 ) eq 'd' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1535} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 644 652
                 do { while (
                  (   ( $pad{I1536} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1536} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1533} ) or 1 )
               &&            ## <concat>
               ## pos: 653 675
               (
      
                 ## <group>
                 ## pos: 653 658
                  (   ( $pad{I1537} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 656 657
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1537} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 658 662
                 do { while (
                  (   ( $pad{I1538} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1538} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 662 675
                  (   ( $pad{I1539} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 662 674
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1539} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token pod_other
*pod_other =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 700 743
           (
               ( $pad{I1540} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 701 720
               (
      
                 ## <group>
                 ## pos: 701 707
                  (   ( $pad{I1541} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1541} ) && 0 ) )
                 ## </group>
    
               &&
    
                 ## <constant>
                 ## pos: 707 708
                 ( ( substr( $s, $pos, 1 ) eq '=' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 708 709
                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
    
                 ## <constant>
                 ## pos: 709 710
                 ( ( substr( $s, $pos, 1 ) eq 'u' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
    
               &&
      
                 ## <group>
                 ## pos: 710 712
                  (   ( $pad{I1542} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 710 711
                   ( ( substr( $s, $pos, 1 ) eq 't' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1542} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 712 720
                 do { while (
                  (   ( $pad{I1543} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1543} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1540} ) or 1 )
               &&            ## <concat>
               ## pos: 721 743
               (
      
                 ## <group>
                 ## pos: 721 726
                  (   ( $pad{I1544} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 724 725
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1544} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 726 730
                 do { while (
                  (   ( $pad{I1545} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1545} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 730 743
                  (   ( $pad{I1546} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 730 742
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1546} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ws
*ws =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 761 1059
           (
            (   ( $pad{I1547} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1548} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1549} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1549} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1550} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1550} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1551} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1551} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1552} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1553} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1553} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1554} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1555} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1556} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1556} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1557} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1557} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1558} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1558} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1559} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1559} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1560} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1560} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1561} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1561} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1562} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1562} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1563} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1563} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1564} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1564} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1565} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1565} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1566} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1567} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1567} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1568} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1568} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1569} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1569} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1570} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1571} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1572} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1572} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1573} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1573} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1574} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1574} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1575} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1575} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1576} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1576} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1554} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1552} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1577} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1577} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1547} ) && 0 ) )
           && do { while (
            (   ( $pad{I1547} = $pos or 1 ) &&
               ## <alt>
               ## pos: 762 1056
               (
                   ( $pad{I1548} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 768 783
                   (
      
                     ## <group>
                     ## pos: 768 775
                      (   ( $pad{I1549} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 772 774
                       ( ( substr( $s, $pos, 1 ) eq '#' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1549} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 775 783
                     do { while (
                      (   ( $pad{I1550} = $pos or 1 ) &&
                         ## <perl5>
                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                             ? ( $pos += length( $1 ) or 1 )
                             : 0
                         )
                         ## </perl5>
     ||    ( ( $pos = $pad{I1550} ) && 0 ) )) {}; $bool = 1 }
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
                   &&                ## <concat>
                   ## pos: 784 1044
                   (
      
                     ## <group>
                     ## pos: 784 791
                      (   ( $pad{I1551} = $pos or 1 ) &&
                       ## <perl5>
                       ( ( substr( $s, $pos ) =~ m/^((?:\n\r?|\r\n?))/ )
                           ? ( $pos += length( $1 ) or 1 )
                           : 0
                       )
                       ## </perl5>
     ||    ( ( $pos = $pad{I1551} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 791 1044
                     (
                      (   ( $pad{I1552} = $pos or 1 ) &&
                         ## <concat>
                         ## pos: 792 1037
                         (
      
                           ## <group>
                           ## pos: 792 795
                            (   ( $pad{I1553} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 793 794
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1553} ) && 0 ) )
                           ## </group>
    
                         &&
                           ## <quant>
                           ## pos: 795 1037
                           (
                            (   ( $pad{I1554} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 796 1022
                               (
                                   ( $pad{I1555} = $pos or 1 )
                                   && (
                                   ## <concat>
                                   ## pos: 810 847
                                   (
      
                                     ## <group>
                                     ## pos: 810 813
                                      (   ( $pad{I1556} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 812 813
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1556} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 813 814
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 814 815
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 815 816
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 816 818
                                      (   ( $pad{I1557} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 816 817
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1557} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 818 824
                                      (   ( $pad{I1558} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 818 823
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1558} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 824 825
                                     ( ( substr( $s, $pos, 1 ) eq 'E' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 825 826
                                     ( ( substr( $s, $pos, 1 ) eq 'N' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 826 828
                                      (   ( $pad{I1559} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 826 827
                                       ( ( substr( $s, $pos, 1 ) eq 'D' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1559} ) && 0 ) )
                                     ## </group>
    
                                   &&
                                     ## <quant>
                                     ## pos: 828 832
                                     do { while (
                                      (   ( $pad{I1560} = $pos or 1 ) &&
                                         ## <perl5>
                                         ( ( substr( $s, $pos ) =~ m/^((?!\n\r?|\r\n?).)/ )
                                             ? ( $pos += length( $1 ) or 1 )
                                             : 0
                                         )
                                         ## </perl5>
     ||    ( ( $pos = $pad{I1560} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   &&
                                     ## <quant>
                                     ## pos: 832 847
                                     do { while (
                                      (   ( $pad{I1561} = $pos or 1 ) &&
    
                                         ## <dot>
                                         ## pos: 832 833
                                         ( substr( $s, $pos++, 1 ) ne '' )
                                         ## </dot>
     ||    ( ( $pos = $pad{I1561} ) && 0 ) )) {}; $bool = 1 }
                                     ## </quant>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 848 882
                                   (
      
                                     ## <group>
                                     ## pos: 848 851
                                      (   ( $pad{I1562} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 850 851
                                       ( ( substr( $s, $pos, 1 ) eq 'b' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1562} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 851 852
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 852 853
                                     ( ( substr( $s, $pos, 1 ) eq 'g' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 853 854
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 854 857
                                      (   ( $pad{I1563} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 854 855
                                       ( ( substr( $s, $pos, 1 ) eq 'n' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1563} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 857 882
                                      (   ( $pad{I1564} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 857 869
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_begin( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1564} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 883 917
                                   (
      
                                     ## <group>
                                     ## pos: 883 886
                                      (   ( $pad{I1565} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 885 886
                                       ( ( substr( $s, $pos, 1 ) eq 'k' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1565} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 886 887
                                     ( ( substr( $s, $pos, 1 ) eq 'w' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 887 888
                                     ( ( substr( $s, $pos, 1 ) eq 'i' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 888 892
                                      (   ( $pad{I1566} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 888 889
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1566} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 892 917
                                      (   ( $pad{I1567} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 892 904
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1567} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 918 952
                                   (
      
                                     ## <group>
                                     ## pos: 918 921
                                      (   ( $pad{I1568} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 920 921
                                       ( ( substr( $s, $pos, 1 ) eq 'p' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1568} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 921 922
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 922 927
                                      (   ( $pad{I1569} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 922 923
                                       ( ( substr( $s, $pos, 1 ) eq 'd' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1569} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 927 952
                                      (   ( $pad{I1570} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 927 939
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1570} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 953 987
                                   (
      
                                     ## <group>
                                     ## pos: 953 956
                                      (   ( $pad{I1571} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 955 956
                                       ( ( substr( $s, $pos, 1 ) eq 'f' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1571} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 956 957
                                     ( ( substr( $s, $pos, 1 ) eq 'o' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 957 962
                                      (   ( $pad{I1572} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 957 958
                                       ( ( substr( $s, $pos, 1 ) eq 'r' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1572} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 962 987
                                      (   ( $pad{I1573} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 962 974
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1573} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1555} ) or 1 )
                                   &&                                ## <concat>
                                   ## pos: 988 1022
                                   (
      
                                     ## <group>
                                     ## pos: 988 991
                                      (   ( $pad{I1574} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 990 991
                                       ( ( substr( $s, $pos, 1 ) eq 'h' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1574} ) && 0 ) )
                                     ## </group>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 991 992
                                     ( ( substr( $s, $pos, 1 ) eq 'e' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 992 993
                                     ( ( substr( $s, $pos, 1 ) eq 'a' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
    
                                     ## <constant>
                                     ## pos: 993 994
                                     ( ( substr( $s, $pos, 1 ) eq 'd' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 994 997
                                      (   ( $pad{I1575} = $pos or 1 ) &&
    
                                       ## <constant>
                                       ## pos: 994 995
                                       ( ( substr( $s, $pos, 1 ) eq '1' )
                                           ? ( $pos += 1 or 1 )
                                           : 0
                                       )
                                       ## </constant>
     ||    ( ( $pos = $pad{I1575} ) && 0 ) )
                                     ## </group>
    
                                   &&
      
                                     ## <group>
                                     ## pos: 997 1022
                                      (   ( $pad{I1576} = $pos or 1 ) &&
                                       ## <metasyntax>
                                       ## pos: 997 1009
                                       do {
                                            my $prior = $::_V6_PRIOR_;
                                            my $match =
                                                   $grammar->pod_other( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                            $::_V6_PRIOR_ = $prior;
                                            my $bool = (!$match != 1);
                                            $pos = $match->to if $bool;
                                            $match;
                                       }
                                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1576} ) && 0 ) )
                                     ## </group>
    
                                   )
                                   ## </concat>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1554} ) && 0 ) )
                           || ( $bool = 1 )
                           )
                           ## </quant>
    
                         )
                         ## </concat>
     ||    ( ( $pos = $pad{I1552} ) && 0 ) )
                     || ( $bool = 1 )
                     )
                     ## </quant>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1548} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1045 1056
                    (   ( $pad{I1577} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1577} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1547} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token ident
*ident =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 1118 1143
           (
            (   ( $pad{I1578} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I1579} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I1580} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1580} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1579} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I1581} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1581} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1579} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I1582} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1582} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1578} ) && 0 ) )
           && do { while (
            (   ( $pad{I1578} = $pos or 1 ) &&
               ## <alt>
               ## pos: 1119 1140
               (
                   ( $pad{I1579} = $pos or 1 )
                   && (
      
                   ## <group>
                   ## pos: 1119 1129
                    (   ( $pad{I1580} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 1120 1128
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1580} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1579} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1130 1133
                    (   ( $pad{I1581} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1131 1132
                     ( ( substr( $s, $pos, 1 ) eq '_' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1581} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1579} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 1134 1140
                    (   ( $pad{I1582} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 1135 1139
                     ( ( substr( $s, $pos, 2 ) eq '::' )
                         ? ( $pos += 2 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1582} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1578} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alnum
*alnum =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1164 1178
            (   ( $pad{I1583} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1583} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token alpha
*alpha =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1199 1210
            (   ( $pad{I1584} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[a-zA-Z]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1584} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token digit
*digit =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 1231 1239
            (   ( $pad{I1585} = $pos or 1 ) &&
             ## <perl5>
             ( ( substr( $s, $pos ) =~ m/^((?:(?=[0-9]))\X)/ )
                 ? ( $pos += length( $1 ) or 1 )
                 : 0
             )
             ## </perl5>
     ||    ( ( $pos = $pad{I1585} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token special_char
*special_char =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 1284 2177
           (
               ( $pad{I1586} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 1285 1473
               (
      
                 ## <group>
                 ## pos: 1285 1296
                  (   ( $pad{I1587} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1287 1294
                           (
                               ( $pad{I1588} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1287 1290
                                (   ( $pad{I1589} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1288 1289
                                 ( ( substr( $s, $pos, 1 ) eq 'c' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1589} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1588} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1291 1294
                                (   ( $pad{I1590} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1292 1293
                                 ( ( substr( $s, $pos, 1 ) eq 'C' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1590} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1587} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1296 1299
                  (   ( $pad{I1591} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1296 1298
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1591} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1299 1340
                  (   ( $pad{I1592} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1300 1338
                           (
                            (   ( $pad{I1593} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I1594} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I1595} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1595} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I1596} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1596} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I1597} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1597} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I1598} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1598} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1593} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1593} = $pos or 1 ) &&
                               ## <alt>
                               ## pos: 1302 1336
                               (
                                   ( $pad{I1594} = $pos or 1 )
                                   && (
                                   ## <named_capture>
                                   ## pos: 1302 1309
                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                               $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'alnum'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                   ## </named_capture>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&                                ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^(\s)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1313 1318
                                    (   ( $pad{I1595} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1314 1317
                                     ( ( substr( $s, $pos, 1 ) eq ';' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1595} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1319 1324
                                    (   ( $pad{I1596} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1320 1323
                                     ( ( substr( $s, $pos, 1 ) eq '(' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1596} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1325 1330
                                    (   ( $pad{I1597} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1326 1329
                                     ( ( substr( $s, $pos, 1 ) eq ')' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1597} ) && 0 ) )
                                   ## </group>
    
                                   )
                                 || (
                                   ( ( $bool = 1 ) && ( $pos = $pad{I1594} ) or 1 )
                                   &&   
                                   ## <group>
                                   ## pos: 1331 1336
                                    (   ( $pad{I1598} = $pos or 1 ) &&
    
                                     ## <constant>
                                     ## pos: 1332 1335
                                     ( ( substr( $s, $pos, 1 ) eq '-' )
                                         ? ( $pos += 1 or 1 )
                                         : 0
                                     )
                                     ## </constant>
     ||    ( ( $pos = $pad{I1598} ) && 0 ) )
                                   ## </group>
    
                                 )
                               )
                               ## </alt>
     ||    ( ( $pos = $pad{I1593} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1592} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1340 1385
                  (   ( $pad{I1599} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1340 1342
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1599} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1385 1473
                  (   ( $pad{I1600} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1385 1463
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1600} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&            ## <concat>
               ## pos: 1474 1617
               (
      
                 ## <group>
                 ## pos: 1474 1485
                  (   ( $pad{I1601} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1476 1483
                   (
                       ( $pad{I1602} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1476 1479
                        (   ( $pad{I1603} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1477 1478
                         ( ( substr( $s, $pos, 1 ) eq 'x' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1603} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1602} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1480 1483
                        (   ( $pad{I1604} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1481 1482
                         ( ( substr( $s, $pos, 1 ) eq 'X' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1604} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1601} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1485 1535
                 (
                  (   ( $pad{I1605} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1605} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1605} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 1485 1493
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1605} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1535 1617
                  (   ( $pad{I1606} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1535 1608
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1606} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&            ## <concat>
               ## pos: 1618 1777
               (
      
                 ## <group>
                 ## pos: 1618 1629
                  (   ( $pad{I1607} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1620 1627
                           (
                               ( $pad{I1608} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1620 1623
                                (   ( $pad{I1609} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1621 1622
                                 ( ( substr( $s, $pos, 1 ) eq 'x' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1609} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1608} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1624 1627
                                (   ( $pad{I1610} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1625 1626
                                 ( ( substr( $s, $pos, 1 ) eq 'X' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1610} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1607} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1629 1632
                  (   ( $pad{I1611} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1629 1631
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1611} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1632 1644
                  (   ( $pad{I1612} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1633 1642
                           (
                            (   ( $pad{I1613} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1613} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1613} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 1633 1641
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->xdigit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'xdigit'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1613} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1612} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1644 1689
                  (   ( $pad{I1614} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1644 1646
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1614} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1689 1777
                  (   ( $pad{I1615} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1689 1767
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1615} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&            ## <concat>
               ## pos: 1778 1915
               (
      
                 ## <group>
                 ## pos: 1778 1789
                  (   ( $pad{I1616} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 1780 1787
                   (
                       ( $pad{I1617} = $pos or 1 )
                       && (
      
                       ## <group>
                       ## pos: 1780 1783
                        (   ( $pad{I1618} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1781 1782
                         ( ( substr( $s, $pos, 1 ) eq 'o' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1618} ) && 0 ) )
                       ## </group>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1617} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 1784 1787
                        (   ( $pad{I1619} = $pos or 1 ) &&
    
                         ## <constant>
                         ## pos: 1785 1786
                         ( ( substr( $s, $pos, 1 ) eq 'O' )
                             ? ( $pos += 1 or 1 )
                             : 0
                         )
                         ## </constant>
     ||    ( ( $pos = $pad{I1619} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1616} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 1789 1833
                 (
                  (   ( $pad{I1620} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1620} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1620} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1620} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 1833 1915
                  (   ( $pad{I1621} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1833 1906
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1621} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&            ## <concat>
               ## pos: 1916 2069
               (
      
                 ## <group>
                 ## pos: 1916 1927
                  (   ( $pad{I1622} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <alt>
                           ## pos: 1918 1925
                           (
                               ( $pad{I1623} = $pos or 1 )
                               && (
      
                               ## <group>
                               ## pos: 1918 1921
                                (   ( $pad{I1624} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1919 1920
                                 ( ( substr( $s, $pos, 1 ) eq 'o' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1624} ) && 0 ) )
                               ## </group>
    
                               )
                             || (
                               ( ( $bool = 1 ) && ( $pos = $pad{I1623} ) or 1 )
                               &&   
                               ## <group>
                               ## pos: 1922 1925
                                (   ( $pad{I1625} = $pos or 1 ) &&
    
                                 ## <constant>
                                 ## pos: 1923 1924
                                 ( ( substr( $s, $pos, 1 ) eq 'O' )
                                     ? ( $pos += 1 or 1 )
                                     : 0
                                 )
                                 ## </constant>
     ||    ( ( $pos = $pad{I1625} ) && 0 ) )
                               ## </group>
    
                             )
                           )
                           ## </alt>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1622} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1927 1930
                  (   ( $pad{I1626} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1927 1929
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1626} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1930 1936
                  (   ( $pad{I1627} = $pos or 1 ) &&
    
                   ## <capture>
                   do{
                       my $hash = do {
                         my $bool = 1;
                         my $from = $pos;
                         my @match;
                         my %named;
                         $bool = 0 unless
                           ## <quant>
                           ## pos: 1931 1934
                           (
                            (   ( $pad{I1628} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I1628} ) && 0 ) )
                           && do { while (
                            (   ( $pad{I1628} = $pos or 1 ) &&
                               ## <perl5>
                               ( ( substr( $s, $pos ) =~ m/^(\d)/ )
                                   ? ( $pos += length( $1 ) or 1 )
                                   : 0
                               )
                               ## </perl5>
     ||    ( ( $pos = $pad{I1628} ) && 0 ) )) {}; $bool = 1 }
                           )
                           ## </quant>
    ;
                         { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                       };
                       my $bool = ${$hash->{'bool'}};
                       $match[ 1 ] = Pugs::Runtime::Match->new( $hash );
                       $bool;
                   }
                   ## </capture>
     ||    ( ( $pos = $pad{I1627} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1936 1981
                  (   ( $pad{I1629} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 1936 1938
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1629} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 1981 2069
                  (   ( $pad{I1630} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 1981 2059
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0]->[0] . $_[0]->[1], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1630} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1586} ) or 1 )
               &&            ## <concat>
               ## pos: 2070 2177
               (
      
                 ## <group>
                 ## pos: 2070 2103
                  (   ( $pad{I1631} = $pos or 1 ) &&
    
                   ## <dot>
                   ## pos: 2071 2072
                   ( substr( $s, $pos++, 1 ) ne '' )
                   ## </dot>
     ||    ( ( $pos = $pad{I1631} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2103 2177
                  (   ( $pad{I1632} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 2103 2176
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { special_char => '\\' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1632} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token literal
*literal =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2200 2251
           do { while (
            (   ( $pad{I1633} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2201 2248
               (
                   ( $pad{I1634} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2207 2231
                   (
      
                     ## <group>
                     ## pos: 2207 2212
                      (   ( $pad{I1635} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2209 2211
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1635} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2212 2231
                      (   ( $pad{I1636} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2212 2226
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1636} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1634} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2232 2248
                    (   ( $pad{I1637} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\']))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1637} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1633} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token double_quoted
*double_quoted =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2280 2372
           do { while (
            (   ( $pad{I1638} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2281 2369
               (
                   ( $pad{I1639} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2287 2311
                   (
      
                     ## <group>
                     ## pos: 2287 2292
                      (   ( $pad{I1640} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2289 2291
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1640} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2292 2311
                      (   ( $pad{I1641} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2292 2306
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1641} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1639} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2312 2352
                    (   ( $pad{I1642} = $pos or 1 ) &&
                    ## <metasyntax>
                     ## pos: 2314 2347
                     do{
                    my $match = 
              ## <variable>
              ## pos: 2314 2347
              do {
                our $I1643;
                our $I1643_sizes;
                unless ( $I1643 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1643_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1643 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1643_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1643->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1643, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                    ## </metasyntax>
     ||    ( ( $pos = $pad{I1642} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1639} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2353 2369
                    (   ( $pad{I1644} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\"]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1644} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1638} ) && 0 ) )) {}; $bool = 1 }
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token metasyntax
*metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2398 2576
           (
            (   ( $pad{I1645} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I1646} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I1647} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1647} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I1648} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1648} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I1649} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1649} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I1650} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1650} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I1651} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1651} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I1652} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1652} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I1653} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1653} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I1654} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1654} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I1655} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1655} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I1656} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1656} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I1657} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1657} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I1658} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1658} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I1659} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1659} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I1660} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1660} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I1661} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1661} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1645} ) && 0 ) )
           && do { while (
            (   ( $pad{I1645} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2399 2573
               (
                   ( $pad{I1646} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2405 2429
                   (
      
                     ## <group>
                     ## pos: 2405 2410
                      (   ( $pad{I1647} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2407 2409
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1647} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2410 2429
                      (   ( $pad{I1648} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2410 2424
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1648} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2430 2458
                   (
      
                     ## <group>
                     ## pos: 2430 2436
                      (   ( $pad{I1649} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2432 2434
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1649} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2436 2451
                      (   ( $pad{I1650} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2436 2446
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1650} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2451 2458
                      (   ( $pad{I1651} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2451 2453
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1651} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2459 2491
                   (
      
                     ## <group>
                     ## pos: 2459 2465
                      (   ( $pad{I1652} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2461 2463
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1652} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2465 2484
                      (   ( $pad{I1653} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2465 2481
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1653} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2484 2491
                      (   ( $pad{I1654} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2484 2486
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1654} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2492 2527
                   (
      
                     ## <group>
                     ## pos: 2492 2498
                      (   ( $pad{I1655} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2494 2496
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1655} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2498 2520
                      (   ( $pad{I1656} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2498 2512
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1656} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2520 2527
                      (   ( $pad{I1657} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2520 2522
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1657} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2528 2556
                   (
      
                     ## <group>
                     ## pos: 2528 2534
                      (   ( $pad{I1658} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2530 2532
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1658} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2534 2549
                      (   ( $pad{I1659} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2534 2547
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1659} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2549 2556
                      (   ( $pad{I1660} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2549 2551
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1660} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1646} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2557 2573
                    (   ( $pad{I1661} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1661} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1645} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_range
*char_range =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2602 2653
           (
            (   ( $pad{I1662} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I1663} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I1664} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1664} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I1665} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1665} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1663} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I1666} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1666} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1662} ) && 0 ) )
           && do { while (
            (   ( $pad{I1662} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2603 2650
               (
                   ( $pad{I1663} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2609 2633
                   (
      
                     ## <group>
                     ## pos: 2609 2614
                      (   ( $pad{I1664} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2611 2613
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1664} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2614 2633
                      (   ( $pad{I1665} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2614 2628
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1665} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1663} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 2634 2650
                    (   ( $pad{I1666} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\]]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1666} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1662} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token char_class
*char_class =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 2679 2739
           (
               ( $pad{I1667} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 2680 2714
               (
      
                 ## <group>
                 ## pos: 2680 2691
                  (   ( $pad{I1668} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2682 2690
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->alpha( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1668} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 2691 2714
                 do { while (
                  (   ( $pad{I1669} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 2692 2706
                     (
                         ( $pad{I1670} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 2692 2702
                          (   ( $pad{I1671} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 2693 2701
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1671} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1670} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 2703 2706
                          (   ( $pad{I1672} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 2704 2705
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1672} ) && 0 ) )
                         ## </group>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1669} ) && 0 ) )) {}; $bool = 1 }
                 ## </quant>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1667} ) or 1 )
               &&            ## <concat>
               ## pos: 2715 2739
               (
      
                 ## <group>
                 ## pos: 2715 2721
                  (   ( $pad{I1673} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2717 2719
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1673} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2721 2736
                  (   ( $pad{I1674} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 2721 2734
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1674} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 2736 2739
                  (   ( $pad{I1675} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 2736 2738
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1675} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token string_code
*string_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <quant>
           ## pos: 2789 3073
           (
            (   ( $pad{I1676} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2790 3070
               (
                   ( $pad{I1677} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2796 2820
                   (
      
                     ## <group>
                     ## pos: 2796 2801
                      (   ( $pad{I1678} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2798 2800
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1678} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2801 2820
                      (   ( $pad{I1679} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2801 2815
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1679} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2821 2849
                   (
      
                     ## <group>
                     ## pos: 2821 2827
                      (   ( $pad{I1680} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2823 2825
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1680} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2827 2842
                      (   ( $pad{I1681} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2827 2837
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1681} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2842 2849
                      (   ( $pad{I1682} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2842 2844
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1682} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2850 2882
                   (
      
                     ## <group>
                     ## pos: 2850 2856
                      (   ( $pad{I1683} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2852 2854
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1683} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2856 2875
                      (   ( $pad{I1684} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2856 2872
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1684} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2875 2882
                      (   ( $pad{I1685} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2875 2877
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1685} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2883 2921
                   (
      
                     ## <group>
                     ## pos: 2883 2889
                      (   ( $pad{I1686} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2885 2887
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1686} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2889 2914
                      (   ( $pad{I1687} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2890 2911
                       (
                           ( $pad{I1688} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2890 2906
                            (   ( $pad{I1689} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2891 2905
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1689} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1688} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2907 2911
                            (   ( $pad{I1690} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1690} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1687} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2914 2921
                      (   ( $pad{I1691} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2914 2916
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1691} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2922 2960
                   (
      
                     ## <group>
                     ## pos: 2922 2928
                      (   ( $pad{I1692} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2924 2926
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1692} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2928 2953
                      (   ( $pad{I1693} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2929 2950
                       (
                           ( $pad{I1694} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2929 2945
                            (   ( $pad{I1695} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2930 2944
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1695} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2946 2950
                            (   ( $pad{I1696} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1696} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1693} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2953 2960
                      (   ( $pad{I1697} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2953 2955
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1697} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2961 2999
                   (
      
                     ## <group>
                     ## pos: 2961 2967
                      (   ( $pad{I1698} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2963 2965
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1698} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2967 2992
                      (   ( $pad{I1699} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2968 2989
                       (
                           ( $pad{I1700} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2968 2984
                            (   ( $pad{I1701} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2969 2983
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1701} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1700} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2985 2989
                            (   ( $pad{I1702} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1702} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1699} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2992 2999
                      (   ( $pad{I1703} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2992 2994
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1703} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 3000 3034
                   (
      
                     ## <group>
                     ## pos: 3000 3027
                      (   ( $pad{I1704} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 3003 3025
                       (
                           ( $pad{I1705} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3003 3010
                            (   ( $pad{I1706} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 3004 3009
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1706} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3011 3015
                            (   ( $pad{I1707} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3012 3014
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1707} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3016 3020
                            (   ( $pad{I1708} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3017 3019
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1708} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3021 3025
                            (   ( $pad{I1709} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3022 3024
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1709} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1704} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3027 3034
                      (   ( $pad{I1710} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3027 3029
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1710} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3035 3047
                    (   ( $pad{I1711} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3037 3042
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1711} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3048 3070
                    (   ( $pad{I1712} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1712} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1676} ) && 0 ) )
           && do { while (
            (   ( $pad{I1676} = $pos or 1 ) &&
               ## <alt>
               ## pos: 2790 3070
               (
                   ( $pad{I1677} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 2796 2820
                   (
      
                     ## <group>
                     ## pos: 2796 2801
                      (   ( $pad{I1678} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2798 2800
                       ( ( substr( $s, $pos, 1 ) eq '\\' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1678} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2801 2820
                      (   ( $pad{I1679} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 2801 2815
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1679} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2821 2849
                   (
      
                     ## <group>
                     ## pos: 2821 2827
                      (   ( $pad{I1680} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2823 2825
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1680} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2827 2842
                      (   ( $pad{I1681} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2827 2837
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1681} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2842 2849
                      (   ( $pad{I1682} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2842 2844
                       ( ( substr( $s, $pos, 1 ) eq chr(39) )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1682} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2850 2882
                   (
      
                     ## <group>
                     ## pos: 2850 2856
                      (   ( $pad{I1683} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2852 2854
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1683} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2856 2875
                      (   ( $pad{I1684} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 2856 2872
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->double_quoted( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1684} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2875 2882
                      (   ( $pad{I1685} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2875 2877
                       ( ( substr( $s, $pos, 1 ) eq '"' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1685} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2883 2921
                   (
      
                     ## <group>
                     ## pos: 2883 2889
                      (   ( $pad{I1686} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2885 2887
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1686} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2889 2914
                      (   ( $pad{I1687} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2890 2911
                       (
                           ( $pad{I1688} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2890 2906
                            (   ( $pad{I1689} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2891 2905
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1689} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1688} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2907 2911
                            (   ( $pad{I1690} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1690} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1687} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2914 2921
                      (   ( $pad{I1691} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2914 2916
                       ( ( substr( $s, $pos, 1 ) eq '}' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1691} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2922 2960
                   (
      
                     ## <group>
                     ## pos: 2922 2928
                      (   ( $pad{I1692} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2924 2926
                       ( ( substr( $s, $pos, 1 ) eq '(' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1692} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2928 2953
                      (   ( $pad{I1693} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2929 2950
                       (
                           ( $pad{I1694} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2929 2945
                            (   ( $pad{I1695} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2930 2944
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1695} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1694} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2946 2950
                            (   ( $pad{I1696} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1696} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1693} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2953 2960
                      (   ( $pad{I1697} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2953 2955
                       ( ( substr( $s, $pos, 1 ) eq ')' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1697} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 2961 2999
                   (
      
                     ## <group>
                     ## pos: 2961 2967
                      (   ( $pad{I1698} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2963 2965
                       ( ( substr( $s, $pos, 1 ) eq '<' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1698} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2967 2992
                      (   ( $pad{I1699} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 2968 2989
                       (
                           ( $pad{I1700} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 2968 2984
                            (   ( $pad{I1701} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 2969 2983
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1701} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1700} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 2985 2989
                            (   ( $pad{I1702} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1702} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1699} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 2992 2999
                      (   ( $pad{I1703} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 2992 2994
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1703} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&                ## <concat>
                   ## pos: 3000 3034
                   (
      
                     ## <group>
                     ## pos: 3000 3027
                      (   ( $pad{I1704} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 3003 3025
                       (
                           ( $pad{I1705} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3003 3010
                            (   ( $pad{I1706} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 3004 3009
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1706} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3011 3015
                            (   ( $pad{I1707} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3012 3014
                             ( ( substr( $s, $pos, 1 ) eq '>' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1707} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3016 3020
                            (   ( $pad{I1708} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3017 3019
                             ( ( substr( $s, $pos, 1 ) eq '=' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1708} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1705} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3021 3025
                            (   ( $pad{I1709} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3022 3024
                             ( ( substr( $s, $pos, 1 ) eq '-' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1709} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1704} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3027 3034
                      (   ( $pad{I1710} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3027 3029
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1710} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3035 3047
                    (   ( $pad{I1711} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 3037 3042
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1711} ) && 0 ) )
                   ## </group>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1677} ) or 1 )
                   &&   
                   ## <group>
                   ## pos: 3048 3070
                    (   ( $pad{I1712} = $pos or 1 ) &&
                     ## <perl5>
                     ( ( substr( $s, $pos ) =~ m/^((?:(?![\}\)\>]))\X)/ )
                         ? ( $pos += length( $1 ) or 1 )
                         : 0
                     )
                     ## </perl5>
     ||    ( ( $pos = $pad{I1712} ) && 0 ) )
                   ## </group>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1676} ) && 0 ) )) {}; $bool = 1 }
           )
           ## </quant>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parsed_code
*parsed_code =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3159 3205
           (
      
             ## <group>
             ## pos: 3159 3178
              (   ( $pad{I1713} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 3159 3173
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->string_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1713} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3178 3205
              (   ( $pad{I1714} = $pos or 1 ) &&
               ## <closure>
               ## pos: 3178 3204
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return '{' . $_[0] . '}'; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1714} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_capture_body
*named_capture_body =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 3239 3730
           (
               ( $pad{I1715} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 3240 3372
               (
      
                 ## <group>
                 ## pos: 3240 3245
                  (   ( $pad{I1716} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3241 3243
                   ( ( substr( $s, $pos, 1 ) eq '(' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1716} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3245 3259
                  (   ( $pad{I1717} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3245 3251
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1717} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3259 3263
                  (   ( $pad{I1718} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3259 3261
                   ( ( substr( $s, $pos, 1 ) eq ')' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1718} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3263 3372
                  (   ( $pad{I1719} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3263 3367
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                                  _pos => [ $_[0]->from, $_[0]->to ], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1719} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 )
               &&            ## <concat>
               ## pos: 3373 3420
               (
      
                 ## <group>
                 ## pos: 3373 3378
                  (   ( $pad{I1720} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3374 3376
                   ( ( substr( $s, $pos, 1 ) eq '[' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1720} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3378 3392
                  (   ( $pad{I1721} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3378 3384
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1721} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3392 3396
                  (   ( $pad{I1722} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3392 3394
                   ( ( substr( $s, $pos, 1 ) eq ']' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1722} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3396 3420
                  (   ( $pad{I1723} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3396 3415
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1723} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 )
               &&            ## <concat>
               ## pos: 3421 3482
               (
      
                 ## <group>
                 ## pos: 3421 3426
                  (   ( $pad{I1724} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3422 3424
                   ( ( substr( $s, $pos, 1 ) eq '<' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1724} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3426 3446
                  (   ( $pad{I1725} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 3426 3444
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1725} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3446 3482
                  (   ( $pad{I1726} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3446 3477
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1726} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 )
               &&            ## <concat>
               ## pos: 3483 3696
               (
      
                 ## <group>
                 ## pos: 3483 3488
                  (   ( $pad{I1727} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3484 3486
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1727} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3488 3502
                  (   ( $pad{I1728} = $pos or 1 ) &&
                   ## <metasyntax>
                   ## pos: 3488 3498
                   do {
                        my $prior = $::_V6_PRIOR_;
                        my $match =
                               $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                        $::_V6_PRIOR_ = $prior;
                        my $bool = (!$match != 1);
                        $pos = $match->to if $bool;
                        $match;
                   }
                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1728} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3502 3513
                  (   ( $pad{I1729} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 3502 3504
                   ( ( substr( $s, $pos, 1 ) eq chr(39) )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1729} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 3513 3696
                  (   ( $pad{I1730} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 3513 3691
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => "${$_[0]}",
                            },
                       _pos => [ $_[0]->from, $_[0]->to ],
                    };
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1730} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1715} ) or 1 )
               &&   
               ## <group>
               ## pos: 3697 3730
                (   ( $pad{I1731} = $pos or 1 ) &&
                 ## <closure>
                 ## pos: 3698 3729
                 do { 
                   local $::_V6_SUCCEED = 1;
                   $::_V6_MATCH_ = $m;
                   sub { die "invalid alias syntax"; }->( $m );
                   1;
                 }
                 ## </closure>
     ||    ( ( $pos = $pad{I1731} ) && 0 ) )
               ## </group>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token parse_metasyntax
*parse_metasyntax =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 3766 6639
           (
      
             ## <group>
             ## pos: 3766 3810
              (   ( $pad{I1732} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 3766 3805
               do{
                    my $from = $pos;
                    my $bool =                    ## <alt>
                       ## pos: 3782 3804
                       (
                           ( $pad{I1733} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 3782 3787
                            (   ( $pad{I1734} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3783 3786
                             ( ( substr( $s, $pos, 1 ) eq '!' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1734} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1733} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3788 3793
                            (   ( $pad{I1735} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3789 3792
                             ( ( substr( $s, $pos, 1 ) eq '?' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1735} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1733} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3794 3799
                            (   ( $pad{I1736} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 3795 3798
                             ( ( substr( $s, $pos, 1 ) eq '.' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1736} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1733} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 3800 3804
                            (   ( $pad{I1737} = $pos or 1 ) &&
     1 # null constant
     ||    ( ( $pos = $pad{I1737} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'modifier'} = $match;
                    $bool
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1732} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 3810 6639
              (   ( $pad{I1738} = $pos or 1 ) &&
               ## <alt>
               ## pos: 3811 6637
               (
                   ( $pad{I1739} = $pos or 1 )
                   && (
                   ## <concat>
                   ## pos: 3811 4029
                   (
      
                     ## <group>
                     ## pos: 3811 3825
                      (   ( $pad{I1740} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3820 3823
                       ( ( substr( $s, $pos, 1 ) eq '{' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1740} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3825 3840
                      (   ( $pad{I1741} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 3825 3838
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1741} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3840 3853
                      (   ( $pad{I1742} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 3840 3844
                       ( ( substr( $s, $pos, 2 ) eq '}>' )
                           ? ( $pos += 2 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1742} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 3853 4029
                      (   ( $pad{I1743} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 3853 4024
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { closure => {
                closure  => ${ $_[0]->{qw(parsed_code)} },
                modifier => ${ $_[0]->{qw(modifier)} },
            },
                _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1743} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1739} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4030 4523
                   (
      
                     ## <group>
                     ## pos: 4030 4060
                      (   ( $pad{I1744} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4039 4051
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1744} ) && 0 ) )
                     ## </group>
    
                   &&
                     ## <quant>
                     ## pos: 4060 4093
                     (
                      (   ( $pad{I1745} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4061 4082
                                 (
      
                                   ## <group>
                                   ## pos: 4061 4069
                                    (   ( $pad{I1746} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1746} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4069 4082
                                    (   ( $pad{I1747} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4069 4081
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I1747} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I1745} ) && 0 ) )
                     && do { while (
                      (   ( $pad{I1745} = $pos or 1 ) &&
    
                         ## <capture>
                         do{
                             my $hash = do {
                               my $bool = 1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
                                 ## <concat>
                                 ## pos: 4061 4082
                                 (
      
                                   ## <group>
                                   ## pos: 4061 4069
                                    (   ( $pad{I1746} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1746} ) && 0 ) )
                                   ## </group>
    
                                 &&
      
                                   ## <group>
                                   ## pos: 4069 4082
                                    (   ( $pad{I1747} = $pos or 1 ) &&
                                     ## <named_capture>
                                     ## pos: 4069 4081
                                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                 $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                     ## </named_capture>
     ||    ( ( $pos = $pad{I1747} ) && 0 ) )
                                   ## </group>
    
                                 )
                                 ## </concat>
    ;
                               { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                             };
                             my $bool = ${$hash->{'bool'}};
                             if ( $bool ) {
                                 push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                             }
                             $bool;
                         }
                         ## </capture>
     ||    ( ( $pos = $pad{I1745} ) && 0 ) )) {}; $bool = 1 }
                     )
                     ## </quant>
    
                   &&
      
                     ## <group>
                     ## pos: 4093 4104
                      (   ( $pad{I1748} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 4093 4095
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1748} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4104 4523
                      (   ( $pad{I1749} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 4104 4518
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub {
                if ( ${ $_[0]->{qw(modifier)} } eq '!' ) {
                  return {
                    negate => {
                      char_class => [
                        '+' . $_[0]->{qw(char_class)},
                        @{$_[0]->[0]},   # TODO - stringify
                  ] } }
                }
                return {
                  char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1749} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1739} ) or 1 )
                   &&                ## <concat>
                   ## pos: 4524 6412
                   (
      
                     ## <group>
                     ## pos: 4524 4549
                      (   ( $pad{I1750} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 4533 4540
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1750} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 4549 6412
                      (   ( $pad{I1751} = $pos or 1 ) &&
                       ## <alt>
                       ## pos: 4550 6406
                       (
                           ( $pad{I1752} = $pos or 1 )
                           && (
                           ## <concat>
                           ## pos: 4550 5167
                           (
      
                             ## <group>
                             ## pos: 4550 4567
                              (   ( $pad{I1753} = $pos or 1 ) &&
                               ## <metasyntax>
                               ## pos: 4561 4566
                               do {
                                    my $prior = $::_V6_PRIOR_;
                                    my $match =
                                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                    $::_V6_PRIOR_ = $prior;
                                    my $bool = (!$match != 1);
                                    $pos = $match->to if $bool;
                                    $match;
                               }
                               ## </metasyntax>
     ||    ( ( $pos = $pad{I1753} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4567 4574
                              (   ( $pad{I1754} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 4567 4573
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1754} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4574 4587
                              (   ( $pad{I1755} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 4574 4576
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1755} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 4587 5167
                              (   ( $pad{I1756} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 4587 5158
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule => ${ $_[0]->{qw(rule)} }, modifier => ${ $_[0]->{qw(modifier)} },
                         }, _pos => [ $_[0]->from - 1, $_[0]->to ], }
                }
                return { metasyntax => {
                            metasyntax => ${ $_[0]->{qw(ident)} },
                            rule       => ${ $_[0]->{qw(rule)} },
                            modifier   => ${ $_[0]->{qw(modifier)} },
                        },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1756} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 5168 6147
                           (
      
                             ## <group>
                             ## pos: 5168 5183
                              (   ( $pad{I1757} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5179 5182
                               ( ( substr( $s, $pos, 1 ) eq ':' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1757} ) && 0 ) )
                             ## </group>
    
                           &&
                             ## <quant>
                             ## pos: 5183 5200
                             (
                              (   ( $pad{I1758} = $pos or 1 ) &&
                                 ## <metasyntax>
                                 ## pos: 5183 5188
                                 do {
                                      my $prior = $::_V6_PRIOR_;
                                      my $match =
                                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                      $::_V6_PRIOR_ = $prior;
                                      my $bool = (!$match != 1);
                                      $pos = $match->to if $bool;
                                      $match;
                                 }
                                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1758} ) && 0 ) )
                             || ( $bool = 1 )
                             )
                             ## </quant>
    
                           &&
      
                             ## <group>
                             ## pos: 5200 5370
                              (   ( $pad{I1759} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 5200 5359
                               do{
                    my $from = $pos;
                    my $bool =                                    ## <quant>
                                       ## pos: 5211 5358
                                       do { while (
                                        (   ( $pad{I1760} = $pos or 1 ) &&
                                           ## <alt>
                                           ## pos: 5225 5345
                                           (
                                               ( $pad{I1761} = $pos or 1 )
                                               && (
                                               ## <concat>
                                               ## pos: 5239 5271
                                               (
      
                                                 ## <group>
                                                 ## pos: 5239 5244
                                                  (   ( $pad{I1762} = $pos or 1 ) &&
    
                                                   ## <constant>
                                                   ## pos: 5241 5243
                                                   ( ( substr( $s, $pos, 1 ) eq '\\' )
                                                       ? ( $pos += 1 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
     ||    ( ( $pos = $pad{I1762} ) && 0 ) )
                                                 ## </group>
    
                                               &&
      
                                                 ## <group>
                                                 ## pos: 5244 5271
                                                  (   ( $pad{I1763} = $pos or 1 ) &&
                                                   ## <named_capture>
                                                   ## pos: 5244 5258
                                                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                                               $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'special_char'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                   ## </named_capture>
     ||    ( ( $pos = $pad{I1763} ) && 0 ) )
                                                 ## </group>
    
                                               )
                                               ## </concat>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I1761} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5272 5320
                                                (   ( $pad{I1764} = $pos or 1 ) &&
                                                ## <metasyntax>
                                                 ## pos: 5274 5307
                                                 do{
                    my $match = 
              ## <variable>
              ## pos: 5274 5307
              do {
                our $I1765;
                our $I1765_sizes;
                unless ( $I1765 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1765_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1765 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1765_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1765->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1765, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { push @{$named{'Pugs::Grammar::Rule::variables'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                                                ## </metasyntax>
     ||    ( ( $pos = $pad{I1764} ) && 0 ) )
                                               ## </group>
    
                                               )
                                             || (
                                               ( ( $bool = 1 ) && ( $pos = $pad{I1761} ) or 1 )
                                               &&   
                                               ## <group>
                                               ## pos: 5321 5345
                                                (   ( $pad{I1766} = $pos or 1 ) &&
                                                 ## <perl5>
                                                 ( ( substr( $s, $pos ) =~ m/^((?:(?![\>]))\X)/ )
                                                     ? ( $pos += length( $1 ) or 1 )
                                                     : 0
                                                 )
                                                 ## </perl5>
     ||    ( ( $pos = $pad{I1766} ) && 0 ) )
                                               ## </group>
    
                                             )
                                           )
                                           ## </alt>
     ||    ( ( $pos = $pad{I1760} ) && 0 ) )) {}; $bool = 1 }
                                       ## </quant>
    ;
                    my $match = Pugs::Runtime::Match->new(
                        { str => \$s, from => \$from, match => [], named => {}, bool => \1, to => \(0+$pos), capture => undef }
                    ); $named{'str'} = $match;
                    $bool
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1759} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5370 5383
                              (   ( $pad{I1767} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 5370 5372
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1767} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 5383 6147
                              (   ( $pad{I1768} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 5383 6138
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub {
                if  ( ${ $_[0]->{qw(ident)} } eq 'before'
                   || ${ $_[0]->{qw(ident)} } eq 'after'
                    ) {
                    return { ${ $_[0]->{qw(ident)} } => {
                        rule     => { metasyntax => {
                                    metasyntax => '\'' . ${ $_[0]->{qw(str)} } . '\'',
                                },
                            _pos => [ $_[0]->{qw(str)}->from, $_[0]->{qw(str)}->to ],                   },
                        modifier => ${ $_[0]->{qw(modifier)} },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                    } }
                }
                return { metasyntax => {
                    metasyntax => ${ $_[0]->{qw(ident)} },
                    string   => ${ $_[0]->{qw(str)} },
                    modifier => ${ $_[0]->{qw(modifier)} },
                },
                    _pos => [ $_[0]->from - 1, $_[0]->to ],
                }
              }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1768} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1752} ) or 1 )
                           &&                        ## <concat>
                           ## pos: 6148 6406
                           (
      
                             ## <group>
                             ## pos: 6148 6163
                              (   ( $pad{I1769} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6159 6161
                               ( ( substr( $s, $pos, 1 ) eq '(' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1769} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6163 6178
                              (   ( $pad{I1770} = $pos or 1 ) &&
                               ## <named_capture>
                               ## pos: 6163 6176
                               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                               ## </named_capture>
     ||    ( ( $pos = $pad{I1770} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6178 6181
                              (   ( $pad{I1771} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6178 6180
                               ( ( substr( $s, $pos, 1 ) eq ')' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1771} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6181 6194
                              (   ( $pad{I1772} = $pos or 1 ) &&
    
                               ## <constant>
                               ## pos: 6181 6183
                               ( ( substr( $s, $pos, 1 ) eq '>' )
                                   ? ( $pos += 1 or 1 )
                                   : 0
                               )
                               ## </constant>
     ||    ( ( $pos = $pad{I1772} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 6194 6406
                              (   ( $pad{I1773} = $pos or 1 ) &&
                               ## <closure>
                               ## pos: 6194 6397
                               do {
                                 local $::_V6_SUCCEED = 1;
                                 $::_V6_MATCH_ = $m;
                                 $m->data->{capture} = \( sub { return { call => {
                  method   => ${ $_[0]->{qw(ident)} },
                  params   => ${ $_[0]->{qw(parsed_code)} },
                  modifier => ${ $_[0]->{qw(modifier)} },
              },
                  _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                                 $bool = $::_V6_SUCCEED;
                                 $::_V6_MATCH_ = $m if $bool; 
                                 return $m if $bool; 
                               }
                               ## </closure>
     ||    ( ( $pos = $pad{I1773} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
    
                         )
                       )
                       ## </alt>
     ||    ( ( $pos = $pad{I1751} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                   )
                 || (
                   ( ( $bool = 1 ) && ( $pos = $pad{I1739} ) or 1 )
                   &&                ## <concat>
                   ## pos: 6413 6637
                   (
      
                     ## <group>
                     ## pos: 6413 6436
                      (   ( $pad{I1774} = $pos or 1 ) &&
                       ## <named_capture>
                       ## pos: 6422 6434
                       do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                   $grammar->metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                       ## </named_capture>
     ||    ( ( $pos = $pad{I1774} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6436 6447
                      (   ( $pad{I1775} = $pos or 1 ) &&
    
                       ## <constant>
                       ## pos: 6436 6438
                       ( ( substr( $s, $pos, 1 ) eq '>' )
                           ? ( $pos += 1 or 1 )
                           : 0
                       )
                       ## </constant>
     ||    ( ( $pos = $pad{I1775} ) && 0 ) )
                     ## </group>
    
                   &&
      
                     ## <group>
                     ## pos: 6447 6637
                      (   ( $pad{I1776} = $pos or 1 ) &&
                       ## <closure>
                       ## pos: 6447 6632
                       do {
                         local $::_V6_SUCCEED = 1;
                         $::_V6_MATCH_ = $m;
                         $m->data->{capture} = \( sub { return { metasyntax => {
                  metasyntax => "${ $_[0]->{qw(metasyntax)} }",
                  modifier   => ${ $_[0]->{qw(modifier)} },
            },
                  _pos => [ $_[0]->from - 1, $_[0]->to ],
            } }->( $m ) ); 
                         $bool = $::_V6_SUCCEED;
                         $::_V6_MATCH_ = $m if $bool; 
                         return $m if $bool; 
                       }
                       ## </closure>
     ||    ( ( $pos = $pad{I1776} ) && 0 ) )
                     ## </group>
    
                   )
                   ## </concat>
    
                 )
               )
               ## </alt>
     ||    ( ( $pos = $pad{I1738} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token var1
*var1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 6749 6851
           (
      
             ## <group>
             ## pos: 6749 6757
              (   ( $pad{I1777} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 6749 6756
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1777} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6757 6768
              (   ( $pad{I1778} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 6757 6759
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1778} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 6768 6851
              (   ( $pad{I1779} = $pos or 1 ) &&
               ## <closure>
               ## pos: 6768 6850
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0]->{ident}, _pos => [$_[0]->from - 2, $_[0]->to], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1779} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$<'} = sub { var1($_[1], $_[0], $_[2], $_[3]) }; 

# token var2
*var2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 6943 7167
           (
               ( $pad{I1780} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 6943 7041
               (
                 ## <quant>
                 ## pos: 6943 6961
                 (
                  (   ( $pad{I1781} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6943 6951
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1781} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1781} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 6943 6951
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1781} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 6961 7041
                  (   ( $pad{I1782} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 6961 7036
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1782} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1780} ) or 1 )
               &&            ## <concat>
               ## pos: 7042 7167
               (
                 ## <quant>
                 ## pos: 7042 7063
                 (
                  (   ( $pad{I1783} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7051 7053
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1783} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7063 7097
                 (
                  (   ( $pad{I1784} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7064 7086
                     (
                         ( $pad{I1785} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7064 7074
                          (   ( $pad{I1786} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7065 7073
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1786} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1785} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7075 7078
                          (   ( $pad{I1787} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7076 7077
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1787} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1785} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7079 7086
                         (
      
                           ## <group>
                           ## pos: 7079 7083
                            (   ( $pad{I1788} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7080 7082
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1788} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7083 7086
                            (   ( $pad{I1789} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7083 7085
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1789} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1784} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1784} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7064 7086
                     (
                         ( $pad{I1785} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7064 7074
                          (   ( $pad{I1786} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7065 7073
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1786} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1785} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7075 7078
                          (   ( $pad{I1787} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7076 7077
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1787} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1785} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7079 7086
                         (
      
                           ## <group>
                           ## pos: 7079 7083
                            (   ( $pad{I1788} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7080 7082
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1788} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7083 7086
                            (   ( $pad{I1789} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7083 7085
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1789} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1784} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7097 7167
                  (   ( $pad{I1790} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7097 7166
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '$' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1790} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'$'} = sub { var2($_[1], $_[0], $_[2], $_[3]) }; 

# token var3
*var3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7258 7480
           (
               ( $pad{I1791} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7258 7355
               (
                 ## <quant>
                 ## pos: 7258 7276
                 (
                  (   ( $pad{I1792} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7258 7266
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1792} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1792} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7258 7266
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1792} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7276 7355
                  (   ( $pad{I1793} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7276 7350
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1793} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1791} ) or 1 )
               &&            ## <concat>
               ## pos: 7356 7480
               (
                 ## <quant>
                 ## pos: 7356 7377
                 (
                  (   ( $pad{I1794} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7365 7367
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1794} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7377 7411
                 (
                  (   ( $pad{I1795} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7378 7400
                     (
                         ( $pad{I1796} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7378 7388
                          (   ( $pad{I1797} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7379 7387
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1797} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1796} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7389 7392
                          (   ( $pad{I1798} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7390 7391
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1798} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1796} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7393 7400
                         (
      
                           ## <group>
                           ## pos: 7393 7397
                            (   ( $pad{I1799} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7394 7396
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1799} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7397 7400
                            (   ( $pad{I1800} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7397 7399
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1800} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1795} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1795} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7378 7400
                     (
                         ( $pad{I1796} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7378 7388
                          (   ( $pad{I1797} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7379 7387
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1797} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1796} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7389 7392
                          (   ( $pad{I1798} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7390 7391
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1798} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1796} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7393 7400
                         (
      
                           ## <group>
                           ## pos: 7393 7397
                            (   ( $pad{I1799} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7394 7396
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1799} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7397 7400
                            (   ( $pad{I1800} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7397 7399
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1800} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1795} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7411 7480
                  (   ( $pad{I1801} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7411 7479
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '@' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1801} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'@'} = sub { var3($_[1], $_[0], $_[2], $_[3]) }; 

# token var4
*var4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 7571 7791
           (
               ( $pad{I1802} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 7571 7667
               (
                 ## <quant>
                 ## pos: 7571 7589
                 (
                  (   ( $pad{I1803} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7571 7579
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1803} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1803} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 7571 7579
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->digit( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1803} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7589 7667
                  (   ( $pad{I1804} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7589 7662
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { match_variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1804} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1802} ) or 1 )
               &&            ## <concat>
               ## pos: 7668 7791
               (
                 ## <quant>
                 ## pos: 7668 7689
                 (
                  (   ( $pad{I1805} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 7677 7679
                     ( ( substr( $s, $pos, 1 ) eq '^' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1805} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
                 ## <quant>
                 ## pos: 7689 7723
                 (
                  (   ( $pad{I1806} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7690 7712
                     (
                         ( $pad{I1807} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7690 7700
                          (   ( $pad{I1808} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7691 7699
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1808} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1807} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7701 7704
                          (   ( $pad{I1809} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7702 7703
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1809} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1807} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7705 7712
                         (
      
                           ## <group>
                           ## pos: 7705 7709
                            (   ( $pad{I1810} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7706 7708
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1810} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7709 7712
                            (   ( $pad{I1811} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7709 7711
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1811} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1806} ) && 0 ) )
                 && do { while (
                  (   ( $pad{I1806} = $pos or 1 ) &&
                     ## <alt>
                     ## pos: 7690 7712
                     (
                         ( $pad{I1807} = $pos or 1 )
                         && (
      
                         ## <group>
                         ## pos: 7690 7700
                          (   ( $pad{I1808} = $pos or 1 ) &&
                           ## <metasyntax>
                           ## pos: 7691 7699
                           do {
                                my $prior = $::_V6_PRIOR_;
                                my $match =
                                       $grammar->alnum( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                $::_V6_PRIOR_ = $prior;
                                my $bool = (!$match != 1);
                                $pos = $match->to if $bool;
                                $match;
                           }
                           ## </metasyntax>
     ||    ( ( $pos = $pad{I1808} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1807} ) or 1 )
                         &&   
                         ## <group>
                         ## pos: 7701 7704
                          (   ( $pad{I1809} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 7702 7703
                           ( ( substr( $s, $pos, 1 ) eq '_' )
                               ? ( $pos += 1 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1809} ) && 0 ) )
                         ## </group>
    
                         )
                       || (
                         ( ( $bool = 1 ) && ( $pos = $pad{I1807} ) or 1 )
                         &&                      ## <concat>
                         ## pos: 7705 7712
                         (
      
                           ## <group>
                           ## pos: 7705 7709
                            (   ( $pad{I1810} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7706 7708
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1810} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 7709 7712
                            (   ( $pad{I1811} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 7709 7711
                             ( ( substr( $s, $pos, 1 ) eq ':' )
                                 ? ( $pos += 1 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1811} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    
                       )
                     )
                     ## </alt>
     ||    ( ( $pos = $pad{I1806} ) && 0 ) )) {}; $bool = 1 }
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 7723 7791
                  (   ( $pad{I1812} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 7723 7790
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { variable => '%' . $_[0], _pos => [$_[0]->from - 1, $_[0]->to] } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1812} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $variables{'%'} = sub { var4($_[1], $_[0], $_[2], $_[3]) }; 

# token term1
*term1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 7992 8142
            (   ( $pad{I1813} = $pos or 1 ) &&
             ## <closure>
             ## pos: 7992 8141
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { metasyntax => {
                            metasyntax => 'null',
            },
                            _pos => [ $_[0]->from, $_[0]->to ],
            } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1813} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{*}'} = sub { term1($_[1], $_[0], $_[2], $_[3]) }; 

# token term2
*term2 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8238 8453
           (
      
             ## <group>
             ## pos: 8238 8253
              (   ( $pad{I1814} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 8238 8248
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->literal( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1814} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8253 8264
              (   ( $pad{I1815} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8253 8255
               ( ( substr( $s, $pos, 1 ) eq chr(39) )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1815} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8264 8453
              (   ( $pad{I1816} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8264 8452
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                    metasyntax => {
                        metasyntax => '\'' . ${$_[0]},
                    },
                        _pos => [ $_[0]->from - 1, $_[0]->to ],
                };
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1816} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\''} = sub { term2($_[1], $_[0], $_[2], $_[3]) }; 

# token term3
*term3 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8548 8664
           (
      
             ## <group>
             ## pos: 8548 8555
              (   ( $pad{I1817} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8548 8554
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1817} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8555 8566
              (   ( $pad{I1818} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8555 8557
               ( ( substr( $s, $pos, 1 ) eq ')' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1818} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8566 8664
              (   ( $pad{I1819} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8566 8663
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capturing_group => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 1, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1819} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'('} = sub { term3($_[1], $_[0], $_[2], $_[3]) }; 

# token term4
*term4 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8758 8879
           (
      
             ## <group>
             ## pos: 8758 8766
              (   ( $pad{I1820} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8758 8764
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1820} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8766 8779
              (   ( $pad{I1821} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 8766 8770
               ( ( substr( $s, $pos, 2 ) eq ')>' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1821} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 8779 8879
              (   ( $pad{I1822} = $pos or 1 ) &&
               ## <closure>
               ## pos: 8779 8878
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { capture_as_result => ${ $_[0]->{qw(rule)} },
                       _pos => [ $_[0]->from - 2, $_[0]->to ], }; }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1822} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<('} = sub { term4($_[1], $_[0], $_[2], $_[3]) }; 

# token term5
*term5 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 8974 9234
           (
      
             ## <group>
             ## pos: 8974 8995
              (   ( $pad{I1823} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 8974 8986
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1823} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 8995 9028
             do { while (
              (   ( $pad{I1824} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 8996 9017
                         (
      
                           ## <group>
                           ## pos: 8996 9004
                            (   ( $pad{I1825} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1825} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9004 9017
                            (   ( $pad{I1826} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9004 9016
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1826} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1824} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9028 9039
              (   ( $pad{I1827} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9028 9030
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1827} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9039 9234
              (   ( $pad{I1828} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9039 9233
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1828} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<+'} = sub { term5($_[1], $_[0], $_[2], $_[3]) }; 

# token term6
*term6 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9329 9589
           (
      
             ## <group>
             ## pos: 9329 9350
              (   ( $pad{I1829} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9329 9341
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1829} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9350 9383
             do { while (
              (   ( $pad{I1830} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9351 9372
                         (
      
                           ## <group>
                           ## pos: 9351 9359
                            (   ( $pad{I1831} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1831} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9359 9372
                            (   ( $pad{I1832} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9359 9371
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1832} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1830} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9383 9394
              (   ( $pad{I1833} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9383 9385
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1833} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9394 9589
              (   ( $pad{I1834} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9394 9588
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '-' . $_[0]->{qw(char_class)},
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1834} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<-'} = sub { term6($_[1], $_[0], $_[2], $_[3]) }; 

# token term7
*term7 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 9684 9955
           (
      
             ## <group>
             ## pos: 9684 9698
              (   ( $pad{I1835} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 9684 9696
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->char_range( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_range'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1835} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9698 9709
              (   ( $pad{I1836} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9698 9700
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1836} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 9709 9742
             do { while (
              (   ( $pad{I1837} = $pos or 1 ) &&
    
                 ## <capture>
                 do{
                     my $hash = do {
                       my $bool = 1;
                       my $from = $pos;
                       my @match;
                       my %named;
                       $bool = 0 unless
                         ## <concat>
                         ## pos: 9710 9731
                         (
      
                           ## <group>
                           ## pos: 9710 9718
                            (   ( $pad{I1838} = $pos or 1 ) &&
                             ## <perl5>
                             ( ( substr( $s, $pos ) =~ m/^((?:(?=[+-]))\X)/ )
                                 ? ( $pos += length( $1 ) or 1 )
                                 : 0
                             )
                             ## </perl5>
     ||    ( ( $pos = $pad{I1838} ) && 0 ) )
                           ## </group>
    
                         &&
      
                           ## <group>
                           ## pos: 9718 9731
                            (   ( $pad{I1839} = $pos or 1 ) &&
                             ## <named_capture>
                             ## pos: 9718 9730
                             do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                         $grammar->char_class( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'char_class'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                             ## </named_capture>
     ||    ( ( $pos = $pad{I1839} ) && 0 ) )
                           ## </group>
    
                         )
                         ## </concat>
    ;
                       { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                     };
                     my $bool = ${$hash->{'bool'}};
                     if ( $bool ) {
                         push @{ $match[ 0 ] }, Pugs::Runtime::Match->new( $hash );
                     }
                     $bool;
                 }
                 ## </capture>
     ||    ( ( $pos = $pad{I1837} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 9742 9753
              (   ( $pad{I1840} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 9742 9744
               ( ( substr( $s, $pos, 1 ) eq '>' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1840} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 9753 9955
              (   ( $pad{I1841} = $pos or 1 ) &&
               ## <closure>
               ## pos: 9753 9954
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                _pos => [ $_[0]->from - 2, $_[0]->to ],
                char_class => [
                    '+[' . $_[0]->{qw(char_range)} . ']',
                    @{$_[0]->[0]},   # TODO - stringify
                ] }
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1841} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<['} = sub { term7($_[1], $_[0], $_[2], $_[3]) }; 

# token term8
*term8 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10050 10109
           (
      
             ## <group>
             ## pos: 10050 10077
              (   ( $pad{I1842} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10050 10068
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parse_metasyntax( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parse_metasyntax'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1842} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10077 10109
              (   ( $pad{I1843} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10077 10108
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(parse_metasyntax)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1843} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<'} = sub { term8($_[1], $_[0], $_[2], $_[3]) }; 

# token term9
*term9 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10203 10393
           (
      
             ## <group>
             ## pos: 10203 10218
              (   ( $pad{I1844} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10203 10216
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1844} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10218 10229
              (   ( $pad{I1845} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10218 10220
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1845} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10229 10393
              (   ( $pad{I1846} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10229 10392
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { closure => {
                closure => ${ $_[0]->{qw(parsed_code)} },
                modifier => 'plain',
            },
                _pos => [$_[0]->from - 1, $_[0]->to],
            } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1846} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'{'} = sub { term9($_[1], $_[0], $_[2], $_[3]) }; 

# token term10
*term10 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10488 10539
           (
      
             ## <group>
             ## pos: 10488 10511
              (   ( $pad{I1847} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10488 10502
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->special_char( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'special_char'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1847} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10511 10539
              (   ( $pad{I1848} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10511 10538
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(special_char)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1848} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'\\'} = sub { term10($_[1], $_[0], $_[2], $_[3]) }; 

# token term11
*term11 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10636 10695
            (   ( $pad{I1849} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10636 10694
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { 'dot' => 1, _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1849} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'.'} = sub { term11($_[1], $_[0], $_[2], $_[3]) }; 

# token term12
*term12 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 10791 10829
           (
      
             ## <group>
             ## pos: 10791 10798
              (   ( $pad{I1850} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 10791 10797
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1850} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10798 10809
              (   ( $pad{I1851} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 10798 10800
               ( ( substr( $s, $pos, 1 ) eq ']' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1851} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 10809 10829
              (   ( $pad{I1852} = $pos or 1 ) &&
               ## <closure>
               ## pos: 10809 10828
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return ${ $_[0]->{qw(rule)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1852} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'['} = sub { term12($_[1], $_[0], $_[2], $_[3]) }; 

# token term13
*term13 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 10917 10980
            (   ( $pad{I1853} = $pos or 1 ) &&
             ## <closure>
             ## pos: 10917 10979
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':::', _pos => [$_[0]->from - 3, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1853} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':::'} = sub { term13($_[1], $_[0], $_[2], $_[3]) }; 

# token term14
*term14 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11070 11132
            (   ( $pad{I1854} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11070 11131
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':?', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1854} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':?'} = sub { term14($_[1], $_[0], $_[2], $_[3]) }; 

# token term15
*term15 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11221 11283
            (   ( $pad{I1855} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11221 11282
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':+', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1855} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':+'} = sub { term15($_[1], $_[0], $_[2], $_[3]) }; 

# token term16
*term16 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11372 11434
            (   ( $pad{I1856} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11372 11433
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '::', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1856} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'::'} = sub { term16($_[1], $_[0], $_[2], $_[3]) }; 

# token term17
*term17 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11523 11584
            (   ( $pad{I1857} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11523 11583
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => ':', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1857} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':'} = sub { term17($_[1], $_[0], $_[2], $_[3]) }; 

# token term18
*term18 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11672 11734
            (   ( $pad{I1858} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11672 11733
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$$', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1858} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$$'} = sub { term18($_[1], $_[0], $_[2], $_[3]) }; 

# token term19
*term19 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11823 11885
            (   ( $pad{I1859} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11823 11884
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '$', _pos => [$_[0]->from - 1, $_[0]->to],  } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1859} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'$'} = sub { term19($_[1], $_[0], $_[2], $_[3]) }; 

# token term20
*term20 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 11973 12035
            (   ( $pad{I1860} = $pos or 1 ) &&
             ## <closure>
             ## pos: 11973 12034
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^^', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1860} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^^'} = sub { term20($_[1], $_[0], $_[2], $_[3]) }; 

# token term21
*term21 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12124 12185
            (   ( $pad{I1861} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12124 12184
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '^', _pos => [$_[0]->from - 1, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1861} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'^'} = sub { term21($_[1], $_[0], $_[2], $_[3]) }; 

# token term22
*term22 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12273 12335
            (   ( $pad{I1862} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12273 12334
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '>>', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1862} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'>>'} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{'»'} = sub { term22($_[1], $_[0], $_[2], $_[3]) }; 

# token term24
*term24 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
      
           ## <group>
           ## pos: 12577 12639
            (   ( $pad{I1863} = $pos or 1 ) &&
             ## <closure>
             ## pos: 12577 12638
             do {
               local $::_V6_SUCCEED = 1;
               $::_V6_MATCH_ = $m;
               $m->data->{capture} = \( sub { return { colon => '<<', _pos => [$_[0]->from - 2, $_[0]->to], } }->( $m ) ); 
               $bool = $::_V6_SUCCEED;
               $::_V6_MATCH_ = $m if $bool; 
               return $m if $bool; 
             }
             ## </closure>
     ||    ( ( $pos = $pad{I1863} ) && 0 ) )
           ## </group>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{'<<'} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{'«'} = sub { term24($_[1], $_[0], $_[2], $_[3]) }; 

# token term26
*term26 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 12889 13066
           (
      
             ## <group>
             ## pos: 12889 12895
              (   ( $pad{I1864} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 12889 12894
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1864} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12895 12910
              (   ( $pad{I1865} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 12895 12901
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1865} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 12910 13066
              (   ( $pad{I1866} = $pos or 1 ) &&
               ## <closure>
               ## pos: 12910 13065
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                modifier => {
                    modifier => 'ignorecase',
                    rule => ${ $_[0]->{qw(rule)} },
                    }
                },
            }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1866} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':i'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':ignorecase'} = sub { term26($_[1], $_[0], $_[2], $_[3]) }; 

# token term28
*term28 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13346 13423
           (
      
             ## <group>
             ## pos: 13346 13352
              (   ( $pad{I1867} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13346 13351
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1867} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13352 13367
              (   ( $pad{I1868} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13352 13358
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1868} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13367 13423
              (   ( $pad{I1869} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13367 13422
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'sigspace', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1869} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':s'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':sigspace'} = sub { term28($_[1], $_[0], $_[2], $_[3]) }; 

# token term30
*term30 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 13702 13776
           (
      
             ## <group>
             ## pos: 13702 13708
              (   ( $pad{I1870} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 13702 13707
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1870} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13708 13723
              (   ( $pad{I1871} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 13708 13714
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1871} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 13723 13776
              (   ( $pad{I1872} = $pos or 1 ) &&
               ## <closure>
               ## pos: 13723 13775
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'Perl5', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1872} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':P5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# Code block from grammar spec
 $rule_terms{':Perl5'} = sub { term30($_[1], $_[0], $_[2], $_[3]) }; 

# token term32
*term32 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14049 14123
           (
      
             ## <group>
             ## pos: 14049 14055
              (   ( $pad{I1873} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14049 14054
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1873} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14055 14070
              (   ( $pad{I1874} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14055 14061
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1874} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14070 14123
              (   ( $pad{I1875} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14070 14122
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'bytes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1875} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':bytes'} = sub { term32($_[1], $_[0], $_[2], $_[3]) }; 

# token term33
*term33 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14224 14298
           (
      
             ## <group>
             ## pos: 14224 14230
              (   ( $pad{I1876} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14224 14229
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1876} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14230 14245
              (   ( $pad{I1877} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14230 14236
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1877} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14245 14298
              (   ( $pad{I1878} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14245 14297
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'codes', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1878} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':codes'} = sub { term33($_[1], $_[0], $_[2], $_[3]) }; 

# token term34
*term34 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14399 14474
           (
      
             ## <group>
             ## pos: 14399 14405
              (   ( $pad{I1879} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14399 14404
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1879} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14405 14420
              (   ( $pad{I1880} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14405 14411
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1880} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14420 14474
              (   ( $pad{I1881} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14420 14473
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'graphs', rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1881} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':graphs'} = sub { term34($_[1], $_[0], $_[2], $_[3]) }; 

# token term35
*term35 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 14576 14651
           (
      
             ## <group>
             ## pos: 14576 14582
              (   ( $pad{I1882} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 14576 14581
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1882} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14582 14597
              (   ( $pad{I1883} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 14582 14588
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1883} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 14597 14651
              (   ( $pad{I1884} = $pos or 1 ) &&
               ## <closure>
               ## pos: 14597 14650
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { modifier => 'langs',  rule => ${ $_[0]->{qw(rule)} } } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1884} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# Code block from grammar spec
 $rule_terms{':langs'} = sub { term35($_[1], $_[0], $_[2], $_[3]) }; 

# token term
*term =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 14746 15548
           (
               ( $pad{I1885} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 14747 15225
               (
      
                 ## <group>
                 ## pos: 14747 14790
                  (   ( $pad{I1886} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 14749 14782
                   do{
                    my $match = 
              ## <variable>
              ## pos: 14749 14782
              do {
                our $I1887;
                our $I1887_sizes;
                unless ( $I1887 ) {
                    my $hash = \%Pugs::Grammar::Rule::variables;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1887_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1887 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1887_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1887->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1887, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::variables'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I1886} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 14790 15225
                  (   ( $pad{I1888} = $pos or 1 ) &&
                   ## <alt>
                   ## pos: 14791 15219
                   (
                       ( $pad{I1889} = $pos or 1 )
                       && (
                       ## <concat>
                       ## pos: 14791 15132
                       (
                         ## <quant>
                         ## pos: 14791 14800
                         (
                          (   ( $pad{I1890} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14793 14798
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1890} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14800 14805
                          (   ( $pad{I1891} = $pos or 1 ) &&
    
                           ## <constant>
                           ## pos: 14800 14804
                           ( ( substr( $s, $pos, 2 ) eq ':=' )
                               ? ( $pos += 2 or 1 )
                               : 0
                           )
                           ## </constant>
     ||    ( ( $pos = $pad{I1891} ) && 0 ) )
                         ## </group>
    
                       &&
                         ## <quant>
                         ## pos: 14805 14812
                         (
                          (   ( $pad{I1892} = $pos or 1 ) &&
                             ## <metasyntax>
                             ## pos: 14805 14810
                             do {
                                  my $prior = $::_V6_PRIOR_;
                                  my $match =
                                         $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                  $::_V6_PRIOR_ = $prior;
                                  my $bool = (!$match != 1);
                                  $pos = $match->to if $bool;
                                  $match;
                             }
                             ## </metasyntax>
     ||    ( ( $pos = $pad{I1892} ) && 0 ) )
                         || ( $bool = 1 )
                         )
                         ## </quant>
    
                       &&
      
                         ## <group>
                         ## pos: 14812 14843
                          (   ( $pad{I1893} = $pos or 1 ) &&
                           ## <named_capture>
                           ## pos: 14812 14832
                           do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                       $grammar->named_capture_body( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_capture_body'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                           ## </named_capture>
     ||    ( ( $pos = $pad{I1893} ) && 0 ) )
                         ## </group>
    
                       &&
      
                         ## <group>
                         ## pos: 14843 15132
                          (   ( $pad{I1894} = $pos or 1 ) &&
                           ## <closure>
                           ## pos: 14843 15124
                           do {
                             local $::_V6_SUCCEED = 1;
                             $::_V6_MATCH_ = $m;
                             $m->data->{capture} = \( sub {
                return { named_capture => {
                            rule =>  ${ $_[0]->{qw(named_capture_body)} },
                            ident => ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} },
                         },
                            _pos => [ $_[0]->from, $_[0]->to ],
                         };
              }->( $m ) ); 
                             $bool = $::_V6_SUCCEED;
                             $::_V6_MATCH_ = $m if $bool; 
                             return $m if $bool; 
                           }
                           ## </closure>
     ||    ( ( $pos = $pad{I1894} ) && 0 ) )
                         ## </group>
    
                       )
                       ## </concat>
    
                       )
                     || (
                       ( ( $bool = 1 ) && ( $pos = $pad{I1889} ) or 1 )
                       &&   
                       ## <group>
                       ## pos: 15133 15219
                        (   ( $pad{I1895} = $pos or 1 ) &&
                         ## <closure>
                         ## pos: 15144 15211
                         do {
                           local $::_V6_SUCCEED = 1;
                           $::_V6_MATCH_ = $m;
                           $m->data->{capture} = \( sub {
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::variables)} }
              }->( $m ) ); 
                           $bool = $::_V6_SUCCEED;
                           $::_V6_MATCH_ = $m if $bool; 
                           return $m if $bool; 
                         }
                         ## </closure>
     ||    ( ( $pos = $pad{I1895} ) && 0 ) )
                       ## </group>
    
                     )
                   )
                   ## </alt>
     ||    ( ( $pos = $pad{I1888} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1885} ) or 1 )
               &&            ## <concat>
               ## pos: 15226 15394
               (
      
                 ## <group>
                 ## pos: 15226 15271
                  (   ( $pad{I1896} = $pos or 1 ) &&
                  ## <metasyntax>
                   ## pos: 15228 15262
                   do{
                    my $match = 
              ## <variable>
              ## pos: 15228 15262
              do {
                our $I1897;
                our $I1897_sizes;
                unless ( $I1897 ) {
                    my $hash = \%Pugs::Grammar::Rule::rule_terms;
                    my %sizes = map { length($_) => 1 } keys %$hash;
                    $I1897_sizes = [ sort { $b <=> $a } keys %sizes ];
                    $I1897 = $hash;
                }
                my $match = 0;
                my $key;
                for ( @$I1897_sizes ) {
                    $key = ( $pos <= length( $s )
                                ? substr( $s, $pos, $_ )
                                : '' );
                    if ( exists $I1897->{$key} ) {
                        #$named{KEY} = $key;
                        #$::_V6_MATCH_ = $m;
                        #print "m: ", Dumper( $::_V6_MATCH_->data )
                        #    if ( $key eq 'until' );
                        $match = Pugs::Runtime::Regex::preprocess_hash( $I1897, $key )->( $s, $grammar, { p => ( $pos + $_ ), positionals => [ ], args => { KEY => $key } }, undef );
                        last if $match;
                    }
                }
                if ( $match ) {
                    $pos = $match->to;
                    #print "match: $key at $pos = ", Dumper( $match->data );
                    $bool = 1;
                }; # else { $bool = 0 }
                $match;
              }
              ## </variable>
    ;
                    if ( $match ) { $named{'Pugs::Grammar::Rule::rule_terms'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                  ## </metasyntax>
     ||    ( ( $pos = $pad{I1896} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15271 15394
                  (   ( $pad{I1898} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15271 15389
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                #print "term: ", Dumper( $_[0]->data );
                return ${ $_[0]->{qw(Pugs::Grammar::Rule::rule_terms)} }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1898} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1885} ) or 1 )
               &&            ## <concat>
               ## pos: 15395 15548
               (
      
                 ## <group>
                 ## pos: 15395 15442
                  (   ( $pad{I1899} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?![\]\}\)\>\:\?\+\*\|\&]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1899} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15442 15548
                  (   ( $pad{I1900} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15442 15547
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub {
                return { 'constant' => ${$_[0]},
                         _pos => [ $_[0]->from, $_[0]->to ] }
            }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1900} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quant
*quant =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 15569 15683
           (
               ( $pad{I1901} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 15570 15661
               (
      
                 ## <group>
                 ## pos: 15570 15578
                  (   ( $pad{I1902} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15573 15577
                   ( ( substr( $s, $pos, 2 ) eq '**' )
                       ? ( $pos += 2 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1902} ) && 0 ) )
                 ## </group>
    
               &&
                 ## <quant>
                 ## pos: 15578 15585
                 (
                  (   ( $pad{I1903} = $pos or 1 ) &&
                     ## <metasyntax>
                     ## pos: 15578 15583
                     do {
                          my $prior = $::_V6_PRIOR_;
                          my $match =
                                 $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                          $::_V6_PRIOR_ = $prior;
                          my $bool = (!$match != 1);
                          $pos = $match->to if $bool;
                          $match;
                     }
                     ## </metasyntax>
     ||    ( ( $pos = $pad{I1903} ) && 0 ) )
                 || ( $bool = 1 )
                 )
                 ## </quant>
    
               &&
      
                 ## <group>
                 ## pos: 15585 15589
                  (   ( $pad{I1904} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15585 15587
                   ( ( substr( $s, $pos, 1 ) eq '{' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1904} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15589 15604
                  (   ( $pad{I1905} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 15589 15602
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->parsed_code( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'parsed_code'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1905} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15604 15615
                  (   ( $pad{I1906} = $pos or 1 ) &&
    
                   ## <constant>
                   ## pos: 15604 15606
                   ( ( substr( $s, $pos, 1 ) eq '}' )
                       ? ( $pos += 1 or 1 )
                       : 0
                   )
                   ## </constant>
     ||    ( ( $pos = $pad{I1906} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 15615 15661
                  (   ( $pad{I1907} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 15615 15656
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return { closure => ${ $_[0]->{qw(parsed_code)} } } }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1907} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1901} ) or 1 )
               &&            ## <quant>
               ## pos: 15662 15683
               (
                (   ( $pad{I1908} = $pos or 1 ) &&
                   ## <perl5>
                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\*\+]))\X)/ )
                       ? ( $pos += length( $1 ) or 1 )
                       : 0
                   )
                   ## </perl5>
     ||    ( ( $pos = $pad{I1908} ) && 0 ) )
               || ( $bool = 1 )
               )
               ## </quant>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token quantifier
*quantifier =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 15709 16475
           (
      
             ## <group>
             ## pos: 15709 15734
              (   ( $pad{I1909} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15709 15729
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15722 15728
                               (
                                (   ( $pad{I1910} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15722 15727
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1910} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws1'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1909} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15734 15769
              (   ( $pad{I1911} = $pos or 1 ) &&
               ## <negate>
               ## pos: 15734 15764
               do{
                   my $pos1 = $pos;
                   do {
                     my $pos = $pos1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 
                         ## <before>
                         ## pos: 15744 15763
                         do{
                             my $pos1 = $pos;
                             do {
                               my $pos = $pos1;
                               my $from = $pos;
                               my @match;
                               my %named;
                               $bool = 0 unless
      
                                   ## <group>
                                   ## pos: 15744 15763
                                    (   ( $pad{I1912} = $pos or 1 ) &&
                                     ## <perl5>
                                     ( ( substr( $s, $pos ) =~ m/^((?:(?=[\}\]\)]))\X)/ )
                                         ? ( $pos += length( $1 ) or 1 )
                                         : 0
                                     )
                                     ## </perl5>
     ||    ( ( $pos = $pad{I1912} ) && 0 ) )
                                   ## </group>
    ;
                               $bool;
                             };
                         }
                         ## </before>
     ? 0 : 1;
                     $bool;
                   };
               }
               ## </negate>
     ||    ( ( $pos = $pad{I1911} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15769 15780
              (   ( $pad{I1913} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15769 15775
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->term( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'term'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1913} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15780 15805
              (   ( $pad{I1914} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15780 15800
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15793 15799
                               (
                                (   ( $pad{I1915} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15793 15798
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1915} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws2'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1914} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15805 15817
              (   ( $pad{I1916} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15805 15812
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->quant( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'quant'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1916} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15817 15851
              (   ( $pad{I1917} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15817 15846
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15831 15845
                               (
                                (   ( $pad{I1918} = $pos or 1 ) &&
                                   ## <perl5>
                                   ( ( substr( $s, $pos ) =~ m/^((?:(?=[\?\+]))\X)/ )
                                       ? ( $pos += length( $1 ) or 1 )
                                       : 0
                                   )
                                   ## </perl5>
     ||    ( ( $pos = $pad{I1918} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'greedy'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1917} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15851 15876
              (   ( $pad{I1919} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 15851 15871
               do{
                    my $match = Pugs::Runtime::Match->new( do {
                        my $bool = 1;
                        my $from = $pos;
                        my @match;
                        my %named;
                        $bool = 0 unless 
                       ## <capture>
                       do{
                           my $hash = do {
                             my $bool = 1;
                             my $from = $pos;
                             my @match;
                             my %named;
                             $bool = 0 unless
                               ## <quant>
                               ## pos: 15864 15870
                               (
                                (   ( $pad{I1920} = $pos or 1 ) &&
                                   ## <metasyntax>
                                   ## pos: 15864 15869
                                   do {
                                        my $prior = $::_V6_PRIOR_;
                                        my $match =
                                               $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                                        $::_V6_PRIOR_ = $prior;
                                        my $bool = (!$match != 1);
                                        $pos = $match->to if $bool;
                                        $match;
                                   }
                                   ## </metasyntax>
     ||    ( ( $pos = $pad{I1920} ) && 0 ) )
                               || ( $bool = 1 )
                               )
                               ## </quant>
    ;
                             { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                           };
                           my $bool = ${$hash->{'bool'}};
                           $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                           $bool;
                       }
                       ## </capture>
    ;
                        { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                    } );
                    if ( $match ) { $named{'ws3'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1919} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 15876 16475
              (   ( $pad{I1921} = $pos or 1 ) &&
               ## <closure>
               ## pos: 15876 16474
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
          if (
                   ${$_[0]->{'quant'}}  eq ''
                && ${$_[0]->{'greedy'}} eq ''
                && ${$_[0]->{'ws1'}}    eq ''
                && ${$_[0]->{'ws2'}}    eq ''
                && ${$_[0]->{'ws3'}}    eq ''
          ) {
              return ${$_[0]->{'term'}};
          }
          return {
            quant => {
                    term    => ${$_[0]->{'term'}},
                    quant   => ${$_[0]->{'quant'}},
                    greedy  => ${$_[0]->{'greedy'}},
                    ws1     => ${$_[0]->{'ws1'}},
                    ws2     => ${$_[0]->{'ws2'}},
                    ws3     => ${$_[0]->{'ws3'}},
                },
            _pos => [$_[0]->from, $_[0]->to],
          }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1921} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token concat
*concat =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16497 16706
           (
             ## <quant>
             ## pos: 16497 16515
             (
              (   ( $pad{I1922} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16497 16509
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1922} ) && 0 ) )
             && do { while (
              (   ( $pad{I1922} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16497 16509
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->quantifier( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'quantifier'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1922} ) && 0 ) )) {}; $bool = 1 }
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16515 16706
              (   ( $pad{I1923} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16515 16705
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $_->()  }  @{ $::_V6_MATCH_->{'quantifier'} };
            return { concat => \@a, _pos => [$_[0]->from, $_[0]->to] }
                if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1923} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive1
*conjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 16734 17014
           (
             ## <quant>
             ## pos: 16734 16768
             (
              (   ( $pad{I1924} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16735 16760
                 (
                   ## <quant>
                   ## pos: 16735 16743
                   (
                    (   ( $pad{I1925} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 16736 16741
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1925} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 16743 16746
                    (   ( $pad{I1926} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16743 16745
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1926} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16746 16760
                    (   ( $pad{I1927} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16746 16759
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16755 16758
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16755 16758
                                          (   ( $pad{I1928} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16755 16757
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1928} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1927} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1924} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16768 16786
             (
              (   ( $pad{I1929} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 16768 16776
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1929} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 16786 16835
             do { while (
              (   ( $pad{I1930} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 16787 16827
                 (
      
                   ## <group>
                   ## pos: 16787 16799
                    (   ( $pad{I1931} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 16796 16798
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1931} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16799 16814
                    (   ( $pad{I1932} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 16799 16812
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 16808 16811
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 16808 16811
                                          (   ( $pad{I1933} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 16808 16810
                                           ( ( substr( $s, $pos, 1 ) eq '&' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1933} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1932} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 16814 16827
                    (   ( $pad{I1934} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 16814 16822
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->concat( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'concat'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1934} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1930} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 16835 17014
              (   ( $pad{I1935} = $pos or 1 ) &&
               ## <closure>
               ## pos: 16835 17013
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'concat'} };
            return { conjunctive1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1935} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token disjunctive1
*disjunctive1 =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17042 17331
           (
             ## <quant>
             ## pos: 17042 17076
             (
              (   ( $pad{I1936} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17043 17068
                 (
                   ## <quant>
                   ## pos: 17043 17051
                   (
                    (   ( $pad{I1937} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17044 17049
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1937} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17051 17054
                    (   ( $pad{I1938} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17051 17053
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1938} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17054 17068
                    (   ( $pad{I1939} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17054 17067
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17063 17066
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17063 17066
                                          (   ( $pad{I1940} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17063 17065
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1940} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1939} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1936} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17076 17100
             (
              (   ( $pad{I1941} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17076 17090
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1941} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17100 17154
             do { while (
              (   ( $pad{I1942} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17101 17146
                 (
      
                   ## <group>
                   ## pos: 17101 17113
                    (   ( $pad{I1943} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17110 17112
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1943} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17113 17127
                    (   ( $pad{I1944} = $pos or 1 ) &&
                     ## <negate>
                     ## pos: 17113 17126
                     do{
                         my $pos1 = $pos;
                         do {
                           my $pos = $pos1;
                           my $from = $pos;
                           my @match;
                           my %named;
                           $bool = 
                               ## <before>
                               ## pos: 17122 17125
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 0 unless
      
                                         ## <group>
                                         ## pos: 17122 17125
                                          (   ( $pad{I1945} = $pos or 1 ) &&
    
                                           ## <constant>
                                           ## pos: 17122 17124
                                           ( ( substr( $s, $pos, 1 ) eq '|' )
                                               ? ( $pos += 1 or 1 )
                                               : 0
                                           )
                                           ## </constant>
     ||    ( ( $pos = $pad{I1945} ) && 0 ) )
                                         ## </group>
    ;
                                     $bool;
                                   };
                               }
                               ## </before>
     ? 0 : 1;
                           $bool;
                         };
                     }
                     ## </negate>
     ||    ( ( $pos = $pad{I1944} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17127 17146
                    (   ( $pad{I1946} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17127 17141
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1946} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1942} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17154 17331
              (   ( $pad{I1947} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17154 17330
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive1'} };
            return { alt1 => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1947} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token conjunctive
*conjunctive =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17358 17632
           (
             ## <quant>
             ## pos: 17358 17381
             (
              (   ( $pad{I1948} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17359 17373
                 (
                   ## <quant>
                   ## pos: 17359 17367
                   (
                    (   ( $pad{I1949} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17360 17365
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1949} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17367 17370
                    (   ( $pad{I1950} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17367 17369
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1950} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17370 17373
                    (   ( $pad{I1951} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17370 17372
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1951} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1948} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17381 17405
             (
              (   ( $pad{I1952} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17381 17395
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1952} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17405 17448
             do { while (
              (   ( $pad{I1953} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17406 17440
                 (
      
                   ## <group>
                   ## pos: 17406 17418
                    (   ( $pad{I1954} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17415 17417
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1954} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17418 17421
                    (   ( $pad{I1955} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17418 17420
                     ( ( substr( $s, $pos, 1 ) eq '&' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1955} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17421 17440
                    (   ( $pad{I1956} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17421 17435
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->disjunctive1( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'disjunctive1'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1956} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1953} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17448 17632
              (   ( $pad{I1957} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17448 17631
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'disjunctive1'} };
            return { conjunctive => \@a, _pos => [$_[0]->from, $_[0]->to] }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1957} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token rule
*rule =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17652 17916
           (
             ## <quant>
             ## pos: 17652 17675
             (
              (   ( $pad{I1958} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17653 17667
                 (
                   ## <quant>
                   ## pos: 17653 17661
                   (
                    (   ( $pad{I1959} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 17654 17659
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I1959} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 &&
      
                   ## <group>
                   ## pos: 17661 17664
                    (   ( $pad{I1960} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17661 17663
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1960} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17664 17667
                    (   ( $pad{I1961} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17664 17666
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1961} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1958} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17675 17698
             (
              (   ( $pad{I1962} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 17675 17688
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I1962} ) && 0 ) )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 17698 17740
             do { while (
              (   ( $pad{I1963} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 17699 17732
                 (
      
                   ## <group>
                   ## pos: 17699 17711
                    (   ( $pad{I1964} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17708 17710
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1964} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17711 17714
                    (   ( $pad{I1965} = $pos or 1 ) &&
    
                     ## <constant>
                     ## pos: 17711 17713
                     ( ( substr( $s, $pos, 1 ) eq '|' )
                         ? ( $pos += 1 or 1 )
                         : 0
                     )
                     ## </constant>
     ||    ( ( $pos = $pad{I1965} ) && 0 ) )
                   ## </group>
    
                 &&
      
                   ## <group>
                   ## pos: 17714 17732
                    (   ( $pad{I1966} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 17714 17727
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->conjunctive( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'conjunctive'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I1966} ) && 0 ) )
                   ## </group>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I1963} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17740 17916
              (   ( $pad{I1967} = $pos or 1 ) &&
               ## <closure>
               ## pos: 17740 17915
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub {
            my @a = map {  $$_  }  @{ $::_V6_MATCH_->{'conjunctive'} };
            return { alt => \@a, _pos => [$_[0]->from, $_[0]->to], }  if scalar @a > 1;
            return $a[0];
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1967} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token named_regex
*named_regex =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 17943 18163
           (
      
             ## <group>
             ## pos: 17943 17978
              (   ( $pad{I1968} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <alt>
                       ## pos: 17944 17972
                       (
                           ( $pad{I1969} = $pos or 1 )
                           && (
      
                           ## <group>
                           ## pos: 17944 17953
                            (   ( $pad{I1970} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17945 17952
                             ( ( substr( $s, $pos, 5 ) eq 'token' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1970} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1969} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17954 17963
                            (   ( $pad{I1971} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17955 17962
                             ( ( substr( $s, $pos, 5 ) eq 'regex' )
                                 ? ( $pos += 5 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1971} ) && 0 ) )
                           ## </group>
    
                           )
                         || (
                           ( ( $bool = 1 ) && ( $pos = $pad{I1969} ) or 1 )
                           &&   
                           ## <group>
                           ## pos: 17964 17972
                            (   ( $pad{I1972} = $pos or 1 ) &&
    
                             ## <constant>
                             ## pos: 17965 17971
                             ( ( substr( $s, $pos, 4 ) eq 'rule' )
                                 ? ( $pos += 4 or 1 )
                                 : 0
                             )
                             ## </constant>
     ||    ( ( $pos = $pad{I1972} ) && 0 ) )
                           ## </group>
    
                         )
                       )
                       ## </alt>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I1968} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17978 17984
              (   ( $pad{I1973} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 17978 17983
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1973} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 17984 17992
              (   ( $pad{I1974} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 17984 17991
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1974} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 17992 17999
             (
              (   ( $pad{I1975} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 17992 17997
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1975} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 17999 18011
              (   ( $pad{I1976} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 17999 18002
               ( ( substr( $s, $pos, 1 ) eq '{' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1976} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18011 18026
             (
              (   ( $pad{I1977} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18011 18016
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1977} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18026 18037
              (   ( $pad{I1978} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18026 18032
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->rule( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'rule'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1978} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18037 18041
              (   ( $pad{I1979} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18037 18040
               ( ( substr( $s, $pos, 1 ) eq '}' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1979} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18041 18051
             (
              (   ( $pad{I1980} = $pos or 1 ) &&
    
                 ## <constant>
                 ## pos: 18041 18044
                 ( ( substr( $s, $pos, 1 ) eq ';' )
                     ? ( $pos += 1 or 1 )
                     : 0
                 )
                 ## </constant>
     ||    ( ( $pos = $pad{I1980} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18051 18163
              (   ( $pad{I1981} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18051 18162
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => ${ $_[0]->[0] },
                name => ${ $_[0]->{qw(ident)} },
                ast => ${ $_[0]->{qw(rule)} }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1981} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token verbatim
*verbatim =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18225 18347
           (
      
             ## <group>
             ## pos: 18225 18230
              (   ( $pad{I1982} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18225 18229
               ( ( substr( $s, $pos, 2 ) eq '%{' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1982} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18230 18256
              (   ( $pad{I1983} = $pos or 1 ) &&
    
               ## <capture>
               do{
                   my $hash = do {
                     my $bool = 1;
                     my $from = $pos;
                     my @match;
                     my %named;
                     $bool = 0 unless
                       ## <quant>
                       ## pos: 18231 18254
                       do { while (
                        (   ( $pad{I1984} = $pos or 1 ) &&
                           ## <concat>
                           ## pos: 18233 18251
                           (
      
                             ## <group>
                             ## pos: 18233 18249
                              (   ( $pad{I1985} = $pos or 1 ) &&
                               ## <negate>
                               ## pos: 18234 18248
                               do{
                                   my $pos1 = $pos;
                                   do {
                                     my $pos = $pos1;
                                     my $from = $pos;
                                     my @match;
                                     my %named;
                                     $bool = 
                                         ## <before>
                                         ## pos: 18243 18247
                                         do{
                                             my $pos1 = $pos;
                                             do {
                                               my $pos = $pos1;
                                               my $from = $pos;
                                               my @match;
                                               my %named;
                                               $bool = 0 unless
    
                                                   ## <constant>
                                                   ## pos: 18243 18247
                                                   ( ( substr( $s, $pos, 2 ) eq '%}' )
                                                       ? ( $pos += 2 or 1 )
                                                       : 0
                                                   )
                                                   ## </constant>
    ;
                                               $bool;
                                             };
                                         }
                                         ## </before>
     ? 0 : 1;
                                     $bool;
                                   };
                               }
                               ## </negate>
     ||    ( ( $pos = $pad{I1985} ) && 0 ) )
                             ## </group>
    
                           &&
      
                             ## <group>
                             ## pos: 18249 18251
                              (   ( $pad{I1986} = $pos or 1 ) &&
    
                               ## <dot>
                               ## pos: 18249 18250
                               ( substr( $s, $pos++, 1 ) ne '' )
                               ## </dot>
     ||    ( ( $pos = $pad{I1986} ) && 0 ) )
                             ## </group>
    
                           )
                           ## </concat>
     ||    ( ( $pos = $pad{I1984} ) && 0 ) )) {}; $bool = 1 }
                       ## </quant>
    ;
                     { str => \$s, from => \$from, match => \@match, named => \%named, bool => \$bool, to => \(0+$pos), capture => undef }
                   };
                   my $bool = ${$hash->{'bool'}};
                   $match[ 0 ] = Pugs::Runtime::Match->new( $hash );
                   $bool;
               }
               ## </capture>
     ||    ( ( $pos = $pad{I1983} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18256 18265
              (   ( $pad{I1987} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18256 18260
               ( ( substr( $s, $pos, 2 ) eq '%}' )
                   ? ( $pos += 2 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1987} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18265 18347
              (   ( $pad{I1988} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18265 18346
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                type => 'block',
                value => ${ $_[0]->[0] }
            };
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I1988} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token item
*item =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <alt>
           ## pos: 18367 18459
           (
               ( $pad{I1989} = $pos or 1 )
               && (
               ## <concat>
               ## pos: 18368 18415
               (
      
                 ## <group>
                 ## pos: 18368 18386
                  (   ( $pad{I1990} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18369 18379
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'verbatim'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1990} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18386 18415
                  (   ( $pad{I1991} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18386 18410
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(verbatim)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1991} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
               )
             || (
               ( ( $bool = 1 ) && ( $pos = $pad{I1989} ) or 1 )
               &&            ## <concat>
               ## pos: 18416 18459
               (
      
                 ## <group>
                 ## pos: 18416 18431
                  (   ( $pad{I1992} = $pos or 1 ) &&
                   ## <named_capture>
                   ## pos: 18417 18430
                   do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                               $grammar->named_regex( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'named_regex'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                   ## </named_capture>
     ||    ( ( $pos = $pad{I1992} ) && 0 ) )
                 ## </group>
    
               &&
      
                 ## <group>
                 ## pos: 18431 18459
                  (   ( $pad{I1993} = $pos or 1 ) &&
                   ## <closure>
                   ## pos: 18431 18458
                   do {
                     local $::_V6_SUCCEED = 1;
                     $::_V6_MATCH_ = $m;
                     $m->data->{capture} = \( sub { return ${ $_[0]->{qw(named_regex)} }; }->( $m ) ); 
                     $bool = $::_V6_SUCCEED;
                     $::_V6_MATCH_ = $m if $bool; 
                     return $m if $bool; 
                   }
                   ## </closure>
     ||    ( ( $pos = $pad{I1993} ) && 0 ) )
                 ## </group>
    
               )
               ## </concat>
    
             )
           )
           ## </alt>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token grammar
*grammar =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18482 18598
           (
             ## <quant>
             ## pos: 18482 18489
             (
              (   ( $pad{I1994} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18482 18487
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1994} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18489 18499
              (   ( $pad{I1995} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18489 18498
               ( ( substr( $s, $pos, 7 ) eq 'grammar' )
                   ? ( $pos += 7 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1995} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18499 18505
              (   ( $pad{I1996} = $pos or 1 ) &&
               ## <metasyntax>
               ## pos: 18499 18504
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    my $bool = (!$match != 1);
                    $pos = $match->to if $bool;
                    $match;
               }
               ## </metasyntax>
     ||    ( ( $pos = $pad{I1996} ) && 0 ) )
             ## </group>
    
           &&
      
             ## <group>
             ## pos: 18505 18513
              (   ( $pad{I1997} = $pos or 1 ) &&
               ## <named_capture>
               ## pos: 18505 18512
               do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                           $grammar->ident( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { $named{'ident'} = $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
               ## </named_capture>
     ||    ( ( $pos = $pad{I1997} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18513 18520
             (
              (   ( $pad{I1998} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18513 18518
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I1998} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18520 18528
              (   ( $pad{I1999} = $pos or 1 ) &&
    
               ## <constant>
               ## pos: 18520 18523
               ( ( substr( $s, $pos, 1 ) eq ';' )
                   ? ( $pos += 1 or 1 )
                   : 0
               )
               ## </constant>
     ||    ( ( $pos = $pad{I1999} ) && 0 ) )
             ## </group>
    
           &&
             ## <quant>
             ## pos: 18528 18539
             (
              (   ( $pad{I2000} = $pos or 1 ) &&
                 ## <metasyntax>
                 ## pos: 18528 18533
                 do {
                      my $prior = $::_V6_PRIOR_;
                      my $match =
                             $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                      $::_V6_PRIOR_ = $prior;
                      my $bool = (!$match != 1);
                      $pos = $match->to if $bool;
                      $match;
                 }
                 ## </metasyntax>
     ||    ( ( $pos = $pad{I2000} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18539 18562
             do { while (
              (   ( $pad{I2001} = $pos or 1 ) &&
                 ## <concat>
                 ## pos: 18540 18555
                 (
      
                   ## <group>
                   ## pos: 18540 18548
                    (   ( $pad{I2002} = $pos or 1 ) &&
                     ## <named_capture>
                     ## pos: 18541 18547
                     do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                                 $grammar->item( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'item'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                     ## </named_capture>
     ||    ( ( $pos = $pad{I2002} ) && 0 ) )
                   ## </group>
    
                 &&
                   ## <quant>
                   ## pos: 18548 18555
                   (
                    (   ( $pad{I2003} = $pos or 1 ) &&
                       ## <metasyntax>
                       ## pos: 18548 18553
                       do {
                            my $prior = $::_V6_PRIOR_;
                            my $match =
                                   $grammar->ws( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                            $::_V6_PRIOR_ = $prior;
                            my $bool = (!$match != 1);
                            $pos = $match->to if $bool;
                            $match;
                       }
                       ## </metasyntax>
     ||    ( ( $pos = $pad{I2003} ) && 0 ) )
                   || ( $bool = 1 )
                   )
                   ## </quant>
    
                 )
                 ## </concat>
     ||    ( ( $pos = $pad{I2001} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18562 18598
              (   ( $pad{I2004} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18562 18597
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return { ${ $_[0]->{qw(ident)} } => $_[0]->{qw(item)} } }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2004} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;

# token spec
*spec =
    ## <global>
    ## sigspace: 0
    ## ratchet: 1
    do { my $rule; $rule = sub {
      my $grammar = $_[0];
      my $s = $_[1];
      $_[3] = $_[2] unless defined $_[3]; # backwards compat
      no warnings 'substr', 'uninitialized', 'syntax';
      my %pad;
      my $m;
      my $bool;
      my @pos;
      # XXX :pos(X) takes the precedence over :continue ?
      if (defined $_[3]{p}) {
        push @pos, $_[3]{p} || 0;
      } elsif ($_[3]{continue}) {
        push @pos, (pos($_[1]) || 0) .. length($s);
      } else {
        push @pos, 0..length($s);
      }
      for my $pos ( @pos ) {
        my %index;
        my @match;
        my %named;
        $bool = 1;
        $named{KEY} = $_[3]{KEY} if exists $_[3]{KEY};
        $m = Pugs::Runtime::Match->new( {
          str => \$s, from => \(0+$pos), to => \($pos),
          bool => \$bool, match => \@match, named => \%named, capture => undef,
        } );
        {
          my $prior = $::_V6_PRIOR_;
          local $::_V6_PRIOR_ = $prior;
          $bool = 0 unless
           ## <concat>
           ## pos: 18618 18738
           (
             ## <quant>
             ## pos: 18618 18634
             (
              (   ( $pad{I2005} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18618 18628
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->verbatim( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'verbatim'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2005} ) && 0 ) )
             || ( $bool = 1 )
             )
             ## </quant>
    
           &&
             ## <quant>
             ## pos: 18634 18649
             do { while (
              (   ( $pad{I2006} = $pos or 1 ) &&
                 ## <named_capture>
                 ## pos: 18634 18643
                 do {
                    my $prior = $::_V6_PRIOR_;
                    my $match =
                             $grammar->grammar( $s, { p => $pos, positionals => [  ], args => {}, }, undef );
                    $::_V6_PRIOR_ = $prior;
                    if ( $match ) { push @{$named{'grammar'}}, $match;
                        $pos = $match->to;
                        1
                    }
                    else { 0 }
                }
                 ## </named_capture>
     ||    ( ( $pos = $pad{I2006} ) && 0 ) )) {}; $bool = 1 }
             ## </quant>
    
           &&
      
             ## <group>
             ## pos: 18649 18738
              (   ( $pad{I2007} = $pos or 1 ) &&
               ## <closure>
               ## pos: 18649 18737
               do {
                 local $::_V6_SUCCEED = 1;
                 $::_V6_MATCH_ = $m;
                 $m->data->{capture} = \( sub { return {
                block => $_[0]->{qw(verbatim)},
                'grammar' => $_[0]->{qw(grammar)} }
        }->( $m ) ); 
                 $bool = $::_V6_SUCCEED;
                 $::_V6_MATCH_ = $m if $bool; 
                 return $m if $bool; 
               }
               ## </closure>
     ||    ( ( $pos = $pad{I2007} ) && 0 ) )
             ## </group>
    
           )
           ## </concat>
    ;
        }
        if ( $bool ) {
          my $prior = $::_V6_PRIOR_;
          $::_V6_PRIOR_ = sub {
            local $main::_V6_PRIOR_ = $prior;
            $rule->(@_);
          };
          #warn "pos2 = ", $pos, "\n";
          pos($_[1]) = $pos if $_[3]{continue};
          last;
        }
      } # /for
      $::_V6_MATCH_ = $m;
      return $m;
    } }
    ## </global>
;



1;
