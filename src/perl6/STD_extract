#!/usr/bin/perl -w
# A script to extract most parser-related information from STD.pm,
# in a simple "functions" form (runable in perl5/ruby/etc),
# to aid the development of new parsers in p6 bootstrap efforts,
# by making the information more accessible.
# 
# Eg,
#   class Term            does PrecOp[|%term]                   {}
# becomes something like
#   class_does_PrecOp('term');
#
# Why functions and not yaml?  I've found it easier to read and use.
#
# Development
#  Set of constructs recognized (almost?) complete.
#    Rest sufficiently unique to likely to remain residue.
# Todo
#  inherit proto args
#  condition arguments
#  check output is syntactically correct (p5,rb,py?).
#  inquire questions
#  
# Questions
#  why doesn't  token parameter {  have an empty arglist?
#   all other occurances of :my are associated with arglists.
#       Answer: the () was a fossil from when I had to do context vars as parameters because :my hadn't been invented yet.
#  why isn't proto rule  statement_control (:$endsym is context = / \s <nofat> /) { }  instead \s+ ?
#	Answer: because statement control rules will eat \s+ anyway via sigspace, and because this ought to have been a lookahead anyway.
#
# Why am I reinventing cheat/metholate?
#	Answer: I don't know.
#

use warnings;
use strict;
use utf8;
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");
sub print_usage_and_exit {
    print STDERR "Usage: $0 [--data|--rest|--both|--data-sorted|--summary]\n";
    exit(2);
}
my $opt = '--data';
if(@ARGV && $ARGV[0] =~ /^--(\w+)/) {
    $opt = shift;
} else {
    print_usage_and_exit;
}
my $std_file = $ARGV[0] || "./STD.pm";
open(F,"<$std_file") or die $!; binmode(F,":utf8");
my $std = join("",<F>); close(F);
local $_ = $std;

sub remove_clutter {
    s/^ *\#.*\n//mg;
    s/ \# .*//mg;
    s/(?<=\s)\#\'//g;
    #s/^=begin\s+(.*?\S)\s*\n(?:.|\n)*?^=end\s+\1\s*\n//mg;
    # no, eg, =begin perlhints <-> matched by =end perlhints .
    s/^=begin\s+(\S+).*\n(?:.|\n)*?^=end\s+\1.*\n//mg;
    
    # grammar Perl:ver<6.0.0.alpha>:auth<http://perl.org>;
    s/^grammar.*//m;
    # BEGIN { say "compiling STD" }
    s/^BEGIN { say.*//m;
    
    # say "Starting...";   to end-of-file
    s/^say .*//ms;
    
    while(s/\n *\n/\n/g){}
    s/^\n+//;
}
sub quote {
    my($s)=@_;
    $s =~ s/\\/\\\\/g;
    $s =~ s/\'/\\\'/g;
    $s;
}
sub replace_sym {
    my($sym,$s)=@_;
    $sym = quote($sym);
    $s =~ s/<sym>/'$sym'/g; # these '' are for the rx literal.
    $s;
}
sub strip_oneliners { # bad idea - ws is significant.
    my($s)=@_;
    return $s if $s =~ /\n/;
    $s =~ s/^\s+//;
    $s =~ s/\s+$//;
    return $s;
}
sub remove_solo_whatever {
    my($s)=@_;
    my $tmp = $s; $tmp =~ s/{\*\}//; $s = $tmp if $tmp !~ /{\*\}/;
    return $s;
}
sub extract {
    local $_ = $_;
    my $braces = "{([^\n]*?|.*?^)}"; #/sm
    my $out = "";
    my($data,$rest,$both) = ("","","");
    my @data_list;
    my @patterns;
    while (1) {
	if(/\A(class (\w+) +does PrecOp\[\|%(.*?)\] *{} *\n)/) {
	    my($all,$name,$prec)=($1,$2,$3);
	    die "assert" if lc($name) ne $prec;
	    $out .= "class_does_PrecOp('$prec');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A(class (\w+) +does QLang +{(.*?)^} *\n)/sm) {
	    my($all,$name,$block)=($1,$2,$3);
	    $block = quote($block);
	    $out .= "class_does_QLang('$name','$block');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A(constant \%(\w+) += {\s*(.*?\S) *}; *\n)/) {
	    my($all,$name,$prec)=($1,$2,$3);
	    $prec =~ s/ +/ /g;
	    $prec =~ s/:(prec|assoc)<(.*?)>,?/$2/g;
	    $out .= "constant_prec('$name','$prec');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A((multi )?(method|sub) +(\w+) *\(([^\)]*?)\)[ \n]*{(.*?)^} *\n)/sm) {
	    my($all,$multi,$methsub,$name,$args,$block)=($1,($2||""),$3,$4,$5,$6);
	    $multi = 'multi_' if $multi;
	    $args = quote($args);
	    $block = quote($block);
	    $out .= "grammar_$multi$methsub('$name','$args','$block');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A(proto token (\w+) { } *\n)/) {
	    $out .= "proto_token_simple('$2');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(proto (token|rule) +(\w+) \(:\$endsym is context = \/( >> <nofat> )\/\) { } *\n)/) {
	    push(@patterns,$4);
	    $out .= "proto_endsym_nofat_angle_$2('$3');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(proto token (\w+) is defequiv\(%(\w+)\) { } *\n)/) {
	    $out .= "proto_token_defequiv('$2','$3');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(proto (token|rule) +(\w+) \(:\$endsym is context = \/([^\/]+?)\/\) { } *\n)/) {
	    push(@patterns,$4);
	    $out .= "proto_endsym_other_${2}('$3','$4');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(rule statement_control:(\w+) +{( <sym> <block> {\*} )}.*\n)/) {
	    push(@patterns,$3);
	    $out .= "rule_statement_control_block('$2');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(rule statement_control:(\w+) +{ *\n(.*?\n)} *\n)/s) {
	    my($all,$name,$pat)=($1,$2,$3);
	    push(@patterns,$pat);
	    $pat = quote(replace_sym($name,$pat));
	    $out .= "rule_statement_control('$name','$pat');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A(rule statement_mod_(cond|loop):(\w+) +{( <sym> <modifier_expr> {\*} )}.*\n)/) {
	    push(@patterns,$4);
	    $out .= "rule_statement_mod_$2('$3');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(token category:(\w+) +{( <sym> )} *\n)/) {
	    push(@patterns,$3);
	    $out .= "token_category('$2');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A((token|rule) ([a-z_]+):(?:sym. *(\S+?(?: \S+)?) *[Â»>}\]\"\']|(\w+))(?: *\( *--> *(\w+) *\))?[ \n]*$braces(?: *#= ([^\n]+))? *\n(?=\w|\z))/sm) {
	    my($all,$tr,$cat,$sym,$sym2,$type,$pat,$callit)=($1,$2,$3,$4,$5,($6||""),$7,($8||""));
	    push(@patterns,$pat);
	    $sym = $sym2 if not defined($sym);
	    $pat = remove_solo_whatever($pat);
	    $pat = '' if $pat =~ /^\s*<sym>\s*$/;
	    $pat = '' if $pat =~ /^\s*\'\Q$sym\E\'\s*$/;
	    $callit = '' if $callit eq $sym;
	    $pat = quote(replace_sym($sym,$pat));
	    $type = lc $type;
	    $out .= "${tr}_op('$cat','$sym','$type','$pat','$callit');\n";
	    $_ = substr($_,length($all));
	}
	elsif(/\A((token|rule|regex) (\w+)(?: *\(([^\)]*)\))? *$braces *\n)/sm) {
	    my($all,$tr,$name,$args,$pat)=($1,$2,$3,$4,$5);
	    push(@patterns,$pat);
	    $pat = remove_solo_whatever($pat);
	    $pat = quote(replace_sym($name,$pat));
	    if(defined $args) {
		$out .= "${tr}_pattern_with_args('$name','$args','$pat');\n";
	    }else{
		$out .= "${tr}_pattern('$name','$pat');\n";
	    }
	    $_ = substr($_,length($all));
	}
	elsif(/\A(rule statement_prefix:(\w+) +{( <sym> <statement> {\*} )}.*\n)/) {
	    push(@patterns,$3);
	    $out .= "rule_statement_prefix('$2');\n";
	    $_ = substr($_,length($1));
	}
	elsif(/\A(.*\n)/) {
	    $rest .= $1;
	    $both .= $1;
	    $_ = substr($_,length($1));
	}
	elsif(/\A\z/) {
	    last;
	}
	else {
	    die "ERROR: match failed.  File doesnt end in newline?\n$_";
	}
	if($out =~ /^(?!\A)\w/m) {
	    die "BUG: a regex overshot, matching:\n$out";
	}
	$data .= $out;
	$both .= $out;
	push(@data_list,$out);
	$out = "";
    }
    if($opt eq '--data') {
	print $data;
    }
    elsif($opt eq '--both') {
	print $both;
    }
    elsif($opt eq '--rest') {
	print $rest;
    }
    elsif($opt eq '--sorted-data') {
	my @sorted = sort { my $atop = $a=~/^(.+)/;my $btop = $b=~/^(.*)/; $a cmp $b } @data_list;
	print join("",@sorted);
    }
    elsif($opt eq '--summary') {
	open(F,"|grep '^\\w'|sort") or die;
	binmode(F, ":utf8");
	print F $both;
	close(F);
    }
    elsif($opt eq '--pattern-elements') {
	print pattern_analysis(\@patterns)->[1];
    }
    else {
	print_usage_and_exit;
    }
}
sub pattern_analysis {
    my($patterns)=@_;
    my $pats = join("", map{/\n\z/?$_:"$_\n"} @$patterns);
    local $_ = $pats;
    s/ +/ /g;
    s/\n /\n/g;
    my $quote_spaces = sub {my($s)=@_;$s=~s/ /\014/g;$s};
    s/(:my.+)/$quote_spaces->($1)/eg;
    s/((?<!\')#.+)/$quote_spaces->($1)/eg;
    s/(?<=\s)(<[^>]+?>)/$quote_spaces->($1)/eg;
    s/(?<=\s)(\([^>]+?\))/$quote_spaces->($1)/eg;
    s/ /\n/g;
    s/\n+/\n/g;
    s/\014/ /g;
    my $elements = $_;
    return [$pats,$elements];
}

remove_clutter;
extract;
