# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;

package KindaPerl6::Grammar;
sub new { shift; bless {@_}, "KindaPerl6::Grammar" }
use KindaPerl6::Grammar::Regex;
use KindaPerl6::Grammar::Mapping;
use KindaPerl6::Grammar::Control;
use KindaPerl6::Grammar::Parameters;
use KindaPerl6::Grammar::Signature;
use KindaPerl6::Grammar::Term;
use KindaPerl6::Grammar::Statements;
use KindaPerl6::Grammar::Quote;
use KindaPerl6::Grammar::Sub;
use KindaPerl6::Grammar::Token;
my $Class_name;

sub get_class_name {
    my $List__ = \@_;
    do { [] };
    $Class_name;
}

sub ident_digit {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                do {
                    my $pos1 = $MATCH->to();
                    (   do {
                            (   do {
                                    my $pos1 = $MATCH->to();
                                    (   do {
                                            do {
                                                my $m2 = $grammar->word( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                                }
                                            }
                                            || (
                                            do { $MATCH->to($pos1); ( ( '_' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                            || do {
                                                $MATCH->to($pos1);
                                                do {
                                                    my $m2 = $grammar->digit( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                    }
                                            }
                                            )
                                    );
                                    }
                                    && do {
                                    my $m2 = $grammar->ident_digit( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                    }
                            );
                            }
                            || do { $MATCH->to($pos1); 1 }
                    );
                    }
                }
            }
    );
    return ($MATCH);
}

sub ident {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   do {
                                            my $tmp = $MATCH;
                                            $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $tmp->to(), 'to' => $tmp->to(), 'bool' => 1, );
                                            $MATCH->bool(
                                                do {
                                                    my $pos1 = $MATCH->to();
                                                    do {
                                                        do {
                                                            my $m2 = $grammar->digit( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                            }
                                                        }
                                                    }
                                            );
                                            $tmp->bool( ( $MATCH ? 0 : 1 ) );
                                            $MATCH = $tmp;
                                            ( $MATCH ? 1 : 0 );
                                            }
                                            && do {
                                            my $m2 = $grammar->word( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                    );
                                    }
                                    || do { $MATCH->to($pos1); ( ( '_' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                            );
                            }
                            && (
                            do {
                                my $m2 = $grammar->ident_digit( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                            && do {
                                my $pos1 = $MATCH->to();
                                (   do {
                                        (   ( ( ':<' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && (
                                                do {
                                                    my $m2 = $grammar->angle_quoted( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'angle_quoted'} = $m2; 1 }
                                                        else {0}
                                                        }
                                                }
                                                && ( ( '>' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                            )
                                        );
                                        }
                                        || do { $MATCH->to($pos1); 1 }
                                );
                            }
                            )
                    );
                    }
                    || do { $MATCH->to($pos1); ( ( ( 'Â' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( '¢' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) ) }
            );
            }
    );
    return ($MATCH);
}

sub full_ident {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->ident( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                (   ( ( '::' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && do {
                                        my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                            else {0}
                                            }
                                        }
                                );
                                }
                                || do { $MATCH->to($pos1); 1 }
                        );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub namespace {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->ident( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( '::' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $pos1 = $MATCH->to();
                                (   do {
                                        (   do {
                                                my $m2 = $grammar->namespace( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'namespace'} = $m2; 1 }
                                                    else {0}
                                                    }
                                                }
                                                && do {
                                                my $ret = sub {
                                                    my $List__ = \@_;
                                                    do { [] };
                                                    do { return ( [ ${ $MATCH->{'ident'} }, @{ ${ $MATCH->{'namespace'} } } ] ) };
                                                    '974^213';
                                                    }
                                                    ->();
                                                do {
                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                    else { }
                                                };
                                                1;
                                                }
                                        );
                                        }
                                        || do {
                                        $MATCH->to($pos1);
                                        do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do { return ( [ ${ $MATCH->{'ident'} } ] ) };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                            }
                                        }
                                );
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( [] ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub to_line_end {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->not_newline( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                            }
                    );
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub pod_begin {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->newline( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( '=end' eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   ( ( '' ne substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            do {
                                my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                            && do {
                                my $m2 = $grammar->pod_begin( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                        )
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub pod_other {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->newline( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( '=cut' eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                            )
                    );
                    }
                    || (
                    do {
                        $MATCH->to($pos1);
                        (   do {
                                my $m2 = $grammar->newline( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                                }
                                && (
                                ( ( '=end' eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) && do {
                                    my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                }
                                )
                        );
                    }
                    || do {
                        $MATCH->to($pos1);
                        (   ( ( '' ne substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                do {
                                    my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                }
                                && do {
                                    my $m2 = $grammar->pod_other( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                }
                            )
                        );
                    }
                    )
            );
            }
    );
    return ($MATCH);
}

sub ws {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                (   ( ( '#' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                        my $m2 = $grammar->to_line_end( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                            else {0}
                                            }
                                        }
                                );
                                }
                                || (
                                do {
                                    $MATCH->to($pos1);
                                    (   do {
                                            my $m2 = $grammar->newline( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                            && do {
                                            my $pos1 = $MATCH->to();
                                            (   do {
                                                    (   ( ( '=begin' eq substr( $str, $MATCH->to(), 6 ) ) ? ( 1 + $MATCH->to( ( 6 + $MATCH->to() ) ) ) : 0 ) && do {
                                                            my $m2 = $grammar->pod_begin( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                            }
                                                    );
                                                    }
                                                    || (
                                                    do {
                                                        $MATCH->to($pos1);
                                                        (   ( ( '=kwid' eq substr( $str, $MATCH->to(), 5 ) ) ? ( 1 + $MATCH->to( ( 5 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                my $m2 = $grammar->pod_other( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                                }
                                                        );
                                                    }
                                                    || (do {
                                                            $MATCH->to($pos1);
                                                            (   ( ( '=pod' eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                    my $m2 = $grammar->pod_other( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                        else {0}
                                                                        }
                                                                    }
                                                            );
                                                        }
                                                        || (do {
                                                                $MATCH->to($pos1);
                                                                (   ( ( '=for' eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                        my $m2 = $grammar->pod_other( $str, $MATCH->to() );
                                                                        do {
                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                            else {0}
                                                                            }
                                                                        }
                                                                );
                                                            }
                                                            || (do {
                                                                    $MATCH->to($pos1);
                                                                    (   ( ( '=head1' eq substr( $str, $MATCH->to(), 6 ) ) ? ( 1 + $MATCH->to( ( 6 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                            my $m2 = $grammar->pod_other( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                else {0}
                                                                                }
                                                                            }
                                                                    );
                                                                }
                                                                || do { $MATCH->to($pos1); 1 }
                                                            )
                                                        )
                                                    )
                                                    )
                                            );
                                            }
                                    );
                                }
                                || do {
                                    $MATCH->to($pos1);
                                    do {
                                        my $m2 = $grammar->space( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                            else {0}
                                            }
                                        }
                                }
                                )
                        );
                        }
                        && do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                do {
                                    my $m2 = $grammar->ws( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                    }
                                }
                                || do { $MATCH->to($pos1); 1 }
                        );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub opt_ws {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    do {
                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                            else {0}
                            }
                        }
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub opt_ws2 {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    do {
                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                            else {0}
                            }
                        }
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub opt_ws3 {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    do {
                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                            else {0}
                            }
                        }
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub parse {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->comp_unit( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'comp_unit'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   do {
                                            my $m2 = $grammar->parse( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'parse'} = $m2; 1 }
                                                else {0}
                                                }
                                            }
                                            && do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do { return ( [ ${ $MATCH->{'comp_unit'} }, @{ ${ $MATCH->{'parse'} } } ] ) };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                            }
                                    );
                                    }
                                    || do {
                                    $MATCH->to($pos1);
                                    do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( [ ${ $MATCH->{'comp_unit'} } ] ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                        }
                                    }
                            );
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( [] ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub unit_type {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( 'class' eq substr( $str, $MATCH->to(), 5 ) ) ? ( 1 + $MATCH->to( ( 5 + $MATCH->to() ) ) ) : 0 ) }
                    || (
                    do { $MATCH->to($pos1); ( ( 'grammar' eq substr( $str, $MATCH->to(), 7 ) ) ? ( 1 + $MATCH->to( ( 7 + $MATCH->to() ) ) ) : 0 ) }
                    || (do    { $MATCH->to($pos1); ( ( 'role'   eq substr( $str, $MATCH->to(), 4 ) ) ? ( 1 + $MATCH->to( ( 4 + $MATCH->to() ) ) ) : 0 ) }
                        || do { $MATCH->to($pos1); ( ( 'module' eq substr( $str, $MATCH->to(), 6 ) ) ? ( 1 + $MATCH->to( ( 6 + $MATCH->to() ) ) ) : 0 ) }
                    )
                    )
            );
            }
    );
    return ($MATCH);
}

sub trait_auxiliary {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( ( 'i' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( 's' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) ) }
                    || (
                    do {
                        $MATCH->to($pos1);
                        (   ( ( 'd' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                && ( ( ( 'o' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                && ( ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( 's' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) ) )
                        );
                    }
                    || do {
                        $MATCH->to($pos1);
                        (   ( ( 'm' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                && ( ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                && ( ( ( 't' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( 'a' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) ) )
                        );
                    }
                    )
            );
            }
    );
    return ($MATCH);
}

sub class_trait {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->trait_auxiliary( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'trait_auxiliary'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && (
                        do {
                            my $m2 = $grammar->ws( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                        }
                        && (do {
                                my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                    else {0}
                                    }
                            }
                            && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( [ ${ $MATCH->{'trait_auxiliary'} }, ${ $MATCH->{'full_ident'} } ] ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                        )
                );
                }
            }
    );
    return ($MATCH);
}

sub class_traits {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->class_trait( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'class_trait'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   do {
                                            my $m2 = $grammar->ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                            && (
                                            do {
                                                my $m2 = $grammar->class_traits( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'class_traits'} = $m2; 1 }
                                                    else {0}
                                                    }
                                            }
                                            && do {
                                                my $ret = sub {
                                                    my $List__ = \@_;
                                                    do { [] };
                                                    do { return ( [ ${ $MATCH->{'class_trait'} }, @{ ${ $MATCH->{'class_traits'} } } ] ) };
                                                    '974^213';
                                                    }
                                                    ->();
                                                do {
                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                    else { }
                                                };
                                                1;
                                            }
                                            )
                                    );
                                    }
                                    || do {
                                    $MATCH->to($pos1);
                                    do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( [ ${ $MATCH->{'class_trait'} } ] ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                        }
                                    }
                            );
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( [] ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub comp_unit {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                else {0}
                                }
                            }
                            && (
                            do {
                                my $pos1 = $MATCH->to();
                                (   do {
                                        (   ( ( ';' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                                }
                                        );
                                        }
                                        || do { $MATCH->to($pos1); 1 }
                                );
                            }
                            && (do {
                                    my $pos1 = $MATCH->to();
                                    (   do {
                                            (   ( ( 'use' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) && (
                                                    do {
                                                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (( ( 'v6-' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) && (
                                                            do {
                                                                my $m2 = $grammar->ident( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && (( ( ';' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                                        do {
                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                            else {0}
                                                                            }
                                                                    }
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            );
                                            }
                                            || do { $MATCH->to($pos1); 1 }
                                    );
                                }
                                && do {
                                    my $pos1 = $MATCH->to();
                                    do {
                                        (   do {
                                                my $m2 = $grammar->unit_type( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'unit_type'} = $m2; 1 }
                                                    else {0}
                                                    }
                                                }
                                                && (
                                                do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $m2 = $grammar->class_traits( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'class_traits'} = $m2; 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && (( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                        do {
                                                                            my $ret = sub {
                                                                                my $List__ = \@_;
                                                                                do { [] };
                                                                                do { $Class_name = ( "" . $MATCH->{'full_ident'} ) };
                                                                                '974^213';
                                                                                }
                                                                                ->();
                                                                            do {
                                                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                else { }
                                                                            };
                                                                            1;
                                                                        }
                                                                        && (do {
                                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && (do {
                                                                                    my $ret = sub {
                                                                                        my $List__ = \@_;
                                                                                        do { [] };
                                                                                        do { COMPILER::add_pad($Class_name) };
                                                                                        '974^213';
                                                                                        }
                                                                                        ->();
                                                                                    do {
                                                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                        else { }
                                                                                    };
                                                                                    1;
                                                                                }
                                                                                && (do {
                                                                                        my $m2 = $grammar->exp_stmts( $str, $MATCH->to() );
                                                                                        do {
                                                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_stmts'} = $m2; 1 }
                                                                                            else {0}
                                                                                            }
                                                                                    }
                                                                                    && (do {
                                                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                            do {
                                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                else {0}
                                                                                                }
                                                                                        }
                                                                                        && (( ( '}' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                                do {
                                                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                                    do {
                                                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                        else {0}
                                                                                                        }
                                                                                                }
                                                                                                && (do {
                                                                                                        my $pos1 = $MATCH->to();
                                                                                                        (   do {
                                                                                                                (   ( ( ';' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                                                        do {
                                                                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                                            else {0}
                                                                                                                            }
                                                                                                                        }
                                                                                                                );
                                                                                                                }
                                                                                                                || do { $MATCH->to($pos1); 1 }
                                                                                                        );
                                                                                                    }
                                                                                                    && do {
                                                                                                        my $ret = sub {
                                                                                                            my $List__ = \@_;
                                                                                                            do { [] };
                                                                                                            do {
                                                                                                                my $env = COMPILER::current_pad();
                                                                                                                COMPILER::drop_pad();
                                                                                                                return (
                                                                                                                    CompUnit->new(
                                                                                                                        'unit_type'  => ${ $MATCH->{'unit_type'} },
                                                                                                                        'name'       => ${ $MATCH->{'full_ident'} },
                                                                                                                        'traits'     => ${ $MATCH->{'class_traits'} },
                                                                                                                        'attributes' => {},
                                                                                                                        'methods'    => {},
                                                                                                                        'body'       => Lit::Code->new(
                                                                                                                            'pad'   => $env,
                                                                                                                            'state' => {},
                                                                                                                            'sig'   => Sig->new( 'invocant' => (undef), 'positional' => [], ),
                                                                                                                            'body'  => ${ $MATCH->{'exp_stmts'} },
                                                                                                                        ),
                                                                                                                    )
                                                                                                                );
                                                                                                            };
                                                                                                            '974^213';
                                                                                                            }
                                                                                                            ->();
                                                                                                        do {
                                                                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                                            else { }
                                                                                                        };
                                                                                                        1;
                                                                                                    }
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                )
                                        );
                                        }
                                }
                            )
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $pos1 = $MATCH->to();
                        do {
                            (   do {
                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                    }
                                    && (
                                    do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { $Class_name = 'Main'; COMPILER::add_pad($Class_name) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                    }
                                    && (do {
                                            my $m2 = $grammar->exp_stmts2( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_stmts2'} = $m2; 1 }
                                                else {0}
                                                }
                                        }
                                        && do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do {
                                                    my $env = COMPILER::current_pad();
                                                    COMPILER::drop_pad();
                                                    return (
                                                        CompUnit->new(
                                                            'unit_type'  => 'module',
                                                            'name'       => 'Main',
                                                            'traits'     => [],
                                                            'attributes' => {},
                                                            'methods'    => {},
                                                            'body'       => Lit::Code->new( 'pad' => $env, 'state' => {}, 'sig' => Sig->new( 'invocant' => (undef), 'positional' => [], ), 'body' => ${ $MATCH->{'exp_stmts2'} }, ),
                                                        )
                                                    );
                                                };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                        }
                                    )
                                    )
                            );
                            }
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub infix_op {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( '+' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                    || (
                    do { $MATCH->to($pos1); ( ( '-' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                    || (do { $MATCH->to($pos1); ( ( '*' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                        || (do { $MATCH->to($pos1); ( ( '//' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                            || (do { $MATCH->to($pos1); ( ( '/' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                || (do {
                                        $MATCH->to($pos1);
                                        ( ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( 'q' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) );
                                    }
                                    || (do {
                                            $MATCH->to($pos1);
                                            ( ( ( 'n' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) );
                                        }
                                        || (do { $MATCH->to($pos1); ( ( '==' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                            || (do { $MATCH->to($pos1); ( ( '!=' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                || (do { $MATCH->to($pos1); ( ( '&&' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                    || (do { $MATCH->to($pos1); ( ( '||' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                        || (do { $MATCH->to($pos1); ( ( '~~' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                            || (do { $MATCH->to($pos1); ( ( '~' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                || (do { $MATCH->to($pos1); ( ( '<=>' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) }
                                                                    || (do { $MATCH->to($pos1); ( ( '<=' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                                        || (do { $MATCH->to($pos1); ( ( '>=' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                                            || (do { $MATCH->to($pos1); ( ( '<' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                || (do { $MATCH->to($pos1); ( ( '>' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                    || (do { $MATCH->to($pos1); ( ( '&' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                        || (do { $MATCH->to($pos1); ( ( '^' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                            || (do { $MATCH->to($pos1); ( ( '|' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                                || (do { $MATCH->to($pos1); ( ( '..' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                                                                    || (do    { $MATCH->to($pos1); ( ( 'but' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) }
                                                                                                        || do { $MATCH->to($pos1); ( ( 'x'   eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    )
            );
            }
    );
    return ($MATCH);
}

sub hyper_op {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( '>>' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub prefix_op {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $pos1 = $MATCH->to();
                        (   do { ( ( '$' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                || (
                                do { $MATCH->to($pos1); ( ( '@' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                || (do { $MATCH->to($pos1); ( ( '%' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                    || (do { $MATCH->to($pos1); ( ( '?' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                        || (do { $MATCH->to($pos1); ( ( '!' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                            || (do { $MATCH->to($pos1); ( ( '++' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                || (do { $MATCH->to($pos1); ( ( '--' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                    || (do { $MATCH->to($pos1); ( ( '+' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                        || (do { $MATCH->to($pos1); ( ( '-' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                            || (do    { $MATCH->to($pos1); ( ( '~' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                || do { $MATCH->to($pos1); ( ( '|' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                )
                        );
                        }
                        && do {
                        my $tmp = $MATCH;
                        $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $tmp->to(), 'to' => $tmp->to(), 'bool' => 1, );
                        $MATCH->bool(
                            do {
                                my $pos1 = $MATCH->to();
                                (   do { ( ( '$' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                        || (
                                        do { $MATCH->to($pos1); ( ( '@' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                        || (do { $MATCH->to($pos1); ( ( '%' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                            || (do { $MATCH->to($pos1); ( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                || (do    { $MATCH->to($pos1); ( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                    || do { $MATCH->to($pos1); ( ( '[' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                )
                                            )
                                        )
                                        )
                                );
                                }
                        );
                        $tmp->bool( ( $MATCH ? 1 : 0 ) );
                        $MATCH = $tmp;
                        ( $MATCH ? 1 : 0 );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub declarator {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( 'my' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                    || (
                    do { $MATCH->to($pos1); ( ( 'state' eq substr( $str, $MATCH->to(), 5 ) ) ? ( 1 + $MATCH->to( ( 5 + $MATCH->to() ) ) ) : 0 ) }
                    || (do    { $MATCH->to($pos1); ( ( 'has' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) }
                        || do { $MATCH->to($pos1); ( ( 'our' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) }
                    )
                    )
            );
            }
    );
    return ($MATCH);
}

sub opt_declarator {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->declarator( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'declarator'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            do {
                                my $m2 = $grammar->ws( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                    else {0}
                                    }
                            }
                            && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( ${ $MATCH->{'declarator'} } ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ('') };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub exp2 {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->exp( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( ${ $MATCH->{'exp'} } ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub exp {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->term_meth( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'term_meth'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                (   do {
                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                            else {0}
                                            }
                                        }
                                        && (
                                        ( ( '??' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && do {
                                            my $pos1 = $MATCH->to();
                                            (   do {
                                                    (   do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                            }
                                                            && (
                                                            do {
                                                                my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && (do {
                                                                        my $pos1 = $MATCH->to();
                                                                        (   do {
                                                                                (   ( ( '::' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                                        my $ret = sub {
                                                                                            my $List__ = \@_;
                                                                                            do { [] };
                                                                                            do { die('maybe you mean ternary:<?? !!>') };
                                                                                            '974^213';
                                                                                            }
                                                                                            ->();
                                                                                        do {
                                                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                            else { }
                                                                                        };
                                                                                        1;
                                                                                        }
                                                                                );
                                                                                }
                                                                                || do { $MATCH->to($pos1); ( ( '!!' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                                                        );
                                                                    }
                                                                    && (do {
                                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                else {0}
                                                                                }
                                                                        }
                                                                        && (do {
                                                                                my $m2 = $grammar->exp2( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp2'} = $m2; 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && do {
                                                                                my $ret = sub {
                                                                                    my $List__ = \@_;
                                                                                    do { [] };
                                                                                    do {
                                                                                        my $macro_ast = Var->new( 'sigil' => '&', 'twigil' => '', 'name' => 'ternary:<?? !!>', 'namespace' => [], );
                                                                                        my $macro = COMPILER::get_var($macro_ast);
                                                                                        do {
                                                                                            if ( defined($macro) ) {
                                                                                                my $sub = COMPILER::current_pad()->eval_ast($macro_ast);
                                                                                                Main::expand_macro( $sub, ${ $MATCH->{'term_meth'} }, ${ $MATCH->{'exp'} }, ${ $MATCH->{'exp2'} } );
                                                                                            }
                                                                                            else { }
                                                                                        };
                                                                                        return (
                                                                                            Apply->new(
                                                                                                'code'      => Var->new( 'sigil'             => '&',               'twigil' => '', 'name' => 'ternary:<?? !!>', 'namespace' => [], ),
                                                                                                'arguments' => [ ${ $MATCH->{'term_meth'} }, ${ $MATCH->{'exp'} }, ${ $MATCH->{'exp2'} } ],
                                                                                            )
                                                                                        );
                                                                                    };
                                                                                    '974^213';
                                                                                    }
                                                                                    ->();
                                                                                do {
                                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                    else { }
                                                                                };
                                                                                1;
                                                                            }
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            )
                                                    );
                                                    }
                                                    || do {
                                                    $MATCH->to($pos1);
                                                    do {
                                                        my $ret = sub {
                                                            my $List__ = \@_;
                                                            do { [] };
                                                            do { Main::say('*** Syntax error in ternary operation') };
                                                            '974^213';
                                                            }
                                                            ->();
                                                        do {
                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                            else { }
                                                        };
                                                        1;
                                                        }
                                                    }
                                            );
                                        }
                                        )
                                );
                                }
                                || (
                                do {
                                    $MATCH->to($pos1);
                                    (   do {
                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                            && (
                                            do {
                                                my $m2 = $grammar->infix_op( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'infix_op'} = $m2; 1 }
                                                    else {0}
                                                    }
                                            }
                                            && (do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && do {
                                                        my $ret = sub {
                                                            my $List__ = \@_;
                                                            do { [] };
                                                            do {
                                                                return (
                                                                    Apply->new(
                                                                        'code' => Var->new( 'sigil' => '&', 'twigil' => '', 'name' => ( 'infix:<' . ( $MATCH->{'infix_op'} . '>' ) ), 'namespace' => [], ),
                                                                        'arguments' => [ ${ $MATCH->{'term_meth'} }, ${ $MATCH->{'exp'} } ],
                                                                    )
                                                                );
                                                            };
                                                            '974^213';
                                                            }
                                                            ->();
                                                        do {
                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                            else { }
                                                        };
                                                        1;
                                                    }
                                                )
                                            )
                                            )
                                    );
                                }
                                || (do {
                                        $MATCH->to($pos1);
                                        (   do {
                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                                }
                                                && (
                                                ( ( '::=' eq substr( $str, $MATCH->to(), 3 ) ) ? ( 1 + $MATCH->to( ( 3 + $MATCH->to() ) ) ) : 0 ) && (
                                                    do {
                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && do {
                                                            my $ret = sub {
                                                                my $List__ = \@_;
                                                                do { [] };
                                                                do { my $bind = Bind->new( 'parameters' => ${ $MATCH->{'term_meth'} }, 'arguments' => ${ $MATCH->{'exp'} }, ); COMPILER::begin_block($bind); return ($bind) };
                                                                '974^213';
                                                                }
                                                                ->();
                                                            do {
                                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                else { }
                                                            };
                                                            1;
                                                        }
                                                    )
                                                )
                                                )
                                        );
                                    }
                                    || (do {
                                            $MATCH->to($pos1);
                                            (   do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                    }
                                                    && (
                                                    ( ( ':=' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && (
                                                        do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && do {
                                                                my $ret = sub {
                                                                    my $List__ = \@_;
                                                                    do { [] };
                                                                    do { return ( Bind->new( 'parameters' => ${ $MATCH->{'term_meth'} }, 'arguments' => ${ $MATCH->{'exp'} }, ) ) };
                                                                    '974^213';
                                                                    }
                                                                    ->();
                                                                do {
                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                    else { }
                                                                };
                                                                1;
                                                            }
                                                        )
                                                    )
                                                    )
                                            );
                                        }
                                        || (do {
                                                $MATCH->to($pos1);
                                                (   do {
                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                        }
                                                        && (
                                                        ( ( '=' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                            do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && do {
                                                                    my $ret = sub {
                                                                        my $List__ = \@_;
                                                                        do { [] };
                                                                        do { return ( Assign->new( 'parameters' => ${ $MATCH->{'term_meth'} }, 'arguments' => ${ $MATCH->{'exp'} }, ) ) };
                                                                        '974^213';
                                                                        }
                                                                        ->();
                                                                    do {
                                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                        else { }
                                                                    };
                                                                    1;
                                                                }
                                                            )
                                                        )
                                                        )
                                                );
                                            }
                                            || do {
                                                $MATCH->to($pos1);
                                                do {
                                                    my $ret = sub {
                                                        my $List__ = \@_;
                                                        do { [] };
                                                        do { return ( ${ $MATCH->{'term_meth'} } ) };
                                                        '974^213';
                                                        }
                                                        ->();
                                                    do {
                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                        else { }
                                                    };
                                                    1;
                                                    }
                                            }
                                        )
                                    )
                                )
                                )
                        );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub opt_ident {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->ident( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return ( ${ $MATCH->{'ident'} } ) };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   1 && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return ('postcircumfix:<( )>') };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub term_meth {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $pos1 = $MATCH->to();
                            do {
                                (   ( ( '.' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        do {
                                            my $m2 = $grammar->hyper_op( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'hyper_op'} = $m2; 1 }
                                                else {0}
                                                }
                                        }
                                        && (do {
                                                my $m2 = $grammar->ident( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                                    else {0}
                                                    }
                                            }
                                            && (do {
                                                    my $pos1 = $MATCH->to();
                                                    (   do {
                                                            (   ( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                    do {
                                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                        do {
                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                            else {0}
                                                                            }
                                                                    }
                                                                    && (do {
                                                                            my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                                else {0}
                                                                                }
                                                                        }
                                                                        && (do {
                                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && ( ( ')' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                                                        )
                                                                    )
                                                                )
                                                            );
                                                            }
                                                            || (
                                                            do {
                                                                $MATCH->to($pos1);
                                                                (   ( ( ':' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                        do {
                                                                            my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                else {0}
                                                                                }
                                                                        }
                                                                        && (do {
                                                                                my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && do {
                                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                        )
                                                                    )
                                                                );
                                                            }
                                                            || do {
                                                                $MATCH->to($pos1);
                                                                do {
                                                                    my $ret = sub {
                                                                        my $List__ = \@_;
                                                                        do { [] };
                                                                        do {
                                                                            return (
                                                                                Call->new(
                                                                                    'invocant'  => Proto->new( 'name' => ( "" . $MATCH->{'full_ident'} ), ),
                                                                                    'method'    => ${ $MATCH->{'ident'} },
                                                                                    'arguments' => (undef),
                                                                                    'hyper'     => ${ $MATCH->{'hyper_op'} },
                                                                                )
                                                                            );
                                                                        };
                                                                        '974^213';
                                                                        }
                                                                        ->();
                                                                    do {
                                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                        else { }
                                                                    };
                                                                    1;
                                                                    }
                                                            }
                                                            )
                                                    );
                                                }
                                                && do {
                                                    my $ret = sub {
                                                        my $List__ = \@_;
                                                        do { [] };
                                                        do {
                                                            return (
                                                                Call->new(
                                                                    'invocant'  => Proto->new( 'name' => ( "" . $MATCH->{'full_ident'} ), ),
                                                                    'method'    => ${ $MATCH->{'ident'} },
                                                                    'arguments' => ${ $MATCH->{'exp_parameter_list'} },
                                                                    'hyper'     => ${ $MATCH->{'hyper_op'} },
                                                                )
                                                            );
                                                        };
                                                        '974^213';
                                                        }
                                                        ->();
                                                    do {
                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                        else { }
                                                    };
                                                    1;
                                                }
                                            )
                                        )
                                    )
                                );
                                }
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   do {
                            my $m2 = $grammar->term( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'term'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   ( ( '.' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                            do {
                                                my $m2 = $grammar->hyper_op( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'hyper_op'} = $m2; 1 }
                                                    else {0}
                                                    }
                                            }
                                            && (do {
                                                    my $m2 = $grammar->opt_ident( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'opt_ident'} = $m2; 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $pos1 = $MATCH->to();
                                                        (   do {
                                                                (   ( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                        do {
                                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                else {0}
                                                                                }
                                                                        }
                                                                        && (do {
                                                                                my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && (do {
                                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                    do {
                                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                        else {0}
                                                                                        }
                                                                                }
                                                                                && ( ( ')' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                                                            )
                                                                        )
                                                                    )
                                                                );
                                                                }
                                                                || (
                                                                do {
                                                                    $MATCH->to($pos1);
                                                                    (   ( ( ':' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                            do {
                                                                                my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                    else {0}
                                                                                    }
                                                                            }
                                                                            && (do {
                                                                                    my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                                    do {
                                                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                                        else {0}
                                                                                        }
                                                                                }
                                                                                && do {
                                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                    do {
                                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                        else {0}
                                                                                        }
                                                                                }
                                                                            )
                                                                        )
                                                                    );
                                                                }
                                                                || do {
                                                                    $MATCH->to($pos1);
                                                                    do {
                                                                        my $ret = sub {
                                                                            my $List__ = \@_;
                                                                            do { [] };
                                                                            do { return ( Call->new( 'invocant' => ${ $MATCH->{'term'} }, 'method' => ${ $MATCH->{'opt_ident'} }, 'arguments' => (undef), 'hyper' => ${ $MATCH->{'hyper_op'} }, ) ) };
                                                                            '974^213';
                                                                            }
                                                                            ->();
                                                                        do {
                                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                            else { }
                                                                        };
                                                                        1;
                                                                        }
                                                                }
                                                                )
                                                        );
                                                    }
                                                    && do {
                                                        my $ret = sub {
                                                            my $List__ = \@_;
                                                            do { [] };
                                                            do {
                                                                return (
                                                                    Call->new( 'invocant' => ${ $MATCH->{'term'} }, 'method' => ${ $MATCH->{'opt_ident'} }, 'arguments' => ${ $MATCH->{'exp_parameter_list'} }, 'hyper' => ${ $MATCH->{'hyper_op'} }, ) );
                                                            };
                                                            '974^213';
                                                            }
                                                            ->();
                                                        do {
                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                            else { }
                                                        };
                                                        1;
                                                    }
                                                )
                                            )
                                        )
                                    );
                                    }
                                    || (
                                    do {
                                        $MATCH->to($pos1);
                                        (   ( ( '[' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (( ( ']' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                my $ret = sub {
                                                                    my $List__ = \@_;
                                                                    do { [] };
                                                                    do { return ( Call->new( 'invocant' => ${ $MATCH->{'term'} }, 'arguments' => [ ${ $MATCH->{'exp'} } ], 'method' => 'INDEX', 'hyper' => '', ) ) };
                                                                    '974^213';
                                                                    }
                                                                    ->();
                                                                do {
                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                    else { }
                                                                };
                                                                1;
                                                            }
                                                        )
                                                    )
                                                )
                                            )
                                        );
                                    }
                                    || (do {
                                            $MATCH->to($pos1);
                                            (   ( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                    do {
                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->exp( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (( ( '}' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                    my $ret = sub {
                                                                        my $List__ = \@_;
                                                                        do { [] };
                                                                        do { return ( Call->new( 'invocant' => ${ $MATCH->{'term'} }, 'arguments' => [ ${ $MATCH->{'exp'} } ], 'method' => 'LOOKUP', 'hyper' => '', ) ) };
                                                                        '974^213';
                                                                        }
                                                                        ->();
                                                                    do {
                                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                        else { }
                                                                    };
                                                                    1;
                                                                }
                                                            )
                                                        )
                                                    )
                                                )
                                            );
                                        }
                                        || (do {
                                                $MATCH->to($pos1);
                                                (   ( ( '<' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                        do {
                                                            my $m2 = $grammar->angle_quoted( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'angle_quoted'} = $m2; 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (( ( '>' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                my $ret = sub {
                                                                    my $List__ = \@_;
                                                                    do { [] };
                                                                    do {
                                                                        return (
                                                                            Call->new( 'invocant' => ${ $MATCH->{'term'} }, 'arguments' => [ Val::Buf->new( 'buf' => ( "" . $MATCH->{'angle_quoted'} ), ) ], 'method' => 'LOOKUP', 'hyper' => '', ) );
                                                                    };
                                                                    '974^213';
                                                                    }
                                                                    ->();
                                                                do {
                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                    else { }
                                                                };
                                                                1;
                                                            }
                                                        )
                                                    )
                                                );
                                            }
                                            || do {
                                                $MATCH->to($pos1);
                                                do {
                                                    my $ret = sub {
                                                        my $List__ = \@_;
                                                        do { [] };
                                                        do { return ( ${ $MATCH->{'term'} } ) };
                                                        '974^213';
                                                        }
                                                        ->();
                                                    do {
                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                        else { }
                                                    };
                                                    1;
                                                    }
                                            }
                                        )
                                    )
                                    )
                            );
                            }
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub sub_or_method_name {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                (   ( ( '.' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                        my $m2 = $grammar->ident( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                            else {0}
                                            }
                                        }
                                );
                                }
                                || do { $MATCH->to($pos1); 1 }
                        );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub opt_type {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $pos1 = $MATCH->to();
                            (   do { ( ( '::' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) }
                                    || do { $MATCH->to($pos1); 1 }
                            );
                            }
                            && (
                            do {
                                my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                    else {0}
                                    }
                            }
                            && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( ${ $MATCH->{'full_ident'} } ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   1 && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return ('') };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub use_from_perl5 {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   ( ( ':from<perl5>' eq substr( $str, $MATCH->to(), 12 ) ) ? ( 1 + $MATCH->to( ( 12 + $MATCH->to() ) ) ) : 0 ) && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return (1) };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return (0) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub sigil {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do { ( ( '$' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                    || (
                    do { $MATCH->to($pos1); ( ( '%' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                    || (do    { $MATCH->to($pos1); ( ( '@' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                        || do { $MATCH->to($pos1); ( ( '&' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                    )
                    )
            );
            }
    );
    return ($MATCH);
}

sub twigil {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    do {
                        my $pos1 = $MATCH->to();
                        (   do { ( ( '.' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                || (
                                do { $MATCH->to($pos1); ( ( '!' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                || (do    { $MATCH->to($pos1); ( ( '^' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                    || do { $MATCH->to($pos1); ( ( '*' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                )
                                )
                        );
                        }
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub undeclared_var {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->sigil( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'sigil'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && (
                        do {
                            my $m2 = $grammar->twigil( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'twigil'} = $m2; 1 }
                                else {0}
                                }
                        }
                        && (do {
                                my $m2 = $grammar->namespace( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'namespace'} = $m2; 1 }
                                    else {0}
                                    }
                            }
                            && (do {
                                    my $m2 = $grammar->ident( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                        else {0}
                                        }
                                }
                                && do {
                                    my $ret = sub {
                                        my $List__ = \@_;
                                        do { [] };
                                        do { return ( Var->new( 'sigil' => ( "" . $MATCH->{'sigil'} ), 'twigil' => ( "" . $MATCH->{'twigil'} ), 'name' => ( "" . $MATCH->{'ident'} ), 'namespace' => ${ $MATCH->{'namespace'} }, ) ) };
                                        '974^213';
                                        }
                                        ->();
                                    do {
                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                        else { }
                                    };
                                    1;
                                }
                            )
                        )
                        )
                );
                }
            }
    );
    return ($MATCH);
}

sub var {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->sigil( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'sigil'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( '/' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( Var->new( 'sigil' => ( "" . $MATCH->{'sigil'} ), 'twigil' => '', 'name' => '/', 'namespace' => [], ) ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   do {
                            my $m2 = $grammar->sigil( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'sigil'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            do {
                                my $m2 = $grammar->twigil( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'twigil'} = $m2; 1 }
                                    else {0}
                                    }
                            }
                            && (do {
                                    my $m2 = $grammar->namespace( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'namespace'} = $m2; 1 }
                                        else {0}
                                        }
                                }
                                && (do {
                                        my $m2 = $grammar->ident( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                            else {0}
                                            }
                                    }
                                    && do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do {
                                                return (
                                                    COMPILER::get_var( Var->new( 'sigil' => ( "" . $MATCH->{'sigil'} ), 'twigil' => ( "" . $MATCH->{'twigil'} ), 'name' => ( "" . $MATCH->{'ident'} ), 'namespace' => ${ $MATCH->{'namespace'} }, ) ) );
                                            };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                    }
                                )
                            )
                            )
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub val {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->val_undef( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'val_undef'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return ( ${ $MATCH->{'val_undef'} } ) };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
                    || (
                    do {
                        $MATCH->to($pos1);
                        (   do {
                                my $m2 = $grammar->val_int( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'val_int'} = $m2; 1 }
                                    else {0}
                                    }
                                }
                                && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( ${ $MATCH->{'val_int'} } ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                                }
                        );
                    }
                    || (do {
                            $MATCH->to($pos1);
                            (   do {
                                    my $m2 = $grammar->val_bit( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'val_bit'} = $m2; 1 }
                                        else {0}
                                        }
                                    }
                                    && do {
                                    my $ret = sub {
                                        my $List__ = \@_;
                                        do { [] };
                                        do { return ( ${ $MATCH->{'val_bit'} } ) };
                                        '974^213';
                                        }
                                        ->();
                                    do {
                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                        else { }
                                    };
                                    1;
                                    }
                            );
                        }
                        || (do {
                                $MATCH->to($pos1);
                                (   do {
                                        my $m2 = $grammar->val_num( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'val_num'} = $m2; 1 }
                                            else {0}
                                            }
                                        }
                                        && do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( ${ $MATCH->{'val_num'} } ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                        }
                                );
                            }
                            || do {
                                $MATCH->to($pos1);
                                (   do {
                                        my $m2 = $grammar->val_buf( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'val_buf'} = $m2; 1 }
                                            else {0}
                                            }
                                        }
                                        && do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( ${ $MATCH->{'val_buf'} } ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                        }
                                );
                            }
                        )
                    )
                    )
            );
            }
    );
    return ($MATCH);
}

sub val_bit {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   ( ( 'T' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'r' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 'u' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( Val::Bit->new( 'bit' => 1, ) ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                    }
                                )
                            )
                        )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   ( ( 'F' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'a' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 'l' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 's' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do { return ( Val::Bit->new( 'bit' => 0, ) ) };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                        }
                                    )
                                )
                            )
                        )
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub val_undef {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'u' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'n' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'd' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 'f' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        do {
                                            my $tmp = $MATCH;
                                            $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $tmp->to(), 'to' => $tmp->to(), 'bool' => 1, );
                                            $MATCH->bool(
                                                do {
                                                    my $pos1 = $MATCH->to();
                                                    do { ( ( 'w' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                    }
                                            );
                                            $tmp->bool( ( $MATCH ? 0 : 1 ) );
                                            $MATCH = $tmp;
                                            ( $MATCH ? 1 : 0 );
                                        }
                                        && do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do { return ( Val::Undef->new() ) };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                        }
                                    )
                                )
                            )
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub val_num {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ('TODO: val_num') };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub digits {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->digit( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $pos1 = $MATCH->to();
                        (   do {
                                do {
                                    my $m2 = $grammar->digits( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'digits'} = $m2; 1 }
                                        else {0}
                                        }
                                    }
                                }
                                || do { $MATCH->to($pos1); 1 }
                        );
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub val_int {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->digits( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'digits'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( Val::Int->new( 'int' => ( "" . $MATCH ), ) ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub exp_seq {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->exp( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   do {
                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                            && (
                                            ( ( ',' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->exp_seq( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_seq'} = $m2; 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $pos1 = $MATCH->to();
                                                                (   do {
                                                                        (   ( ( ',' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                do {
                                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                    else {0}
                                                                                    }
                                                                                }
                                                                        );
                                                                        }
                                                                        || do { $MATCH->to($pos1); 1 }
                                                                );
                                                            }
                                                            && do {
                                                                my $ret = sub {
                                                                    my $List__ = \@_;
                                                                    do { [] };
                                                                    do { return ( [ ${ $MATCH->{'exp'} }, @{ ${ $MATCH->{'exp_seq'} } } ] ) };
                                                                    '974^213';
                                                                    }
                                                                    ->();
                                                                do {
                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                    else { }
                                                                };
                                                                1;
                                                            }
                                                        )
                                                    )
                                                )
                                            )
                                            )
                                    );
                                    }
                                    || do {
                                    $MATCH->to($pos1);
                                    (   do {
                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                            }
                                            && (
                                            do {
                                                my $pos1 = $MATCH->to();
                                                (   do {
                                                        (   ( ( ',' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                                }
                                                        );
                                                        }
                                                        || do { $MATCH->to($pos1); 1 }
                                                );
                                            }
                                            && do {
                                                my $ret = sub {
                                                    my $List__ = \@_;
                                                    do { [] };
                                                    do { return ( [ ${ $MATCH->{'exp'} } ] ) };
                                                    '974^213';
                                                    }
                                                    ->();
                                                do {
                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                    else { }
                                                };
                                                1;
                                            }
                                            )
                                    );
                                    }
                            );
                            }
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( [] ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub lit {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->lit_object( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'lit_object'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( ${ $MATCH->{'lit_object'} } ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                );
                }
            }
    );
    return ($MATCH);
}

sub lit_seq {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ('TODO: lit_seq') };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub lit_array {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ('TODO: lit_array') };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub lit_hash {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ('TODO: lit_hash') };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub lit_code {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'X' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ('TODO - Lit::Code') };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub lit_object {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( '::' eq substr( $str, $MATCH->to(), 2 ) ) ? ( 1 + $MATCH->to( ( 2 + $MATCH->to() ) ) ) : 0 ) && (
                        do {
                            my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                else {0}
                                }
                        }
                        && (( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $pos1 = $MATCH->to();
                                (   do {
                                        (   do {
                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                                }
                                                && (
                                                do {
                                                    my $m2 = $grammar->exp_mapping( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_mapping'} = $m2; 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (( ( ')' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                            my $ret = sub {
                                                                my $List__ = \@_;
                                                                do { [] };
                                                                do { return ( Lit::Object->new( 'class' => ${ $MATCH->{'full_ident'} }, 'fields' => ${ $MATCH->{'exp_mapping'} }, ) ) };
                                                                '974^213';
                                                                }
                                                                ->();
                                                            do {
                                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                else { }
                                                            };
                                                            1;
                                                        }
                                                    )
                                                )
                                                )
                                        );
                                        }
                                        || do {
                                        $MATCH->to($pos1);
                                        do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do { Main::say( '*** Syntax Error parsing Constructor ', ${ $MATCH->{'full_ident'} } ); die() };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                            }
                                        }
                                );
                            }
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub call {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->exp( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && (
                        ( ( '.' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            do {
                                my $m2 = $grammar->ident( $str, $MATCH->to() );
                                do {
                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                    else {0}
                                    }
                            }
                            && (( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    do {
                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                            else {0}
                                            }
                                    }
                                    && (do {
                                            my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                else {0}
                                                }
                                        }
                                        && (do {
                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                            }
                                            && (( ( ')' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                                    my $ret = sub {
                                                        my $List__ = \@_;
                                                        do { [] };
                                                        do { return ( Call->new( 'invocant' => ${ $MATCH->{'exp'} }, 'method' => ${ $MATCH->{'ident'} }, 'arguments' => ${ $MATCH->{'exp_parameter_list'} }, ) ) };
                                                        '974^213';
                                                        }
                                                        ->();
                                                    do {
                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                        else { }
                                                    };
                                                    1;
                                                }
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        )
                );
                }
            }
    );
    return ($MATCH);
}

sub apply {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   do {
                        my $m2 = $grammar->namespace( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'namespace'} = $m2; 1 }
                            else {0}
                            }
                        }
                        && (
                        do {
                            my $m2 = $grammar->ident( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                                else {0}
                                }
                        }
                        && do {
                            my $pos1 = $MATCH->to();
                            (   do {
                                    (   do {
                                            my $pos1 = $MATCH->to();
                                            (   do {
                                                    (   ( ( '(' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                            do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && (do {
                                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                        do {
                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                            else {0}
                                                                            }
                                                                    }
                                                                    && ( ( ')' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 )
                                                                )
                                                            )
                                                        )
                                                    );
                                                    }
                                                    || do {
                                                    $MATCH->to($pos1);
                                                    (   do {
                                                            my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                            }
                                                            && (
                                                            do {
                                                                my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            )
                                                    );
                                                    }
                                            );
                                            }
                                            && do {
                                            my $ret = sub {
                                                my $List__ = \@_;
                                                do { [] };
                                                do {
                                                    return (
                                                        Apply->new(
                                                            'code'      => COMPILER::get_var( Var->new( 'sigil' => '&', 'twigil' => '', 'name' => ${ $MATCH->{'ident'} }, 'namespace' => ${ $MATCH->{'namespace'} }, ) ),
                                                            'arguments' => ${ $MATCH->{'exp_parameter_list'} },
                                                        )
                                                    );
                                                };
                                                '974^213';
                                                }
                                                ->();
                                            do {
                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                else { }
                                            };
                                            1;
                                            }
                                    );
                                    }
                                    || do {
                                    $MATCH->to($pos1);
                                    do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( Apply->new( 'code' => COMPILER::get_var( Var->new( 'sigil' => '&', 'twigil' => '', 'name' => ${ $MATCH->{'ident'} }, 'namespace' => ${ $MATCH->{'namespace'} }, ) ), 'arguments' => [], ) ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                        }
                                    }
                            );
                        }
                        )
                );
                }
            }
    );
    return ($MATCH);
}

sub opt_name {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    do {
                        my $m2 = $grammar->ident( $str, $MATCH->to() );
                        do {
                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'ident'} = $m2; 1 }
                            else {0}
                            }
                        }
                    }
                    || do { $MATCH->to($pos1); 1 }
            );
            }
    );
    return ($MATCH);
}

sub invocant {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->var( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'var'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( ':' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && do {
                                my $ret = sub {
                                    my $List__ = \@_;
                                    do { [] };
                                    do { return ( ${ $MATCH->{'var'} } ) };
                                    '974^213';
                                    }
                                    ->();
                                do {
                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                    else { }
                                };
                                1;
                            }
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    do {
                        my $ret = sub {
                            my $List__ = \@_;
                            do { [] };
                            do { return ( (undef) ) };
                            '974^213';
                            }
                            ->();
                        do {
                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                            else { }
                        };
                        1;
                        }
                    }
            );
            }
    );
    return ($MATCH);
}

sub capture {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            (   do {
                    (   do {
                            my $m2 = $grammar->exp( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && (
                            ( ( ':' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                do {
                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                    do {
                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                        else {0}
                                        }
                                }
                                && (do {
                                        my $m2 = $grammar->exp_parameter_list( $str, $MATCH->to() );
                                        do {
                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_parameter_list'} = $m2; 1 }
                                            else {0}
                                            }
                                    }
                                    && do {
                                        my $ret = sub {
                                            my $List__ = \@_;
                                            do { [] };
                                            do { return ( Capture->new( 'invocant' => ${ $MATCH->{'exp'} }, 'array' => ${ $MATCH->{'exp_parameter_list'} }, 'hash' => [], ) ) };
                                            '974^213';
                                            }
                                            ->();
                                        do {
                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                            else { }
                                        };
                                        1;
                                    }
                                )
                            )
                            )
                    );
                    }
                    || do {
                    $MATCH->to($pos1);
                    (   do {
                            my $m2 = $grammar->exp_mapping( $str, $MATCH->to() );
                            do {
                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_mapping'} = $m2; 1 }
                                else {0}
                                }
                            }
                            && do {
                            my $ret = sub {
                                my $List__ = \@_;
                                do { [] };
                                do { return ( Capture->new( 'invocant' => (undef), 'array' => [], 'hash' => ${ $MATCH->{'exp_mapping'} }, ) ) };
                                '974^213';
                                }
                                ->();
                            do {
                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                else { }
                            };
                            1;
                            }
                    );
                    }
            );
            }
    );
    return ($MATCH);
}

sub base_class {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                do {
                    my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                    do {
                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                        else {0}
                        }
                    }
                }
            }
    );
    return ($MATCH);
}

sub subset {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 's' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'u' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'b' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 's' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        ( ( 't' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                            do {
                                                my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                do {
                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                    else {0}
                                                    }
                                            }
                                            && (do {
                                                    my $m2 = $grammar->full_ident( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'full_ident'} = $m2; 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (( ( 'o' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                            ( ( 'f' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                do {
                                                                    my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                                    do {
                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                        else {0}
                                                                        }
                                                                }
                                                                && (do {
                                                                        my $m2 = $grammar->base_class( $str, $MATCH->to() );
                                                                        do {
                                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'base_class'} = $m2; 1 }
                                                                            else {0}
                                                                            }
                                                                    }
                                                                    && (do {
                                                                            my $m2 = $grammar->ws( $str, $MATCH->to() );
                                                                            do {
                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                else {0}
                                                                                }
                                                                        }
                                                                        && (( ( 'w' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                ( ( 'h' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                    ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                        ( ( 'r' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                            ( ( 'e' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                                do {
                                                                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                                    do {
                                                                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                        else {0}
                                                                                                        }
                                                                                                }
                                                                                                && (( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                                                                        do {
                                                                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                                            do {
                                                                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                                else {0}
                                                                                                                }
                                                                                                        }
                                                                                                        && (do {
                                                                                                                my $ret = sub {
                                                                                                                    my $List__ = \@_;
                                                                                                                    do { [] };
                                                                                                                    do { COMPILER::add_pad() };
                                                                                                                    '974^213';
                                                                                                                    }
                                                                                                                    ->();
                                                                                                                do {
                                                                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                                                    else { }
                                                                                                                };
                                                                                                                1;
                                                                                                            }
                                                                                                            && (do {
                                                                                                                    my $m2 = $grammar->exp_stmts( $str, $MATCH->to() );
                                                                                                                    do {
                                                                                                                        if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_stmts'} = $m2; 1 }
                                                                                                                        else {0}
                                                                                                                        }
                                                                                                                }
                                                                                                                && (do {
                                                                                                                        my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                                                                        do {
                                                                                                                            if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                                                                            else {0}
                                                                                                                            }
                                                                                                                    }
                                                                                                                    && (do {
                                                                                                                            my $pos1 = $MATCH->to();
                                                                                                                            (   do { ( ( '}' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                                                                                    || do {
                                                                                                                                    $MATCH->to($pos1);
                                                                                                                                    do {
                                                                                                                                        my $ret = sub {
                                                                                                                                            my $List__ = \@_;
                                                                                                                                            do { [] };
                                                                                                                                            do {
                                                                                                                                                Main::say(
                                                                                                                                                    '*** Syntax Error in subset \'',
                                                                                                                                                    get_class_name(), '.', ${ $MATCH->{'name'} },
                                                                                                                                                    '\' near pos=', $MATCH->to()
                                                                                                                                                );
                                                                                                                                                die('error in Block');
                                                                                                                                            };
                                                                                                                                            '974^213';
                                                                                                                                            }
                                                                                                                                            ->();
                                                                                                                                        do {
                                                                                                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                                                                            else { }
                                                                                                                                        };
                                                                                                                                        1;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                            );
                                                                                                                        }
                                                                                                                        && do {
                                                                                                                            my $ret = sub {
                                                                                                                                my $List__ = \@_;
                                                                                                                                do { [] };
                                                                                                                                do {
                                                                                                                                    my $env = COMPILER::current_pad();
                                                                                                                                    COMPILER::drop_pad();
                                                                                                                                    return (
                                                                                                                                        Subset->new(
                                                                                                                                            'name'       => ${ $MATCH->{'full_ident'} },
                                                                                                                                            'base_class' => Proto->new( 'name' => ${ $MATCH->{'base_class'} }, ),
                                                                                                                                            'block'      => Sub->new(
                                                                                                                                                'name'  => (undef),
                                                                                                                                                'block' => Lit::Code->new(
                                                                                                                                                    'pad'   => $env,
                                                                                                                                                    'state' => {},
                                                                                                                                                    'sig'   => Sig->new( 'invocant' => (undef), 'positional' => [], ),
                                                                                                                                                    'body'  => ${ $MATCH->{'exp_stmts'} },
                                                                                                                                                ),
                                                                                                                                            ),
                                                                                                                                        )
                                                                                                                                    );
                                                                                                                                };
                                                                                                                                '974^213';
                                                                                                                                }
                                                                                                                                ->();
                                                                                                                            do {
                                                                                                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                                                                else { }
                                                                                                                            };
                                                                                                                            1;
                                                                                                                        }
                                                                                                                    )
                                                                                                                )
                                                                                                            )
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub begin_block {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'B' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'E' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'G' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 'I' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 'N' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        do {
                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                        }
                                        && (( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $ret = sub {
                                                            my $List__ = \@_;
                                                            do { [] };
                                                            do { COMPILER::add_pad() };
                                                            '974^213';
                                                            }
                                                            ->();
                                                        do {
                                                            if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                            else { }
                                                        };
                                                        1;
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->exp_stmts( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_stmts'} = $m2; 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                                do {
                                                                    if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                    else {0}
                                                                    }
                                                            }
                                                            && (do {
                                                                    my $pos1 = $MATCH->to();
                                                                    (   do { ( ( '}' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                            || do {
                                                                            $MATCH->to($pos1);
                                                                            do {
                                                                                my $ret = sub {
                                                                                    my $List__ = \@_;
                                                                                    do { [] };
                                                                                    do { Main::say( '*** Syntax Error in BEGIN near pos=', $MATCH->to() ); die('error in Block') };
                                                                                    '974^213';
                                                                                    }
                                                                                    ->();
                                                                                do {
                                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                    else { }
                                                                                };
                                                                                1;
                                                                                }
                                                                            }
                                                                    );
                                                                }
                                                                && do {
                                                                    my $ret = sub {
                                                                        my $List__ = \@_;
                                                                        do { [] };
                                                                        do {
                                                                            my $env = COMPILER::current_pad();
                                                                            COMPILER::drop_pad();
                                                                            return (
                                                                                COMPILER::begin_block(
                                                                                    Lit::Code->new( 'pad' => $env, 'state' => {}, 'sig' => Sig->new( 'invocant' => (undef), 'positional' => [], ), 'body' => ${ $MATCH->{'exp_stmts'} }, )
                                                                                )
                                                                            );
                                                                        };
                                                                        '974^213';
                                                                        }
                                                                        ->();
                                                                    do {
                                                                        if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                        else { }
                                                                    };
                                                                    1;
                                                                }
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

sub check_block {
    my $grammar = shift;
    my $List__  = \@_;
    my $str;
    my $pos;
    do { $str = $List__->[0]; $pos = $List__->[1]; [ $str, $pos ] };
    my $MATCH;
    $MATCH = MiniPerl6::Perl5::Match->new( 'str' => $str, 'from' => $pos, 'to' => $pos, 'bool' => 1, );
    $MATCH->bool(
        do {
            my $pos1 = $MATCH->to();
            do {
                (   ( ( 'C' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                        ( ( 'H' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                            ( ( 'E' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                ( ( 'C' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                    ( ( 'K' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                        do {
                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                            do {
                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                else {0}
                                                }
                                        }
                                        && (( ( '{' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) && (
                                                do {
                                                    my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                    do {
                                                        if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                        else {0}
                                                        }
                                                }
                                                && (do {
                                                        my $m2 = $grammar->exp_stmts( $str, $MATCH->to() );
                                                        do {
                                                            if ($m2) { $MATCH->to( $m2->to() ); $MATCH->{'exp_stmts'} = $m2; 1 }
                                                            else {0}
                                                            }
                                                    }
                                                    && (do {
                                                            my $m2 = $grammar->opt_ws( $str, $MATCH->to() );
                                                            do {
                                                                if ($m2) { $MATCH->to( $m2->to() ); 1 }
                                                                else {0}
                                                                }
                                                        }
                                                        && (do {
                                                                my $pos1 = $MATCH->to();
                                                                (   do { ( ( '}' eq substr( $str, $MATCH->to(), 1 ) ) ? ( 1 + $MATCH->to( ( 1 + $MATCH->to() ) ) ) : 0 ) }
                                                                        || do {
                                                                        $MATCH->to($pos1);
                                                                        do {
                                                                            my $ret = sub {
                                                                                my $List__ = \@_;
                                                                                do { [] };
                                                                                do { Main::say('*** Syntax Error in CHECK block'); die('error in Block') };
                                                                                '974^213';
                                                                                }
                                                                                ->();
                                                                            do {
                                                                                if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                                else { }
                                                                            };
                                                                            1;
                                                                            }
                                                                        }
                                                                );
                                                            }
                                                            && do {
                                                                my $ret = sub {
                                                                    my $List__ = \@_;
                                                                    do { [] };
                                                                    do { return ( COMPILER::check_block( ${ $MATCH->{'exp_stmts'} } ) ) };
                                                                    '974^213';
                                                                    }
                                                                    ->();
                                                                do {
                                                                    if ( ( $ret ne '974^213' ) ) { $MATCH->capture($ret); $MATCH->bool(1); return ($MATCH) }
                                                                    else { }
                                                                };
                                                                1;
                                                            }
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
                }
            }
    );
    return ($MATCH);
}

1;
