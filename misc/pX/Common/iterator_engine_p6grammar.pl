# pX/Common/iterator_engine_p6regex.pl - fglock
#
# experimental implementation of a grammar that could parse pge/P6Rule.grammar

use strict;
use warnings;

require 'iterator_engine_p6rule.pl';

# XXX - make grammars inherit from Grammar; make grammars inheritable
# XXX - write an emitter that generates perl5 regexes (or dies)
# XXX - add (API/documentation) to generate unnamed rules, unnamed grammars
# XXX - fix the extra commas in the generated code
# XXX - create error messages for compiling errors

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Pad = '# ';

{
  package grammar1;

  no warnings 'once';

  *pod = 
        ::compile_rule( '\=[pod|head1] .*? \=cut' );
  *grammar_name = 
        ruleop::capture( 
            'grammar_name', 
            ::compile_rule( 'grammar (.*?) \;' )
        ); 
  *rule_decl = 
        ruleop::capture( 
            'rule_decl',
            ::compile_rule( 'rule <ws>+ (<word>) <ws>* \{ (<rule>) \}' )
        ); 
  *grammar = 
        ::compile_rule( '[<ws>*[<pod>|<grammar_name>|<rule_decl>]]*<ws>*' );
}

# ------ grammar emitter

my $namespace = 'grammar1::';

{
  package grammar;
  use Data::Dumper; 

sub header {
    return <<EOT;
#! perl
#
# grammar file
# perl5 code generated by iterator_engine_p6grammar.pl - fglock

use strict;
use warnings;
require 'iterator_engine.pl';
require 'iterator_engine_p6rule_lib.pl';

EOT
}

sub emit_rule {
    my $n = $_[0];
    local $Data::Dumper::Indent = 0;
    #print "emit_rule: ", ref($n)," ",Dumper( $n ), "\n";

    # $n = $n->{match};

    if ( ! defined $n ) {
        # empty node; maybe a <null> match
        return;
    }
    if ( ref( $n ) eq 'ARRAY' ) {
        my @s;
        for ( @$n ) {
            push @s, emit_rule( $_ );
        }
        return join( '', @s ) ;
    }
    elsif ( ref( $n ) eq 'HASH' ) 
    {
        my ( $k, $v ) = each %$n;
        #print "$k => $v \n";

        if ( $k eq 'pod' ) {
            return;
        }
        if ( $k eq 'grammar_name' ) {
            #print Dumper $v;
            my @captures = grep { ref($_) eq 'HASH' } @$v;
            my $name = join('', @{ $captures[0]{capturing_group} } );
            return "package $name;\n";
        }
        if ( $k eq 'rule_decl' ) {
            local $Data::Dumper::Indent = 1;
            # print "*** rule_decl:\n",Dumper $v;
            my @captures = grep { ref($_) eq 'HASH' } @$v;
            my $name = $captures[0]{capturing_group}[0];
            my $ast = $captures[1]{capturing_group};
            #print "*** ast:\n",Dumper $ast;

            my $program = main::emit_rule( $ast );

            #print "rule_decl captures:\n",Dumper @captures;
            return "*$name = \n$program;\n";
        }
        else {
            die "unknown node: ", Dumper( $n );
        }
    }
    else 
    {
        die "unknown node: ", Dumper( $n );
    }
}

} # /package

1;
