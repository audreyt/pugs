#!/usr/local/bin/perl

# Core modules
use strict;
use warnings;
use utf8;
use English;
use Getopt::Long;

# CPAN modules
use File::Slurp;

# And finally our modules
use STD;
use DumpMatch;

=head1 NAME

STD_syntax_highlight - Highlights Perl 6 source code using STD.pm

=head1 SYNOPSIS

    # print html output with inlined resources for 'comp_unit'
    STD_syntax_highlight foo.pl

    # print separate html, css and javascript files
    STD_syntax_highlight --clean-html foo.pl

    # print html for with 'statementlist' as the top-level rule
    STD_syntax_highlight foo.pl statementlist

=head1 SUBROUTINES

=over

=cut

#process the command line
my $clean_html = 0;
GetOptions(
    "clean-html"=>\$clean_html);

if ($#ARGV < 0) {
    die <<"HELP";
USAGE: 
    $PROGRAM_NAME [--clean-html] filename [rule]
HELP
}

#start parsing...
my $file = shift;
my $what = shift // 'comp_unit';

my $r = STD->parsefile($file,$what);

=item highlight_match

Returns the generated Perl6 highlighted HTML from C<highlight_perl6>
subroutine after traversing the STD parse tree using 
DumpMatch.pm C<traverse_match>.
=cut
sub highlight_match {
    my $name = shift;
    my $r = shift;
    my $opt = shift || {};
    my $events = [];
    traverse_match($r,$name,0,$events,$opt);
    highlight_perl6(${$r->{_orig}},$events,$opt);
}

=item highlight_perl6

Generates the Perl6 highlighted HTML string for STD parse tree provided. 
The resources can be inlined (by default) or externalized (--clean-html). 
=cut
sub highlight_perl6 {
    my ($orig,$events,$opt) = @_;
    my $str = "";
    my $at = 0;

    # slurp libraries and javascript to inline them
    my ($JQUERY_JS,$JS,$CSS) = (
        'jquery-1.2.6.pack.js', 
        'STD_syntax_highlight.js',
        'STD_syntax_highlight.css');
    my $jquery_js = qq{<script type="text/javascript" src="../$JQUERY_JS"></script>};
    my $js = qq{<script type="text/javascript" src="../$JS"></script>};
    my $css = qq{<link href="../$CSS" rel="stylesheet" type="text/css">};
    if(!$clean_html) {
        $jquery_js = read_file($JQUERY_JS) 
            or die "Error while slurping file: $OS_ERROR\n";    
        $js = read_file($JS) 
            or die "Error while slurping file: $OS_ERROR\n";
        $css = read_file($CSS)
            or die "Error while slurping file: $OS_ERROR\n";
        $jquery_js = qq{<script type="text/javascript">\n$jquery_js\n</script>};
        $js = qq{<script type="text/javascript">\n$js\n</script>};
        $css = qq{<style type="text/css">\n$css\n</style>};
    }

    $str .= <<"HTML";
<html>
<head>
    <title>$PROGRAM_NAME $file</title>
    $css
    $jquery_js
    $js
</head>
<body>
    <div id="parse_tree">
        <button id="parse_tree_expand">
            Show Syntax Tree
        </button>
        <button id="parse_tree_collapse">
            Hide it
        </button>
        <button id="parse_tree_help">
            Help
        </button>
        <div id="parse_tree_output"></div>
    </div>

    <pre>
HTML

    my $curr_rule = q{}; 
    for (sort {$a->[0] <=> $b->[0] or $a->[4] <=> $b->[4]} @{$events}) {
        my $text = substr($orig,$at,$_->[0]-$at);
        my $esc_text .= escape_html($text);
        $at = $_->[0];

        if($curr_rule eq 'identifier') {
            if($r->is_type($text)) {
                $str .= qq{<span class="_type">$esc_text</span>};
            } elsif($r->is_routine($text)) {
                $str .= qq{<span class="_routine">$esc_text</span>};
            } else {
                $str .= $esc_text;
            }
        } else {
            $str .= $esc_text;
        }

        if ($_->[1] eq 'from') {
            $curr_rule = $_->[2];
            $str .= '<span class="'.$curr_rule.'">';
        } elsif ($_->[1] eq 'to') {
            $str .=  '</span>';
        }
    }

    $str .= <<"HTML";
    </pre>
</body>
</html>
HTML

    $str;
}

=item escape_html

Converts some characters to their equivalent html entities 
=cut
sub escape_html {
    my $str = shift;
    my %esc = (
        '<'     => '&lt;',
        '>'     => '&gt;',
        '"'     => '&quot;',
        '&'     => '&amp;'
    );
    my $re = join '|', map quotemeta, keys %esc;
    $str =~ s/($re)/$esc{$1}/g;
    return $str;
}

=back

=head1 AUTHOR

Written by Ahmad M. Zawawi (azawawi), Moritz Lenz and Pawe. Murias (pmurias)

The project idea was inspired by Moritz Lenz (moritz)
See http://www.nntp.perl.org/group/perl.perl6.users/2008/07/msg788.html

The initial STD tree traversal code was written by Pawe. Murias (pmurias).

The browser code was written by Ahmad M. Zawawi (azawawi)
=cut

# and finally print out the html code
print highlight_match($what=>$r,{}) . "\n";

