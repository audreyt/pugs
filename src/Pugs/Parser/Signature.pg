# A set of rules for parsing Signatures in perl6

# XXX invocants are tracked in any sig, not just method and submethod sigs
# XXX no support for isLValue, isWritable, or isLazy (don't understand isLazy)
#       described in InternalNames.hs line 798

# XXX trusting rules to DWIM for whitespace.
#   Do I have to be explicit in places where whitespace is _not_ allowed?
#     $ foo # should not be allowed
#   Do I have to be explicit about places where whitespace is required?
#     $foo is rwis deep # should not be allowed

grammar Signature {
    # stand-in for bracketing constructs
    # XXX add more or get unicode character classes working
    token openGroup { <[<({[]> }   # should be Ps and <
    token closeGroup { <[>)}\]]> } # should be Pe and >
                           
    # perl6 sigils in signatures
    # XXX does this need to handle ^ as a sigil?
    token sigil { <[$@%&]> }

    # routine type isn't actually part of the sig
    # but we need to detect it so that we can catch RETTYPE
    # declared before the routine
    token routine { sub | method | submethod }
    token routineName { <name> }
    
    # names don't have \d as the first character and have
    # at least one non-_ character
    # XXX this allows  [_]**{2..*} names.  OK?
    token paramName    { [ <alpha> | _ ]+ [ <alpha> | \d | _ ]+  }
    token internal     { <paramName> }
    token external     { <paramName> }

    # defaults for arguments can be assigned in the sig
    rule default { = <expression( terminates => ',' )> }
    
    # types start with an uppercase letter
    # XXX isn't ^ a [s|tw]igil dealing with meta stuff?  Do I need to recognize it here?
    token typeName { <upper>+ [ <alpha> | _ | \d ]* }
    token type     { <typeName> }
    token retType  { <typeName> }
    token typeVar  { <typeName> }
    rule  returns  { \-\-\> <retType> }
    
    # parse *@x and :$x and mark for slurpy/named
    # XXX does this need to handle \ at all?
    token isNamed    { <[:]> }
    token isSlurpy   { <[*]> }
    token prefix_mod { [ <isNamed> | <isSlurpy> ] }

    # parse $x! and $x? and mark for required/optional
    token isOptional  { <[?]> }
    token isRequired  { <[!]> }
    token postfix_mod { [ <isOptional> | <isRequired> ] }

    # parse $^x and mark it as an implicit.  leave room for other twigils
    token isImplicit { <[^]> }
    token twigil     { <isImplicit> }

    # traits have the same rules for names as params
    token traitName := paramName;
    token trait { is \s+ <traitName> }
    
    # this allows specifying a type on a parameter, as well parameterizing that type.
    rule typeParam { <type> [ \:\: <typeVar> ]? }

    # $x, $^x
    rule positional {
        [ <sigil> <twigil>? $<internal> := <external> ]
    }

    # :$x and :x($y)
    # XXX is it possible to have implicit nameds? :$^foo ? :foo($^bar) ?
    rule named {
        <isNamed>
        [
        | <sigil> <twigil>? $<internal> := <external>
        | <openGroup> <external> <sigil> <twigil>? <internal> <closeGroup>
        ]
    }

    # [ $x, *@y ]
    # XXX how should unpacked params be accessed?  in $/<unpacked>?
    #  in some cases they'll be aliased to something in $/<positional|named>
    #  in other cases, they'll act as anonymous $<positional>
    rule unpacked {
        <openGroup> <typeParam>? <positional>+ <trait>* <slurpy>? <closeGroup>
    }
        
    rule param {
        <typeParam>?
        [
        | <positional>
        | <named>
        | <unpacked>
        ]
        <postfix_mod>? <trait>* <default>?
    }
        
    # *@x
    # need to keep slurpies separate from other params because they have to come last
    # XXX *@^x is possible, right?
    rule slurpy {
        <typeParam>? <isSlurpy> <sigil> <twigil>? <name> <trait>* <default>?
    }

    # signature for a single dispatch routine
    # XXX is more than one slurpy allowed?
    rule single_sig {
        [ <param> <unpacked>? , ]* <slurpy>? <returns>?
    }

    # sig for multi dispatch routine
    rule multi_sig {
        <single_sig> [ \: <single_sig> ]*
        : { @single_sig[*..-2]<is_invocant> >>++ } # thanks audreyt++
    }

    # general form for signatures
    # XXX is there some way to parse the fronted RETTYPE without
    #   matching the rest of this stuff?
    rule signature {
        <retType> <routine> <routineName>
        \( [ <single_sig> | <multi_sig> ] \)
    }
}
