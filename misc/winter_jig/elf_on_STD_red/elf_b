#!/usr/bin/perl -w
#line 5 elf_a_src/prelude.pl
package main;
use Perl6::Say;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

our $a_ARGS = [@ARGV];

sub ::undef{undef}

use Carp;
sub slurp{my($file)=@_; `cat $file`;}
sub unslurp{my($text,$file)=@_; open(F,">$file") or die $!; print F $text; close F;}
sub file_exists{-e $_[0]}
sub system{system(@_)}
sub eval_perl5{my($p5)=@_;my $res = eval($p5); croak($@) if $@; $res}
sub ::die{croak @_}
sub ::exit{exit(@_)}
sub ::defined{defined($_[0])}

package SCALAR;
sub re_gsub ($$$) {$_[0] =~ s/$_[1]/$_[2]/g; $_[0]}
sub re_sub  ($$$) {$_[0] =~ s/$_[1]/$_[2]/;  $_[0]}

package main;

#line 2 emitted_p5_9208
package main;
use Data::Dumper;

{ package Match;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
has 'rule' => (is => 'rw');;
has 'str' => (is => 'rw');;
has 'from' => (is => 'rw');;
has 'to' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub make{my $self=CORE::shift;my($r,$s,$f,$t,$h)=@_;
my $init = {'rule', $r, 'str', $s, 'from', $f, 'to', $t, 'hash', $h};
$self->new($init)};
sub match_describe{my $self=CORE::shift;my $s = ((((((($self->rule . '<') . $self->from) . ',') . $self->to) . ',\'') . $self->str) . '\',{');
for($self->hash->keys()->flatten){
my $k = $_;
my $v = $self->hash->{$k};
my $vs = 'undef';
if(::defined($v)) {
($vs = $v->match_describe())
};
($s = ((((($s . '
  ') . $k) . ' => ') . $self->indent_except_top($vs)) . ','))
};
if($self->hash->keys()->elems()) {
($s = ($s . '
'))
};
($s = ($s . '}>'))};
sub indent{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?!\Z))/, '  ')};
sub indent_except_top{my $self=CORE::shift;my($s)=@_;
$s->re_gsub(qr/(?m:^(?<!\A)(?!\Z))/, '  ')};
sub match_string{my $self=CORE::shift;$self->str}
}
;

{ package ARRAY;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub match_describe{my $self=CORE::shift;((('[
' . Match->indent($self->map(sub {my($e)=@_;
$e->match_describe()})->join(',
'))) . '
]'))}
}
;

{ package SCALAR;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub match_describe{my $self=CORE::shift;(('\'' . $self) . '\'')}
}

;
#line 2 emitted_p5_6935
package main;
use Data::Dumper;

{ package IRBuild;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
has 'constructors' => (is => 'rw');;
($main::irbuilder = IRBuild->new());
sub add_constructor{my $self=CORE::shift;my($k,$constructor)=@_;
if($self->constructors) {

}else {
my $h = {};
$self->constructors($h)
};
($self->constructors->{$k} = $constructor)};
sub make_ir_from_Match_tree{my $self=CORE::shift;my($m)=@_;
my $rule = $m->rule();
my $constructor = $self->constructors->{$rule};
if(($constructor)) {
$constructor->($m)
}else {
::die('Unknown rule: $rule
It needs to be added to ast_handlers.
')
}}
}
;

{ package Match;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$main::irbuilder->make_ir_from_Match_tree($self)}
}
;

{ package ARRAY;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self->map(sub {my($e)=@_;
$e->make_ir_from_Match_tree()})}
}
;

{ package SCALAR;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}
}
;

{ package UNDEF;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub make_ir_from_Match_tree{my $self=CORE::shift;$self}
}
;
sub irbuild_ir{my($x)=@_;
$x->make_ir_from_Match_tree()}
;
#line 2 emitted_p5_3675
package main;
use Data::Dumper;

{ package IRBuild;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
$main::irbuilder->add_constructor('comp_unit', sub {my($m)=@_;
IR0::CompUnit->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('statement', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('expect_term', sub {my($m)=@_;
{package main; use vars '$es_blackboard__expect_term_base'};local $::es_blackboard__expect_term_base = ::irbuild_ir($m->{'hash'}->{'noun'});
my $post = ($m->{'hash'}->{'post'} || []);
for(($post)->flatten){
($::es_blackboard__expect_term_base = ::ir($_))
};
$::es_blackboard__expect_term_base});
$main::irbuilder->add_constructor('post', sub {my($m)=@_;
(::irbuild_ir($m->{'hash'}->{'dotty'}) or ::irbuild_ir($m->{'hash'}->{'postop'}))});
$main::irbuilder->add_constructor('dotty:methodop', sub {my($m)=@_;
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), ::irbuild_ir($m->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'semilist'}))});
$main::irbuilder->add_constructor('dotty:postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), $ident, ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('postcircumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
my $ident = ('postcircumfix:' . $name);
IR0::Call->newp($m, $::es_blackboard__expect_term_base, ::undef(), $ident, ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('term:expect_term', sub {my($m)=@_;
::irbuild_ir($m->{'hash'}->{'noun'})});
$main::irbuilder->add_constructor('term', sub {my($m)=@_;
if(((($m->match_string()) eq 'self'))) {
IR0::Apply->newp($m, 'self', [])
}else {
::die('AST term partially unimplemented.
')
}});
$main::irbuilder->add_constructor('integer', sub {my($m)=@_;
IR0::Val_Int->newp($m, ($m->match_string()))});
$main::irbuilder->add_constructor('subcall', sub {my($m)=@_;
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'subshortname'}), ::irbuild_ir($m->{'hash'}->{'semilist'}))});
$main::irbuilder->add_constructor('name', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('statement_control:use', sub {my($m)=@_;
IR0::Use->newp($m, ::irbuild_ir($m->{'hash'}->{'module_name'}))});
$main::irbuilder->add_constructor('module_name:depreciated', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('module_name:normal', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('term:listop', sub {my($m)=@_;
my $not_really_an_arglist = ::irbuild_ir($m->{'hash'}->{'arglist'});
if((::irbuild_ir($m->{'hash'}->{'arglist'}))) {
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), [$not_really_an_arglist])
}else {
IR0::Apply->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), [])
}});
$main::irbuilder->add_constructor('quote:q', sub {my($m)=@_;
IR0::Val_Buf->newp($m, ::irbuild_ir($m->{'hash'}->{'text'}))});
$main::irbuilder->add_constructor('quote:qq', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
$s->re_gsub(qr/(?<!\\)\\n/, '\\n');
$s->re_gsub(qr/(?<!\\)\\t/, '\\t');
IR0::Val_Buf->newp($m, $s)});
$main::irbuilder->add_constructor('quote:regex', sub {my($m)=@_;
my $s = ::irbuild_ir($m->{'hash'}->{'text'});
IR0::Val_Rx->newp($m, $s)});
$main::irbuilder->add_constructor('infix', sub {my($m)=@_;
my $op = ($m->match_string());
if((($op eq 'str'))) {
($op = '=')
};
IR0::Apply->newp($m, ('infix:' . $op), [::irbuild_ir($m->{'hash'}->{'left'}), ::irbuild_ir($m->{'hash'}->{'right'})])});
$main::irbuilder->add_constructor('scope_declarator:my', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'my', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:has', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'has', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scope_declarator:our', sub {my($m)=@_;
my $vd = ::irbuild_ir($m->{'hash'}->{'scoped'});
IR0::Decl->newp($m, 'our', ::undef(), $vd->[0], $vd->[1])});
$main::irbuilder->add_constructor('scoped', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('variable_decl', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'variable'}), ::irbuild_ir($m->{'hash'}->{'default_value'})]});
$main::irbuilder->add_constructor('variable', sub {my($m)=@_;
IR0::Var->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'desigilname'}))});
$main::irbuilder->add_constructor('sigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('twigil', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('circumfix', sub {my($m)=@_;
my $s = ($m->match_string());
my $name = ((::substr($s, 0, 1) . ' ') . ::substr($s, (0 - 1), 1));
IR0::Apply->newp($m, ('circumfix:' . $name), ::irbuild_ir($m->{'hash'}->{'kludge_name'}))});
$main::irbuilder->add_constructor('statement_control:for', sub {my($m)=@_;
IR0::For->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:while', sub {my($m)=@_;
IR0::While->newp($m, ::irbuild_ir($m->{'hash'}->{'expr'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('statement_control:if', sub {my($m)=@_;
IR0::If->newp($m, ::irbuild_ir($m->{'hash'}->{'if_expr'}), ::irbuild_ir($m->{'hash'}->{'if_block'}), ::irbuild_ir($m->{'hash'}->{'elsif'}), ::irbuild_ir($m->{'hash'}->{'else'}))});
$main::irbuilder->add_constructor('elsif', sub {my($m)=@_;
[::irbuild_ir($m->{'hash'}->{'elsif_expr'}), ::irbuild_ir($m->{'hash'}->{'elsif_block'})]});
$main::irbuilder->add_constructor('if__else', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('pblock', sub {my($m)=@_;
my $key;
for($m->{'hash'}->keys()->flatten){
if(($_ ne 'match')) {
if($key) {
::die('Unexpectedly more than 1 field - dont know which to choose
')
};
($key = $_)
}
};
my $one = ::irbuild_ir($m->{'hash'}->{$key});
$one});
$main::irbuilder->add_constructor('block', sub {my($m)=@_;
IR0::Block->newp($m, ::irbuild_ir($m->{'hash'}->{'statementlist'}))});
$main::irbuilder->add_constructor('routine_declarator:routine_def', sub {my($m)=@_;
my $ident = '';
if((::irbuild_ir($m->{'hash'}->{'ident'}))) {
($ident = ::irbuild_ir($m->{'hash'}->{'ident'})->[0])
};
my $sig = IR0::Sig->newp($m, ::undef(), []);
if((::irbuild_ir($m->{'hash'}->{'multisig'}))) {
($sig = ::irbuild_ir($m->{'hash'}->{'multisig'})->[0])
};
IR0::Sub->newp($m, $ident, $sig, ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('routine_declarator:method_def', sub {my($m)=@_;
IR0::Method->newp($m, ::irbuild_ir($m->{'hash'}->{'ident'}), ::irbuild_ir($m->{'hash'}->{'multisig'})->[0], ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('signature', sub {my($m)=@_;
IR0::Sig->newp($m, ::undef(), ::irbuild_ir($m->{'hash'}->{'parsep'}))});
$main::irbuilder->add_constructor('parameter', sub {my($m)=@_;
IR0::Lit_SigArgument->newp($m, ::irbuild_ir($m->{'hash'}->{'param_var'}))});
$main::irbuilder->add_constructor('param_var', sub {my($m)=@_;
IR0::Var->newp($m, ::irbuild_ir($m->{'hash'}->{'sigil'}), ::irbuild_ir($m->{'hash'}->{'twigil'}), ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('package_declarator:class', sub {my($m)=@_;
{package main; use vars '$es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'class';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:module', sub {my($m)=@_;
{package main; use vars '$es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'module';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_declarator:package', sub {my($m)=@_;
{package main; use vars '$es_blackboard__package_declarator'};local $::es_blackboard__package_declarator = 'package';
::irbuild_ir($m->{'hash'}->{'package_def'})});
$main::irbuilder->add_constructor('package_def', sub {my($m)=@_;
IR0::PackageDeclarator->newp($m, $::es_blackboard__package_declarator, ::irbuild_ir($m->{'hash'}->{'module_name'})->[0], ::irbuild_ir($m->{'hash'}->{'traits'}), ::irbuild_ir($m->{'hash'}->{'block'}))});
$main::irbuilder->add_constructor('fulltypename', sub {my($m)=@_;
::join('::', ::irbuild_ir($m->{'hash'}->{'typename'})->flatten())});
$main::irbuilder->add_constructor('typename', sub {my($m)=@_;
($m->match_string())});
$main::irbuilder->add_constructor('trait_verb:is', sub {my($m)=@_;
IR0::Trait->newp($m, 'is', ::irbuild_ir($m->{'hash'}->{'ident'}))});
$main::irbuilder->add_constructor('circumfix:pblock', sub {my($m)=@_;
if((::not((::irbuild_ir($m->{'hash'}->{'lambda'}) and ::not(::irbuild_ir($m->{'hash'}->{'signature'})))))) {
IR0::Lit_Hash->newp($m, ::irbuild_ir($m->{'hash'}->{'block'}->{'hash'}->{'statementlist'}))
}else {
::die('AST handler circumfix:pblock partially unimplemented')
}})
}

;
#line 2 emitted_p5_6920
package main;
use Data::Dumper;

{ package ARRAY;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub ir0_describe{my $self=CORE::shift;(('[' . $self->map(sub {my($e)=@_;
$e->ir0_describe()})->join(',')) . ']')}
}
;

{ package SCALAR;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub ir0_describe{my $self=CORE::shift;($self . '')}
}
;

{ package UNDEF;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub ir0_describe{my $self=CORE::shift;'undef'}
}
;

{ package IR0;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

{ package IR0::Base;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';

}
;

{ package IR0::Val_Base;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';
}
;

{ package IR0::Lit_Base;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';
}
;

{ package IR0::Rule_Base;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';
}
;

{ package IR0::CompUnit;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'statements' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
$self->new('match', $match, 'statements', $statements)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_CompUnit($self)};
sub node_name{my $self=CORE::shift;'CompUnit'};
sub field_names{my $self=CORE::shift;['statements']};
sub field_values{my $self=CORE::shift;[$self->statements]};
sub ir0_describe{my $self=CORE::shift;(('CompUnit(' . $self->statements->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Int;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'text' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$text)=@_;
$self->new('match', $match, 'text', $text)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Int($self)};
sub node_name{my $self=CORE::shift;'Val_Int'};
sub field_names{my $self=CORE::shift;['text']};
sub field_values{my $self=CORE::shift;[$self->text]};
sub ir0_describe{my $self=CORE::shift;(('Val_Int(' . $self->text->ir0_describe()) . ')')}
}
;

{ package IR0::PackageDeclarator;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'kind' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'traits' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$kind,$name,$traits,$block)=@_;
$self->new('match', $match, 'kind', $kind, 'name', $name, 'traits', $traits, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_PackageDeclarator($self)};
sub node_name{my $self=CORE::shift;'PackageDeclarator'};
sub field_names{my $self=CORE::shift;['kind', 'name', 'traits', 'block']};
sub field_values{my $self=CORE::shift;[$self->kind, $self->name, $self->traits, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((((('PackageDeclarator(' . $self->kind->ir0_describe()) . ',') . $self->name->ir0_describe()) . ',') . $self->traits->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Trait;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'verb' => (is => 'rw');;
has 'expr' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$verb,$expr)=@_;
$self->new('match', $match, 'verb', $verb, 'expr', $expr)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Trait($self)};
sub node_name{my $self=CORE::shift;'Trait'};
sub field_names{my $self=CORE::shift;['verb', 'expr']};
sub field_values{my $self=CORE::shift;[$self->verb, $self->expr]};
sub ir0_describe{my $self=CORE::shift;(((('Trait(' . $self->verb->ir0_describe()) . ',') . $self->expr->ir0_describe()) . ')')}
}
;

{ package IR0::Block;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'statements' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
$self->new('match', $match, 'statements', $statements)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Block($self)};
sub node_name{my $self=CORE::shift;'Block'};
sub field_names{my $self=CORE::shift;['statements']};
sub field_values{my $self=CORE::shift;[$self->statements]};
sub ir0_describe{my $self=CORE::shift;(('Block(' . $self->statements->ir0_describe()) . ')')}
}
;

{ package IR0::Quote;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'concat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$concat)=@_;
$self->new('match', $match, 'concat', $concat)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Quote($self)};
sub node_name{my $self=CORE::shift;'Quote'};
sub field_names{my $self=CORE::shift;['concat']};
sub field_values{my $self=CORE::shift;[$self->concat]};
sub ir0_describe{my $self=CORE::shift;(('Quote(' . $self->concat->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Bit;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'bit' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$bit)=@_;
$self->new('match', $match, 'bit', $bit)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Bit($self)};
sub node_name{my $self=CORE::shift;'Val_Bit'};
sub field_names{my $self=CORE::shift;['bit']};
sub field_values{my $self=CORE::shift;[$self->bit]};
sub ir0_describe{my $self=CORE::shift;(('Val_Bit(' . $self->bit->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Num;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'num' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$num)=@_;
$self->new('match', $match, 'num', $num)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Num($self)};
sub node_name{my $self=CORE::shift;'Val_Num'};
sub field_names{my $self=CORE::shift;['num']};
sub field_values{my $self=CORE::shift;[$self->num]};
sub ir0_describe{my $self=CORE::shift;(('Val_Num(' . $self->num->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Buf;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'buf' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$buf)=@_;
$self->new('match', $match, 'buf', $buf)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Buf($self)};
sub node_name{my $self=CORE::shift;'Val_Buf'};
sub field_names{my $self=CORE::shift;['buf']};
sub field_values{my $self=CORE::shift;[$self->buf]};
sub ir0_describe{my $self=CORE::shift;(('Val_Buf(' . $self->buf->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Char;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'char' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$char)=@_;
$self->new('match', $match, 'char', $char)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Char($self)};
sub node_name{my $self=CORE::shift;'Val_Char'};
sub field_names{my $self=CORE::shift;['char']};
sub field_values{my $self=CORE::shift;[$self->char]};
sub ir0_describe{my $self=CORE::shift;(('Val_Char(' . $self->char->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Undef;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Undef($self)};
sub node_name{my $self=CORE::shift;'Val_Undef'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Val_Undef(' . ')')}
}
;

{ package IR0::Val_Object;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'clazz' => (is => 'rw');;
has 'fields' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$clazz,$fields)=@_;
$self->new('match', $match, 'clazz', $clazz, 'fields', $fields)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Object($self)};
sub node_name{my $self=CORE::shift;'Val_Object'};
sub field_names{my $self=CORE::shift;['clazz', 'fields']};
sub field_values{my $self=CORE::shift;[$self->clazz, $self->fields]};
sub ir0_describe{my $self=CORE::shift;(((('Val_Object(' . $self->clazz->ir0_describe()) . ',') . $self->fields->ir0_describe()) . ')')}
}
;

{ package IR0::Val_Rx;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Val_Base';has 'match' => (is => 'rw');;
has 'pat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$pat)=@_;
$self->new('match', $match, 'pat', $pat)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Val_Rx($self)};
sub node_name{my $self=CORE::shift;'Val_Rx'};
sub field_names{my $self=CORE::shift;['pat']};
sub field_values{my $self=CORE::shift;[$self->pat]};
sub ir0_describe{my $self=CORE::shift;(('Val_Rx(' . $self->pat->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Seq;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'seq' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$seq)=@_;
$self->new('match', $match, 'seq', $seq)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Seq($self)};
sub node_name{my $self=CORE::shift;'Lit_Seq'};
sub field_names{my $self=CORE::shift;['seq']};
sub field_values{my $self=CORE::shift;[$self->seq]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Seq(' . $self->seq->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Array;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$array)=@_;
$self->new('match', $match, 'array', $array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Array($self)};
sub node_name{my $self=CORE::shift;'Lit_Array'};
sub field_names{my $self=CORE::shift;['array']};
sub field_values{my $self=CORE::shift;[$self->array]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Array(' . $self->array->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Hash;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$hash)=@_;
$self->new('match', $match, 'hash', $hash)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Hash($self)};
sub node_name{my $self=CORE::shift;'Lit_Hash'};
sub field_names{my $self=CORE::shift;['hash']};
sub field_values{my $self=CORE::shift;[$self->hash]};
sub ir0_describe{my $self=CORE::shift;(('Lit_Hash(' . $self->hash->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Pair;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
$self->new('match', $match, 'key', $key, 'value', $value)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Pair($self)};
sub node_name{my $self=CORE::shift;'Lit_Pair'};
sub field_names{my $self=CORE::shift;['key', 'value']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_Pair(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_SigArgument;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
has 'type' => (is => 'rw');;
has 'has_default' => (is => 'rw');;
has 'is_named_only' => (is => 'rw');;
has 'is_optional' => (is => 'rw');;
has 'is_slurpy' => (is => 'rw');;
has 'is_multidimensional' => (is => 'rw');;
has 'is_rw' => (is => 'rw');;
has 'is_copy' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value,$type,$has_default,$is_named_only,$is_optional,$is_slurpy,$is_multidimensional,$is_rw,$is_copy)=@_;
$self->new('match', $match, 'key', $key, 'value', $value, 'type', $type, 'has_default', $has_default, 'is_named_only', $is_named_only, 'is_optional', $is_optional, 'is_slurpy', $is_slurpy, 'is_multidimensional', $is_multidimensional, 'is_rw', $is_rw, 'is_copy', $is_copy)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_SigArgument($self)};
sub node_name{my $self=CORE::shift;'Lit_SigArgument'};
sub field_names{my $self=CORE::shift;['key', 'value', 'type', 'has_default', 'is_named_only', 'is_optional', 'is_slurpy', 'is_multidimensional', 'is_rw', 'is_copy']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value, $self->type, $self->has_default, $self->is_named_only, $self->is_optional, $self->is_slurpy, $self->is_multidimensional, $self->is_rw, $self->is_copy]};
sub ir0_describe{my $self=CORE::shift;(((((((((((((((((((('Lit_SigArgument(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ',') . $self->type->ir0_describe()) . ',') . $self->has_default->ir0_describe()) . ',') . $self->is_named_only->ir0_describe()) . ',') . $self->is_optional->ir0_describe()) . ',') . $self->is_slurpy->ir0_describe()) . ',') . $self->is_multidimensional->ir0_describe()) . ',') . $self->is_rw->ir0_describe()) . ',') . $self->is_copy->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_NamedArgument;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'key' => (is => 'rw');;
has 'value' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
$self->new('match', $match, 'key', $key, 'value', $value)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_NamedArgument($self)};
sub node_name{my $self=CORE::shift;'Lit_NamedArgument'};
sub field_names{my $self=CORE::shift;['key', 'value']};
sub field_values{my $self=CORE::shift;[$self->key, $self->value]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_NamedArgument(' . $self->key->ir0_describe()) . ',') . $self->value->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Code;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'pad' => (is => 'rw');;
has 'state' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'body' => (is => 'rw');;
has 'catch' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$pad,$state,$sig,$body,$catch)=@_;
$self->new('match', $match, 'pad', $pad, 'state', $state, 'sig', $sig, 'body', $body, 'catch', $catch)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Code($self)};
sub node_name{my $self=CORE::shift;'Lit_Code'};
sub field_names{my $self=CORE::shift;['pad', 'state', 'sig', 'body', 'catch']};
sub field_values{my $self=CORE::shift;[$self->pad, $self->state, $self->sig, $self->body, $self->catch]};
sub ir0_describe{my $self=CORE::shift;(((((((((('Lit_Code(' . $self->pad->ir0_describe()) . ',') . $self->state->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->body->ir0_describe()) . ',') . $self->catch->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Object;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'clazz' => (is => 'rw');;
has 'fields' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$clazz,$fields)=@_;
$self->new('match', $match, 'clazz', $clazz, 'fields', $fields)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Object($self)};
sub node_name{my $self=CORE::shift;'Lit_Object'};
sub field_names{my $self=CORE::shift;['clazz', 'fields']};
sub field_values{my $self=CORE::shift;[$self->clazz, $self->fields]};
sub ir0_describe{my $self=CORE::shift;(((('Lit_Object(' . $self->clazz->ir0_describe()) . ',') . $self->fields->ir0_describe()) . ')')}
}
;

{ package IR0::Var;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'sigil' => (is => 'rw');;
has 'twigil' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'namespace' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name,$namespace)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name, 'namespace', $namespace)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Var($self)};
sub node_name{my $self=CORE::shift;'Var'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name', 'namespace']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name, $self->namespace]};
sub ir0_describe{my $self=CORE::shift;(((((((('Var(' . $self->sigil->ir0_describe()) . ',') . $self->twigil->ir0_describe()) . ',') . $self->name->ir0_describe()) . ',') . $self->namespace->ir0_describe()) . ')')}
}
;

{ package IR0::Bind;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'parameters' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$parameters,$arguments)=@_;
$self->new('match', $match, 'parameters', $parameters, 'arguments', $arguments)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Bind($self)};
sub node_name{my $self=CORE::shift;'Bind'};
sub field_names{my $self=CORE::shift;['parameters', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->parameters, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Bind(' . $self->parameters->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}
}
;

{ package IR0::Assign;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'parameters' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$parameters,$arguments)=@_;
$self->new('match', $match, 'parameters', $parameters, 'arguments', $arguments)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Assign($self)};
sub node_name{my $self=CORE::shift;'Assign'};
sub field_names{my $self=CORE::shift;['parameters', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->parameters, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Assign(' . $self->parameters->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}
}
;

{ package IR0::Proto;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name)=@_;
$self->new('match', $match, 'name', $name)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Proto($self)};
sub node_name{my $self=CORE::shift;'Proto'};
sub field_names{my $self=CORE::shift;['name']};
sub field_values{my $self=CORE::shift;[$self->name]};
sub ir0_describe{my $self=CORE::shift;(('Proto(' . $self->name->ir0_describe()) . ')')}
}
;

{ package IR0::Call;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'hyper' => (is => 'rw');;
has 'method' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$hyper,$method,$arguments)=@_;
$self->new('match', $match, 'invocant', $invocant, 'hyper', $hyper, 'method', $method, 'arguments', $arguments)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Call($self)};
sub node_name{my $self=CORE::shift;'Call'};
sub field_names{my $self=CORE::shift;['invocant', 'hyper', 'method', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->hyper, $self->method, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((((((('Call(' . $self->invocant->ir0_describe()) . ',') . $self->hyper->ir0_describe()) . ',') . $self->method->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}
}
;

{ package IR0::Apply;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'code' => (is => 'rw');;
has 'arguments' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$code,$arguments)=@_;
$self->new('match', $match, 'code', $code, 'arguments', $arguments)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Apply($self)};
sub node_name{my $self=CORE::shift;'Apply'};
sub field_names{my $self=CORE::shift;['code', 'arguments']};
sub field_values{my $self=CORE::shift;[$self->code, $self->arguments]};
sub ir0_describe{my $self=CORE::shift;(((('Apply(' . $self->code->ir0_describe()) . ',') . $self->arguments->ir0_describe()) . ')')}
}
;

{ package IR0::Return;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'result' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$result)=@_;
$self->new('match', $match, 'result', $result)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Return($self)};
sub node_name{my $self=CORE::shift;'Return'};
sub field_names{my $self=CORE::shift;['result']};
sub field_values{my $self=CORE::shift;[$self->result]};
sub ir0_describe{my $self=CORE::shift;(('Return(' . $self->result->ir0_describe()) . ')')}
}
;

{ package IR0::If;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'test' => (is => 'rw');;
has 'body' => (is => 'rw');;
has 'elsif' => (is => 'rw');;
has 'else' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$test,$body,$elsif,$else)=@_;
$self->new('match', $match, 'test', $test, 'body', $body, 'elsif', $elsif, 'else', $else)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_If($self)};
sub node_name{my $self=CORE::shift;'If'};
sub field_names{my $self=CORE::shift;['test', 'body', 'elsif', 'else']};
sub field_values{my $self=CORE::shift;[$self->test, $self->body, $self->elsif, $self->else]};
sub ir0_describe{my $self=CORE::shift;(((((((('If(' . $self->test->ir0_describe()) . ',') . $self->body->ir0_describe()) . ',') . $self->elsif->ir0_describe()) . ',') . $self->else->ir0_describe()) . ')')}
}
;

{ package IR0::While;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'test' => (is => 'rw');;
has 'body' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$test,$body)=@_;
$self->new('match', $match, 'test', $test, 'body', $body)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_While($self)};
sub node_name{my $self=CORE::shift;'While'};
sub field_names{my $self=CORE::shift;['test', 'body']};
sub field_values{my $self=CORE::shift;[$self->test, $self->body]};
sub ir0_describe{my $self=CORE::shift;(((('While(' . $self->test->ir0_describe()) . ',') . $self->body->ir0_describe()) . ')')}
}
;

{ package IR0::For;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'expr' => (is => 'rw');;
has 'body' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$expr,$body)=@_;
$self->new('match', $match, 'expr', $expr, 'body', $body)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_For($self)};
sub node_name{my $self=CORE::shift;'For'};
sub field_names{my $self=CORE::shift;['expr', 'body']};
sub field_values{my $self=CORE::shift;[$self->expr, $self->body]};
sub ir0_describe{my $self=CORE::shift;(((('For(' . $self->expr->ir0_describe()) . ',') . $self->body->ir0_describe()) . ')')}
}
;

{ package IR0::Decl;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'decl' => (is => 'rw');;
has 'type' => (is => 'rw');;
has 'var' => (is => 'rw');;
has 'default' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$decl,$type,$var,$default)=@_;
$self->new('match', $match, 'decl', $decl, 'type', $type, 'var', $var, 'default', $default)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Decl($self)};
sub node_name{my $self=CORE::shift;'Decl'};
sub field_names{my $self=CORE::shift;['decl', 'type', 'var', 'default']};
sub field_values{my $self=CORE::shift;[$self->decl, $self->type, $self->var, $self->default]};
sub ir0_describe{my $self=CORE::shift;(((((((('Decl(' . $self->decl->ir0_describe()) . ',') . $self->type->ir0_describe()) . ',') . $self->var->ir0_describe()) . ',') . $self->default->ir0_describe()) . ')')}
}
;

{ package IR0::Sig;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'positional' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$positional)=@_;
$self->new('match', $match, 'invocant', $invocant, 'positional', $positional)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Sig($self)};
sub node_name{my $self=CORE::shift;'Sig'};
sub field_names{my $self=CORE::shift;['invocant', 'positional']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->positional]};
sub ir0_describe{my $self=CORE::shift;(((('Sig(' . $self->invocant->ir0_describe()) . ',') . $self->positional->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Capture;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'invocant' => (is => 'rw');;
has 'array' => (is => 'rw');;
has 'hash' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$invocant,$array,$hash)=@_;
$self->new('match', $match, 'invocant', $invocant, 'array', $array, 'hash', $hash)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Capture($self)};
sub node_name{my $self=CORE::shift;'Lit_Capture'};
sub field_names{my $self=CORE::shift;['invocant', 'array', 'hash']};
sub field_values{my $self=CORE::shift;[$self->invocant, $self->array, $self->hash]};
sub ir0_describe{my $self=CORE::shift;(((((('Lit_Capture(' . $self->invocant->ir0_describe()) . ',') . $self->array->ir0_describe()) . ',') . $self->hash->ir0_describe()) . ')')}
}
;

{ package IR0::Lit_Subset;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Lit_Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'base_class' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$base_class,$block)=@_;
$self->new('match', $match, 'name', $name, 'base_class', $base_class, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Lit_Subset($self)};
sub node_name{my $self=CORE::shift;'Lit_Subset'};
sub field_names{my $self=CORE::shift;['name', 'base_class', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->base_class, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Lit_Subset(' . $self->name->ir0_describe()) . ',') . $self->base_class->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Method;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Method($self)};
sub node_name{my $self=CORE::shift;'Method'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Method(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Sub;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Sub($self)};
sub node_name{my $self=CORE::shift;'Sub'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Sub(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Macro;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Macro($self)};
sub node_name{my $self=CORE::shift;'Macro'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Macro(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Coro;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'sig' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$sig,$block)=@_;
$self->new('match', $match, 'name', $name, 'sig', $sig, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Coro($self)};
sub node_name{my $self=CORE::shift;'Coro'};
sub field_names{my $self=CORE::shift;['name', 'sig', 'block']};
sub field_values{my $self=CORE::shift;[$self->name, $self->sig, $self->block]};
sub ir0_describe{my $self=CORE::shift;(((((('Coro(' . $self->name->ir0_describe()) . ',') . $self->sig->ir0_describe()) . ',') . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::P5Token;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'regex' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$regex)=@_;
$self->new('match', $match, 'regex', $regex)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_P5Token($self)};
sub node_name{my $self=CORE::shift;'P5Token'};
sub field_names{my $self=CORE::shift;['regex']};
sub field_values{my $self=CORE::shift;[$self->regex]};
sub ir0_describe{my $self=CORE::shift;(('P5Token(' . $self->regex->ir0_describe()) . ')')}
}
;

{ package IR0::Token;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'name' => (is => 'rw');;
has 'regex' => (is => 'rw');;
has 'sym' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$name,$regex,$sym)=@_;
$self->new('match', $match, 'name', $name, 'regex', $regex, 'sym', $sym)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Token($self)};
sub node_name{my $self=CORE::shift;'Token'};
sub field_names{my $self=CORE::shift;['name', 'regex', 'sym']};
sub field_values{my $self=CORE::shift;[$self->name, $self->regex, $self->sym]};
sub ir0_describe{my $self=CORE::shift;(((((('Token(' . $self->name->ir0_describe()) . ',') . $self->regex->ir0_describe()) . ',') . $self->sym->ir0_describe()) . ')')}
}
;

{ package IR0::Do;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$block)=@_;
$self->new('match', $match, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Do($self)};
sub node_name{my $self=CORE::shift;'Do'};
sub field_names{my $self=CORE::shift;['block']};
sub field_values{my $self=CORE::shift;[$self->block]};
sub ir0_describe{my $self=CORE::shift;(('Do(' . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Begin;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'block' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$block)=@_;
$self->new('match', $match, 'block', $block)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Begin($self)};
sub node_name{my $self=CORE::shift;'Begin'};
sub field_names{my $self=CORE::shift;['block']};
sub field_values{my $self=CORE::shift;[$self->block]};
sub ir0_describe{my $self=CORE::shift;(('Begin(' . $self->block->ir0_describe()) . ')')}
}
;

{ package IR0::Use;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
has 'mod' => (is => 'rw');;
has 'perl5' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$mod,$perl5)=@_;
$self->new('match', $match, 'mod', $mod, 'perl5', $perl5)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Use($self)};
sub node_name{my $self=CORE::shift;'Use'};
sub field_names{my $self=CORE::shift;['mod', 'perl5']};
sub field_values{my $self=CORE::shift;[$self->mod, $self->perl5]};
sub ir0_describe{my $self=CORE::shift;(((('Use(' . $self->mod->ir0_describe()) . ',') . $self->perl5->ir0_describe()) . ')')}
}
;

{ package IR0::Rule;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule($self)};
sub node_name{my $self=CORE::shift;'Rule'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Rule(' . ')')}
}
;

{ package IR0::Rule_Quantifier;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'term' => (is => 'rw');;
has 'quant' => (is => 'rw');;
has 'greedy' => (is => 'rw');;
has 'ws1' => (is => 'rw');;
has 'ws2' => (is => 'rw');;
has 'ws3' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$term,$quant,$greedy,$ws1,$ws2,$ws3)=@_;
$self->new('match', $match, 'term', $term, 'quant', $quant, 'greedy', $greedy, 'ws1', $ws1, 'ws2', $ws2, 'ws3', $ws3)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Quantifier($self)};
sub node_name{my $self=CORE::shift;'Rule_Quantifier'};
sub field_names{my $self=CORE::shift;['term', 'quant', 'greedy', 'ws1', 'ws2', 'ws3']};
sub field_values{my $self=CORE::shift;[$self->term, $self->quant, $self->greedy, $self->ws1, $self->ws2, $self->ws3]};
sub ir0_describe{my $self=CORE::shift;(((((((((((('Rule_Quantifier(' . $self->term->ir0_describe()) . ',') . $self->quant->ir0_describe()) . ',') . $self->greedy->ir0_describe()) . ',') . $self->ws1->ir0_describe()) . ',') . $self->ws2->ir0_describe()) . ',') . $self->ws3->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Or;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'terms' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$terms)=@_;
$self->new('match', $match, 'terms', $terms)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Or($self)};
sub node_name{my $self=CORE::shift;'Rule_Or'};
sub field_names{my $self=CORE::shift;['terms']};
sub field_values{my $self=CORE::shift;[$self->terms]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Or(' . $self->terms->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Concat;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'concat' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$concat)=@_;
$self->new('match', $match, 'concat', $concat)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Concat($self)};
sub node_name{my $self=CORE::shift;'Rule_Concat'};
sub field_names{my $self=CORE::shift;['concat']};
sub field_values{my $self=CORE::shift;[$self->concat]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Concat(' . $self->concat->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Subrule;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'metasyntax' => (is => 'rw');;
has 'ident' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$metasyntax,$ident,$capture_to_array)=@_;
$self->new('match', $match, 'metasyntax', $metasyntax, 'ident', $ident, 'capture_to_array', $capture_to_array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Subrule($self)};
sub node_name{my $self=CORE::shift;'Rule_Subrule'};
sub field_names{my $self=CORE::shift;['metasyntax', 'ident', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->metasyntax, $self->ident, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Subrule(' . $self->metasyntax->ir0_describe()) . ',') . $self->ident->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_SubruleNoCapture;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'metasyntax' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$metasyntax)=@_;
$self->new('match', $match, 'metasyntax', $metasyntax)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_SubruleNoCapture($self)};
sub node_name{my $self=CORE::shift;'Rule_SubruleNoCapture'};
sub field_names{my $self=CORE::shift;['metasyntax']};
sub field_values{my $self=CORE::shift;[$self->metasyntax]};
sub ir0_describe{my $self=CORE::shift;(('Rule_SubruleNoCapture(' . $self->metasyntax->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Var;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'sigil' => (is => 'rw');;
has 'twigil' => (is => 'rw');;
has 'name' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
$self->new('match', $match, 'sigil', $sigil, 'twigil', $twigil, 'name', $name)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Var($self)};
sub node_name{my $self=CORE::shift;'Rule_Var'};
sub field_names{my $self=CORE::shift;['sigil', 'twigil', 'name']};
sub field_values{my $self=CORE::shift;[$self->sigil, $self->twigil, $self->name]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Var(' . $self->sigil->ir0_describe()) . ',') . $self->twigil->ir0_describe()) . ',') . $self->name->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Constant;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'constant' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$constant)=@_;
$self->new('match', $match, 'constant', $constant)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Constant($self)};
sub node_name{my $self=CORE::shift;'Rule_Constant'};
sub field_names{my $self=CORE::shift;['constant']};
sub field_values{my $self=CORE::shift;[$self->constant]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Constant(' . $self->constant->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Dot;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match)=@_;
$self->new('match', $match)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Dot($self)};
sub node_name{my $self=CORE::shift;'Rule_Dot'};
sub field_names{my $self=CORE::shift;[]};
sub field_values{my $self=CORE::shift;[]};
sub ir0_describe{my $self=CORE::shift;('Rule_Dot(' . ')')}
}
;

{ package IR0::Rule_SpecialChar;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'char' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$char)=@_;
$self->new('match', $match, 'char', $char)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_SpecialChar($self)};
sub node_name{my $self=CORE::shift;'Rule_SpecialChar'};
sub field_names{my $self=CORE::shift;['char']};
sub field_values{my $self=CORE::shift;[$self->char]};
sub ir0_describe{my $self=CORE::shift;(('Rule_SpecialChar(' . $self->char->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Block;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'closure' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$closure)=@_;
$self->new('match', $match, 'closure', $closure)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Block($self)};
sub node_name{my $self=CORE::shift;'Rule_Block'};
sub field_names{my $self=CORE::shift;['closure']};
sub field_values{my $self=CORE::shift;[$self->closure]};
sub ir0_describe{my $self=CORE::shift;(('Rule_Block(' . $self->closure->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_InterpolateVar;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'var' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$var)=@_;
$self->new('match', $match, 'var', $var)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_InterpolateVar($self)};
sub node_name{my $self=CORE::shift;'Rule_InterpolateVar'};
sub field_names{my $self=CORE::shift;['var']};
sub field_values{my $self=CORE::shift;[$self->var]};
sub ir0_describe{my $self=CORE::shift;(('Rule_InterpolateVar(' . $self->var->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_NamedCapture;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'ident' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$ident,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'ident', $ident, 'capture_to_array', $capture_to_array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_NamedCapture($self)};
sub node_name{my $self=CORE::shift;'Rule_NamedCapture'};
sub field_names{my $self=CORE::shift;['rule', 'ident', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->ident, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_NamedCapture(' . $self->rule->ir0_describe()) . ',') . $self->ident->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Before;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'assertion_modifier' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$assertion_modifier,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'assertion_modifier', $assertion_modifier, 'capture_to_array', $capture_to_array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Before($self)};
sub node_name{my $self=CORE::shift;'Rule_Before'};
sub field_names{my $self=CORE::shift;['rule', 'assertion_modifier', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->assertion_modifier, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Before(' . $self->rule->ir0_describe()) . ',') . $self->assertion_modifier->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_After;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'assertion_modifier' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$assertion_modifier,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'assertion_modifier', $assertion_modifier, 'capture_to_array', $capture_to_array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_After($self)};
sub node_name{my $self=CORE::shift;'Rule_After'};
sub field_names{my $self=CORE::shift;['rule', 'assertion_modifier', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->assertion_modifier, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_After(' . $self->rule->ir0_describe()) . ',') . $self->assertion_modifier->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_NegateCharClass;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'chars' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$chars)=@_;
$self->new('match', $match, 'chars', $chars)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_NegateCharClass($self)};
sub node_name{my $self=CORE::shift;'Rule_NegateCharClass'};
sub field_names{my $self=CORE::shift;['chars']};
sub field_values{my $self=CORE::shift;[$self->chars]};
sub ir0_describe{my $self=CORE::shift;(('Rule_NegateCharClass(' . $self->chars->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_CharClass;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'chars' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$chars)=@_;
$self->new('match', $match, 'chars', $chars)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_CharClass($self)};
sub node_name{my $self=CORE::shift;'Rule_CharClass'};
sub field_names{my $self=CORE::shift;['chars']};
sub field_values{my $self=CORE::shift;[$self->chars]};
sub ir0_describe{my $self=CORE::shift;(('Rule_CharClass(' . $self->chars->ir0_describe()) . ')')}
}
;

{ package IR0::Rule_Capture;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
extends 'IR0::Rule_Base';has 'match' => (is => 'rw');;
has 'rule' => (is => 'rw');;
has 'position' => (is => 'rw');;
has 'capture_to_array' => (is => 'rw');;
sub newp{my $self=CORE::shift;my($match,$rule,$position,$capture_to_array)=@_;
$self->new('match', $match, 'rule', $rule, 'position', $position, 'capture_to_array', $capture_to_array)};
sub emit{my $self=CORE::shift;my($emitter)=@_;
$emitter->emit_Rule_Capture($self)};
sub node_name{my $self=CORE::shift;'Rule_Capture'};
sub field_names{my $self=CORE::shift;['rule', 'position', 'capture_to_array']};
sub field_values{my $self=CORE::shift;[$self->rule, $self->position, $self->capture_to_array]};
sub ir0_describe{my $self=CORE::shift;(((((('Rule_Capture(' . $self->rule->ir0_describe()) . ',') . $self->position->ir0_describe()) . ',') . $self->capture_to_array->ir0_describe()) . ')')}
}

}

;
#line 2 emitted_p5_1946
package main;
use Data::Dumper;

{ package Program;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub print_usage_and_die{my $self=CORE::shift;::say('
elf_b [-e P6_CODE]
');
::exit(2)};
sub main{my $self=CORE::shift;my($args)=@_;
if(($args->elems() == 0)) {
$self->print_usage_and_die()
};
my $p6_code;
while($args->elems()) {
my $arg = $args->shift();
if(($arg eq '-e')) {
($p6_code = $args->shift())
}elsif(::file_exists($arg)) {
($p6_code = ::slurp($arg))
}else {
$self->print_usage_and_die()
}
};
::unslurp($p6_code, 'deleteme.p6');
my $parser = '../../STD_red/STD_red_run';
my $cmd = ($parser . ' -q --dump5 deleteme.p6 > deleteme.dump');
((::system($cmd) == 0) or ::die('Parse failed.
'));
my $dump5 = ::slurp('deleteme.dump');
my $tree = ::eval_perl5(('package Fastdump;' . $dump5));
::say($tree->match_describe());
my $ir = $tree->make_ir_from_Match_tree();
::say($ir->ir0_describe())}
}
;
Program->new()->main($a_ARGS);

{ package Fastdump;
use Moose;
use Moose::Autobox; use autobox; use autobox::Core; use autobox UNDEF => 'UNDEF';
sub match{my($r,$s,$f,$t,$h)=@_;
Match->make($r, $s, $f, $t, $h)}
}

;

