#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <smop.h>
#include <smop_oo.h>
#include <smop_lowlevel.h>
#include "p6opaque.h"

typedef struct SMOP__p6opaque__Array__methods_struct {
  SMOP__Object__BASE
  SMOP__Object* instance;
} SMOP__p6opaque__Array__methods_struct;

SMOP__Object* SMOP__p6opaque__Array__methods;

static void check_metadata_pointer(SMOP__Object* interpreter,
                                   SMOP__Object* invocant) {
  smop_lowlevel_rdlock(invocant);
  SMOP__Object* instance = ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance;
  smop_lowlevel_unlock(invocant);

  smop_lowlevel_rdlock(instance);
  if (!((SMOP__p6opaque_struct*)instance)->metadata) {
    // upgrade the lock to be a write lock
    smop_lowlevel_unlock(instance);
    smop_lowlevel_wrlock(instance);
    SMOP__p6opaque_LOWL_metadata* m = calloc(1,sizeof(SMOP__p6opaque_LOWL_metadata));
    assert(m);
    ((SMOP__p6opaque_struct*)instance)->metadata = m;
  }
  smop_lowlevel_unlock(instance);
}

static SMOP__Object* p6opaque_methods_message(SMOP__Object* interpreter,
                                              SMOP__ResponderInterface* self,
                                              SMOP__Object* identifier,
                                              SMOP__Object* capture) {

  SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter,capture);

  if (identifier == SMOP__ID__DESTROYALL) {
    smop_lowlevel_wrlock(invocant);
    SMOP__Object* instance = ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance;
    ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance = NULL;
    smop_lowlevel_unlock(invocant);
    SMOP_RELEASE(interpreter,instance);

  } else if (identifier == SMOP__ID__push) {
    SMOP__Object* frame;
    SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                               SMOP__ID__continuation, SMOP_REFERENCE(interpreter,interpreter));
    /* frame = q:p6 {
        $invocant.register($capture.positional(0).name,$capture.positional(0).signature,$capture.positional(0));
    } */
    frame = q:sm0p {
      identifier: q:identifier[name];
      method: $capture.positional(0);
      methodcopy: $SMOP__SLIME__CurrentFrame.copy(`method);
      methodcopy2: $SMOP__SLIME__CurrentFrame.copy(`method);
      $SMOP__SLIME__CurrentFrame.move_responder(`methodcopy,3);
      $SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(`methodcopy2,(),(),2));
      $SMOP__SLIME__CurrentFrame.move_identifier(`identifier,1);
      methodname: ;
      methodcopy3: $SMOP__SLIME__CurrentFrame.copy(`method);
      methodcopy4: $SMOP__SLIME__CurrentFrame.copy(`method);
      identifier2: q:identifier[signature];
      $SMOP__SLIME__CurrentFrame.move_responder(`methodcopy3,3);
      $SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(`methodcopy4,(),(),2));
      $SMOP__SLIME__CurrentFrame.move_identifier(`identifier2,1);
      signature: ;
      identifier3: q:identifier[register];
      invocant: $invocant;
      invocant2: $invocant;
      $SMOP__SLIME__CurrentFrame.move_responder(`invocant,3);
      $SMOP__SLIME__CurrentFrame.move_capturize(SMOP__SLIME__Capturize.new(`invocant2,(`methodname,`signature,`method),(),2));
      $SMOP__SLIME__CurrentFrame.move_identifier(`identifier3,1);
      ;
      $SMOP__SLIME__CurrentFrame.forget();
      $interpreter.goto(|$continuation);
    };
    
    SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                  SMOP__ID__goto,
                  frame);

  } else if (identifier == SMOP__ID__register) {
    SMOP__Object* invocant = SMOP__NATIVE__capture_invocant(interpreter, capture);
    SMOP__Object* name = SMOP__NATIVE__capture_positional(interpreter, capture, 0);
    SMOP__Object* signature = SMOP__NATIVE__capture_positional(interpreter, capture, 1);
    SMOP__Object* method = SMOP__NATIVE__capture_positional(interpreter, capture, 2);

    smop_lowlevel_rdlock(invocant);
    SMOP__Object* instance = ((SMOP__p6opaque__Array__methods_struct*)invocant)->instance;
    if (SMOP_RI(name) == SMOP_RI(SMOP__ID__new)) {
      // add this method as one of the items in the methods hash...
    } else {
      fprintf(stderr,"[p6opaque methods] non-constant identifiers not supported.\n");
    }
    smop_lowlevel_unlock(invocant);

    SMOP_RELEASE(interpreter, method);
    SMOP_RELEASE(interpreter, name);
    SMOP_RELEASE(interpreter, signature);
    SMOP_RELEASE(interpreter, invocant);
   
  } else if (identifier == SMOP__ID__shift) {
    check_metadata_pointer(interpreter,invocant);

  } else {
    fprintf(stderr,"[smop p6opaque methods] unknown method called.\n");
  }

  SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return SMOP__NATIVE__bool_false;
}

static SMOP__Object* p6opaque_methods_reference(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__Array__methods != obj) {
    smop_lowlevel_refcnt_inc(interpreter, responder, obj);
  }
  return obj;
}

static SMOP__Object* p6opaque_methods_release(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)SMOP__p6opaque__Array__methods != obj) {
    smop_lowlevel_refcnt_dec(interpreter, responder, obj);
  }
  return obj;
}

extern void p6opaque_methods_init() {
  SMOP__p6opaque__Array__methods = calloc(1,sizeof(SMOP__ResponderInterface));
  assert(SMOP__p6opaque__Array__methods);
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->MESSAGE = p6opaque_methods_message;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->REFERENCE = p6opaque_methods_reference;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->RELEASE = p6opaque_methods_release;
  ((SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods)->id = "p6opaque methods array";
}

extern void p6opaque_methods_destr() {
  free(SMOP__p6opaque__Array__methods);
}

extern SMOP__Object* p6opaque_methods_array_create(SMOP__Object* interpreter,
                                                   SMOP__Object* invocant) {
  SMOP__Object* ret = smop_lowlevel_alloc(sizeof(SMOP__p6opaque__Array__methods_struct));
  ret->RI = (SMOP__ResponderInterface*)SMOP__p6opaque__Array__methods;
  ((SMOP__p6opaque__Array__methods_struct*)ret)->instance = SMOP_REFERENCE(interpreter,invocant);
  return ret;
}


