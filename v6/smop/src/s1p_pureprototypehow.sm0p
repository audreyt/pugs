/* generated by tools/ri - do not edit*/
#include <smop.h>
#include <smop_lowlevel.h>
#include <smop_s1p.h>
#include <stdlib.h>
#include <stdio.h>
#include <smop_mold.h>
SMOP__Object* SMOP__S1P__PurePrototypeHow;
static SMOP__Object* ID__dispatch;
static SMOP__Object* dispatch_mold;

typedef struct smop_s1p_pureprototypehow_struct {
  SMOP__Object__BASE
} smop_s1p_pureprototypehow_struct;

static SMOP__Object* message(SMOP__Object* interpreter,
                                     SMOP__ResponderInterface* self,
                                     SMOP__Object* identifier,
                                     SMOP__Object* capture) {
  
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;
  SMOP__Object* invocant = (SMOP__Object*) SMOP__NATIVE__capture_invocant(interpreter, capture);
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
if (ID__dispatch == identifier) {
    SMOP__Object* actualresponder = SMOP__NATIVE__capture_positional(interpreter,capture,0);
    SMOP__Object* actualidentifier = SMOP__NATIVE__capture_positional(interpreter,capture,1);
    SMOP__Object* actualcapture = SMOP__NATIVE__capture_positional(interpreter,capture,2);
    SMOP__Object* actualinvocant = SMOP__NATIVE__capture_invocant(interpreter,actualcapture);
    SMOP__Object* continuation = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
                                               SMOP__ID__continuation, 
                                               SMOP_REFERENCE(interpreter,interpreter));
    SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,
                                                   SMOP_REFERENCE(interpreter,
                                                                  dispatch_mold));
    mold_reg_set(interpreter,frame,0,SMOP_REFERENCE(interpreter,interpreter));
    mold_reg_set(interpreter,frame,1,actualresponder);
    mold_reg_set(interpreter,frame,2,actualidentifier);
    mold_reg_set(interpreter,frame,3,actualcapture);
    mold_reg_set(interpreter,frame,4,actualinvocant);
    mold_back_set(interpreter,frame,continuation);
    SMOP_DISPATCH(interpreter,SMOP_RI(interpreter),SMOP__ID__goto,frame);

  } else {
    ___UNKNOWN_METHOD___;
  }

  if (invocant) SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return ret;
    
}

void smop_s1p_pureprototypehow_init() {
  SMOP__S1P__PurePrototypeHow = SMOP__RI__create(
      message,
      smop_lowlevel_generic_reference,
      smop_lowlevel_generic_release,
      "PurePrototypeHow");
  SMOP__Object* interpreter = SMOP__GlobalInterpreter;
  ID__dispatch = SMOP__NATIVE__idconst_create("dispatch");
  dispatch_mold = SMOP__Mold_create(12,(SMOP__Object*[]) {SMOP__NATIVE__idconst_createn("FETCH",5),SMOP__NATIVE__idconst_createn("^!methods",9),SMOP__NATIVE__idconst_createn("back",4),SMOP__NATIVE__idconst_createn("continuation",12),SMOP__NATIVE__idconst_createn("exists",6),SMOP__NATIVE__idconst_createn("goto",4),SMOP__NATIVE__idconst_createn("postcircumfix:( )",17),SMOP__NATIVE__idconst_createn("postcircumfix:{ }",17),SMOP__NATIVE__idconst_createn("setr",4),SMOP_REFERENCE(interpreter,SMOP__NATIVE__bool_false),NULL},64,(int[]) {1,16,14,1,0,0,1,17,16,4,1,12,0,4,17,17,37,1,18,16,7,1,12,0,1,19,18,0,0,0,1,9,19,6,1,13,0,1,20,10,3,0,0,1,21,20,2,0,0,1,15,21,8,1,9,0,1,15,10,5,1,21,0,0})
;
 
}

void smop_s1p_pureprototypehow_destr() {
SMOP_RELEASE(SMOP__GlobalInterpreter,dispatch_mold);

  SMOP_RELEASE(SMOP__GlobalInterpreter,SMOP__S1P__PurePrototypeHow);
}
