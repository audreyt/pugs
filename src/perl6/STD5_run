#!/usr/local/bin/perl
# A script to make running STD5.pm easier,
# by providing it input, and isolating it's Match yaml output.
use strict;
use warnings;

sub print_usage_and_exit {
    print STDERR <<"END"; exit(2);
$0 [-fo] GRAMMAR_RULE [ INPUT_FILE | -e INPUT ]

Examples:
  $0 noun -e 42
END
}

my $fo = '';
$fo = shift if $ARGV[0] eq '-fo';

sub main {
    print_usage_and_exit if @ARGV < 2 || $ARGV[0] eq '--help';
    my $rule = shift(@ARGV);
    print_usage_and_exit if $rule !~ /^\w+$/;
    my $input;
    if($ARGV[0] eq '-e') {
	shift(@ARGV);
	print_usage_and_exit if not @ARGV;
	$input = shift(@ARGV);
	#$input = 'qq{'.quotemeta($input).'}';
    }
    else {
	my $fn = shift(@ARGV);
	print_usage_and_exit if !-f $fn;
	$input = "`cat $fn`";
    }
    if(-e 'STD.pm' and -e 'cheat') { # We're in the right place.
	# pretend we're 'make'
	if(!-e 'STD5.pm' or
		-M 'STD5.pm' > -M 'STD.pm' or
		-M 'STD5.pm' > -M 'cheat' or
		-M 'STD5.pm' > -M 'gimme5') {
	    system("./cheat STD.pm | ./gimme5 $fo >STD5.pm");
	    system("rm -f lex/*");
	}
    }
    #my $cmd = qq/perl -w -I . -MSTD5 -e 'print Perl::Dump(Perl->new(orig=>$input)->${rule}(["$rule"]));'/;
    #warn "# ",$cmd,"\n";
    #system "$cmd 2>std5.err";
    unshift(@INC,'.');
    require "STD5.pm";
    my $err = "std5.err";
    open(STDERR,">$err") or die;
    my $perl = Perl->new($input);
    if(!$perl->can($rule)) { die "\nERROR: Unknown rule: $rule\n"; }
    my $result = eval { $perl->${rule}(); };
    if($result) { 
      print Perl::Dump($result);
    } else {
      print "Parse failed.  See $err.\n";
    }
}
main;

__END__
