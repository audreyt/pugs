=pod

=encoding utf8

=head1 NAME

Muldis::DB::Language::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::DB::Language::Core version 0.1.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::DB::Language>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

A significant subset of the Muldis D core entities are specific to being or
implementing the Muldis D system catalog / meta-model, and aren't used
elsewhere by the system; these are documented in the
L<Muldis::DB::Language::Catalog> document; all the other core entities are
described in the current C<Core> document.  TODO: EDIT THIS PARAGRAPH.

This current C<Core> document features the boolean, order, integer, bit
string, and character string types and operators, plus the tuple and
relation type constructors (and quasi- variants) and operators, plus the
type system minimal and maximal types, and the polymorphic operators that
all types, or some types including core types, have defined over them.

Extensions are in these other documents: L<Muldis::DB::Language::Ext::Num>,
L<Muldis::DB::Language::Ext::Temporal>,
L<Muldis::DB::Language::Ext::Spatial>.

I<This documentation is pending.>

=head1 TYPE SUMMARY

Following are all the data types and data type factories described in this
document, arranged in a type graph according to their proper sub|supertype
relationships:

    sys.type.Universal

        sys.type.Empty

        sys.type.Scalar
            sys.type.Ordinal

                # The following are all regular ordinal scalar types.

                sys.type.Bool
                    sys.type.Bool.False
                    sys.type.Bool.True
                sys.type.Order
                    sys.type.Order.Increase
                    sys.type.Order.Same
                    sys.type.Order.Decrease
                sys.type.Int
                    sys.type.UInt
                        sys.type.PInt
                sys.type.Blob
                    sys.type.NEBlob
                sys.type.Text
                    sys.type.NEText
                sys.type.ShortName
                sys.type.LongName

        # The following are all nonscalar type factories.

        sys.type.Tuple
            sys.type.Database

        sys.type.Relation
            sys.type.Set
                sys.type.Maybe
            sys.type.Seq
            sys.type.Bag

        # The following are all quasi-nonscalar type factories.

        sys.type.QuasiTuple

        sys.type.QuasiRelation
            sys.type.QuasiSet
                sys.type.QuasiMaybe
            sys.type.QuasiSeq
            sys.type.QuasiBag

Note that C<sys.type.Empty> is a proper subtype of all of the other types
in this graph, but every other type has only one immediate supertype shown,
and hence the graph of them is a simple hierarchy.

I<This documentation is pending.>

=head1 SYSTEM-DEFINED MAXIMAL AND MINIMAL DATA TYPES

These data types are special and are the only Muldis D types that are
neither scalar nor nonscalar nor quasi-nonscalar types.  They are all
system-defined and it is impossible for users to define more types of this
nature.

=over

=item C<sys.type.Universal>

The C<Universal> type is the maximal type of the entire Muldis D type
system, and contains every value that can possibly exist.  Every other type
is implicitly a proper subtype of C<Universal>, and C<Universal> is
implicitly a union type over all other types.  Its default value is
C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Empty>

The C<Empty> type is the minimal type of the entire Muldis D type system,
and is the only type that contains exactly zero values.  Every other type
is implicitly a proper supertype of C<Empty> and C<Empty> is implicitly an
intersection type over all other types.  It has no default value.  The
cardinality of this type is zero.

=back

=head1 SYSTEM-DEFINED CORE SCALAR DATA TYPES

These scalar data types are the most fundamental Muldis D types.  Each one
has zero possreps, and hence has no named components that can be
referenced.  Concrete Muldis D provides a specific syntax per type to
select a value of one of these types, which does not look like a routine
invocation, but rather like a scalar literal in a typical programming
language; details of that syntax are not given here, but in
L<Muldis::DB::Language::Grammar>.  Abstract Muldis D as hosted in another
language will essentially use literals of corresponding host language
types, whatever they use for eg booleans and integers and character
strings, but tagged with extra meta-data if the host language is more
weakly typed or lacks one-to-one type correspondence.

=over

=item C<sys.type.Scalar>

The C<Scalar> type is the maximal type of all Muldis D scalar types, and
contains every scalar value that can possibly exist.  Every other scalar
type is implicitly a proper subtype of C<Scalar>, and C<Scalar> is
implicitly a union type over all other scalar types.  Its default value is
C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Ordinal>

The C<Ordinal> type is a proper subtype of C<Scalar> that is a proper
supertype of all scalar types that are considered ordinal.  Any scalar
types which consider themselves ordinal, which happens to include every
system-defined core scalar root type, will explicitly declare themselves as
subtypes of C<Ordinal> in their type definitions; the definition of
C<Ordinal> does not specify what other types it is a union over.  Its
default value is C<Bool.False>.  The cardinality of this type is infinity.

=item C<sys.type.Bool>

A C<Bool> is an enumeration consisting of the 2 values C<Bool.False> and
C<Bool.True>.  It represents a truth value, and is the result type of any
C<equal> or C<not_equal> routine; it is the only essential scalar data type
of a B<D> language.  Its default value is C<Bool.False>.  The cardinality
of this type is 2.

=item C<sys.type.Order>

A C<Order> is an enumeration consisting of the 3 values C<Order.Increase>,
C<Order.Same>, C<Order.Decrease>.  It is the result type of any C<compare>
routine that is used on 2 values of a C<sys.type.Ordinal> subtype.  Its
default value is C<Order.Same>.  The cardinality of this type is 3.

=item C<sys.type.Int>

An C<Int> is a single integral number of any magnitude.  Its default value
is zero.  The cardinality of this type is infinity; to define a
most-generalized finite C<Int> subtype, you must specify the 2 integer
end-points of the inclusive range that all its values are in.

=item C<sys.type.UInt>

A C<UInt> (unsigned integer) is a proper subtype of C<Int> where all member
values are non-negative / greater than or equal to zero.

=item C<sys.type.PInt>

A C<PInt> (positive integer) is a proper subtype of C<UInt> where all
member values are positive / greater than or equal to one.  Its default
value is one.

=item C<sys.type.Blob>

A C<Blob> is an undifferentiated string of bits.  Its default value is the
empty string.  The cardinality of this type is infinity; to define a
most-generalized finite C<Blob> subtype, you must specify a maximum length
in characters that the subtype's strings are.

=item C<sys.type.NEBlob>

A C<NEBlob> (non-empty blob) is a proper subtype of C<Blob> where its
length in bits must be at least 1; it can be any C<Blob> except for the
empty string.  Its default value is a single zero bit.

=item C<sys.type.Text>

A C<Text> is a string of characters.  Its default value is the empty
string.  Note that there is only one system-defined character repertoire
for C<Text> types, which is the newest Unicode repertoire (5.0.0).  The
cardinality of this type is infinity; to define a most-generalized finite
C<Text> subtype, you must specify a maximum length in characters (that is,
eg, in NFC graphemes) that the subtype's strings are.

=item C<sys.type.NEText>

A C<NEText> (non-empty text) is a proper subtype of C<Text> where its
length in characters must be more than zero; it can be any C<Text> except
for the empty string.  Its default value is a single "space" character.

=item C<sys.type.ShortName>

A C<ShortName> is a canonical name for some DBMS entities (others use
C<LongName>), such as the declared names of attributes of scalar possreps
or collection types, and for the declared names of routine parameters, and
for the invocation names of the same.  It is the same as C<Text> in all
ways but that it is specifically intended for use in naming DBMS entities
rather than being normal data.

=item C<sys.type.LongName>

A C<LongName> is a canonical name for some DBMS entities (others use
C<ShortName>), such as the invocation names of types, routines, and
variables, and it is typically used for the declared names of the same.  A
C<LongName> consists of a sequence (1..N) of C<ShortName>, the elements
being ordered from greatest to least significance.  Its default value is a
single element that is the default value of C<ShortName>, the empty string.

=back



=head2 Core Nonscalar Data Types

These nonscalar data types, C<Tuple|Relation|Database|Set|Seq|Bag|Maybe>,
permit transparent/user-visible compositions of multiple values into other
conceptual values.  Unlike with scalar types in general, every
system-defined selector for nonscalar values will result in values that are
of proper subtypes of the 2 nonscalar root types (the first 2), and none
whose most specific type is "just" one of those 2.  Moreover, every such
most-specific type has explicit element types or attribute sets defined;
there are no nonscalar values where the element types or attribute sets
are undefined.  For all nonscalar types, their cardinality is mainly or
wholly dependent on the data types they are composed of.

=over

=item C<sys.type.Tuple>

A C<Tuple> is an unordered heterogeneous collection of 0..N named
attributes (the count of attributes being its I<degree>), where all
attribute names are mutually distinct, and each attribute may be of
distinct selectable types; the mapping of a tuple's attribute names and
their declared data types is called the tuple's I<heading>.  Its default
value is a zero-attribute tuple.  The cardinality of this type is equal to
the product of the number of permutations drawable from the values of each
of its attributes' declared data types; for a C<Tuple> subtype to be
finite, all of its attribute types must be.

=item C<sys.type.Database>

A C<Database> is a proper subtype of C<Tuple> where all of its attributes
are Relation-typed; it is otherwise the same.

=item C<sys.type.Relation>

A C<Relation> is analogous to a set of 0..N tuples where all tuples have
the same heading (the degrees match and all attribute names and
corresponding declared data types match), but that a C<Relation> data type
still has its own corresponding heading (attribute names and declared data
types) even when it consists of zero tuples.  Its default value is a
zero-attribute and zero-tuple relation.  Matters of its cardinality are
generally the same as for C<Tuple>.  A Relation data type can also have
(unique) keys each defined over a subset of its attributes, which constrain
its set of values relative to there being no explicit keys, but having the
keys won't turn an infinite Relation type into a finite one.

=item C<sys.type.Set>

A C<Set> is a proper subtype of C<Relation> that has 1 attribute, and its
name is C<value>; it can be of any declared type.  A C<Set> subtype is
normally used by any system-defined N-ary operators where the order of
their argument elements or result is not significant, and that duplicate
values are not significant.  Its default value has zero tuples.

=item C<sys.type.Maybe>

A C<Maybe> is a proper subtype of C<Set> that may have at most one element;
that is, it is a unary C<Relation> with a nullary key.  Operators that work
specifically with C<Maybe> subtypes can provide a syntactic shorthand for
working with sparse data; so Muldis D has something which is conceptually
close to SQL's nullable types without actually having 3-valued logic; it
would probably be convenient for code that round-trips SQL by way of
Muldis D to use the C<Maybe> type.  Its default value has zero tuples.

=item C<sys.type.Seq>

An C<Seq> is a proper subtype of C<Relation> that has 2 attributes,
and their names are C<index> and C<value>, where C<index> is a unary key
and its declared type is an C<UInt> subtype (C<value> can be non-unique and
of any declared type).  A Seq is considered dense, and all C<index>
values in one are numbered consecutively from 0 to 1 less than the count of
tuples, like array indices in typical programming languages.  A C<Seq>
subtype is normally used by any system-defined N-ary operators where the
order of their argument elements or result is significant (and duplicate
values are significant); specifically, C<index> defines an explicit
ordering for C<values>.  Its default value has zero tuples.

=item C<sys.type.Bag>

A C<Bag> is a proper subtype of C<Relation> that has 2 attributes, and
their names are C<value> and C<count>, where C<value> is a unary key (that
can have any declared type) and C<count> is a C<PInt> subtype.  A C<Bag>
subtype is normally used by any system-defined N-ary operators where the
order of their argument elements or result is not significant, but that
duplicate values are significant; specifically, C<count> defines an
explicit count of occurrences for C<values>.  Its default value has zero
tuples.

=back

=head2 Core Quasi-Nonscalar Data Types

These quasi-nonscalar data types correspond to their similarly-named
(differing only by the C<Quasi>) nonscalar data types, and their use is
intended to be limited to the few situations where the corresponding
nonscalar data types can't be used.

=over

=item C<sys.type.QuasiTuple>

A C<QuasiTuple> is like a C<Tuple> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.type.QuasiRelation>

A C<QuasiRelation> is like a C<Relation> but that the declared types of its
attributes can be anything at all.  Its cardinality is infinite.

=item C<sys.type.QuasiSet>

A C<QuasiSet> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Set> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.type.QuasiMaybe>

A C<QuasiMaybe> is a proper subtype of C<QuasiRelation> in the
corresponding manner to C<Maybe> being a proper subtype of C<Relation>.
Its cardinality is infinite.

=item C<sys.type.QuasiSeq>

A C<QuasiSeq> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Seq> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=item C<sys.type.QuasiBag>

A C<QuasiBag> is a proper subtype of C<QuasiRelation> in the corresponding
manner to C<Bag> being a proper subtype of C<Relation>.  Its cardinality is
infinite.

=back

=head1 SEE ALSO

Go to L<Muldis::DB> for the majority of distribution-internal references,
and L<Muldis::DB::SeeAlso> for the majority of distribution-external
references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the Muldis::DB framework.

Muldis::DB is Copyright © 2002-2007, Darren Duncan.

See the LICENSE AND COPYRIGHT of L<Muldis::DB> for details.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::DB> apply to this file too.

=cut
