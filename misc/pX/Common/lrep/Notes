This file contains assorted design notes from #perl6 or docs - fglock

from PGE docs: Available syntactic categories include "infix:", 
"prefix:", "postfix:", "term:", "circumfix:", and "postcircumfix:"

 --> and: statement_control ?

random notes...

<fglock> audreyt: what is the relationship between AST and Match? (I'm compiling 
the match captures)
<audreyt> fglock: no relationship whatsoever :)
<audreyt> fglock: the Match object may carry an captured object in $/<>
<audreyt> aka $()
<audreyt> and if you are writing a Perl 6 parser, then that capture object may be 
an AST object
<audreyt> you can set the capture object by
<audreyt> rule { $() := ... }
<audreyt> or
<audreyt> rule { ... { return $capture_object } }
<audreyt> or
<audreyt> rule { ... { $() := ... } }
<audreyt> if the capture object is not set explicitly
<audreyt> then it's set to the entire match as matched by the rule.
<spinclad> so in q:code:{ say $x; {{{$a}}} } the $x is literal but the $a is 
unquoted (interpolated)? therefore the {{{ }}}'s?
<audreyt> +$/ and ~$/ resolves to +$() and ~$() respectively.

----

re: '&'

22:16 < putter> [<mail_header>&.*?^^From: (\N+).*] $<body>:=(.*)
22:20 < putter> PerlJam: what's an increased specificity example?  both 
of mine
                were assert-spec&unpack pairs.
22:22 < fglock> putter: .* would make it fail, isn't it?
22:23 < putter> you mean the .* after the (\N+) ?
22:23 < fglock> yes
22:23 < PerlJam> putter: yes, mine are similar, just that the "unpack" 
part
                 isn't necessary:    [<mail_header>&^^<'From:'>] &&
                 do_something_only_with_from_lines;
22:23 < putter> I don't believe so.  I would expect the & to force the * 
to
                backtrack.
22:24 < PerlJam> putter: btw, beware the cut-colon!  :-)  (unless I'm 
mistaken
                 that you meant for the : to be matched)

-----

re: statement_control

22:50 < putter> one uses  multi statement_control:<if> (...){...}  multi
                statement_control:<while> (...){...} etc to fill it in.
22:51 < fglock> putter: you mean, statement_control is represented by an 
array?
                (or namespace thing)
22:52 -!- pdcawley [n=pdcawley@adsl-217.146.110.1.merula.net] has joined 
#perl6
22:52 < putter> fglock: yeah, but there are some issues... like how do  
(pause)
22:52 -!- clkao [n=clkao@220-132-58-30.HINET-IP.hinet.net] has quit 
[Read
          error: 104 (Connection reset by peer)]
22:52 < PerlJam> must not have been enough svk talk here ;-)
22:52 < fglock> putter: please not that it is an array of rule - it is 
very
                flexible
22:53 < putter> statement_control is a grammatical category.  it defines 
one of
                the <statement> subrules.
22:53 < putter> (my yeah, was directed at <@subrule>, not represented by 
an
                array ;)
22:55 -!- r0n|mess [n=r0nny@p54B893E3.dip0.t-ipconnect.de] has quit 
[Connection
          timed out]
22:57 < putter> fglock: yes but.  when writing a grammar, in a first 
match wins
                engine (like | is), you carefully craft the order of the
                subrule list.  when subrules get added by 
statement_control
                defs, someone other than the human has to do the 
crafting.
                either the statement_control infrastructure assures the 
@array
                has a nice order, or <statement> can't use <@array>.
22:58 < fglock> putter: you can opt to use longest-match instead of
                ordered-match
22:58 < putter> yes
22:58 < fglock> that would be <%statement_control>
22:59 < putter> and the real parser can play games like trying to 
massage the
                @array into a trie, so it doesnt have to repeatedly 
reparse the
                same stuff the same way.
22:59 < fglock> putter: it is cached

23:02 < putter> re statement_control,
                http://dev.perl.org/perl6/doc/design/syn/S04.html has a 
little
                bit in Statement parsing.

----

re: Smart::Comments
re: defining 'if' with macros

23:08 < putter> re hash, "An interpolated hash matches the longest 
possible key
                of the hash as a literal, or fails if no key matches.", 
which
                doesnt help you distinguish between  /if <expr> <block> 
[else
                <block>]?/ and /if <expr> <block> [else <block>]?
                [wrap_around_both_branches <mumble>]?/.   comparing "if" 
and
                "if" isnt going to help.
23:09 < pmurias> Does any one think that useing Smart::Comments in
                 iterator_engine.pl would be a good idea?
23:09 < fglock> pmurias: I like Smart::Comments, but I'd like to keep it 
simple
                (that is, no unnecessary dependencies)
23:09 < putter> (there shouldn't have been a ? on the <mumble> clause)
23:10 < pmurias> It would be a dependency only for debugging :)
23:10 < pmurias> And casual users don't do that often :)
23:11 < pmurias> at least they shouldn't have to :)
23:11 < fglock> pmurias: I'll check that (you mean, disable 'use
                Smart::Comments' when not in use?)
23:11 < pmurias> the use line should be comment out by default
23:12 < fglock> putter: re /if.../ - I don't understand the mumble part, 
what
                would it be?
23:12 < pmurias> and if the debuging messages are needed you just delete 
the #
23:12 < putter> re if macro, well, you need to add a regex to 
<statement> so
                you can parse it.  and we can currently hang regexs off 
of,
                well, rule, and macros     macro statement_control:<if> 
(...)
                is parsed(/heres the regex/) {...}
23:12 < pmurias> i'll commit it tommorow if youd don't mind
23:12 < fglock> pmurias: sounds good - I'll check the pod again


23:36 < fglock> it will look like: %statement_control:<if> = rule { ... 
}

-------

re: bootstrapping vs. correctness

<TimToady> personally, I'd aim for the bootstrap, and if we have to 
write
<TimToady> "funny" code to use it, that's okayish.
<fglock> putter: :)
<fglock> TimToady: ok - this helps!
<putter> fglock: what are some possible milestones one could imagine 
reaching for?
<fglock> for example: I could implement 'if' very easily in perl5, but 
implementing with a Perl 6 macro is more correct-ish
<fglock> putter: the compiler is not OO, so we don't need that in the 
bootstrap
<fglock> so implementing closures, hash, array should be ok
<fglock> operator precedence isn't important right now
* putter 's next question will be "what is the _simplest_ approach you 
can imagine?"
<fglock> "_simplest_" - keep writing nodes in perl5; "right" - start 
writing Perl 6 from this point
<fglock> however, nodes can be migrated to Perl 6 later, now that we 
know how to do it
* putter is a great fan of simple
<fglock> maybe next step: rewrite iterator_engine.pl in simple-Perl6, 
and struggle to compile it to Perl5
<putter> hmm, another thing one might do is step back, and try to come 
up with a list of _other_ things you might be working on/towards.  
because it's not only is this useful in itself, but is it the most 
useful thing you can think to do at the moment


-----------

re: pads

<fglock> is there some CPAN module that implements a hash that behaves 
something like a pad? we could use it for implementing lexical subs for 
example
<TimToady> Yes, especially if scoped lexically via %^H modifying pragms.
<fglock> pmurias: each node is actually a state machine
<gaal> what ever happened to MJD's pragma patch?
<fglock> s/each node/each node in a rule/
*** Daveman left #perl6 ["Leaving"]
<TimToady> gaal: dunno--I only ever heard about it second-hand--never 
looked at it.
<pmurias> fglock:I sort of understand now :)
<gaal> it's really elegant. (in taking advantage of the 
parser<->evaluator chumminess of p5)
<webmind> .win 3
<webmind> oops
* gaal wanders off to entertain a guest
<webmind> hf
<putter> fglock: 
http://search.cpan.org/~mneylon/Tie-Hash-Stack-0.09/Stack.pm ?

------

re: modifiers

<PerlJam> fglock: rule xxx { :perl5 .* }
<PerlJam> fglock: in yours, .* would be a parameter to the :perl5 
attribute.
*** FurnaceBoy [n=qu1j0t3@67.68.33.193] has quit [brown.freenode.net 
irc.freenode.net]
*** chris2 [n=chris@p549D1C58.dip0.t-ipconnect.de] has quit 
[brown.freenode.net irc.freenode.net]
*** meppl [i=mephisto@meppl.net] has quit [brown.freenode.net 
irc.freenode.net]
<putter> :perl5 , like :i :mumble, is a modifier.
<putter> block scoped
<putter> [:i(1) This CoDe Is CaSe insensiteive ]


----

re: building AST

<fglock> re OO AST nodes - does it make any sense to use hashes, and 
autobox when necessary? (just because building objects during the 
parsing may be expensive - backtracking throws many nodes away)
*** Nouk [n=Nouk@219-87-211-192.static.tfn.net.tw] has joined #perl6
*** Nouk [n=Nouk@219-87-211-192.static.tfn.net.tw] has quit [Client 
Quit]
<audreyt> fglock: for perf I'll even just use arrays with constant 
lookup keys
<audreyt> fglock: but I'd suggest to _not_ care about performance
<audreyt> just optimize for clarity/effieciency for coding
<audreyt> it may be nice to adopt the haskellish
<audreyt> Val(VInt(3))
<audreyt> i.e. instead of calling ->new, use functions as constructors
<fglock> audreyt: but are resulting nodes objects of functions?
<fglock> audreyt: you mean like:   rule xxx {... { return Val(VInt(3)) } 
}
<fglock> audreyt: I'm ok with that - Val and VInt are "node constructor" 
functions, which we can modify later
<fglock>     rule xxx {... { return Val(VInt( $1 )) } }
<audreyt> yes.
<audreyt> this is because in p6
<audreyt> VInt(3)
<audreyt> is basically
<audreyt> 3 as VInt
<audreyt> and you can install multis in the VInt class to anticipate the 
infix "as" call
*** drbean [n=greg@momotaro.chinmin.edu.tw] has joined #perl6
<fglock> audreyt: and if Val returns a function, we can delay "building" 
the AST by not evaluating it, right?
<audreyt> yes
<audreyt> but I'm not sure how much you gain in p5land from that
<fglock> audreyt: I don't know too - just thinking aloud :)
<audreyt> without core support for thunks, and with a typical compiler 
run visiting all nodes
<audreyt> delaying ast buildup doesn't gain you much.
<fglock> audreyt: you get time by not bulding things that would be 
destroyed by backtracking - I think that's all
<audreyt> yup, so it's CV creation vs HVMG creation
<audreyt> well, with the encapsulation offereed by function constuctors 
we can switch style at all times
<audreyt> but my gut feeling is that plain HVMG is good enough
<fglock> audreyt: VInt(3) - you don't need to specify the argument name? 
(sorry, I don't really know p6)
<fglock> HVMG?
<audreyt> no - it's a coercion
<audreyt> blessed hashref
<audreyt> some help in p5land for this kind of thing:
<audreyt> http://search.cpan.org/dist/Symbol-Opaque/
<audreyt> http://search.cpan.org/dist/Data-Variant/

