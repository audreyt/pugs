# --------------------------------------------------------------------------- #
# Array Container
# --------------------------------------------------------------------------- #

::Array.set_name('Array');
::Array.set_version('0.0.1');
::Array.set_authority('url:pugscode.org');

::Array.set_superclasses([ ::Object ]);

::Array.add_method('FETCH', -> $i     { self`fetch_elem($i)           } );
::Array.add_method('STORE', -> $i, $x { self`store_elem($i, $x); self } );

# --------------------------------------------------------------------------- #
# Array Role
# --------------------------------------------------------------------------- #

::rArray := ::Role.new({});
::rArray.set_name('Array');
::rArray.set_version('0.0.1');
::rArray.set_authority('url:pugscode.org');

::rArray.add_method('elems', -> { 
    self`fetch_list()`length() 
});

# List interface (as speced in S29) 
# NOTE: break this out into List.pil and List role maybe ...

::rArray.add_method('join', -> $sep {
    -> @elems, $acc {
        &redo := &?SUB;
        @elems`is_empty()`cond(
            -> { $acc },
            -> { 
                &redo`(
                    @elems`splice(1), 
                    @elems`length()`eq(1)`cond(
                        -> { $acc`concat(@elems`fetch(0)`as_str()) },
                        -> { $acc`concat(@elems`fetch(0)`as_str())`concat($sep`as_str()) }
                    )
                );
            }
        );
    }`(self`fetch_list(), '');
});

::rArray.add_method('map', -> &func {
    $?CLASS`create(
        -> $elem {
            &func`($elem)
        }`do_for(self`fetch_list())
    );
});

::rArray.add_method('grep', -> &func {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> {
                $elem := @list`fetch(0);
                &func`($elem)`as_bit()`cond(
                    -> { &redo`(@list`splice(1), @acc`push($elem)) },
                    -> { &redo`(@list`splice(1), @acc)             }            
                );
            }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('reverse', -> {
    self`store_list(self`fetch_list()`reverse());
    self;
});

::rArray.add_method('reduce', -> &func {
    -> @list, $acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $acc },
            -> { &redo`(@list`splice(1), &func`($acc, @list`fetch(0))) }
        );        
    }`(self`fetch_list()`splice(1), self`fetch_elem(0));
});

::rArray.add_method('zip', -> @values {
    -> @l, @r, @acc {
        &redo := &?SUB;
        @l`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { &redo`(@l`splice(1), @r`splice(1), @acc`concat([ @l`fetch(0), @r`fetch(0) ])) }
        );
    }`(self`fetch_list(), @values`fetch_list(), []);
});

# bottom up merge sort
::rArray.add_method('sort', -> {
    self.elems()`le(1)`cond(
        -> { self },
        -> {         
            &compare := -> $a, $b { 
                $a`eq($b)`cond(
                    -> { 0 }, 
                    -> { 
                        $a`lt($b)`cond(
                            -> { -1 }, 
                            -> { 1 }
                        );
                    }
                ); 
            };
            
            &split := -> @lst, @acc { 
                &redo := &?SUB;            
                @lst`length()`eq(0)`cond(
                    -> { @acc },
                    -> { &redo`(@lst`splice(1), @acc`push([ @lst`fetch(0) ])) } 
                ); 
            };   

            &merge := -> @l1, @l2 { 
                &redo := &?SUB;
                @l1`is_nil()`cond(
                    -> { @l2 },
                    -> {
                        @l1`is_empty()`cond(
                            -> { @l2 },
                            -> { 
                                @l2`is_nil()`cond(
                                    -> { @l1 },
                                    -> {
                                        @l2`is_empty()`cond(
                                            -> { @l1 },
                                            -> { 
                                                $hl1 := @l1`fetch(0);
                                                $hl2 := @l2`fetch(0);
                                                &compare`($hl1, $hl2)`lt(0)`cond(
                                                    ->{ 
                                                        [ $hl1 ]`concat( &redo`( @l1`splice(1), @l2 ) ) 
                                                    },
                                                    ->{ 
                                                        [ $hl2 ]`concat( &redo`( @l1, @l2`splice(1) ) ) 
                                                    }
                                                ); 
                                            } 
                                        );
                                    }
                                ); 
                            } 
                        );
                    }
                ); 
            };                           

            &mergepairs := -> @lst { 
                &redo := &?SUB;
                @lst`length()`le(1)`cond(
                    -> { @lst`fetch(0) },
                    -> { 
                        &merge`(
                            &merge`(@lst`fetch(0), @lst`fetch(1)), 
                            &redo`(@lst`splice(2))
                        );
                    } 
                );
            };           

            &mergesort := -> @lst { 
                &redo := &?SUB;            
                @lst`length()`eq(1)`cond(
                    -> { @lst`fetch(0) },
                    -> { &mergepairs`(@lst) } 
                ) 
            };
            
            $?CLASS`create(&mergesort`(&split`(self`fetch_list(), [])));
        }
    );
});

# Array method (as speced in S29)

::rArray.add_method('pop', -> {
    $elem := self`fetch_elem(self.elems()`decrement());
    # this is a ugly kludge for now :-/
    self`store_list(self`fetch_list()`reverse()`splice(1)`reverse());
    $elem;    
});

::rArray.add_method('push', -> $elem {
    self`store_list(self`fetch_list()`concat([ $elem ]));
    self;
});

::rArray.add_method('shift', -> {
    $elem := self`fetch_elem(0);
    self`store_list(self`fetch_list()`splice(1));
    $elem;
});

::rArray.add_method('unshift', -> $elem {
    self`store_list([ $elem ]`concat(self`fetch_list()));
    self;    
});

::rArray.add_method('delete', -> @indices {});
::rArray.add_method('exists', -> @indices {});
::rArray.add_method('splice', -> $offset, $length, @values {});

::rArray.add_method('keys', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { &redo`(@list`splice(1), @acc`push(@acc`length())) }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('values', -> { self });

::rArray.add_method('pairs', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { 
                &redo`(
                    @list`splice(1), 
                    @acc`push(::Pair.new({ 
                        'k' => @acc`length(), 
                        'v' => @list`fetch(0) 
                    }))
                ) 
            }
        );
    }`(self`fetch_list(), []);
});

::rArray.add_method('kv', -> {
    -> @list, @acc {
        &redo := &?SUB;
        @list`is_empty()`cond(
            -> { $?CLASS`create(@acc) },
            -> { 
                &redo`(
                    @list`splice(1), 
                    @acc`push(::Array`create([ 
                        @acc`length(), 
                        @list`fetch(0) 
                    ]))
                ) 
            }
        );
    }`(self`fetch_list(), []);
});

# --------------------------------------------------------------------------- #
# Bootstrap Array Container to Array Role
# --------------------------------------------------------------------------- #

::Array.set_roles([ ::rArray ]);
::Array.resolve();
