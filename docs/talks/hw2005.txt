
                  Pugs: Bootstrapping Perl 6 with Haskell
                                Autrijus Tang
                            Haskell Workshop 2005
                  (Applications, Practice, and Experience)

== Abstract ==

Perl is a general-purpose language, known for its vast number of freely
available extension libraries.  The Perl 6 project was started in 2000
to create a more robust runtime environment, and improve the language's
support for multi-paradigmic programming.  However, attempts at producing a
concrete implementation failed to take off in the first 4 years.

This paper presents Pugs, a working implementation of Perl 6, written in
Haskell.  We review the challenges posed by Perl 6's unusual execution model,
and how Pugs tackles them with features introduced in GHC 6.4, such as
Template Haskell, Software Transactional Memory, and GADTs.

Moreover, we demonstrate how Pugs uses Haskell's FFI to embed Perl 5, Parrot
and Haskell within Perl 6 programs, and how it mediates the execution context
between these runtime environments.

Finally, we discuss Parrot, a register-based virtual machine designated as the
reference implementation of Perl 6's runtime.  We show how Pugs can evolve from
an interpreter to a compiler targeting Parrot, with a design based on
metacomputational monads.

== Categories and Subject Descriptors ==

D.3.m [Programming Languages]: Miscellaneous

== General Terms ==

Design, Languages

== Keywords ==

Perl, Haskell

---------------------------------------------------------------------------

1. Introduction

The Perl language, developed by Larry Wall in the mid-1980s, is an attempt to
synthesise the capabilities of the Unix toolset (C, shell, grep, sed, awk,
etc.), presenting them in a way that maximises ease of use, efficiency and
completeness.

During the mid-1990s, Wall developed Perl 5, incoporating features from
contemporary languages (Scheme, C++, Python, etc.), such as modules, closures,
object-oriented programming and bytecode compilation. 

The Perl 6 project was started in 2000, with a focus on improved cross-language
interoperation and support for multiple programming paradigms.  The design
process continued well into 2005, producing the language specification in
installments.

However, the Perl 6 implementation, originally planned to proceed in parallel
with the design process, failed to materialise; this has seriously impeded the
development and adoption of the new language.

This paper presents Pugs, an independent implementation of Perl 6 using Haskell
as the host language, started in 2005.  Haskell proved to be a capable choice
for this task: we released the first working interpreter within the first week,
and by the third week we had a unit testing framework written in Perl 6.

By having a working implementation of Perl 6, we make the following
contributions:

* Provide a proving ground to resolve inconsistencies in language design
* Encourage people to contribute modules and unit tests for Perl 6
* Explore more rigorous ways to define Perl 6's execution model

The rest of this paper will proceed as follows.  In section 2, we give an
overview of the Perl 6 project's history and the language's execution model.
Section 3 discusses previous implementation efforts.  We then present the
design of Pugs's interpreter core in section 4.

Because Pugs is targeting GHC 6.4 instead of Haskell 98, it takes full
advantage of modern Haskell features GHC provides.  In section 5, we review
Pugs's use of GADT, STM, as well as subcontinuations built on higher-rank
polymorphism.  In section 6, we demonstrate how Pugs uses FFI and hs-plugins to
dynamically load Perl 5, Haskell and Parrot modules at runtime.

Although the naïve tree-reduction interpreter served well for prototyping,
it is not efficient enough for production use.  In section 7, we discuss the
ongoing work to adapt Pugs into a compiler, targeting the register-based Parrot
virtual machine.  Section 8 outlines our plans for future development.

---------------------------------------------------------------------------

2. Overview of the Perl 6 Project

Through Perl 5's release, major revisions of Perl were designed and implemented
by Wall alone.  However, Perl 6's development is driven by Perl community's
varied and often conflicting needs.  As such, we will start with a brief
overview of the Perl community, and how Perl 6 has come to be.

2.1. Historical Background

Following Perl 5's release in 1994, a community of volunteers known as the
"Perl 5 porters" was formed to take charge of the ongoing development of
Perl 5.  For each major revision, the porters appoint a "pumpking" (release
manager) to lead the design process and arbitrate patches submitted by other
porters.

In 1995, Jarkko Hietaniemi and Andreas König established the Comprehensive Perl
Archive Network (CPAN), an infrastructure for sharing freely reusable
libraries, programs and documentation.  Perl itself comes with a built-in client
side utility for automatic downloading, testing and installation of CPAN
modules.  As of 2005, CPAN has more than 8000 modules, supported by a toolchain
that covers smoke testing, issue tracking, cross-referencing, rating and
discussion forums.

Driven by hundreds of Perl 5 porters and thousands of CPAN authors, Perl 5's
development puts a strong emphasis on backward compatibility.  Developers
avoid adding new built-in functions, as they might clash with user-defined
functions of the same name.  Conversely, deprecated features are almost never
fully retracted, while new incompatible features are consistently rejected.
For example, one cannot rewrite the reference-counting garbage collector,
because existing programs may rely on its object destruction semantics.

In 2000, many developers felt that Perl 5 development was stuck.  Some have
described the C-based runtime as a tower of Jenga, where new features are
constrained to re-use existing semantics, making it ever more fragile.

In response to this situation, Perl developers started the Perl 6 project to
rewrite Perl from scratch, dropping language-level backward compatibility for
the first time.  To use existing Perl 5 programs, one would need to embed a
Perl 5 runtime inside Perl 6's runtime, or recompile them into Perl 6.

2.2. Execution Model

The Perl 6 project started with a "requirement analysis" phase; during this
two-month period, 26 working groups produced 361 RFCs submissions as initial
input to the design team, calling for improved functional, object-oriented,
concurrency-based, data-driven and logic programming support in the base
language.  In order to support these requirements, the design team focused
on Perl 6's metaprogramming capabilities.

Unlike most languages, Perl 5 has no static grammar: its parser is tightly
coupled with the evaluator, so compile-time computation can affect how the
parser handles the rest of the program.  This allows for a limited form of
macros known as "source filters", where a Perl module can transform the
importing program's source code before its parsing.

Many CPAN modules use source filters to implement Perl dialects and embedded
domain-specific languages.  However, as the transformation happens on the
source string level instead of the AST level, multiple filters cannot reliably
work together.

Perl 6 proposes an unusual execution model to address this problem.  The parser
and compiler are implemented in Perl 6, with an initial set of Rules to parse
source code into ASTs.  Rules are composable, first-class functions, written in
a sub-language of Perl 6 that defines parsers for context sensitive, infinite
look-ahead grammars.

The parser parses the program with the top-level "program" rule, composed of
sub-rules that handles parts of the program.  Rules may contain embedded Perl 6
code to produce side effects.  For example, the "BEGIN {...}" syntax defines a
block of code to be executed during compilation.

Immediately after parsing a BEGIN block, the compiler will generate its object
code, then dynamically load and run it.  This code has access to the
compilation environment; it may rewrite the partially produced parse tree,
define new grammar rules, or replace the compiler entirely from the next token
onwards.

With a default grammar that supports user-defined operators of arbitary fixity
and precedence, programmers can easily introduce new language semantics under
this execution model.

During runtime, the program still has access to the built-in parser and
compiler modules.  The "eval" primitive triggers the compilation and linking
process again, with full access to the current runtime environment.

2.3. Language Interoperability

Perl 6 is designed to operate in a mixed-language environment. The Inline.pm
framework already implements this capability in Perl 5; it provides a unified
interface to three strategies for interoperating with other languages.

* Translate:  Sometimes it is possible to transform the foreign language
into equivalent Perl code.  In that case, it is a simple matter of applying a
source filter, or "eval" the translated code in its own namespace.

* Native call:  Statically compiled languages (such as C, C++ and assembly)
are compiled into dynamically loaded shared libraries.  Inline.pm automatically
generates wrappers to foreign functions; it also exports Perl's runtime API so
the embedded language can also call functions defined in Perl.

* Runtime harness:  For languages with a rich runtime (e.g. Java and Python),
Inline.pm will run them alongside Perl's own runtime, sharing the execution
context in a coroutine-like fashion.  Types and global bindings are encoded
both ways, so the Perl program can invoke a foreign object's methods and vice 
versa.

In addition to these strategies, Perl 6 is also designed to run on a shared
high-level virtual machine, such as the Java VM or .Net CLR.  As part of the
Perl 6 project, the Parrot VM is the reference implementation for a
cross-language runtime to support Perl 6 and other dynamic languages.

---------------------------------------------------------------------------

3. Related Work

Perl 6 is designed to be self-hosting, unlike previous versions that were
implemented in C.  Its execution model demands a mixed parsing, compiling and
execution cycle, which complicates the bootstrap process.  In this section, we
briefly review various bootstrap strategies proposed over the years.

3.1. Perl6::Rules

The initial plan was to use Perl 5 as the host language: by first transforming
Perl 6's Rules to Perl 5 regular expressions, then implementing the Perl 6 to
Parrot compiler in Perl 5, and finally translating the compiler itself to Perl 6
using a Perl 5 to Perl 6 translator, implemented as one of Perl 5's bytecode
compiler backends.

Implementing Perl 6 rules as a Perl 5 module proved to be difficult; although
Rules were defined in 2002, it took nearly two years for the first version of
Perl6::Rules to appear.  The implementation relied on various experimental
features in Perl 5's regular expression engine, and failed to work on newer
Perl 5 revisions, rendering it unsuitable as a basis for implementing the
parser for Perl 6.

3.2. P6C

Started in 2002, P6C was the first concrete implementation of Perl 6, written
in Perl 5, as one of the language prototypes in the Parrot codebase.  Due to
the lack of Perl6::Rules, P6C uses Parse::RecDescent to construct a
recursive-descent parser for Perl 6.

P6C's design is based on multiple passes on the parse tree.  In the first
pass, Parse::RecDescent produces "raw parse objects": each node has a "tree" 
method that turns itself to "op-tree objects", produced by recursively calling
the "tree" method of its subnodes.  On the next pass, the compiler traverses
the op-tree to annotate each term with its inferred type.  Finally, the "val"
method is recursively called on each node, to produce the compiled code in
PIR, a high-level assembly code for Parrot.

Under that design, each term's reduction rules are hard-coded in assembly,
making it prohibitively difficult to reason about the execution.  Because P6C
cannot check the resulting assembly code for correctness, subtle bugs often
goes unnoticed for a long time.

Development of P6C continued for two years, eventually stalled in 2004.  As
of this writing, it can handle a few builtins, simple expressions, basic rules
matching and user-defined function.  It provides no support for BEGIN blocks,
"eval", modules and objects; code generated by P6C cannot interoperate with
other languages targetting Parrot.

3.3. PGE and PAST

In February 2005, Perl 6 developers announced a revised bootstrapping plan,
based on two new projects:

* Parrot Grammar Engine (PGE), a compiler that takes Perl 6 Rules and
  generate PIR functions that implement the parser.

* Parrot Abstract Syntax Tree (PAST), a higher level representation
  of PIR programs as Parrot objects.

The developers intend to define Perl 6's grammar as a set of Rules that
produces Parrot AST objects.  Once PGE is capable of process the rules, we can
reimplement PGE in Perl 6 to finish the bootstrapping process.

As of this writing, both PGE and PAST are under active development.  A subset
of Python's AST has been ported to Parrot, along with a C-based parser for its
concrete syntax.

PGE can handle most of static Rules constructs, but does not support calling
out to other functions, so the parser returns only simple match objects, not
AST nodes.  Because the Perl 6 grammar had not been specified in Rules, the
planned Perl 6 compiler, based on PGE/PAST, is yet to be written.

---------------------------------------------------------------------------

4. Pugs the Interpreter

...how pugs started...

4.1. The Eval Monad

...basic types, CALLER::, OUTER::, coro, delayed evaluation...

4.2. Compile-time Evaluation

...BEGIN, rebindable rules, macros...

4.3. Introspection

...OO metamodel, profiling, reified AST...

---------------------------------------------------------------------------

5. Experimental Features 

...GHC's peculiarities that helped Pugs development...

5.1. "Tied" Variables with GADT

...ITypes/IVar, VRef, VOpaque...

5.2. Composable Concurrency

...SIO, liftSTM/liftIO, atomic{}...

5.3. Reified Subcontinuations

...CC_2CPST, Zipper, resumable runEvalIO...

---------------------------------------------------------------------------

6. Embedded Languages

...migration issues...

6.1. Perl 5

...callconv, context passing, XS stack handling...

6.2. Haskell

...hs-plugins, externalizeHaskell, class Value...

6.3. Parrot

...PIR overview, compreg, cross-lang interop...

---------------------------------------------------------------------------

7. Compiling Perl 6

...mixed notion of compile/runtime...

7.1. Metacomputational Compilation

...partial evaluation, Static/Dynam monads...

7.2. Targeting Parrot

...optimization, unboxing, helper PMCs...

7.3. Other Backends

...generating haskell with TH, ANF/SSA...

---------------------------------------------------------------------------

8. Conclusion and Future Work

...porting Pugs to perl 6, compiling Haskell to PIR...

---------------------------------------------------------------------------

9. Acknowledgments

...thank some 100+ contributors here...

---------------------------------------------------------------------------

== References ==

...lots and lots of papers...

