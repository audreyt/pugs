# Do not edit this file - Generated by MiniPerl6
use v5;
use strict;
use MiniPerl6::Perl5::Runtime;
use MiniPerl6::Perl5::Match;
package KindaPerl6::Visitor::MetaClass; sub new { shift; bless { @_ }, "KindaPerl6::Visitor::MetaClass" } sub visit { my $self = shift; my $List__ = \@_; my $node; my $node_name; do {  $node = $List__->[0];  $node_name = $List__->[1]; [$node, $node_name] }; do { if (($node_name eq 'CompUnit')) { my  $module = [];do { if (($node->unit_type() eq 'role')) { push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $node->name(), )],'method' => 'new','invocant' => Proto->new( 'name' => 'KindaPerl6::Role', ), )) } else { my  $metaclass = 'Class';do { for my $trait ( @{$node->traits()} ) { do { if (($trait->[0] eq 'meta')) { $metaclass = $trait->[1] } else {  } } } };my  $metaobject = Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $node->name(), )],'method' => 'new','invocant' => Proto->new( 'name' => $metaclass, ), );push(@{$module}, Bind->new( 'parameters' => Proto->new( 'name' => $node->name(), ),'arguments' => Call->new( 'invocant' => $metaobject,'method' => 'PROTOTYPE','hyper' => '', ), )) } };do { for my $trait ( @{$node->traits()} ) { do { if (($trait->[0] eq 'does')) { push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $trait->[1], )],'method' => 'add_role','invocant' => Call->new( 'hyper' => '','arguments' => [],'method' => 'HOW','invocant' => Proto->new( 'name' => $node->name(), ), ), )) } else { do { if (($trait->[0] eq 'is')) { push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $trait->[1], )],'method' => 'add_parent','invocant' => Call->new( 'hyper' => '','arguments' => [],'method' => 'HOW','invocant' => Proto->new( 'name' => $node->name(), ), ), )) } else { do { if (($trait->[0] eq 'meta')) {  } else { die('unknown class trait: ', $trait->[0]) } } } } } } } };do { for my $item ( @{$node->body()->body()} ) { do { if (Main::isa($item, 'Method')) { push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $item->name(), ), Call->new( 'hyper' => '','arguments' => [Method->new( 'name' => '','block' => $item->block(), )],'method' => 'new','invocant' => Proto->new( 'name' => 'Method', ), )],'method' => 'add_method','invocant' => Call->new( 'hyper' => '','arguments' => [],'method' => 'HOW','invocant' => Proto->new( 'name' => $node->name(), ), ), )) } else {  } };do { if ((Main::isa($item, 'Decl') && ($item->decl() eq 'has'))) { push(@{$module}, Call->new( 'hyper' => '','arguments' => [Val::Buf->new( 'buf' => $item->var()->name(), )],'method' => 'add_attribute','invocant' => Call->new( 'hyper' => '','arguments' => [],'method' => 'HOW','invocant' => Proto->new( 'name' => $node->name(), ), ), )) } else {  } } } };do { for my $item ( @{$node->body()->body()} ) { do { if ((Main::isa($item, 'Method') || (Main::isa($item, 'Decl') && ($item->decl() eq 'has')))) {  } else { push(@{$module}, $item) } } } };return(CompUnit->new( 'unit_type' => 'module','name' => $node->name(),'body' => Lit::Code->new( 'pad' => $node->body()->pad(),'state' => {  },'sig' => Sig->new( 'invocant' => (undef),'positional' => [],'named' => {  }, ),'body' => $module, ), )) } else {  } }; return((undef)) }
;
1;
