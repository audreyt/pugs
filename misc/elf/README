OVERVIEW

Elf is a p6 compiler.

The currently recommended version is:
  elf_g

elf_g --help  for more info.

It uses perl from your path.  5.10 is recommended, but 5.8 works too.

P6 scripts:
  $ cat say3
  #!/usr/bin/env elf_g
  say 3;
  $ ./say 3
  3


INSTALL

The elf executable is generic perl 5.
It can be called from any directory.  It can be renamed.

It can be moved to a different directory, but needs to find STD_red_run.
It looks for ../STD_red/STD_red_run or ./elf_X_src/STD_red/STD_red_run,
relative to the directory of the executable (active elf versions use the
first, older slushy/frozen versions use the second).
Both can be overridden by setting the ELF_STD_RED_RUN environment variable.

STD_red requires ruby 1.9.  See it's README for installation info.

RUNNING TESTS

  See  make test  in elf_g_src/Makefile.

VERSIONS

See file VERSIONS.


----------------------------------------------------------------------
Other stuff...

TIPS

    eval_perl5('sub{print Data::Dumper::Dumper($_[0])}').($n);

OTHER

A development story (a tale of two compilers)

  Bootstraps can be very confusing.  This story may help.

  Say someone hands you a working perl6.
  What can you do with it?

  If you already have your own implementation of p6, written in p6,
  you could now compile it.
    six -o mysix -x MySix.pm

  (This is section is highly doubtfull, and IMHO an elf bug -- pmurias)
  But you could *not*, in general, do
    six MySix.pm
  If you tried, as MySix was compiled (which can involve running) and
  run, it would stomp all over the implementation of six.  In general,
  breaking it.

  If you instead wanted to make small, *compatible* changes to six,
  you could do
    six TweakSix.pm ...
  Which would likely give you 'mumble was redefined' warnings, but
  could otherwise be harmless and helpful.

  But what if you have something inbetween.  More than a compatible
  tweak, but less than a full implementation.  Some hook apis are
  provided to permit larger changes.

  To make it easier to work on new compilers, the compiler for
  internal use need not be the same one used to provide external
  compiled code.  And the compiler used for each, can be independently
  hot-swapped at runtime.  That's why there are conceptually two
  compilers.  And $*compiler0, $*compiler1, $*emitter0, $*emitter1, etc.

